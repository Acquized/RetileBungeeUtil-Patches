From 160fc02a6421d0fce7e3030eb8e4ddde301e41cb Mon Sep 17 00:00:00 2001
From: Acquized <flare.returns@outlook.com>
Date: Wed, 5 Oct 2016 10:50:16 +0200
Subject: [PATCH] [Prepare] Prepare Developement using Gradle

---
 .gitattributes                                     |    3 +
 .gitignore                                         |   35 +
 LICENSE.txt                                        |   24 +
 README.md                                          |   43 +
 build.gradle                                       |  123 ++
 circle.yml                                         |    0
 gradle.properties                                  |    5 +
 gradle/wrapper/gradle-wrapper.jar                  |  Bin 0 -> 53556 bytes
 gradle/wrapper/gradle-wrapper.properties           |    6 +
 gradlew                                            |  164 +++
 gradlew.bat                                        |   90 ++
 settings.gradle                                    |    2 +
 .../dev/wolveringer/BungeeUtil/AsyncCatcher.java   |   66 +
 .../java/dev/wolveringer/BungeeUtil/BlockFace.java |  136 ++
 .../dev/wolveringer/BungeeUtil/BungeeUtil.java     |  296 ++++
 .../dev/wolveringer/BungeeUtil/ClientVersion.java  |  129 ++
 .../wolveringer/BungeeUtil/CostumPrintStream.java  |    6 +
 .../wolveringer/BungeeUtil/DebugProperties.java    |   10 +
 .../java/dev/wolveringer/BungeeUtil/HandType.java  |    6 +
 .../wolveringer/BungeeUtil/HandleErrorAction.java  |    7 +
 src/main/java/dev/wolveringer/BungeeUtil/Main.java |  108 ++
 .../java/dev/wolveringer/BungeeUtil/Material.java  |  980 ++++++++++++++
 .../dev/wolveringer/BungeeUtil/MaterialData.java   |  120 ++
 .../wolveringer/BungeeUtil/NumberConversions.java  |  101 ++
 .../OperatingSystem/OperatingSystemType.java       |  136 ++
 .../wolveringer/BungeeUtil/OperationCalback.java   |    5 +
 .../wolveringer/BungeeUtil/PacketHandleEvent.java  |   49 +
 .../dev/wolveringer/BungeeUtil/PacketHandler.java  |    7 +
 .../java/dev/wolveringer/BungeeUtil/PacketLib.java |  186 +++
 .../java/dev/wolveringer/BungeeUtil/Player.java    |   91 ++
 .../dev/wolveringer/BungeeUtil/RamStatistics.java  |  139 ++
 .../BungeeUtil/RamStatisticsPainter.java           |   95 ++
 .../wolveringer/BungeeUtil/bukkit/BukkitMain.java  |   17 +
 .../BungeeUtil/configuration/Configuration.java    |  110 ++
 .../BungeeUtil/exception/ExceptionUtils.java       |  121 ++
 .../BungeeUtil/gameprofile/GameProfile.java        |   51 +
 .../gameprofile/GameProfileSerializer.java         |   97 ++
 .../BungeeUtil/gameprofile/PlayerInfoData.java     |   67 +
 .../BungeeUtil/gameprofile/Property.java           |   38 +
 .../BungeeUtil/gameprofile/PropertyMap.java        |   83 ++
 .../wolveringer/BungeeUtil/gameprofile/Skin.java   |  224 +++
 .../BungeeUtil/gameprofile/SkinCache.java          |   92 ++
 .../BungeeUtil/gameprofile/SkinFactory.java        |  122 ++
 .../BungeeUtil/gameprofile/SkinRequest.java        |   46 +
 .../BungeeUtil/gameprofile/SteveSkin.java          |  100 ++
 .../wolveringer/BungeeUtil/gameprofile/Test.java   |   12 +
 .../BungeeUtil/gameprofile/UUIDFetcher.java        |  116 ++
 .../BungeeUtil/injector/InjectFiles.java           |  119 ++
 .../wolveringer/BungeeUtil/item/ClickListener.java |    7 +
 .../java/dev/wolveringer/BungeeUtil/item/Item.java |  416 ++++++
 .../wolveringer/BungeeUtil/item/ItemBuilder.java   |  135 ++
 .../dev/wolveringer/BungeeUtil/item/ItemStack.java |   84 ++
 .../BungeeUtil/item/MultiClickItemStack.java       |   41 +
 .../wolveringer/BungeeUtil/item/SyncHandle.java    |   10 +
 .../java/dev/wolveringer/BungeeUtil/item/Test.java |   14 +
 .../BungeeUtil/item/itemmeta/CraftItemMeta.java    |  178 +++
 .../BungeeUtil/item/itemmeta/ItemMeta.java         |   74 +
 .../BungeeUtil/item/itemmeta/MetaFactory.java      |   99 ++
 .../BungeeUtil/item/itemmeta/MetaListener.java     |    7 +
 .../BungeeUtil/item/itemmeta/SkullMeta.java        |  123 ++
 .../packets/Abstract/PacketAbstract.java           |   23 +
 .../BungeeUtil/packets/Abstract/PacketPlayIn.java  |    3 +
 .../BungeeUtil/packets/Abstract/PacketPlayOut.java |    3 +
 .../Abstract/PacketPlayOutEntityAbstract.java      |   38 +
 .../Abstract/PacketPlayXXXHeldItemSlot.java        |   22 +
 .../BungeeUtil/packets/AbstractPacketCreator.java  |  194 +++
 .../wolveringer/BungeeUtil/packets/BetaPacket.java |   34 +
 .../BungeeUtil/packets/NormalPacketCreator.java    |  298 ++++
 .../dev/wolveringer/BungeeUtil/packets/Packet.java |  292 ++++
 .../BungeeUtil/packets/PacketLoginDisconnect.java  |   36 +
 .../packets/PacketPlayInArmAnimation.java          |   45 +
 .../BungeeUtil/packets/PacketPlayInBlockDig.java   |   76 ++
 .../BungeeUtil/packets/PacketPlayInBlockPlace.java |   93 ++
 .../BungeeUtil/packets/PacketPlayInChat.java       |   39 +
 .../packets/PacketPlayInClientState.java           |   26 +
 .../packets/PacketPlayInCloseWindow.java           |   31 +
 .../BungeeUtil/packets/PacketPlayInFlying.java     |   69 +
 .../packets/PacketPlayInHeldItemSlot.java          |   25 +
 .../BungeeUtil/packets/PacketPlayInLook.java       |   22 +
 .../packets/PacketPlayInPluginMessage.java         |   86 ++
 .../BungeeUtil/packets/PacketPlayInPosition.java   |   36 +
 .../packets/PacketPlayInPositionLook.java          |   39 +
 .../BungeeUtil/packets/PacketPlayInUpdateSign.java |   46 +
 .../BungeeUtil/packets/PacketPlayInUseEntity.java  |   89 ++
 .../packets/PacketPlayInWindowClick.java           |  151 +++
 .../BungeeUtil/packets/PacketPlayOutBossBar.java   |  182 +++
 .../BungeeUtil/packets/PacketPlayOutChat.java      |   61 +
 .../packets/PacketPlayOutCloseWindow.java          |   36 +
 .../packets/PacketPlayOutDisconnect.java           |   33 +
 .../packets/PacketPlayOutEntityDestroy.java        |   46 +
 .../packets/PacketPlayOutEntityEffect.java         |   59 +
 .../packets/PacketPlayOutEntityEquipment.java      |   74 +
 .../packets/PacketPlayOutEntityHeadRotation.java   |   40 +
 .../packets/PacketPlayOutEntityMetadata.java       |   40 +
 .../packets/PacketPlayOutEntityProperties.java     |  155 +++
 .../packets/PacketPlayOutEntityTeleport.java       |  101 ++
 .../packets/PacketPlayOutGameStateChange.java      |   44 +
 .../packets/PacketPlayOutHeldItemSlot.java         |   25 +
 .../BungeeUtil/packets/PacketPlayOutKeepAlive.java |   24 +
 .../packets/PacketPlayOutNamedEntitySpawn.java     |  160 +++
 .../packets/PacketPlayOutNamedSoundEffect.java     |   73 +
 .../packets/PacketPlayOutOpenWindow.java           |  111 ++
 .../packets/PacketPlayOutPlayerInfo.java           |  156 +++
 .../PacketPlayOutPlayerListHeaderFooter.java       |   52 +
 .../packets/PacketPlayOutPluginMessage.java        |   82 ++
 .../BungeeUtil/packets/PacketPlayOutPosition.java  |   70 +
 .../packets/PacketPlayOutRemoveEntityEffect.java   |   50 +
 .../PacketPlayOutScoreboardDisplayObjective.java   |   56 +
 .../packets/PacketPlayOutScoreboardObjective.java  |  114 ++
 .../packets/PacketPlayOutScoreboardScore.java      |   94 ++
 .../packets/PacketPlayOutScoreboardTeam.java       |  219 +++
 .../packets/PacketPlayOutSetExperience.java        |   49 +
 .../BungeeUtil/packets/PacketPlayOutSetSlot.java   |   62 +
 .../packets/PacketPlayOutSpawnEntity.java          |   76 ++
 .../packets/PacketPlayOutSpawnEntityLiving.java    |  132 ++
 .../packets/PacketPlayOutSpawnPostition.java       |   27 +
 .../BungeeUtil/packets/PacketPlayOutStatistic.java |   47 +
 .../BungeeUtil/packets/PacketPlayOutTitle.java     |   68 +
 .../packets/PacketPlayOutTransaction.java          |   62 +
 .../packets/PacketPlayOutUpdateHealth.java         |   38 +
 .../packets/PacketPlayOutUpdateSign.java           |   45 +
 .../packets/PacketPlayOutWindowData.java           |   61 +
 .../packets/PacketPlayOutWindowItems.java          |   69 +
 .../packets/PacketPlayOutWorldParticles.java       |  145 ++
 .../BungeeUtil/packets/UnderknownPacket.java       |   20 +
 src/main/java/dev/wolveringer/NPC/Equipment.java   |   72 +
 .../java/dev/wolveringer/NPC/InteractListener.java |    8 +
 src/main/java/dev/wolveringer/NPC/NPC.java         |  331 +++++
 src/main/java/dev/wolveringer/NPC/NPCData.java     |  337 +++++
 .../java/dev/wolveringer/Reflect/Test/Main.java    |   40 +
 .../java/dev/wolveringer/Reflect/Test/TEST.java    |   89 ++
 .../dev/wolveringer/Reflect/Test/TestClass.java    |    9 +
 src/main/java/dev/wolveringer/Reflect/Until.java   |   35 +
 src/main/java/dev/wolveringer/ServerDatReader.java |   58 +
 .../java/dev/wolveringer/TimingsDataReader.java    |   52 +
 .../java/dev/wolveringer/animations/Animation.java |   10 +
 .../wolveringer/animations/AnimationCallback.java  |    5 +
 .../dev/wolveringer/animations/AnimatonLoop.java   |    5 +
 .../inventory/InventoryViewChangeAnimations.java   |  223 +++
 .../animations/inventory/LimetedScheduller.java    |   52 +
 .../wolveringer/animations/text/FormatTest.java    |   28 +
 .../wolveringer/animations/text/NumericUntil.java  |   31 +
 .../animations/text/RunningTextFormater.java       |   53 +
 .../dev/wolveringer/animations/text/Scroller.java  |   67 +
 .../wolveringer/animations/text/StringUntils.java  |   24 +
 .../wolveringer/animations/text/TextFormater.java  |  109 ++
 .../animations/text/TickedTextFormater.java        |   35 +
 .../wolveringer/api/bossbar/BossBarListener.java   |   58 +
 .../wolveringer/api/bossbar/BossBarManager.java    |  163 +++
 .../dev/wolveringer/api/datawatcher/BlockData.java |   18 +
 .../wolveringer/api/datawatcher/DataWatcher.java   |   52 +
 .../api/datawatcher/DataWatcherObjekt.java         |   46 +
 .../dev/wolveringer/api/datawatcher/Direction.java |   17 +
 .../api/datawatcher/EntityDataWatcher.java         |   60 +
 .../api/datawatcher/HumanDataWatcher.java          |   22 +
 .../api/datawatcher/LivingEntityDataWatcher.java   |   27 +
 .../api/datawatcher/OptionalBlockPosition.java     |   22 +
 .../wolveringer/api/datawatcher/OptionalUUID.java  |   20 +
 .../api/datawatcher/impl/DataWatcherObjekt.java    |   46 +
 .../api/datawatcher/impl/v1_10_DataWatcher.java    |  277 ++++
 .../datawatcher/impl/v1_10_EntityDataWatcher.java  |  160 +++
 .../impl/v1_10_HumanEntityDataWatcher.java         |   55 +
 .../impl/v1_10_LivingEntityDataWatcher.java        |   67 +
 .../api/datawatcher/impl/v1_8_DataWatcher.java     |  240 ++++
 .../datawatcher/impl/v1_8_EntityDataWatcher.java   |  152 +++
 .../impl/v1_8_HumanEntityDataWatcher.java          |   59 +
 .../impl/v1_8_LivingEntityDataWatcher.java         |   95 ++
 .../api/datawatcher/impl/v1_9_DataWatcher.java     |  276 ++++
 .../datawatcher/impl/v1_9_EntityDataWatcher.java   |  158 +++
 .../impl/v1_9_HumanEntityDataWatcher.java          |   55 +
 .../impl/v1_9_LivingEntityDataWatcher.java         |   65 +
 .../java/dev/wolveringer/api/gui/AnvilGui.java     |  364 +++++
 .../dev/wolveringer/api/gui/AnvilGuiListener.java  |   19 +
 .../dev/wolveringer/api/inventory/Inventory.java   |  301 +++++
 .../wolveringer/api/inventory/InventoryType.java   |   39 +
 .../wolveringer/api/inventory/ItemContainer.java   |  136 ++
 .../wolveringer/api/inventory/PlayerInventory.java |  119 ++
 .../api/inventory/ScrolingInventory.java           |  184 +++
 .../wolveringer/api/particel/ParticleEffect.java   | 1211 +++++++++++++++++
 .../wolveringer/api/position/BlockPosition.java    |   10 +
 .../dev/wolveringer/api/position/Location.java     |  492 +++++++
 .../dev/wolveringer/api/position/Potision.java     |   68 +
 .../java/dev/wolveringer/api/position/Vector.java  |  690 ++++++++++
 .../dev/wolveringer/api/position/Vector3f.java     |   48 +
 .../dev/wolveringer/api/scoreboard/Objektive.java  |  129 ++
 .../api/scoreboard/PacketListenerScoreboard.java   |  140 ++
 .../dev/wolveringer/api/scoreboard/Scoreboard.java |  109 ++
 .../java/dev/wolveringer/api/scoreboard/Team.java  |   94 ++
 .../dev/wolveringer/api/sound/SoundCategory.java   |   24 +
 .../dev/wolveringer/api/sound/SoundEffect.java     | 1423 ++++++++++++++++++++
 .../dev/wolveringer/chat/ChatBaseComponent.java    |  131 ++
 .../dev/wolveringer/chat/ChatClickListener.java    |    7 +
 .../java/dev/wolveringer/chat/ChatClickable.java   |   59 +
 .../chat/ChatColor/AnsiColorFormater.java          |   67 +
 .../wolveringer/chat/ChatColor/ChatColorUtils.java |  162 +++
 .../dev/wolveringer/chat/ChatComponentText.java    |   83 ++
 .../java/dev/wolveringer/chat/ChatFunction1.java   |   14 +
 .../java/dev/wolveringer/chat/ChatFunction2.java   |   16 +
 .../java/dev/wolveringer/chat/ChatHoverable.java   |   59 +
 .../java/dev/wolveringer/chat/ChatMessage.java     |  148 ++
 .../dev/wolveringer/chat/ChatMessageException.java |   18 +
 .../java/dev/wolveringer/chat/ChatModifier.java    |  271 ++++
 .../wolveringer/chat/ChatModifierSerializer.java   |  142 ++
 .../java/dev/wolveringer/chat/ChatSerializer.java  |  309 +++++
 .../java/dev/wolveringer/chat/ChatStyleRoot.java   |  109 ++
 .../java/dev/wolveringer/chat/ChatTextBuilder.java |   72 +
 .../java/dev/wolveringer/chat/ChatTypeAdapter.java |   58 +
 .../wolveringer/chat/ChatTypeAdapterFactory.java   |   45 +
 .../java/dev/wolveringer/chat/EnumClickAction.java |   44 +
 .../java/dev/wolveringer/chat/EnumHoverAction.java |   41 +
 .../dev/wolveringer/chat/IChatBaseComponent.java   |   32 +
 .../dev/wolveringer/chat/PlayerChatListener.java   |   64 +
 .../java/dev/wolveringer/chat/StringMethode.java   |    9 +
 .../dev/wolveringer/commands/BungeeTimings.java    |   82 ++
 .../dev/wolveringer/commands/RamStatistics.java    |   53 +
 .../wolveringer/configuration/Configuration.java   |   84 ++
 .../configuration/ConfigurationOptions.java        |   90 ++
 .../configuration/ConfigurationSection.java        |  641 +++++++++
 .../InvalidConfigurationException.java             |   45 +
 .../configuration/MemoryConfiguration.java         |   79 ++
 .../configuration/MemoryConfigurationOptions.java  |   28 +
 .../wolveringer/configuration/MemorySection.java   |  754 +++++++++++
 .../configuration/file/FileConfiguration.java      |  288 ++++
 .../file/FileConfigurationOptions.java             |  119 ++
 .../configuration/file/YamlConfiguration.java      |  250 ++++
 .../file/YamlConfigurationOptions.java             |   71 +
 .../configuration/file/YamlConstructor.java        |   49 +
 .../configuration/file/YamlRepresenter.java        |   38 +
 .../serialization/ConfigurationSerializable.java   |   35 +
 .../serialization/ConfigurationSerialization.java  |  270 ++++
 .../serialization/DelegateDeserialization.java     |   22 +
 .../serialization/SerializableAs.java              |   34 +
 .../hastebin/DocumentNotFoundException.java        |    9 +
 .../dev/wolveringer/hastebin/HastebinDocument.java |   80 ++
 .../dev/wolveringer/hastebin/HastebinPost.java     |   91 ++
 .../listener/InventoryResetListener.java           |   13 +
 .../java/dev/wolveringer/maps/CachedArrayList.java |  257 ++++
 .../java/dev/wolveringer/maps/CachedHashMap.java   |   97 ++
 src/main/java/dev/wolveringer/nbt/LimitStream.java |   29 +
 src/main/java/dev/wolveringer/nbt/MathHelper.java  |  175 +++
 src/main/java/dev/wolveringer/nbt/NBTBase.java     |   90 ++
 .../wolveringer/nbt/NBTCompressedStreamTools.java  |  168 +++
 src/main/java/dev/wolveringer/nbt/NBTNumber.java   |   19 +
 .../java/dev/wolveringer/nbt/NBTReadLimiter.java   |   19 +
 .../wolveringer/nbt/NBTReadLimiterUnlimited.java   |   10 +
 src/main/java/dev/wolveringer/nbt/NBTTagByte.java  |  102 ++
 .../java/dev/wolveringer/nbt/NBTTagByteArray.java  |   89 ++
 .../java/dev/wolveringer/nbt/NBTTagCompound.java   |  341 +++++
 .../java/dev/wolveringer/nbt/NBTTagDouble.java     |  104 ++
 src/main/java/dev/wolveringer/nbt/NBTTagEnd.java   |   38 +
 src/main/java/dev/wolveringer/nbt/NBTTagFloat.java |  102 ++
 src/main/java/dev/wolveringer/nbt/NBTTagInt.java   |  102 ++
 .../java/dev/wolveringer/nbt/NBTTagIntArray.java   |  112 ++
 src/main/java/dev/wolveringer/nbt/NBTTagList.java  |  177 +++
 src/main/java/dev/wolveringer/nbt/NBTTagLong.java  |  101 ++
 src/main/java/dev/wolveringer/nbt/NBTTagShort.java |  102 ++
 .../java/dev/wolveringer/nbt/NBTTagString.java     |   91 ++
 src/main/java/dev/wolveringer/network/Cleaner.java |   16 +
 src/main/java/dev/wolveringer/network/Decoder.java |  223 +++
 src/main/java/dev/wolveringer/network/Encoder.java |   94 ++
 .../dev/wolveringer/network/IIInitialHandler.java  |  379 ++++++
 .../dev/wolveringer/network/IInitialHandler.java   |  231 ++++
 .../network/ProxiedPlayerUserConnection.java       |  320 +++++
 .../network/channel/ChannelHandler.java            |  121 ++
 .../network/channel/ChannelWrapper.java            |  349 +++++
 .../network/channel/init/BungeeConnectionInit.java |   26 +
 .../channel/init/BungeeUtilChannelInit.java        |  135 ++
 .../network/channel/init/ChannelInizializer.java   |   59 +
 .../network/inject/XChannelFutureListener.java     |   47 +
 .../network/inject/XChannelInitializer.java        |   33 +
 .../dev/wolveringer/packet/ByteBuffCreator.java    |   32 +
 .../java/dev/wolveringer/packet/DebugMenue.java    |  356 +++++
 .../dev/wolveringer/packet/MathHelper_v1_8.java    |  232 ++++
 .../dev/wolveringer/packet/ObjectSereizer.java     |   20 +
 .../wolveringer/packet/PacketDataSerializer.java   |  885 ++++++++++++
 .../packet/PacketDataSerializer_v1_7.java          |  199 +++
 .../packet/PacketDataSerializer_v1_8.java          |  263 ++++
 .../packet/PacketDataSerializer_vX_X.java          |   17 +
 .../java/dev/wolveringer/packet/PacketHandle.java  |  210 +++
 .../dev/wolveringer/profiler/MethodProfiler.java   |   64 +
 .../dev/wolveringer/profiler/ProfileMenue.java     |   69 +
 .../java/dev/wolveringer/profiler/Profiler.java    |  253 ++++
 .../java/dev/wolveringer/profiler/Timings.java     |  185 +++
 .../java/dev/wolveringer/strings/Messages.java     |   20 +
 .../dev/wolveringer/terminal/TerminalListener.java |  218 +++
 src/main/java/dev/wolveringer/updater/Updater.java |  325 +++++
 src/main/java/dev/wolveringer/util/ByteString.java |   25 +
 src/main/java/dev/wolveringer/util/MathUtil.java   |   31 +
 .../java/dev/wolveringer/util/UtilReflection.java  |   92 ++
 src/main/resources/Messages.properties             |   24 +
 src/main/resources/bungee.yml                      |    4 +
 src/main/resources/config.yml                      |   58 +
 src/main/resources/plugin.yml                      |    6 +
 .../test/NormalPacketCreatorRedefieTest.java       |    7 +
 294 files changed, 33266 insertions(+)
 create mode 100644 .gitattributes
 create mode 100644 .gitignore
 create mode 100644 LICENSE.txt
 create mode 100644 README.md
 create mode 100644 build.gradle
 create mode 100644 circle.yml
 create mode 100644 gradle.properties
 create mode 100644 gradle/wrapper/gradle-wrapper.jar
 create mode 100644 gradle/wrapper/gradle-wrapper.properties
 create mode 100644 gradlew
 create mode 100644 gradlew.bat
 create mode 100644 settings.gradle
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/AsyncCatcher.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/BlockFace.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/BungeeUtil.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/ClientVersion.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/CostumPrintStream.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/DebugProperties.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/HandType.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/HandleErrorAction.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/Main.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/Material.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/MaterialData.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/NumberConversions.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/OperatingSystem/OperatingSystemType.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/OperationCalback.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/PacketHandleEvent.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/PacketHandler.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/PacketLib.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/Player.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/RamStatistics.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/RamStatisticsPainter.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/bukkit/BukkitMain.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/configuration/Configuration.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/exception/ExceptionUtils.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/gameprofile/GameProfile.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/gameprofile/GameProfileSerializer.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/gameprofile/PlayerInfoData.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/gameprofile/Property.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/gameprofile/PropertyMap.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/gameprofile/Skin.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/gameprofile/SkinCache.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/gameprofile/SkinFactory.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/gameprofile/SkinRequest.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/gameprofile/SteveSkin.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/gameprofile/Test.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/gameprofile/UUIDFetcher.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/injector/InjectFiles.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/item/ClickListener.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/item/Item.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/item/ItemBuilder.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/item/ItemStack.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/item/MultiClickItemStack.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/item/SyncHandle.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/item/Test.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/item/itemmeta/CraftItemMeta.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/item/itemmeta/ItemMeta.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/item/itemmeta/MetaFactory.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/item/itemmeta/MetaListener.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/item/itemmeta/SkullMeta.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/packets/Abstract/PacketAbstract.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/packets/Abstract/PacketPlayIn.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/packets/Abstract/PacketPlayOut.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/packets/Abstract/PacketPlayOutEntityAbstract.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/packets/Abstract/PacketPlayXXXHeldItemSlot.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/packets/AbstractPacketCreator.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/packets/BetaPacket.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/packets/NormalPacketCreator.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/packets/Packet.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/packets/PacketLoginDisconnect.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInArmAnimation.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInBlockDig.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInBlockPlace.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInChat.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInClientState.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInCloseWindow.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInFlying.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInHeldItemSlot.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInLook.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInPluginMessage.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInPosition.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInPositionLook.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInUpdateSign.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInUseEntity.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInWindowClick.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutBossBar.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutChat.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutCloseWindow.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutDisconnect.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutEntityDestroy.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutEntityEffect.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutEntityEquipment.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutEntityHeadRotation.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutEntityMetadata.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutEntityProperties.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutEntityTeleport.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutGameStateChange.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutHeldItemSlot.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutKeepAlive.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutNamedEntitySpawn.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutNamedSoundEffect.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutOpenWindow.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutPlayerInfo.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutPlayerListHeaderFooter.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutPluginMessage.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutPosition.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutRemoveEntityEffect.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutScoreboardDisplayObjective.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutScoreboardObjective.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutScoreboardScore.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutScoreboardTeam.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutSetExperience.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutSetSlot.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutSpawnEntity.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutSpawnEntityLiving.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutSpawnPostition.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutStatistic.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutTitle.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutTransaction.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutUpdateHealth.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutUpdateSign.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutWindowData.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutWindowItems.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutWorldParticles.java
 create mode 100644 src/main/java/dev/wolveringer/BungeeUtil/packets/UnderknownPacket.java
 create mode 100644 src/main/java/dev/wolveringer/NPC/Equipment.java
 create mode 100644 src/main/java/dev/wolveringer/NPC/InteractListener.java
 create mode 100644 src/main/java/dev/wolveringer/NPC/NPC.java
 create mode 100644 src/main/java/dev/wolveringer/NPC/NPCData.java
 create mode 100644 src/main/java/dev/wolveringer/Reflect/Test/Main.java
 create mode 100644 src/main/java/dev/wolveringer/Reflect/Test/TEST.java
 create mode 100644 src/main/java/dev/wolveringer/Reflect/Test/TestClass.java
 create mode 100644 src/main/java/dev/wolveringer/Reflect/Until.java
 create mode 100644 src/main/java/dev/wolveringer/ServerDatReader.java
 create mode 100644 src/main/java/dev/wolveringer/TimingsDataReader.java
 create mode 100644 src/main/java/dev/wolveringer/animations/Animation.java
 create mode 100644 src/main/java/dev/wolveringer/animations/AnimationCallback.java
 create mode 100644 src/main/java/dev/wolveringer/animations/AnimatonLoop.java
 create mode 100644 src/main/java/dev/wolveringer/animations/inventory/InventoryViewChangeAnimations.java
 create mode 100644 src/main/java/dev/wolveringer/animations/inventory/LimetedScheduller.java
 create mode 100644 src/main/java/dev/wolveringer/animations/text/FormatTest.java
 create mode 100644 src/main/java/dev/wolveringer/animations/text/NumericUntil.java
 create mode 100644 src/main/java/dev/wolveringer/animations/text/RunningTextFormater.java
 create mode 100644 src/main/java/dev/wolveringer/animations/text/Scroller.java
 create mode 100644 src/main/java/dev/wolveringer/animations/text/StringUntils.java
 create mode 100644 src/main/java/dev/wolveringer/animations/text/TextFormater.java
 create mode 100644 src/main/java/dev/wolveringer/animations/text/TickedTextFormater.java
 create mode 100644 src/main/java/dev/wolveringer/api/bossbar/BossBarListener.java
 create mode 100644 src/main/java/dev/wolveringer/api/bossbar/BossBarManager.java
 create mode 100644 src/main/java/dev/wolveringer/api/datawatcher/BlockData.java
 create mode 100644 src/main/java/dev/wolveringer/api/datawatcher/DataWatcher.java
 create mode 100644 src/main/java/dev/wolveringer/api/datawatcher/DataWatcherObjekt.java
 create mode 100644 src/main/java/dev/wolveringer/api/datawatcher/Direction.java
 create mode 100644 src/main/java/dev/wolveringer/api/datawatcher/EntityDataWatcher.java
 create mode 100644 src/main/java/dev/wolveringer/api/datawatcher/HumanDataWatcher.java
 create mode 100644 src/main/java/dev/wolveringer/api/datawatcher/LivingEntityDataWatcher.java
 create mode 100644 src/main/java/dev/wolveringer/api/datawatcher/OptionalBlockPosition.java
 create mode 100644 src/main/java/dev/wolveringer/api/datawatcher/OptionalUUID.java
 create mode 100644 src/main/java/dev/wolveringer/api/datawatcher/impl/DataWatcherObjekt.java
 create mode 100644 src/main/java/dev/wolveringer/api/datawatcher/impl/v1_10_DataWatcher.java
 create mode 100644 src/main/java/dev/wolveringer/api/datawatcher/impl/v1_10_EntityDataWatcher.java
 create mode 100644 src/main/java/dev/wolveringer/api/datawatcher/impl/v1_10_HumanEntityDataWatcher.java
 create mode 100644 src/main/java/dev/wolveringer/api/datawatcher/impl/v1_10_LivingEntityDataWatcher.java
 create mode 100644 src/main/java/dev/wolveringer/api/datawatcher/impl/v1_8_DataWatcher.java
 create mode 100644 src/main/java/dev/wolveringer/api/datawatcher/impl/v1_8_EntityDataWatcher.java
 create mode 100644 src/main/java/dev/wolveringer/api/datawatcher/impl/v1_8_HumanEntityDataWatcher.java
 create mode 100644 src/main/java/dev/wolveringer/api/datawatcher/impl/v1_8_LivingEntityDataWatcher.java
 create mode 100644 src/main/java/dev/wolveringer/api/datawatcher/impl/v1_9_DataWatcher.java
 create mode 100644 src/main/java/dev/wolveringer/api/datawatcher/impl/v1_9_EntityDataWatcher.java
 create mode 100644 src/main/java/dev/wolveringer/api/datawatcher/impl/v1_9_HumanEntityDataWatcher.java
 create mode 100644 src/main/java/dev/wolveringer/api/datawatcher/impl/v1_9_LivingEntityDataWatcher.java
 create mode 100644 src/main/java/dev/wolveringer/api/gui/AnvilGui.java
 create mode 100644 src/main/java/dev/wolveringer/api/gui/AnvilGuiListener.java
 create mode 100644 src/main/java/dev/wolveringer/api/inventory/Inventory.java
 create mode 100644 src/main/java/dev/wolveringer/api/inventory/InventoryType.java
 create mode 100644 src/main/java/dev/wolveringer/api/inventory/ItemContainer.java
 create mode 100644 src/main/java/dev/wolveringer/api/inventory/PlayerInventory.java
 create mode 100644 src/main/java/dev/wolveringer/api/inventory/ScrolingInventory.java
 create mode 100644 src/main/java/dev/wolveringer/api/particel/ParticleEffect.java
 create mode 100644 src/main/java/dev/wolveringer/api/position/BlockPosition.java
 create mode 100644 src/main/java/dev/wolveringer/api/position/Location.java
 create mode 100644 src/main/java/dev/wolveringer/api/position/Potision.java
 create mode 100644 src/main/java/dev/wolveringer/api/position/Vector.java
 create mode 100644 src/main/java/dev/wolveringer/api/position/Vector3f.java
 create mode 100644 src/main/java/dev/wolveringer/api/scoreboard/Objektive.java
 create mode 100644 src/main/java/dev/wolveringer/api/scoreboard/PacketListenerScoreboard.java
 create mode 100644 src/main/java/dev/wolveringer/api/scoreboard/Scoreboard.java
 create mode 100644 src/main/java/dev/wolveringer/api/scoreboard/Team.java
 create mode 100644 src/main/java/dev/wolveringer/api/sound/SoundCategory.java
 create mode 100644 src/main/java/dev/wolveringer/api/sound/SoundEffect.java
 create mode 100644 src/main/java/dev/wolveringer/chat/ChatBaseComponent.java
 create mode 100644 src/main/java/dev/wolveringer/chat/ChatClickListener.java
 create mode 100644 src/main/java/dev/wolveringer/chat/ChatClickable.java
 create mode 100644 src/main/java/dev/wolveringer/chat/ChatColor/AnsiColorFormater.java
 create mode 100644 src/main/java/dev/wolveringer/chat/ChatColor/ChatColorUtils.java
 create mode 100644 src/main/java/dev/wolveringer/chat/ChatComponentText.java
 create mode 100644 src/main/java/dev/wolveringer/chat/ChatFunction1.java
 create mode 100644 src/main/java/dev/wolveringer/chat/ChatFunction2.java
 create mode 100644 src/main/java/dev/wolveringer/chat/ChatHoverable.java
 create mode 100644 src/main/java/dev/wolveringer/chat/ChatMessage.java
 create mode 100644 src/main/java/dev/wolveringer/chat/ChatMessageException.java
 create mode 100644 src/main/java/dev/wolveringer/chat/ChatModifier.java
 create mode 100644 src/main/java/dev/wolveringer/chat/ChatModifierSerializer.java
 create mode 100644 src/main/java/dev/wolveringer/chat/ChatSerializer.java
 create mode 100644 src/main/java/dev/wolveringer/chat/ChatStyleRoot.java
 create mode 100644 src/main/java/dev/wolveringer/chat/ChatTextBuilder.java
 create mode 100644 src/main/java/dev/wolveringer/chat/ChatTypeAdapter.java
 create mode 100644 src/main/java/dev/wolveringer/chat/ChatTypeAdapterFactory.java
 create mode 100644 src/main/java/dev/wolveringer/chat/EnumClickAction.java
 create mode 100644 src/main/java/dev/wolveringer/chat/EnumHoverAction.java
 create mode 100644 src/main/java/dev/wolveringer/chat/IChatBaseComponent.java
 create mode 100644 src/main/java/dev/wolveringer/chat/PlayerChatListener.java
 create mode 100644 src/main/java/dev/wolveringer/chat/StringMethode.java
 create mode 100644 src/main/java/dev/wolveringer/commands/BungeeTimings.java
 create mode 100644 src/main/java/dev/wolveringer/commands/RamStatistics.java
 create mode 100644 src/main/java/dev/wolveringer/configuration/Configuration.java
 create mode 100644 src/main/java/dev/wolveringer/configuration/ConfigurationOptions.java
 create mode 100644 src/main/java/dev/wolveringer/configuration/ConfigurationSection.java
 create mode 100644 src/main/java/dev/wolveringer/configuration/InvalidConfigurationException.java
 create mode 100644 src/main/java/dev/wolveringer/configuration/MemoryConfiguration.java
 create mode 100644 src/main/java/dev/wolveringer/configuration/MemoryConfigurationOptions.java
 create mode 100644 src/main/java/dev/wolveringer/configuration/MemorySection.java
 create mode 100644 src/main/java/dev/wolveringer/configuration/file/FileConfiguration.java
 create mode 100644 src/main/java/dev/wolveringer/configuration/file/FileConfigurationOptions.java
 create mode 100644 src/main/java/dev/wolveringer/configuration/file/YamlConfiguration.java
 create mode 100644 src/main/java/dev/wolveringer/configuration/file/YamlConfigurationOptions.java
 create mode 100644 src/main/java/dev/wolveringer/configuration/file/YamlConstructor.java
 create mode 100644 src/main/java/dev/wolveringer/configuration/file/YamlRepresenter.java
 create mode 100644 src/main/java/dev/wolveringer/configuration/serialization/ConfigurationSerializable.java
 create mode 100644 src/main/java/dev/wolveringer/configuration/serialization/ConfigurationSerialization.java
 create mode 100644 src/main/java/dev/wolveringer/configuration/serialization/DelegateDeserialization.java
 create mode 100644 src/main/java/dev/wolveringer/configuration/serialization/SerializableAs.java
 create mode 100644 src/main/java/dev/wolveringer/hastebin/DocumentNotFoundException.java
 create mode 100644 src/main/java/dev/wolveringer/hastebin/HastebinDocument.java
 create mode 100644 src/main/java/dev/wolveringer/hastebin/HastebinPost.java
 create mode 100644 src/main/java/dev/wolveringer/listener/InventoryResetListener.java
 create mode 100644 src/main/java/dev/wolveringer/maps/CachedArrayList.java
 create mode 100644 src/main/java/dev/wolveringer/maps/CachedHashMap.java
 create mode 100644 src/main/java/dev/wolveringer/nbt/LimitStream.java
 create mode 100644 src/main/java/dev/wolveringer/nbt/MathHelper.java
 create mode 100644 src/main/java/dev/wolveringer/nbt/NBTBase.java
 create mode 100644 src/main/java/dev/wolveringer/nbt/NBTCompressedStreamTools.java
 create mode 100644 src/main/java/dev/wolveringer/nbt/NBTNumber.java
 create mode 100644 src/main/java/dev/wolveringer/nbt/NBTReadLimiter.java
 create mode 100644 src/main/java/dev/wolveringer/nbt/NBTReadLimiterUnlimited.java
 create mode 100644 src/main/java/dev/wolveringer/nbt/NBTTagByte.java
 create mode 100644 src/main/java/dev/wolveringer/nbt/NBTTagByteArray.java
 create mode 100644 src/main/java/dev/wolveringer/nbt/NBTTagCompound.java
 create mode 100644 src/main/java/dev/wolveringer/nbt/NBTTagDouble.java
 create mode 100644 src/main/java/dev/wolveringer/nbt/NBTTagEnd.java
 create mode 100644 src/main/java/dev/wolveringer/nbt/NBTTagFloat.java
 create mode 100644 src/main/java/dev/wolveringer/nbt/NBTTagInt.java
 create mode 100644 src/main/java/dev/wolveringer/nbt/NBTTagIntArray.java
 create mode 100644 src/main/java/dev/wolveringer/nbt/NBTTagList.java
 create mode 100644 src/main/java/dev/wolveringer/nbt/NBTTagLong.java
 create mode 100644 src/main/java/dev/wolveringer/nbt/NBTTagShort.java
 create mode 100644 src/main/java/dev/wolveringer/nbt/NBTTagString.java
 create mode 100644 src/main/java/dev/wolveringer/network/Cleaner.java
 create mode 100644 src/main/java/dev/wolveringer/network/Decoder.java
 create mode 100644 src/main/java/dev/wolveringer/network/Encoder.java
 create mode 100644 src/main/java/dev/wolveringer/network/IIInitialHandler.java
 create mode 100644 src/main/java/dev/wolveringer/network/IInitialHandler.java
 create mode 100644 src/main/java/dev/wolveringer/network/ProxiedPlayerUserConnection.java
 create mode 100644 src/main/java/dev/wolveringer/network/channel/ChannelHandler.java
 create mode 100644 src/main/java/dev/wolveringer/network/channel/ChannelWrapper.java
 create mode 100644 src/main/java/dev/wolveringer/network/channel/init/BungeeConnectionInit.java
 create mode 100644 src/main/java/dev/wolveringer/network/channel/init/BungeeUtilChannelInit.java
 create mode 100644 src/main/java/dev/wolveringer/network/channel/init/ChannelInizializer.java
 create mode 100644 src/main/java/dev/wolveringer/network/inject/XChannelFutureListener.java
 create mode 100644 src/main/java/dev/wolveringer/network/inject/XChannelInitializer.java
 create mode 100644 src/main/java/dev/wolveringer/packet/ByteBuffCreator.java
 create mode 100644 src/main/java/dev/wolveringer/packet/DebugMenue.java
 create mode 100644 src/main/java/dev/wolveringer/packet/MathHelper_v1_8.java
 create mode 100644 src/main/java/dev/wolveringer/packet/ObjectSereizer.java
 create mode 100644 src/main/java/dev/wolveringer/packet/PacketDataSerializer.java
 create mode 100644 src/main/java/dev/wolveringer/packet/PacketDataSerializer_v1_7.java
 create mode 100644 src/main/java/dev/wolveringer/packet/PacketDataSerializer_v1_8.java
 create mode 100644 src/main/java/dev/wolveringer/packet/PacketDataSerializer_vX_X.java
 create mode 100644 src/main/java/dev/wolveringer/packet/PacketHandle.java
 create mode 100644 src/main/java/dev/wolveringer/profiler/MethodProfiler.java
 create mode 100644 src/main/java/dev/wolveringer/profiler/ProfileMenue.java
 create mode 100644 src/main/java/dev/wolveringer/profiler/Profiler.java
 create mode 100644 src/main/java/dev/wolveringer/profiler/Timings.java
 create mode 100644 src/main/java/dev/wolveringer/strings/Messages.java
 create mode 100644 src/main/java/dev/wolveringer/terminal/TerminalListener.java
 create mode 100644 src/main/java/dev/wolveringer/updater/Updater.java
 create mode 100644 src/main/java/dev/wolveringer/util/ByteString.java
 create mode 100644 src/main/java/dev/wolveringer/util/MathUtil.java
 create mode 100644 src/main/java/dev/wolveringer/util/UtilReflection.java
 create mode 100644 src/main/resources/Messages.properties
 create mode 100644 src/main/resources/bungee.yml
 create mode 100644 src/main/resources/config.yml
 create mode 100644 src/main/resources/plugin.yml
 create mode 100644 src/test/java/dev/wolveringer/test/NormalPacketCreatorRedefieTest.java

diff --git a/.gitattributes b/.gitattributes
new file mode 100644
index 0000000..1abcd92
--- /dev/null
+++ b/.gitattributes
@@ -0,0 +1,3 @@
+*.java text eol=lf
+*.yml text eol=lf
+*.properties text eol=lf
\ No newline at end of file
diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..cc9d563
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,35 @@
+# Created by .ignore support plugin (hsz.mobi)
+
+# IntelliJ project files
+.idea
+*.iml
+out
+gen### Java template
+*.class
+
+# Mobile Tools for Java (J2ME)
+.mtj.tmp/
+
+# Package Files #
+*.jar
+*.war
+*.ear
+
+# virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xml
+hs_err_pid*
+
+.gradle
+build/
+
+# Ignore Gradle GUI config
+gradle-app.setting
+
+# Avoid ignoring Gradle wrapper jar file (.jar files are usually ignored)
+!gradle-wrapper.jar
+
+# Cache of project
+.gradletasknamecache
+
+# # Work around https://youtrack.jetbrains.com/issue/IDEA-116898
+# gradle/wrapper/gradle-wrapper.properties
+
diff --git a/LICENSE.txt b/LICENSE.txt
new file mode 100644
index 0000000..00d2e13
--- /dev/null
+++ b/LICENSE.txt
@@ -0,0 +1,24 @@
+This is free and unencumbered software released into the public domain.
+
+Anyone is free to copy, modify, publish, use, compile, sell, or
+distribute this software, either in source code form or as a compiled
+binary, for any purpose, commercial or non-commercial, and by any
+means.
+
+In jurisdictions that recognize copyright laws, the author or authors
+of this software dedicate any and all copyright interest in the
+software to the public domain. We make this dedication for the benefit
+of the public at large and to the detriment of our heirs and
+successors. We intend this dedication to be an overt act of
+relinquishment in perpetuity of all present and future rights to this
+software under copyright law.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+OTHER DEALINGS IN THE SOFTWARE.
+
+For more information, please refer to <http://unlicense.org/>
\ No newline at end of file
diff --git a/README.md b/README.md
new file mode 100644
index 0000000..77609d3
--- /dev/null
+++ b/README.md
@@ -0,0 +1,43 @@
+# RetileBungeeUtil
+[![Circle CI](https://img.shields.io/circleci/project/Acquized/RetileBungeeUtil.svg?maxAge=300&style=flat-square)](https://circleci.com/gh/Acquized/RetileBungeeUtil)
+[![Version](https://img.shields.io/github/release/Acquized/RetileBungeeUtil.svg?maxAge=2592000&style=flat-square)](https://github.com/WolverinDEV/BungeeUtil/tree/jars)
+[![BungeeUtil](https://img.shields.io/badge/origin-BungeeUtil-lightgrey.svg?maxAge=2592000&style=flat-square)](https://github.com/WolverinDEV/BungeeUtil)  
+
+ProjectRetile's official Fork of the popular BungeeUtil Library.  
+  
+### Information
+This is ProjectRetile's official Fork of the popular BungeeUtil Library. This Fork is shaded directly into the ProjectRetile Plugin.
+The Code in this upstream Repository is owned and copyrighted by WolverinDev. All credits go to him. All Commits commited by Acquized
+are internal Changes to the Plugin for the best User Experience of ProjectRetile and this Library.  
+  
+### Binaries
+Pre-compiled Binaries are not avaible for the end user. I strongly discourage anyone to build this Project by themself cause it may not work. 
+If you still want to build the Project, use `gradlew clean build shadowJar` to build the Project.  
+  
+### Continous Integration
+This Fork uses [Circle CI](https://circleci.com/) for Continous Integration. You can visit the Project [here](https://circleci.com/gh/Acquized/RetileBungeeUtil).  
+  
+### Maven
+```xml
+<repositories>
+    <repository>
+        <id>jitpack-central</id>
+        <url>https://jitpack.io</url>
+    </repository>
+</repositories>
+
+<dependencies>
+    <dependency>
+        <groupId>com.github.acquized</groupId>
+        <artifactId>RetileBungeeUtil</artifactId>
+        <version>master-SNAPSHOT</version>
+        <scope>provided</scope>
+    </dependency>
+</dependencies>
+```  
+  
+### License
+The Project's licensed is mirrored from its origin Project, BungeeUtil. BungeeUtil's Upstream Repository doesn't contains a `LICENSE.txt` File, so its
+automaticly licensed under the Unlicense. Please visit the LICENSE.txt File for the complete License.  
+  
+Copyright Â© 2016 WolverinDev
\ No newline at end of file
diff --git a/build.gradle b/build.gradle
new file mode 100644
index 0000000..a81bc98
--- /dev/null
+++ b/build.gradle
@@ -0,0 +1,123 @@
+apply plugin: 'java'
+apply plugin: 'idea'
+apply plugin: 'com.github.johnrengelman.shadow'
+apply plugin: 'io.franzbecker.gradle-lombok'
+
+println """
+***************************************
+ You are building ProjectRetile's Fork of BungeeUtil!
+
+ If you encounter trouble:
+ 1) Read the wiki if you haven't yet
+ 2) Try running 'build' in a separate Gradle run
+ 3) Use gradlew and not gradle
+ 4) If you still need help, ask per Spigot PM. Do not open a Issue
+
+***************************************
+"""
+
+group 'dev.wolveringer'
+version '1.0.0-SNAPSHOT'
+sourceCompatibility = 1.7
+
+repositories {
+    mavenCentral()
+    mavenLocal()
+    maven {
+        name 'acquized-repo'
+        url 'http://www.acquized.pw/content/repositories/releases/'
+    }
+    maven {
+        name 'jitpack-central'
+        url 'https://jitpack.io'
+    }
+}
+
+dependencies {
+    // Provided at Runtime
+    compile ("net.md-5:bungeecord-api:1.10-SNAPSHOT") {
+        exclude group: 'io.netty', module: 'netty-buffer'
+        exclude group: 'io.netty', module: 'netty-codec'
+        exclude group: 'io.netty', module: 'netty-codec-http'
+        exclude group: 'io.netty', module: 'netty-common'
+        exclude group: 'io.netty', module: 'netty-handler'
+        exclude group: 'io.netty', module: 'netty-resolver'
+        exclude group: 'io.netty', module: 'netty-transport'
+        exclude group: 'io.netty', module: 'netty-transport-native-epoll'
+    }
+    compile ("net.md-5:bungeecord-proxy:1.10-SNAPSHOT") {
+        exclude group: 'io.netty', module: 'netty-buffer'
+        exclude group: 'io.netty', module: 'netty-codec'
+        exclude group: 'io.netty', module: 'netty-codec-http'
+        exclude group: 'io.netty', module: 'netty-common'
+        exclude group: 'io.netty', module: 'netty-handler'
+        exclude group: 'io.netty', module: 'netty-resolver'
+        exclude group: 'io.netty', module: 'netty-transport'
+        exclude group: 'io.netty', module: 'netty-transport-native-epoll'
+    }
+    compile group: 'io.netty', name: 'netty-handler', version: '4.0.41.Final'
+    compile group: 'org.projectlombok', name: 'lombok', version: '1.16.8'
+
+    // Compile using ShadowJar
+    compile group: 'org.json', name: 'json', version: '20160212'
+    compile group: 'org.jsoup', name: 'jsoup', version: '1.9.2'
+    compile group: 'commons-io', name: 'commons-io', version: '2.4'
+    compile group: 'dev.wolveringer', name: 'TerminalUtils', version: '0.0.1-SNAPSHOT'
+
+    // Test
+    testCompile group: 'junit', name: 'junit', version: '4.11'
+}
+
+buildscript {
+    repositories {
+        jcenter()
+        maven { url 'https://plugins.gradle.org/m2/' }
+    }
+    dependencies {
+        classpath 'com.github.jengelman.gradle.plugins:shadow:1.2.3'
+        classpath 'io.franzbecker:gradle-lombok:1.6'
+        classpath "info.robotbrain.gradle.lombok:lombok-gradle:1.1"
+    }
+}
+
+//noinspection GroovyMissingReturnStatement
+shadowJar {
+    dependencies {
+        include(dependency('org.json:json:20160212'))
+        include(dependency('org.jsoup:jsoup:1.9.2'))
+        include(dependency('commons-io:commons-io:2.4'))
+        include(dependency('dev.wolveringer:TerminalUtils:0.0.1-SNAPSHOT'))
+    }
+}
+
+processResources {
+    expand project.properties
+}
+
+task delombok {
+    //noinspection GroovyAssignabilityCheck
+    description 'Delomboks the entire source code tree'
+    def srcDelomboked = 'build/src-delomboked'
+    def srcJava = 'src'
+
+    inputs.files file( srcJava )
+    outputs.dir file( srcDelomboked )
+
+    doLast {
+        //noinspection GroovyAssignabilityCheck
+        def collection = files( configurations.compile + configurations.testCompile )
+        def sumTree = collection + fileTree( dir: 'bin' )
+
+        ant.taskdef( name: 'delombok', classname: 'lombok.delombok.ant.DelombokTask',
+                classpath: configurations.compile.asPath +
+                        configurations.testCompile.asPath )
+        ant.delombok( from:srcJava, to:srcDelomboked, classpath: sumTree.asPath )
+
+
+        // Replace current src directory with delomboked source
+        copy {
+            from srcDelomboked
+            into srcJava
+        }
+    }
+}
\ No newline at end of file
diff --git a/circle.yml b/circle.yml
new file mode 100644
index 0000000..e69de29
diff --git a/gradle.properties b/gradle.properties
new file mode 100644
index 0000000..a85d0dc
--- /dev/null
+++ b/gradle.properties
@@ -0,0 +1,5 @@
+projectName = RetileBungeeUtil
+group = dev.wolveringer
+version = 1.0.0-SNAPSHOT
+author = WolverinDEV
+main = dev.wolveringer.BungeeUtil.Main
\ No newline at end of file
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
new file mode 100644
index 0000000000000000000000000000000000000000..ca78035ef0501d802d4fc55381ef2d5c3ce0ec6e
GIT binary patch
literal 53556
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
Q83rH(K<qiVj&HyHKR~t&1poj5

literal 0
HcmV?d00001

diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
new file mode 100644
index 0000000..418256e
--- /dev/null
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -0,0 +1,6 @@
+#Tue Oct 04 23:10:01 CEST 2016
+distributionBase=GRADLE_USER_HOME
+distributionPath=wrapper/dists
+zipStoreBase=GRADLE_USER_HOME
+zipStorePath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.13-all.zip
diff --git a/gradlew b/gradlew
new file mode 100644
index 0000000..27309d9
--- /dev/null
+++ b/gradlew
@@ -0,0 +1,164 @@
+#!/usr/bin/env bash
+
+##############################################################################
+##
+##  Gradle start up script for UN*X
+##
+##############################################################################
+
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >/dev/null
+APP_HOME="`pwd -P`"
+cd "$SAVED" >/dev/null
+
+APP_NAME="Gradle"
+APP_BASE_NAME=`basename "$0"`
+
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""
+
+# Use the maximum available, or set MAX_FD != -1 to use that value.
+MAX_FD="maximum"
+
+warn ( ) {
+    echo "$*"
+}
+
+die ( ) {
+    echo
+    echo "$*"
+    echo
+    exit 1
+}
+
+# OS specific support (must be 'true' or 'false').
+cygwin=false
+msys=false
+darwin=false
+nonstop=false
+case "`uname`" in
+  CYGWIN* )
+    cygwin=true
+    ;;
+  Darwin* )
+    darwin=true
+    ;;
+  MINGW* )
+    msys=true
+    ;;
+  NONSTOP* )
+    nonstop=true
+    ;;
+esac
+
+CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
+
+# Determine the Java command to use to start the JVM.
+if [ -n "$JAVA_HOME" ] ; then
+    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
+        # IBM's JDK on AIX uses strange locations for the executables
+        JAVACMD="$JAVA_HOME/jre/sh/java"
+    else
+        JAVACMD="$JAVA_HOME/bin/java"
+    fi
+    if [ ! -x "$JAVACMD" ] ; then
+        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+    fi
+else
+    JAVACMD="java"
+    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+fi
+
+# Increase the maximum file descriptors if we can.
+if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
+    MAX_FD_LIMIT=`ulimit -H -n`
+    if [ $? -eq 0 ] ; then
+        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
+            MAX_FD="$MAX_FD_LIMIT"
+        fi
+        ulimit -n $MAX_FD
+        if [ $? -ne 0 ] ; then
+            warn "Could not set maximum file descriptor limit: $MAX_FD"
+        fi
+    else
+        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
+    fi
+fi
+
+# For Darwin, add options to specify how the application appears in the dock
+if $darwin; then
+    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
+fi
+
+# For Cygwin, switch paths to Windows format before running java
+if $cygwin ; then
+    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
+    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+    JAVACMD=`cygpath --unix "$JAVACMD"`
+
+    # We build the pattern for arguments to be converted via cygpath
+    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
+    SEP=""
+    for dir in $ROOTDIRSRAW ; do
+        ROOTDIRS="$ROOTDIRS$SEP$dir"
+        SEP="|"
+    done
+    OURCYGPATTERN="(^($ROOTDIRS))"
+    # Add a user-defined pattern to the cygpath arguments
+    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
+        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
+    fi
+    # Now convert the arguments - kludge to limit ourselves to /bin/sh
+    i=0
+    for arg in "$@" ; do
+        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
+        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option
+
+        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
+            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
+        else
+            eval `echo args$i`="\"$arg\""
+        fi
+        i=$((i+1))
+    done
+    case $i in
+        (0) set -- ;;
+        (1) set -- "$args0" ;;
+        (2) set -- "$args0" "$args1" ;;
+        (3) set -- "$args0" "$args1" "$args2" ;;
+        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
+        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
+        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
+        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
+        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
+        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
+    esac
+fi
+
+# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
+function splitJvmOpts() {
+    JVM_OPTS=("$@")
+}
+eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
+JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"
+
+exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
diff --git a/gradlew.bat b/gradlew.bat
new file mode 100644
index 0000000..832fdb6
--- /dev/null
+++ b/gradlew.bat
@@ -0,0 +1,90 @@
+@if "%DEBUG%" == "" @echo off
+@rem ##########################################################################
+@rem
+@rem  Gradle startup script for Windows
+@rem
+@rem ##########################################################################
+
+@rem Set local scope for the variables with windows NT shell
+if "%OS%"=="Windows_NT" setlocal
+
+set DIRNAME=%~dp0
+if "%DIRNAME%" == "" set DIRNAME=.
+set APP_BASE_NAME=%~n0
+set APP_HOME=%DIRNAME%
+
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS=
+
+@rem Find java.exe
+if defined JAVA_HOME goto findJavaFromJavaHome
+
+set JAVA_EXE=java.exe
+%JAVA_EXE% -version >NUL 2>&1
+if "%ERRORLEVEL%" == "0" goto init
+
+echo.
+echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:findJavaFromJavaHome
+set JAVA_HOME=%JAVA_HOME:"=%
+set JAVA_EXE=%JAVA_HOME%/bin/java.exe
+
+if exist "%JAVA_EXE%" goto init
+
+echo.
+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:init
+@rem Get command-line arguments, handling Windows variants
+
+if not "%OS%" == "Windows_NT" goto win9xME_args
+if "%@eval[2+2]" == "4" goto 4NT_args
+
+:win9xME_args
+@rem Slurp the command line arguments.
+set CMD_LINE_ARGS=
+set _SKIP=2
+
+:win9xME_args_slurp
+if "x%~1" == "x" goto execute
+
+set CMD_LINE_ARGS=%*
+goto execute
+
+:4NT_args
+@rem Get arguments from the 4NT Shell from JP Software
+set CMD_LINE_ARGS=%$
+
+:execute
+@rem Setup the command line
+
+set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
+
+@rem Execute Gradle
+"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
+
+:end
+@rem End local scope for the variables with windows NT shell
+if "%ERRORLEVEL%"=="0" goto mainEnd
+
+:fail
+rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
+rem the _cmd.exe /c_ return code!
+if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
+exit /b 1
+
+:mainEnd
+if "%OS%"=="Windows_NT" endlocal
+
+:omega
diff --git a/settings.gradle b/settings.gradle
new file mode 100644
index 0000000..8cec7e2
--- /dev/null
+++ b/settings.gradle
@@ -0,0 +1,2 @@
+rootProject.name = 'RetileBungeeUtil'
+
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/AsyncCatcher.java b/src/main/java/dev/wolveringer/BungeeUtil/AsyncCatcher.java
new file mode 100644
index 0000000..1c80c43
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/AsyncCatcher.java
@@ -0,0 +1,66 @@
+package dev.wolveringer.BungeeUtil;
+
+import java.util.ArrayList;
+
+import dev.wolveringer.BungeeUtil.configuration.Configuration;
+import dev.wolveringer.BungeeUtil.exception.ExceptionUtils;
+import net.md_5.bungee.api.plugin.Plugin;
+
+public class AsyncCatcher {
+	
+	public static enum AsyncCatcherMode {
+		DISABLED,
+		EXCEPTION,
+		WARNING;
+		
+		private AsyncCatcherMode() {}
+	}
+	
+	private static AsyncCatcherMode mode = AsyncCatcherMode.EXCEPTION;
+	private static ArrayList<ThreadGroup> unchecked_threads = new ArrayList<ThreadGroup>();
+	private static ArrayList<Plugin> unchecked_plugins = new ArrayList<Plugin>();
+	
+	public static void catchOp(String reason) {
+		if(mode != AsyncCatcherMode.DISABLED){
+			if(unchecked_threads.size() != 0)
+				for(Plugin p : unchecked_plugins)
+					if(p.getDescription().getName().contains(Thread.currentThread().getThreadGroup().getName()))
+						return;
+			if(unchecked_threads.size() != 0)
+				if(unchecked_threads.contains(Thread.currentThread().getThreadGroup()))
+					return;
+			if(mode == AsyncCatcherMode.EXCEPTION)
+				throw new IllegalStateException("Asynchronous " + reason + "!"); 
+			else if(mode == AsyncCatcherMode.WARNING){
+				StackTraceElement e = ExceptionUtils.getCurruntMethodeStackTraceElement();
+				if(e == null)
+					BungeeUtil.getInstance().sendMessage("Async catcher catched from underknown src. Message: "+reason);
+				else
+					BungeeUtil.getInstance().sendMessage("Async catcher catched from "+e.getClassName()+"#"+e.getMethodName()+"("+e.getLineNumber()+"). Message: "+reason);
+			}
+		}
+	}
+	
+	public static void disable(Plugin plugin){
+		if(unchecked_threads.contains(Thread.currentThread().getThreadGroup()));
+			//throw new UnsupportedOperationException("Thread alredy unregistered!");
+		unchecked_threads.add(Thread.currentThread().getThreadGroup());
+		unchecked_plugins.add(plugin);
+	}
+	public static void enable(Plugin plugin){
+		if(!unchecked_threads.contains(Thread.currentThread().getThreadGroup()));
+			//throw new UnsupportedOperationException("Thread alredy registered!");
+		unchecked_plugins.remove(plugin);
+		unchecked_threads.remove(Thread.currentThread().getThreadGroup());
+	}
+	@Deprecated
+	public static void disableAll(){
+		mode = AsyncCatcherMode.DISABLED;
+	}
+
+	public static void init() {
+		mode = Configuration.getAsyncMode();
+		if(mode == null)
+			throw new RuntimeException("Async catcher mode not found!");
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/BlockFace.java b/src/main/java/dev/wolveringer/BungeeUtil/BlockFace.java
new file mode 100644
index 0000000..524e65d
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/BlockFace.java
@@ -0,0 +1,136 @@
+package dev.wolveringer.BungeeUtil;
+
+public enum BlockFace {
+    NORTH(0, 0, -1),
+    EAST(1, 0, 0),
+    SOUTH(0, 0, 1),
+    WEST(-1, 0, 0),
+    UP(0, 1, 0),
+    DOWN(0, -1, 0),
+    NORTH_EAST(NORTH, EAST),
+    NORTH_WEST(NORTH, WEST),
+    SOUTH_EAST(SOUTH, EAST),
+    SOUTH_WEST(SOUTH, WEST),
+    WEST_NORTH_WEST(WEST, NORTH_WEST),
+    NORTH_NORTH_WEST(NORTH, NORTH_WEST),
+    NORTH_NORTH_EAST(NORTH, NORTH_EAST),
+    EAST_NORTH_EAST(EAST, NORTH_EAST),
+    EAST_SOUTH_EAST(EAST, SOUTH_EAST),
+    SOUTH_SOUTH_EAST(SOUTH, SOUTH_EAST),
+    SOUTH_SOUTH_WEST(SOUTH, SOUTH_WEST),
+    WEST_SOUTH_WEST(WEST, SOUTH_WEST),
+    SELF(0, 0, 0);
+
+    private final int modX;
+    private final int modY;
+    private final int modZ;
+
+    private BlockFace(final int modX, final int modY, final int modZ) {
+        this.modX = modX;
+        this.modY = modY;
+        this.modZ = modZ;
+    }
+
+    private BlockFace(final BlockFace face1, final BlockFace face2) {
+        this.modX = face1.getModX() + face2.getModX();
+        this.modY = face1.getModY() + face2.getModY();
+        this.modZ = face1.getModZ() + face2.getModZ();
+    }
+
+    /**
+     * Get the amount of X-coordinates to modify to get the represented block
+     *
+     * @return Amount of X-coordinates to modify
+     */
+    public int getModX() {
+        return modX;
+    }
+
+    /**
+     * Get the amount of Y-coordinates to modify to get the represented block
+     *
+     * @return Amount of Y-coordinates to modify
+     */
+    public int getModY() {
+        return modY;
+    }
+
+    /**
+     * Get the amount of Z-coordinates to modify to get the represented block
+     *
+     * @return Amount of Z-coordinates to modify
+     */
+    public int getModZ() {
+        return modZ;
+    }
+
+    public BlockFace getOppositeFace() {
+        switch (this) {
+        case NORTH:
+            return BlockFace.SOUTH;
+
+        case SOUTH:
+            return BlockFace.NORTH;
+
+        case EAST:
+            return BlockFace.WEST;
+
+        case WEST:
+            return BlockFace.EAST;
+
+        case UP:
+            return BlockFace.DOWN;
+
+        case DOWN:
+            return BlockFace.UP;
+
+        case NORTH_EAST:
+            return BlockFace.SOUTH_WEST;
+
+        case NORTH_WEST:
+            return BlockFace.SOUTH_EAST;
+
+        case SOUTH_EAST:
+            return BlockFace.NORTH_WEST;
+
+        case SOUTH_WEST:
+            return BlockFace.NORTH_EAST;
+
+        case WEST_NORTH_WEST:
+            return BlockFace.EAST_SOUTH_EAST;
+
+        case NORTH_NORTH_WEST:
+            return BlockFace.SOUTH_SOUTH_EAST;
+
+        case NORTH_NORTH_EAST:
+            return BlockFace.SOUTH_SOUTH_WEST;
+
+        case EAST_NORTH_EAST:
+            return BlockFace.WEST_SOUTH_WEST;
+
+        case EAST_SOUTH_EAST:
+            return BlockFace.WEST_NORTH_WEST;
+
+        case SOUTH_SOUTH_EAST:
+            return BlockFace.NORTH_NORTH_WEST;
+
+        case SOUTH_SOUTH_WEST:
+            return BlockFace.NORTH_NORTH_EAST;
+
+        case WEST_SOUTH_WEST:
+            return BlockFace.EAST_NORTH_EAST;
+
+        case SELF:
+            return BlockFace.SELF;
+        }
+
+        return BlockFace.SELF;
+    }
+    
+    public static BlockFace getBlockFace(int modx,int mody,int modz){
+    	for(BlockFace f : values())
+    		if(f.getModX() == modx && f.getModY() == mody && f.getModZ() == modz)
+    			return f;
+    	return null;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/BungeeUtil.java b/src/main/java/dev/wolveringer/BungeeUtil/BungeeUtil.java
new file mode 100644
index 0000000..605b7d0
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/BungeeUtil.java
@@ -0,0 +1,296 @@
+package dev.wolveringer.BungeeUtil;
+
+import net.md_5.bungee.BungeeCord;
+import net.md_5.bungee.api.plugin.Plugin;
+
+import java.io.IOException;
+import java.math.BigDecimal;
+import java.math.BigInteger;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+
+import dev.wolveringer.BungeeUtil.configuration.Configuration;
+import dev.wolveringer.BungeeUtil.injector.InjectFiles;
+import dev.wolveringer.BungeeUtil.packets.Packet;
+import dev.wolveringer.chat.ChatColor.AnsiColorFormater;
+import dev.wolveringer.chat.ChatColor.ChatColorUtils;
+import dev.wolveringer.commands.BungeeTimings;
+import dev.wolveringer.listener.InventoryResetListener;
+import dev.wolveringer.network.IIInitialHandler;
+import dev.wolveringer.network.ProxiedPlayerUserConnection;
+import dev.wolveringer.network.channel.init.ChannelInizializer;
+import dev.wolveringer.terminal.TerminalListener;
+import lombok.Getter;
+
+public final class BungeeUtil {
+	@Getter
+	private static Plugin pluginInstance;
+	@Getter
+	private static BungeeUtil instance;
+	
+	public static BungeeUtil createInstance(Plugin plugin){
+		if(instance == null){
+			if(System.getProperty("bungeetil.instance") == null){
+				System.setProperty("bungeetil.instance", "WolverinDEV");
+			}
+			else
+				throw new NullPointerException("BungeeUtil have alredy an instance!");
+			pluginInstance = plugin;
+			instance = new BungeeUtil();
+		}
+		return instance;
+	}
+	
+	private BigInteger state = new BigDecimal(0).toBigInteger();
+	@Getter
+	private boolean active;
+	private boolean costumPromtLine = false;
+	private String costumPormtLineMessage = "";
+	private String costumPormtLineRawMessage = "";
+	private SimpleDateFormat date_format = new SimpleDateFormat("HH:mm:ss");
+	public RamStatistics ramStatistiks;
+	
+	private BungeeUtil() {}
+	
+	public void load(){
+		if(state.testBit(0) || active)
+			throw new RuntimeException("Alredy loading plugin.");
+		if(state.testBit(1))
+			throw new RuntimeException("BungeeUtil alredy loaded!");
+		if(!isInjected() && !state.testBit(3))
+			throw new RuntimeException("BungeeUtil isnt injected!");
+		state.setBit(0);
+		try{
+			active =  true;
+			setInformation("\u00A7aLoading configuration.");
+			sendMessage("\u00A7aLoading configuration.");
+			Configuration.init();
+			sleep(500);
+			setInformation("\u00A7aValidate configuration.");
+			sendMessage("\u00A7aValidate configuration.");
+			if(Configuration.getHandleExceptionAction() == null){
+				sendMessage("\u00A7cCant find the NetworkExceptionAction for "+Configuration.getConfig().getString("network.exception")+". \u00A76Using default ("+HandleErrorAction.DISCONNECT+")");
+				Configuration.getConfig().set("network.exception", HandleErrorAction.DISCONNECT.name().toUpperCase());
+			}
+			sleep(500);
+			setInformation("\u00A7aConfiguration valid.");
+			sendMessage("\u00A7aConfiguration valid.");
+			sleep(500);
+			setInformation("\u00A7aLoading AsyncCatcher");
+			sendMessage("\u00A7aLoading AsyncCatcher");
+			AsyncCatcher.init();
+			AsyncCatcher.disable(pluginInstance);
+			AsyncCatcher.catchOp("Async test failed");
+			TerminalListener.setInstance(new TerminalListener());
+			sleep(500);
+			setInformation("\u00A7aAsyncCatcher successfull loaded");
+			sendMessage("\u00A7aAsyncCatcher successfull loaded");
+			sleep(500);
+			setInformation("\u00A7aLoading ChannelInizializer");
+			sendMessage("\u00A7aLoading ChannelInizializer");
+			boolean flag = true;
+			try {
+				ChannelInizializer.init();
+			} catch (Exception e) {
+				flag = false;
+				e.printStackTrace();
+				sendMessage(ChatColorUtils.COLOR_CHAR + "7[" + ChatColorUtils.COLOR_CHAR + "eBungeeUntil" + ChatColorUtils.COLOR_CHAR + "7] " + ChatColorUtils.COLOR_CHAR + "cError while loading ProtocolLIB " + ChatColorUtils.COLOR_CHAR + "4Code: 002");
+				sendMessage(ChatColorUtils.COLOR_CHAR + "7[" + ChatColorUtils.COLOR_CHAR + "eBungeeUntil" + ChatColorUtils.COLOR_CHAR + "7] " + ChatColorUtils.COLOR_CHAR + "cDisable ProtocolLIB");
+			}
+			sleep(500);
+			if(!flag){
+				setInformation("\u00A7cAn error happend while loading aChannelInizializer.");
+				sendMessage("\u00A7cAn error happend while loading aChannelInizializer.");
+				sleep(500);
+				return;
+			}
+			setInformation("\u00A7aChannelInizializer successfull loaded.");
+			sendMessage("\u00A7aChannelInizializer successfull loaded.");
+			sleep(500);
+			setInformation("\u00A7aLoading player class");
+			sendMessage("\u00A7aLoading player class");
+			IIInitialHandler.init(ProxiedPlayerUserConnection.class);
+			sleep(500);
+			setInformation("\u00A7aPlayer class loaded");
+			sendMessage("\u00A7aPlayer class loaded");
+			
+			sleep(500);
+			setInformation("\u00A7aRegister commands and scheduler");
+			sendMessage("\u00A7aRegister commands and scheduler");
+			BungeeCord.getInstance().getPluginManager().registerListener(pluginInstance, new InventoryResetListener());
+			BungeeCord.getInstance().getPluginManager().registerCommand(pluginInstance, new BungeeTimings());
+			BungeeCord.getInstance().getScheduler().runAsync(pluginInstance, new Runnable() {
+				@Override
+				public void run() {
+					sendMessage("\u00A7eSystem.gc() -> Enabled: " + Configuration.isGCEnabled());
+					while (Configuration.isGCEnabled()) {
+						try {
+							Thread.sleep(5 * 1000);
+						}
+						catch (InterruptedException e) {
+						}
+						if (!active) return;
+						System.gc();
+					}
+				}
+			});
+			if (Configuration.ramStatistics()) {
+				ramStatistiks = new RamStatistics();
+				ramStatistiks.start();
+				RamStatisticsPainter tsp = new RamStatisticsPainter();
+				TerminalListener.getInstance().getListener().add(tsp);
+				BungeeCord.getInstance().getScheduler().runAsync(pluginInstance, tsp);
+				BungeeCord.getInstance().getPluginManager().registerCommand(pluginInstance, new dev.wolveringer.commands.RamStatistics());
+			}
+			
+			sleep(500);
+			setInformation("\u00A7aRegister packets");
+			sendMessage("\u00A7aRegister packets");
+			Packet.countPackets();
+			sleep(500);
+			setInformation("\u00A7aPackets registered");
+			sendMessage("\u00A7aPackets registered");
+			sleep(500);
+			setInformation(null);
+			state.setBit(1);
+			active = true;
+		}catch(Exception e){
+			active = false;
+			throw e;
+		}finally{
+			state.clearBit(0);
+		}
+	}
+	
+	public int inject(){
+		if(state.testBit(2))
+			throw new RuntimeException("Alredy injecting plugin.");
+		if(state.testBit(3))
+			throw new RuntimeException("BungeeUtil alredy injected!");
+		state.setBit(2);
+		try{
+			if(isInjected())
+				return -1;
+			setInformation("\u00A7aInjecting patches");
+			sendMessage("\u00A7aInjecting patches");
+			switch (InjectFiles.inject()) {
+			case -1:
+				return -1;
+			case 0:
+				sendMessage(ChatColorUtils.COLOR_CHAR + "7[" + ChatColorUtils.COLOR_CHAR + "eBungeeUntil" + ChatColorUtils.COLOR_CHAR + "7] " + ChatColorUtils.COLOR_CHAR + "cA fatal error has blocked in the injection of BungeeUtil.");
+				sendMessage(ChatColorUtils.COLOR_CHAR + "7[" + ChatColorUtils.COLOR_CHAR + "eBungeeUntil" + ChatColorUtils.COLOR_CHAR + "7] " + ChatColorUtils.COLOR_CHAR + "cDisable BungeeUtil");
+				setInformation(null);
+				return 2;
+			case 1:
+				sendMessage(ChatColorUtils.COLOR_CHAR + "7[" + ChatColorUtils.COLOR_CHAR + "eBungeeUntil" + ChatColorUtils.COLOR_CHAR + "7] " + ChatColorUtils.COLOR_CHAR + "aBungeeUtil injection successful. Need a BungeeCord restart.");
+				setInformation(null);
+				state.setBit(3);
+				return 0;
+		};
+		}finally{
+			state.clearBit(2);
+		}
+		return 2;
+	}
+	
+	public boolean isInjected(){
+		return InjectFiles.isInjected() || state.testBit(3);
+	}
+	
+	public static void debug(String string) {
+		if (pluginInstance == null || Configuration.isDebugEnabled()) System.out.println(string); // Debug if this not a plugin
+	}
+	
+	public static void debug(Exception e, String otherMessage) {
+		if (pluginInstance == null || Configuration.isDebugEnabled()) 
+			e.printStackTrace(); // Debug isf this not a plugin
+		else
+			System.out.println(otherMessage);
+	}
+	
+	public static void debug(Exception e) {
+		debug(e, "An error happed. "+e.getClass().getName().substring(e.getClass().getName().lastIndexOf('.'))+" message -> " + e.getMessage());
+	}
+	
+	void sleep(int millis) {
+		if (!Configuration.isFastBoot()) {
+			int procent = millis / 100;
+			int now = 0;
+			while (now * procent < millis) {
+				setPromt(costumPormtLineRawMessage + " [" + now + "%]");
+				try {
+					Thread.sleep(procent);
+				}
+				catch (InterruptedException ex) {
+					ex.printStackTrace();
+				}
+				now++;
+			}
+			setPromt(costumPormtLineRawMessage + " [100%]");
+			try {
+				Thread.sleep(100);
+			}
+			catch (InterruptedException ex) {
+				ex.printStackTrace();
+			}
+		}
+	}
+	
+	
+	public void disable(){
+		active = false;
+		BungeeCord.getInstance().getConsole().sendMessage(ChatColorUtils.COLOR_CHAR + "7[" + ChatColorUtils.COLOR_CHAR + "eBungeeUntil" + ChatColorUtils.COLOR_CHAR + "7] " + ChatColorUtils.COLOR_CHAR + "aThank you for using BungeeUntil");
+	}
+	
+	public void setInformation(String info) {
+		if ("".equalsIgnoreCase(info) || info == null) costumPromtLine = false;
+		else costumPromtLine = true;
+		costumPormtLineRawMessage = info;
+		setPromt(info);
+	}
+	
+	private void setPromt(String info) {
+		try {
+			if (costumPromtLine){
+				try{
+					BungeeCord.getInstance().getConsoleReader().resetPromptLine(costumPormtLineMessage = AnsiColorFormater.getFormater().format(ChatColorUtils.COLOR_CHAR + "aLoading BungeeUtil >> " + ChatColorUtils.COLOR_CHAR + "b" + info), "", 0);
+				}catch(Exception e){
+					try{
+						BungeeCord.getInstance().getConsoleReader().resetPromptLine("", "", 0);
+						BungeeCord.getInstance().getConsoleReader().resetPromptLine(costumPormtLineMessage = AnsiColorFormater.getFormater().format(ChatColorUtils.COLOR_CHAR + "aLoading BungeeUtil >> " + ChatColorUtils.COLOR_CHAR + "b" + info), "", 0);
+					}catch(Exception e2){
+						debug(e2);
+					}
+				}
+			}
+			else{
+				BungeeCord.getInstance().getConsoleReader().resetPromptLine(">", "", 1);
+			}
+		}
+		catch (IOException ex) {
+			ex.printStackTrace();
+		}
+	}
+	
+	@SuppressWarnings("deprecation")
+	public void sendMessage(String message) {
+		if (!message.startsWith(ChatColorUtils.PREFIX + " ")) message = ChatColorUtils.PREFIX + " " + message;
+		message = "\r" + date_format.format(new Date()) + " " + message;
+		if (costumPromtLine) {
+			try {
+				while (message.length() < costumPormtLineMessage.length()) {
+					message += " ";
+				}
+				BungeeCord.getInstance().getConsoleReader().resetPromptLine("", "", 0);
+				BungeeCord.getInstance().getConsole().sendMessage(message);
+				BungeeCord.getInstance().getConsoleReader().resetPromptLine(costumPormtLineMessage, "", 0);
+			}
+			catch (Exception e) {
+				e.printStackTrace();
+			}
+		}
+		else {
+			BungeeCord.getInstance().getConsole().sendMessage(message);
+		}
+	}
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/ClientVersion.java b/src/main/java/dev/wolveringer/BungeeUtil/ClientVersion.java
new file mode 100644
index 0000000..e736db5
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/ClientVersion.java
@@ -0,0 +1,129 @@
+package dev.wolveringer.BungeeUtil;
+
+import java.util.ArrayList;
+
+import lombok.AllArgsConstructor;
+import lombok.Getter;
+import net.md_5.bungee.api.ChatMessageType;
+import net.md_5.bungee.api.connection.ProxiedPlayer;
+
+public enum ClientVersion {
+	UnderknownVersion(-1, BigClientVersion.UnderknownVersion, ProtocollVersion.Unsupported),
+	v1_7_1(4, BigClientVersion.v1_7, ProtocollVersion.v1_7),
+	v1_7_2(4, BigClientVersion.v1_7, ProtocollVersion.v1_7),
+	v1_7_3(4, BigClientVersion.v1_7, ProtocollVersion.v1_7),
+	v1_7_4(4, BigClientVersion.v1_7, ProtocollVersion.v1_7),
+	v1_7_5(4, BigClientVersion.v1_7, ProtocollVersion.v1_7),
+	v1_7_6(5, BigClientVersion.v1_7, ProtocollVersion.v1_7),
+	v1_7_7(5, BigClientVersion.v1_7, ProtocollVersion.v1_7),
+	v1_7_8(5, BigClientVersion.v1_7, ProtocollVersion.v1_7),
+	v1_7_9(5, BigClientVersion.v1_7, ProtocollVersion.v1_7),
+	v1_7_10(5, BigClientVersion.v1_7, ProtocollVersion.v1_7),
+	v1_8_0(47, BigClientVersion.v1_8, ProtocollVersion.v1_8),
+	v1_8_1(47, BigClientVersion.v1_8, ProtocollVersion.v1_8),
+	v1_8_2(47, BigClientVersion.v1_8, ProtocollVersion.v1_8), // 1.8.2-1.8.10
+	                                                          // //Unchanged
+	v1_8_3(47, BigClientVersion.v1_8, ProtocollVersion.v1_8),
+	v1_8_4(47, BigClientVersion.v1_8, ProtocollVersion.v1_8),
+	v1_8_5(47, BigClientVersion.v1_8, ProtocollVersion.v1_8),
+	v1_8_6(47, BigClientVersion.v1_8, ProtocollVersion.v1_8),
+	v1_8_7(47, BigClientVersion.v1_8, ProtocollVersion.v1_8),
+	v1_8_8(47, BigClientVersion.v1_8, ProtocollVersion.v1_8),
+	v1_8_9(47, BigClientVersion.v1_8, ProtocollVersion.v1_8),
+	v1_8_10(47, BigClientVersion.v1_8, ProtocollVersion.v1_8),
+	// Skip snapshots
+	v1_9_0(107, BigClientVersion.v1_9, ProtocollVersion.v1_9),
+	v1_9_1(107, BigClientVersion.v1_9, ProtocollVersion.v1_9),
+	v1_9_2(108, BigClientVersion.v1_9, ProtocollVersion.v1_9_2),
+	v1_9_3(109, BigClientVersion.v1_9, ProtocollVersion.v1_9_3),
+	v1_9_4(110, BigClientVersion.v1_9, ProtocollVersion.v1_9_4),
+	v1_9_5(110, BigClientVersion.v1_9, ProtocollVersion.v1_9_4),
+	v1_10_0(210, BigClientVersion.v1_10, ProtocollVersion.v1_10);
+	
+	@Getter
+	private int version;
+	private BigClientVersion bigClientVersion;
+	@Getter
+	private ProtocollVersion protocollVersion;
+	
+	private ClientVersion(int v, BigClientVersion bv, ProtocollVersion protocol) {
+		this.version = v;
+		this.bigClientVersion = bv;
+		this.protocollVersion = protocol;
+	}
+	
+	public BigClientVersion getBigVersion() {
+		return bigClientVersion;
+	}
+	
+	public static enum BigClientVersion {
+		UnderknownVersion(0),
+		v1_7(1),
+		v1_8(2),
+		v1_9(3),
+		v1_10(7);
+		
+		private ProtocollVersion protocollVersion;
+		private int protocollVersionInt;
+		private ProtocollVersion[] protocollVersions;
+		
+		private BigClientVersion(int basedVersion) {
+			this.protocollVersionInt = basedVersion;
+		}
+		public ProtocollVersion getProtocollVersion() {
+			if(protocollVersion == null)
+				protocollVersion = ProtocollVersion.values()[protocollVersionInt];
+			return protocollVersion;
+		}
+
+		public ProtocollVersion[] getProtocollVersions(){
+			if(protocollVersions != null)
+				return protocollVersions;
+			ArrayList<ProtocollVersion> versions = new ArrayList<>();
+			for(ProtocollVersion v : ProtocollVersion.values())
+				if(v.getBasedVersion() == this)
+					versions.add(v);
+			this.protocollVersions = versions.toArray(new ProtocollVersion[0]);
+			return protocollVersions;
+		}
+	}
+	
+	@Getter
+	public static enum ProtocollVersion {
+		Unsupported(0, -1, false),
+		v1_7(1, 5, false),
+		v1_8(2, 47, true),
+		v1_9(3, 107, true),
+		v1_9_2(3,108, true),
+		v1_9_3(3, 109, true),
+		v1_9_4(3, 110, true),
+		v1_10(4, 210, true);
+		
+		private int basedVersionInt;
+		private BigClientVersion basedVersion;
+		private boolean supported;
+		private int protocollVersion;
+		
+		private ProtocollVersion(int basedVersion,int protocoll, boolean supported) {
+			this.basedVersionInt = basedVersion;
+			this.supported = supported;
+			this.protocollVersion = protocoll;
+		}
+		
+		public BigClientVersion getBasedVersion(){
+			if(basedVersion == null)
+				basedVersion = BigClientVersion.values()[basedVersionInt];
+			return basedVersion;
+		}
+		
+		public int getProtocollVersion(){
+			return protocollVersion;
+		}
+	}
+	
+	public static ClientVersion fromProtocoll(int protocolVersion) {
+		for (ClientVersion v : ClientVersion.values())
+			if (v.getVersion() == protocolVersion) return v;
+		return null;
+	}
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/CostumPrintStream.java b/src/main/java/dev/wolveringer/BungeeUtil/CostumPrintStream.java
new file mode 100644
index 0000000..ba51998
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/CostumPrintStream.java
@@ -0,0 +1,6 @@
+package dev.wolveringer.BungeeUtil;
+
+public interface CostumPrintStream {
+	public void print(String s);
+	public void println(String s);
+}
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/DebugProperties.java b/src/main/java/dev/wolveringer/BungeeUtil/DebugProperties.java
new file mode 100644
index 0000000..ac44f76
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/DebugProperties.java
@@ -0,0 +1,10 @@
+package dev.wolveringer.BungeeUtil;
+
+public class DebugProperties {
+	public static final boolean CONSOHLE_COLORED_OUTPUT = true;
+	public static final boolean CONSOHLE_CONNECTION_INFORMATION = true;
+	public static final boolean PACKET_ERROR_DISCCONNECT = true;
+	public static final boolean PACKET_DEVELOPMENT = true;
+	public static final boolean TAB_SCOREBORD_FIX = true;
+	public static final boolean WHITELISTED = false;
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/HandType.java b/src/main/java/dev/wolveringer/BungeeUtil/HandType.java
new file mode 100644
index 0000000..d15e23e
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/HandType.java
@@ -0,0 +1,6 @@
+package dev.wolveringer.BungeeUtil;
+
+public enum HandType {
+	MAIN,
+	OFF;
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/HandleErrorAction.java b/src/main/java/dev/wolveringer/BungeeUtil/HandleErrorAction.java
new file mode 100644
index 0000000..e5bbafc
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/HandleErrorAction.java
@@ -0,0 +1,7 @@
+package dev.wolveringer.BungeeUtil;
+
+public enum HandleErrorAction {
+	DISCONNECT,
+	PRINT,
+	NONE;
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/Main.java b/src/main/java/dev/wolveringer/BungeeUtil/Main.java
new file mode 100644
index 0000000..2e39e15
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/Main.java
@@ -0,0 +1,108 @@
+package dev.wolveringer.BungeeUtil;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map.Entry;
+
+import org.fusesource.jansi.AnsiConsole;
+
+import net.md_5.bungee.api.plugin.Plugin;
+import dev.wolveringer.BungeeUtil.configuration.Configuration;
+import dev.wolveringer.BungeeUtil.packets.Packet;
+import dev.wolveringer.chat.ChatColor.ChatColorUtils;
+import dev.wolveringer.terminal.table.TerminalTable;
+import dev.wolveringer.terminal.table.TerminalTable.Align;
+import dev.wolveringer.terminal.table.TerminalTable.TerminalRow;
+import dev.wolveringer.updater.Updater;
+
+public class Main extends Plugin {
+	public Updater updater;
+	private static Main main = null;
+	
+	public static Main getMain() {
+		return main;
+	}
+	
+	@Override
+	public void onLoad() {
+		main = this;
+
+	}
+	
+	@Override
+	public void onEnable() {
+		main = this;
+		if(BungeeUtil.getInstance() == null)
+			BungeeUtil.createInstance(main);
+		Configuration.init();
+		BungeeUtil.getInstance().sendMessage("Ansi consolen class: "+AnsiConsole.out.getClass());
+		BungeeUtil.getInstance().setInformation("Check for updates");
+		try {
+			updater = new Updater("https://raw.githubusercontent.com/WolverinDEV/BungeeUtil/jars/versions.json");
+			updater.loadData();
+			if(updater.getData() == null){
+				BungeeUtil.getInstance().sendMessage("\u00A7cCant get versions informations.");
+			}
+			else
+			{
+				if (Configuration.isUpdaterActive() && updater.checkUpdate()) {
+					BungeeUtil.getInstance().setInformation("\u00A7cRestarting bungeecord");
+					BungeeUtil.getInstance().sleep(1000);
+					BungeeUtil.getInstance().setInformation(null);
+					System.exit(-1);
+					return;
+				}
+			}
+		}
+		catch (Exception e) {
+			e.printStackTrace();
+		}
+		
+		if (Configuration.getLastVersion() != null && updater != null) {
+			BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR + "aBungeeUtil successful updated!");
+			BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR + "aUpdates:");
+			TerminalTable table = new TerminalTable(new TerminalTable.TerminalColumn[]{
+					new TerminalTable.TerminalColumn("Version", Align.LEFT),
+					new TerminalTable.TerminalColumn("Changes", Align.LEFT)
+			});
+			HashMap<String, List<String>> _changes = updater.createChanges(Configuration.getLastVersion());
+			List<Entry<String, List<String>>> changes = new ArrayList<>(_changes.entrySet());
+			Collections.sort(changes, new Comparator<Entry<String, List<String>>>() {
+				@Override
+				public int compare(Entry<String, List<String>> o1, Entry<String, List<String>> o2) {
+					return Long.compare(Long.parseLong(o2.getKey().replaceAll("\\.", "")), Long.parseLong(o1.getKey().replaceAll("\\.", "")));
+				}
+			});
+			for(Entry<String, List<String>> e : changes){
+				TerminalRow row = new TerminalRow(2);
+				row.getColumns()[1].addAll(e.getValue());
+				row.setText(0, e.getKey());
+				table.addRow(row);
+			}
+			for(String message : table.buildLines())
+				BungeeUtil.getInstance().sendMessage(message);
+		}
+		
+		if(!BungeeUtil.getInstance().isInjected()){
+			switch (BungeeUtil.getInstance().inject()) {
+			case 0:
+				System.exit(-1);
+				break;
+			case -1:
+				break;
+			default:
+				return;
+			}
+		}
+		BungeeUtil.getInstance().load();
+		Packet.listPackets();
+	}
+	
+	@Override
+	public void onDisable() {
+		BungeeUtil.getInstance().disable();
+	}
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/Material.java b/src/main/java/dev/wolveringer/BungeeUtil/Material.java
new file mode 100644
index 0000000..d785a9b
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/Material.java
@@ -0,0 +1,980 @@
+package dev.wolveringer.BungeeUtil;
+
+import java.lang.reflect.Array;
+import java.util.Map;
+
+import com.google.common.collect.Maps;
+
+class Java15Compat {
+	@SuppressWarnings("unchecked")
+	public static <T> T[] Arrays_copyOfRange(T[] original, int start, int end) {
+		if(original.length >= start && 0 <= start){
+			if(start <= end){
+				int length = end - start;
+				int copyLength = Math.min(length, original.length - start);
+				T[] copy = (T[]) Array.newInstance(original.getClass().getComponentType(), length);
+
+				System.arraycopy(original, start, copy, 0, copyLength);
+				return copy;
+			}
+			throw new IllegalArgumentException();
+		}
+		throw new ArrayIndexOutOfBoundsException();
+	}
+}
+
+/**
+ * An enum of all material IDs accepted by the official server and client
+ */
+public enum Material {
+	AIR(0, 0),
+	STONE(1),
+	GRASS(2),
+	DIRT(3),
+	COBBLESTONE(4),
+	WOOD(5),
+	SAPLING(6),
+	BEDROCK(7),
+	WATER(8),
+	STATIONARY_WATER(9),
+	LAVA(10),
+	STATIONARY_LAVA(11),
+	SAND(12),
+	GRAVEL(13),
+	GOLD_ORE(14),
+	IRON_ORE(15),
+	COAL_ORE(16),
+	LOG(17),
+	LEAVES(18),
+	SPONGE(19),
+	GLASS(20),
+	LAPIS_ORE(21),
+	LAPIS_BLOCK(22),
+	DISPENSER(23),
+	SANDSTONE(24),
+	NOTE_BLOCK(25),
+	BED_BLOCK(26),
+	POWERED_RAIL(27),
+	DETECTOR_RAIL(28),
+	PISTON_STICKY_BASE(29),
+	WEB(30),
+	LONG_GRASS(31),
+	DEAD_BUSH(32),
+	PISTON_BASE(33),
+	PISTON_EXTENSION(34),
+	WOOL(35),
+	PISTON_MOVING_PIECE(36),
+	YELLOW_FLOWER(37),
+	RED_ROSE(38),
+	BROWN_MUSHROOM(39),
+	RED_MUSHROOM(40),
+	GOLD_BLOCK(41),
+	IRON_BLOCK(42),
+	DOUBLE_STEP(43),
+	STEP(44),
+	BRICK(45),
+	TNT(46),
+	BOOKSHELF(47),
+	MOSSY_COBBLESTONE(48),
+	OBSIDIAN(49),
+	TORCH(50),
+	FIRE(51),
+	MOB_SPAWNER(52),
+	WOOD_STAIRS(53),
+	CHEST(54),
+	REDSTONE_WIRE(55),
+	DIAMOND_ORE(56),
+	DIAMOND_BLOCK(57),
+	WORKBENCH(58),
+	CROPS(59),
+	SOIL(60),
+	FURNACE(61),
+	BURNING_FURNACE(62),
+	SIGN_POST(63, 64),
+	WOODEN_DOOR(64),
+	LADDER(65),
+	RAILS(66),
+	COBBLESTONE_STAIRS(67),
+	WALL_SIGN(68, 64),
+	LEVER(69),
+	STONE_PLATE(70),
+	IRON_DOOR_BLOCK(71),
+	WOOD_PLATE(72),
+	REDSTONE_ORE(73),
+	GLOWING_REDSTONE_ORE(74),
+	REDSTONE_TORCH_OFF(75),
+	REDSTONE_TORCH_ON(76),
+	STONE_BUTTON(77),
+	SNOW(78),
+	ICE(79),
+	SNOW_BLOCK(80),
+	CACTUS(81),
+	CLAY(82),
+	SUGAR_CANE_BLOCK(83),
+	JUKEBOX(84),
+	FENCE(85),
+	PUMPKIN(86),
+	NETHERRACK(87),
+	SOUL_SAND(88),
+	GLOWSTONE(89),
+	PORTAL(90),
+	JACK_O_LANTERN(91),
+	CAKE_BLOCK(92, 64),
+	DIODE_BLOCK_OFF(93),
+	DIODE_BLOCK_ON(94),
+	LOCKED_CHEST(95),
+	STAINED_GLASS(95),
+	TRAP_DOOR(96),
+	MONSTER_EGGS(97),
+	SMOOTH_BRICK(98),
+	HUGE_MUSHROOM_1(99),
+	HUGE_MUSHROOM_2(100),
+	IRON_FENCE(101),
+	THIN_GLASS(102),
+	MELON_BLOCK(103),
+	PUMPKIN_STEM(10),
+	MELON_STEM(105),
+	VINE(106),
+	FENCE_GATE(107),
+	BRICK_STAIRS(108),
+	SMOOTH_STAIRS(109),
+	MYCEL(110),
+	WATER_LILY(111),
+	NETHER_BRICK(112),
+	NETHER_FENCE(113),
+	NETHER_BRICK_STAIRS(114),
+	NETHER_WARTS(115),
+	ENCHANTMENT_TABLE(116),
+	BREWING_STAND(117),
+	CAULDRON(118),
+	ENDER_PORTAL(119),
+	ENDER_PORTAL_FRAME(120),
+	ENDER_STONE(121),
+	DRAGON_EGG(122),
+	REDSTONE_LAMP_OFF(123),
+	REDSTONE_LAMP_ON(124),
+	WOOD_DOUBLE_STEP(125),
+	WOOD_STEP(126),
+	COCOA(127),
+	SANDSTONE_STAIRS(128),
+	EMERALD_ORE(129),
+	ENDER_CHEST(130),
+	TRIPWIRE_HOOK(131),
+	TRIPWIRE(132),
+	EMERALD_BLOCK(133),
+	SPRUCE_WOOD_STAIRS(134),
+	BIRCH_WOOD_STAIRS(135),
+	JUNGLE_WOOD_STAIRS(136),
+	COMMAND(137),
+	BEACON(138),
+	COBBLE_WALL(139),
+	FLOWER_POT(140),
+	CARROT(141),
+	POTATO(142),
+	WOOD_BUTTON(143),
+	SKULL(144),
+	ANVIL(145),
+	TRAPPED_CHEST(146),
+	GOLD_PLATE(147),
+	IRON_PLATE(148),
+	REDSTONE_COMPARATOR_OFF(149),
+	REDSTONE_COMPARATOR_ON(150),
+	DAYLIGHT_DETECTOR(151),
+	REDSTONE_BLOCK(152),
+	QUARTZ_ORE(153),
+	HOPPER(154),
+	QUARTZ_BLOCK(155),
+	QUARTZ_STAIRS(156),
+	ACTIVATOR_RAIL(157),
+	DROPPER(158),
+	STAINED_CLAY(159),
+	STAINED_GLASS_PANE(160),
+	LEAVES_2(161),
+	LOG_2(162),
+	ACACIA_STAIRS(163),
+	DARK_OAK_STAIRS(164),
+	SLIME_BLOCK(165),
+	BARRIER(166),
+	IRON_TRAPDOOR(167),
+	PRISMARINE(168),
+	SEA_LANTERN(169),
+	HAY_BLOCK(170),
+	CARPET(171),
+	HARD_CLAY(172),
+	COAL_BLOCK(173),
+	PACKED_ICE(174),
+	DOUBLE_PLANT(175),
+	STANDING_BANNER(176),
+	WALL_BANNER(177),
+	DAYLIGHT_DETECTOR_INVERTED(178),
+	RED_SANDSTONE(179),
+	RED_SANDSTONE_STAIRS(180),
+	DOUBLE_STONE_SLAB2(181),
+	STONE_SLAB2(182),
+	SPRUCE_FENCE_GATE(183),
+	BIRCH_FENCE_GATE(184),
+	JUNGLE_FENCE_GATE(185),
+	DARK_OAK_FENCE_GATE(186),
+	ACACIA_FENCE_GATE(187),
+	SPRUCE_FENCE(188),
+	BIRCH_FENCE(189),
+	JUNGLE_FENCE(190),
+	DARK_OAK_FENCE(191),
+	ACACIA_FENCE(192),
+	SPRUCE_DOOR(193),
+	BIRCH_DOOR(194),
+	JUNGLE_DOOR(195),
+	ACACIA_DOOR(196),
+	DARK_OAK_DOOR(197),
+	IRON_SPADE(256, 1, 250),
+	IRON_PICKAXE(257, 1, 250),
+	IRON_AXE(258, 1, 250),
+	FLINT_AND_STEEL(259, 1, 64),
+	APPLE(260),
+	BOW(261, 1, 384),
+	ARROW(262),
+	COAL(263),
+	DIAMOND(264),
+	IRON_INGOT(265),
+	GOLD_INGOT(266),
+	IRON_SWORD(267, 1, 250),
+	WOOD_SWORD(268, 1, 59),
+	WOOD_SPADE(269, 1, 59),
+	WOOD_PICKAXE(270, 1, 59),
+	WOOD_AXE(271, 1, 59),
+	STONE_SWORD(272, 1, 131),
+	STONE_SPADE(273, 1, 131),
+	STONE_PICKAXE(274, 1, 131),
+	STONE_AXE(275, 1, 131),
+	DIAMOND_SWORD(276, 1, 1561),
+	DIAMOND_SPADE(277, 1, 1561),
+	DIAMOND_PICKAXE(278, 1, 1561),
+	DIAMOND_AXE(279, 1, 1561),
+	STICK(280),
+	BOWL(281),
+	MUSHROOM_SOUP(282, 1),
+	GOLD_SWORD(283, 1, 32),
+	GOLD_SPADE(284, 1, 32),
+	GOLD_PICKAXE(285, 1, 32),
+	GOLD_AXE(286, 1, 32),
+	STRING(287),
+	FEATHER(288),
+	SULPHUR(289),
+	WOOD_HOE(290, 1, 59),
+	STONE_HOE(291, 1, 131),
+	IRON_HOE(292, 1, 250),
+	DIAMOND_HOE(293, 1, 1561),
+	GOLD_HOE(294, 1, 32),
+	SEEDS(295),
+	WHEAT(296),
+	BREAD(297),
+	LEATHER_HELMET(298, 1, 55),
+	LEATHER_CHESTPLATE(299, 1, 80),
+	LEATHER_LEGGINGS(300, 1, 75),
+	LEATHER_BOOTS(301, 1, 65),
+	CHAINMAIL_HELMET(302, 1, 165),
+	CHAINMAIL_CHESTPLATE(303, 1, 240),
+	CHAINMAIL_LEGGINGS(304, 1, 225),
+	CHAINMAIL_BOOTS(305, 1, 195),
+	IRON_HELMET(306, 1, 165),
+	IRON_CHESTPLATE(307, 1, 240),
+	IRON_LEGGINGS(308, 1, 225),
+	IRON_BOOTS(309, 1, 195),
+	DIAMOND_HELMET(310, 1, 363),
+	DIAMOND_CHESTPLATE(311, 1, 528),
+	DIAMOND_LEGGINGS(312, 1, 495),
+	DIAMOND_BOOTS(313, 1, 429),
+	GOLD_HELMET(314, 1, 77),
+	GOLD_CHESTPLATE(315, 1, 112),
+	GOLD_LEGGINGS(316, 1, 105),
+	GOLD_BOOTS(317, 1, 91),
+	FLINT(318),
+	PORK(319),
+	GRILLED_PORK(320),
+	PAINTING(321),
+	GOLDEN_APPLE(322),
+	SIGN(323, 16),
+	WOOD_DOOR(324, 64),
+	BUCKET(325, 16),
+	WATER_BUCKET(326, 1),
+	LAVA_BUCKET(327, 1),
+	MINECART(328, 1),
+	SADDLE(329, 1),
+	IRON_DOOR(330, 64),
+	REDSTONE(331),
+	SNOW_BALL(332, 16),
+	BOAT(333, 1),
+	LEATHER(334),
+	MILK_BUCKET(335, 1),
+	CLAY_BRICK(336),
+	CLAY_BALL(337),
+	SUGAR_CANE(338),
+	PAPER(339),
+	BOOK(340),
+	SLIME_BALL(341),
+	STORAGE_MINECART(342, 1),
+	POWERED_MINECART(343, 1),
+	EGG(344, 16),
+	COMPASS(345),
+	FISHING_ROD(346, 1, 64),
+	WATCH(347),
+	GLOWSTONE_DUST(348),
+	RAW_FISH(349),
+	COOKED_FISH(350),
+	INK_SACK(351),
+	BONE(352),
+	SUGAR(353),
+	CAKE(354, 1),
+	BED(355, 1),
+	DIODE(356),
+	COOKIE(357),
+	MAP(358),
+	SHEARS(359, 1, 238),
+	MELON(360),
+	PUMPKIN_SEEDS(361),
+	MELON_SEEDS(362),
+	RAW_BEEF(363),
+	COOKED_BEEF(364),
+	RAW_CHICKEN(365),
+	COOKED_CHICKEN(366),
+	ROTTEN_FLESH(367),
+	ENDER_PEARL(368, 16),
+	BLAZE_ROD(369),
+	GHAST_TEAR(370),
+	GOLD_NUGGET(371),
+	NETHER_STALK(372),
+	POTION(373, 1),
+	GLASS_BOTTLE(374),
+	SPIDER_EYE(375),
+	FERMENTED_SPIDER_EYE(376),
+	BLAZE_POWDER(377),
+	MAGMA_CREAM(378),
+	BREWING_STAND_ITEM(379),
+	CAULDRON_ITEM(380),
+	EYE_OF_ENDER(381),
+	SPECKLED_MELON(382),
+	MONSTER_EGG(383, 64),
+	EXP_BOTTLE(384, 64),
+	FIREBALL(385, 64),
+	BOOK_AND_QUILL(386, 1),
+	WRITTEN_BOOK(387, 16),
+	EMERALD(388, 64),
+	ITEM_FRAME(389),
+	FLOWER_POT_ITEM(390),
+	CARROT_ITEM(391),
+	POTATO_ITEM(392),
+	BAKED_POTATO(393),
+	POISONOUS_POTATO(394),
+	EMPTY_MAP(395),
+	GOLDEN_CARROT(396),
+	SKULL_ITEM(397),
+	CARROT_STICK(398, 1, 25),
+	NETHER_STAR(399),
+	PUMPKIN_PIE(400),
+	FIREWORK(401),
+	FIREWORK_CHARGE(402),
+	ENCHANTED_BOOK(403, 1),
+	REDSTONE_COMPARATOR(404),
+	NETHER_BRICK_ITEM(405),
+	QUARTZ(406),
+	EXPLOSIVE_MINECART(407, 1),
+	HOPPER_MINECART(408, 1),
+	PRISMARINE_SHARD(409),
+	PRISMARINE_CRYSTALS(410),
+	RABBIT(411),
+	COOKED_RABBIT(412),
+	RABBIT_STEW(413, 1),
+	RABBIT_FOOT(414),
+	RABBIT_HIDE(415),
+	ARMOR_STAND(416, 16),
+	IRON_BARDING(417, 1),
+	GOLD_BARDING(418, 1),
+	DIAMOND_BARDING(419, 1),
+	LEASH(420),
+	NAME_TAG(421),
+	COMMAND_MINECART(422, 1),
+	MUTTON(423),
+	COOKED_MUTTON(424),
+	BANNER(425, 16),
+	SPRUCE_DOOR_ITEM(427),
+	BIRCH_DOOR_ITEM(428),
+	JUNGLE_DOOR_ITEM(429),
+	ACACIA_DOOR_ITEM(430),
+	DARK_OAK_DOOR_ITEM(431),
+	GOLD_RECORD(2256, 1),
+	GREEN_RECORD(2257, 1),
+	RECORD_3(2258, 1),
+	RECORD_4(2259, 1),
+	RECORD_5(2260, 1),
+	RECORD_6(2261, 1),
+	RECORD_7(2262, 1),
+	RECORD_8(2263, 1),
+	RECORD_9(2264, 1),
+	RECORD_10(2265, 1),
+	RECORD_11(2266, 1),
+	RECORD_12(2267, 1);
+
+	private final static Map<String, Material> BY_NAME = Maps.newHashMap();
+	private static Material[] byId = new Material[383];
+	static{
+		for(Material material : values()){
+			if(byId.length > material.id){
+				byId[material.id] = material;
+			}else{
+				byId = Java15Compat.Arrays_copyOfRange(byId, 0, material.id + 2);
+				byId[material.id] = material;
+			}
+			BY_NAME.put(material.name(), material);
+		}
+	}
+
+	/**
+	 * Attempts to get the Material with the given ID
+	 *
+	 * @param id
+	 *            ID of the material to get
+	 * @return Material if found, or null
+	 * @deprecated Magic value
+	 */
+	@Deprecated
+	public static Material getMaterial(final int id) {
+		if(byId.length > id && id >= 0){
+			return byId[id];
+		}else{
+			return null;
+		}
+	}
+
+	/**
+	 * Attempts to get the Material with the given name.
+	 * <p>
+	 * This is a normal lookup, names must be the precise name they are given in
+	 * the enum.
+	 *
+	 * @param name
+	 *            Name of the material to get
+	 * @return Material if found, or null
+	 */
+	public static Material getMaterial(final String name) {
+		return BY_NAME.get(name);
+	}
+
+	/**
+	 * Attempts to match the Material with the given name.
+	 * <p>
+	 * This is a match lookup; names will be converted to uppercase, then
+	 * stripped of special characters in an attempt to format it like the enum.
+	 * <p>
+	 * Using this for match by ID is deprecated.
+	 *
+	 * @param name
+	 *            Name of the material to get
+	 * @return Material if found, or null
+	 */
+	public static Material matchMaterial(final String name) {
+		Material result = null;
+
+		try{
+			result = getMaterial(Integer.parseInt(name));
+		}catch (NumberFormatException ex){
+		}
+
+		if(result == null){
+			String filtered = name.toUpperCase();
+
+			filtered = filtered.replaceAll("\\s+", "_").replaceAll("\\W", "");
+			result = BY_NAME.get(filtered);
+		}
+
+		return result;
+	}
+
+	private final short durability;
+
+	private final int id;
+
+	private final int maxStack;
+
+	private Material(final int id) {
+		this(id, 64);
+	}
+
+	private Material(final int id, final int stack) {
+		this(id, stack, 0);
+	}
+
+	private Material(final int id, final int stack, final int durability) {
+		this.id = id;
+		this.durability = (short) durability;
+		this.maxStack = stack;
+	}
+
+	/**
+	 * Gets the item ID or block ID of this Material
+	 *
+	 * @return ID of this material
+	 * @deprecated Magic value
+	 */
+	@Deprecated
+	public int getId() {
+		return id;
+	}
+
+	/**
+	 * Gets the maximum durability of this material
+	 *
+	 * @return Maximum durability for this material
+	 */
+	public short getMaxDurability() {
+		return durability;
+	}
+
+	/**
+	 * Gets the maximum amount of this material that can be held in a stack
+	 *
+	 * @return Maximum stack size for this material
+	 */
+	public int getMaxStackSize() {
+		return maxStack;
+	}
+
+	/**
+	 * @return True if this material is affected by gravity.
+	 */
+	public boolean hasGravity() {
+		if(!isBlock()){
+			return false;
+		}
+		switch (this) {
+			case SAND:
+			case GRAVEL:
+			case ANVIL:
+				return true;
+			default:
+				return false;
+		}
+	}
+
+	/**
+	 * Checks if this Material is a placable block
+	 *
+	 * @return true if this material is a block
+	 */
+	public boolean isBlock() {
+		return id < 256;
+	}
+
+	/**
+	 * Check if the material is a block and can burn away
+	 *
+	 * @return True if this material is a block and can burn away
+	 */
+	public boolean isBurnable() {
+		if(!isBlock()){
+			return false;
+		}
+		switch (this) {
+			case WOOD:
+			case LOG:
+			case LEAVES:
+			case LONG_GRASS:
+			case WOOL:
+			case YELLOW_FLOWER:
+			case RED_ROSE:
+			case TNT:
+			case BOOKSHELF:
+			case WOOD_STAIRS:
+			case FENCE:
+			case VINE:
+			case WOOD_DOUBLE_STEP:
+			case WOOD_STEP:
+			case SPRUCE_WOOD_STAIRS:
+			case BIRCH_WOOD_STAIRS:
+			case JUNGLE_WOOD_STAIRS:
+			case HAY_BLOCK:
+			case COAL_BLOCK:
+			case LEAVES_2:
+			case LOG_2:
+			case CARPET:
+			case DOUBLE_PLANT:
+				return true;
+			default:
+				return false;
+		}
+	}
+
+	/**
+	 * Checks if this Material is edible.
+	 *
+	 * @return true if this Material is edible.
+	 */
+	public boolean isEdible() {
+		switch (this) {
+			case BREAD:
+			case CARROT_ITEM:
+			case BAKED_POTATO:
+			case POTATO_ITEM:
+			case POISONOUS_POTATO:
+			case GOLDEN_CARROT:
+			case PUMPKIN_PIE:
+			case COOKIE:
+			case MELON:
+			case MUSHROOM_SOUP:
+			case RAW_CHICKEN:
+			case COOKED_CHICKEN:
+			case RAW_BEEF:
+			case COOKED_BEEF:
+			case RAW_FISH:
+			case COOKED_FISH:
+			case PORK:
+			case GRILLED_PORK:
+			case APPLE:
+			case GOLDEN_APPLE:
+			case ROTTEN_FLESH:
+			case SPIDER_EYE:
+				return true;
+			default:
+				return false;
+		}
+	}
+
+	/**
+	 * Check if the material is a block and can catch fire
+	 *
+	 * @return True if this material is a block and can catch fire
+	 */
+	public boolean isFlammable() {
+		if(!isBlock()){
+			return false;
+		}
+		switch (this) {
+			case WOOD:
+			case LOG:
+			case LEAVES:
+			case NOTE_BLOCK:
+			case BED_BLOCK:
+			case LONG_GRASS:
+			case DEAD_BUSH:
+			case WOOL:
+			case TNT:
+			case BOOKSHELF:
+			case WOOD_STAIRS:
+			case CHEST:
+			case WORKBENCH:
+			case SIGN_POST:
+			case WOODEN_DOOR:
+			case WALL_SIGN:
+			case WOOD_PLATE:
+			case JUKEBOX:
+			case FENCE:
+			case TRAP_DOOR:
+			case HUGE_MUSHROOM_1:
+			case HUGE_MUSHROOM_2:
+			case VINE:
+			case FENCE_GATE:
+			case WOOD_DOUBLE_STEP:
+			case WOOD_STEP:
+			case SPRUCE_WOOD_STAIRS:
+			case BIRCH_WOOD_STAIRS:
+			case JUNGLE_WOOD_STAIRS:
+			case TRAPPED_CHEST:
+			case DAYLIGHT_DETECTOR:
+			case CARPET:
+			case LEAVES_2:
+			case LOG_2:
+			case ACACIA_STAIRS:
+			case DARK_OAK_STAIRS:
+				return true;
+			default:
+				return false;
+		}
+	}
+
+	/**
+	 * Check if the material is a block and completely blocks vision
+	 *
+	 * @return True if this material is a block and completely blocks vision
+	 */
+	public boolean isOccluding() {
+		if(!isBlock()){
+			return false;
+		}
+		switch (this) {
+			case STONE:
+			case GRASS:
+			case DIRT:
+			case COBBLESTONE:
+			case WOOD:
+			case BEDROCK:
+			case SAND:
+			case GRAVEL:
+			case GOLD_ORE:
+			case IRON_ORE:
+			case COAL_ORE:
+			case LOG:
+			case SPONGE:
+			case LAPIS_ORE:
+			case LAPIS_BLOCK:
+			case DISPENSER:
+			case SANDSTONE:
+			case NOTE_BLOCK:
+			case WOOL:
+			case GOLD_BLOCK:
+			case IRON_BLOCK:
+			case DOUBLE_STEP:
+			case BRICK:
+			case BOOKSHELF:
+			case MOSSY_COBBLESTONE:
+			case OBSIDIAN:
+			case MOB_SPAWNER:
+			case DIAMOND_ORE:
+			case DIAMOND_BLOCK:
+			case WORKBENCH:
+			case FURNACE:
+			case BURNING_FURNACE:
+			case REDSTONE_ORE:
+			case GLOWING_REDSTONE_ORE:
+			case SNOW_BLOCK:
+			case CLAY:
+			case JUKEBOX:
+			case PUMPKIN:
+			case NETHERRACK:
+			case SOUL_SAND:
+			case JACK_O_LANTERN:
+			case MONSTER_EGGS:
+			case SMOOTH_BRICK:
+			case HUGE_MUSHROOM_1:
+			case HUGE_MUSHROOM_2:
+			case MELON_BLOCK:
+			case MYCEL:
+			case NETHER_BRICK:
+			case ENDER_PORTAL_FRAME:
+			case ENDER_STONE:
+			case REDSTONE_LAMP_OFF:
+			case REDSTONE_LAMP_ON:
+			case WOOD_DOUBLE_STEP:
+			case EMERALD_ORE:
+			case EMERALD_BLOCK:
+			case COMMAND:
+			case QUARTZ_ORE:
+			case QUARTZ_BLOCK:
+			case DROPPER:
+			case STAINED_CLAY:
+			case HAY_BLOCK:
+			case HARD_CLAY:
+			case COAL_BLOCK:
+			case LOG_2:
+			case PACKED_ICE:
+				return true;
+			default:
+				return false;
+		}
+	}
+
+	/**
+	 * @return True if this material represents a playable music disk.
+	 */
+	public boolean isRecord() {
+		return id >= GOLD_RECORD.id && id <= RECORD_12.id;
+	}
+
+	/**
+	 * Check if the material is a block and solid (cannot be passed through by
+	 * a player)
+	 *
+	 * @return True if this material is a block and solid
+	 */
+	public boolean isSolid() {
+		if(!isBlock() || id == 0){
+			return false;
+		}
+		switch (this) {
+			case STONE:
+			case GRASS:
+			case DIRT:
+			case COBBLESTONE:
+			case WOOD:
+			case BEDROCK:
+			case SAND:
+			case GRAVEL:
+			case GOLD_ORE:
+			case IRON_ORE:
+			case COAL_ORE:
+			case LOG:
+			case LEAVES:
+			case SPONGE:
+			case GLASS:
+			case LAPIS_ORE:
+			case LAPIS_BLOCK:
+			case DISPENSER:
+			case SANDSTONE:
+			case NOTE_BLOCK:
+			case BED_BLOCK:
+			case PISTON_STICKY_BASE:
+			case PISTON_BASE:
+			case PISTON_EXTENSION:
+			case WOOL:
+			case PISTON_MOVING_PIECE:
+			case GOLD_BLOCK:
+			case IRON_BLOCK:
+			case DOUBLE_STEP:
+			case STEP:
+			case BRICK:
+			case TNT:
+			case BOOKSHELF:
+			case MOSSY_COBBLESTONE:
+			case OBSIDIAN:
+			case MOB_SPAWNER:
+			case WOOD_STAIRS:
+			case CHEST:
+			case DIAMOND_ORE:
+			case DIAMOND_BLOCK:
+			case WORKBENCH:
+			case SOIL:
+			case FURNACE:
+			case BURNING_FURNACE:
+			case SIGN_POST:
+			case WOODEN_DOOR:
+			case COBBLESTONE_STAIRS:
+			case WALL_SIGN:
+			case STONE_PLATE:
+			case IRON_DOOR_BLOCK:
+			case WOOD_PLATE:
+			case REDSTONE_ORE:
+			case GLOWING_REDSTONE_ORE:
+			case ICE:
+			case SNOW_BLOCK:
+			case CACTUS:
+			case CLAY:
+			case JUKEBOX:
+			case FENCE:
+			case PUMPKIN:
+			case NETHERRACK:
+			case SOUL_SAND:
+			case GLOWSTONE:
+			case JACK_O_LANTERN:
+			case CAKE_BLOCK:
+			case LOCKED_CHEST:
+			case STAINED_GLASS:
+			case TRAP_DOOR:
+			case MONSTER_EGGS:
+			case SMOOTH_BRICK:
+			case HUGE_MUSHROOM_1:
+			case HUGE_MUSHROOM_2:
+			case IRON_FENCE:
+			case THIN_GLASS:
+			case MELON_BLOCK:
+			case FENCE_GATE:
+			case BRICK_STAIRS:
+			case SMOOTH_STAIRS:
+			case MYCEL:
+			case NETHER_BRICK:
+			case NETHER_FENCE:
+			case NETHER_BRICK_STAIRS:
+			case ENCHANTMENT_TABLE:
+			case BREWING_STAND:
+			case CAULDRON:
+			case ENDER_PORTAL_FRAME:
+			case ENDER_STONE:
+			case DRAGON_EGG:
+			case REDSTONE_LAMP_OFF:
+			case REDSTONE_LAMP_ON:
+			case WOOD_DOUBLE_STEP:
+			case WOOD_STEP:
+			case SANDSTONE_STAIRS:
+			case EMERALD_ORE:
+			case ENDER_CHEST:
+			case EMERALD_BLOCK:
+			case SPRUCE_WOOD_STAIRS:
+			case BIRCH_WOOD_STAIRS:
+			case JUNGLE_WOOD_STAIRS:
+			case COMMAND:
+			case BEACON:
+			case COBBLE_WALL:
+			case ANVIL:
+			case TRAPPED_CHEST:
+			case GOLD_PLATE:
+			case IRON_PLATE:
+			case DAYLIGHT_DETECTOR:
+			case REDSTONE_BLOCK:
+			case QUARTZ_ORE:
+			case HOPPER:
+			case QUARTZ_BLOCK:
+			case QUARTZ_STAIRS:
+			case DROPPER:
+			case STAINED_CLAY:
+			case HAY_BLOCK:
+			case HARD_CLAY:
+			case COAL_BLOCK:
+			case STAINED_GLASS_PANE:
+			case LEAVES_2:
+			case LOG_2:
+			case ACACIA_STAIRS:
+			case DARK_OAK_STAIRS:
+			case PACKED_ICE:
+				return true;
+			default:
+				return false;
+		}
+	}
+
+	/**
+	 * Check if the material is a block and does not block any light
+	 *
+	 * @return True if this material is a block and does not block any light
+	 */
+	public boolean isTransparent() {
+		if(!isBlock()){
+			return false;
+		}
+		switch (this) {
+			case AIR:
+			case SAPLING:
+			case POWERED_RAIL:
+			case DETECTOR_RAIL:
+			case LONG_GRASS:
+			case DEAD_BUSH:
+			case YELLOW_FLOWER:
+			case RED_ROSE:
+			case BROWN_MUSHROOM:
+			case RED_MUSHROOM:
+			case TORCH:
+			case FIRE:
+			case REDSTONE_WIRE:
+			case CROPS:
+			case LADDER:
+			case RAILS:
+			case LEVER:
+			case REDSTONE_TORCH_OFF:
+			case REDSTONE_TORCH_ON:
+			case STONE_BUTTON:
+			case SNOW:
+			case SUGAR_CANE_BLOCK:
+			case PORTAL:
+			case DIODE_BLOCK_OFF:
+			case DIODE_BLOCK_ON:
+			case PUMPKIN_STEM:
+			case MELON_STEM:
+			case VINE:
+			case WATER_LILY:
+			case NETHER_WARTS:
+			case ENDER_PORTAL:
+			case COCOA:
+			case TRIPWIRE_HOOK:
+			case TRIPWIRE:
+			case FLOWER_POT:
+			case CARROT:
+			case POTATO:
+			case WOOD_BUTTON:
+			case SKULL:
+			case REDSTONE_COMPARATOR_OFF:
+			case REDSTONE_COMPARATOR_ON:
+			case ACTIVATOR_RAIL:
+			case CARPET:
+			case DOUBLE_PLANT:
+				return true;
+			default:
+				return false;
+		}
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/MaterialData.java b/src/main/java/dev/wolveringer/BungeeUtil/MaterialData.java
new file mode 100644
index 0000000..2eeb3d9
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/MaterialData.java
@@ -0,0 +1,120 @@
+package dev.wolveringer.BungeeUtil;
+
+import dev.wolveringer.BungeeUtil.item.Item;
+
+/**
+ * Handles specific metadata for certain items or blocks
+ */
+public class MaterialData implements Cloneable {
+	private byte data = 0;
+	private final int type;
+
+	public MaterialData(final int type) {
+		this(type, (byte) 0);
+	}
+
+	public MaterialData(final int type, final byte data) {
+		this.type = type;
+		this.data = data;
+	}
+
+	public MaterialData(final Material type) {
+		this(type, (byte) 0);
+	}
+
+	@SuppressWarnings("deprecation")
+	public MaterialData(final Material type, final byte data) {
+		this(type.getId(), data);
+	}
+
+	@Override
+	public MaterialData clone() {
+		try{
+			return (MaterialData) super.clone();
+		}catch (CloneNotSupportedException e){
+			throw new Error(e);
+		}
+	}
+
+	@Override
+	public boolean equals(Object obj) {
+		if(obj != null && obj instanceof MaterialData){
+			MaterialData md = (MaterialData) obj;
+
+			return md.getItemTypeId() == getItemTypeId() && md.getData() == getData();
+		}else{
+			return false;
+		}
+	}
+
+	/**
+	 * Gets the raw data in this material
+	 *
+	 * @return Raw data
+	 */
+	public byte getData() {
+		return data;
+	}
+
+	/**
+	 * Gets the Material that this MaterialData represents
+	 *
+	 * @return Material represented by this MaterialData
+	 */
+	@SuppressWarnings("deprecation")
+	public Material getItemType() {
+		return Material.getMaterial(type);
+	}
+
+	/**
+	 * Gets the Material Id that this MaterialData represents
+	 *
+	 * @return Material Id represented by this MaterialData
+	 * @deprecated Magic value
+	 */
+	public int getItemTypeId() {
+		return type;
+	}
+
+	public int hashCode() {
+		return getItemTypeId() << 8 ^ getData();
+	}
+
+	/**
+	 * Sets the raw data of this material
+	 *
+	 * @param data
+	 *            New raw data
+	 * @deprecated Magic value
+	 */
+	public void setData(byte data) {
+		this.data = data;
+	}
+
+	/**
+	 * Creates a new ItemStack based on this MaterialData
+	 *
+	 * @return New ItemStack containing a copy of this MaterialData
+	 */
+	@SuppressWarnings("deprecation")
+	public Item toItemStack() {
+		return new Item(type, 1, data);
+	}
+
+	/**
+	 * Creates a new ItemStack based on this MaterialData
+	 *
+	 * @param amount
+	 *            The stack size of the new stack
+	 * @return New ItemStack containing a copy of this MaterialData
+	 */
+	@SuppressWarnings("deprecation")
+	public Item toItemStack(int amount) {
+		return new Item(type, amount, data);
+	}
+
+	@Override
+	public String toString() {
+		return getItemType() + "(" + getData() + ")";
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/NumberConversions.java b/src/main/java/dev/wolveringer/BungeeUtil/NumberConversions.java
new file mode 100644
index 0000000..0b2da24
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/NumberConversions.java
@@ -0,0 +1,101 @@
+package dev.wolveringer.BungeeUtil;
+
+public final class NumberConversions {
+    private NumberConversions() {}
+
+    public static int floor(double num) {
+        final int floor = (int) num;
+        return floor == num ? floor : floor - (int) (Double.doubleToRawLongBits(num) >>> 63);
+    }
+
+    public static int ceil(final double num) {
+        final int floor = (int) num;
+        return floor == num ? floor : floor + (int) (~Double.doubleToRawLongBits(num) >>> 63);
+    }
+
+    public static int round(double num) {
+        return floor(num + 0.5d);
+    }
+
+    public static double square(double num) {
+        return num * num;
+    }
+
+    public static int toInt(Object object) {
+        if (object instanceof Number) {
+            return ((Number) object).intValue();
+        }
+
+        try {
+            return Integer.valueOf(object.toString());
+        } catch (NumberFormatException e) {
+        } catch (NullPointerException e) {
+        }
+        return 0;
+    }
+
+    public static float toFloat(Object object) {
+        if (object instanceof Number) {
+            return ((Number) object).floatValue();
+        }
+
+        try {
+            return Float.valueOf(object.toString());
+        } catch (NumberFormatException e) {
+        } catch (NullPointerException e) {
+        }
+        return 0;
+    }
+
+    public static double toDouble(Object object) {
+        if (object instanceof Number) {
+            return ((Number) object).doubleValue();
+        }
+
+        try {
+            return Double.valueOf(object.toString());
+        } catch (NumberFormatException e) {
+        } catch (NullPointerException e) {
+        }
+        return 0;
+    }
+
+    public static long toLong(Object object) {
+        if (object instanceof Number) {
+            return ((Number) object).longValue();
+        }
+
+        try {
+            return Long.valueOf(object.toString());
+        } catch (NumberFormatException e) {
+        } catch (NullPointerException e) {
+        }
+        return 0;
+    }
+
+    public static short toShort(Object object) {
+        if (object instanceof Number) {
+            return ((Number) object).shortValue();
+        }
+
+        try {
+            return Short.valueOf(object.toString());
+        } catch (NumberFormatException e) {
+        } catch (NullPointerException e) {
+        }
+        return 0;
+    }
+
+    public static byte toByte(Object object) {
+        if (object instanceof Number) {
+            return ((Number) object).byteValue();
+        }
+
+        try {
+            return Byte.valueOf(object.toString());
+        } catch (NumberFormatException e) {
+        } catch (NullPointerException e) {
+        }
+        return 0;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/OperatingSystem/OperatingSystemType.java b/src/main/java/dev/wolveringer/BungeeUtil/OperatingSystem/OperatingSystemType.java
new file mode 100644
index 0000000..34c9b77
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/OperatingSystem/OperatingSystemType.java
@@ -0,0 +1,136 @@
+package dev.wolveringer.BungeeUtil.OperatingSystem;
+
+import java.util.HashMap;
+
+public class OperatingSystemType {
+	public static abstract class OperatingSystem {
+		public OperatingSystem() {
+			types.put(getIdentifier(), this);
+		}
+		public abstract String getIdentifier();
+		
+		public boolean isWindows(){
+			return getIdentifier().toLowerCase().contains("windows");
+		}
+		public boolean isLinux(){
+			return getIdentifier().toLowerCase().contains("linux");
+		}
+		public boolean isMac(){
+			return getIdentifier().toLowerCase().contains("mac");
+		}
+	}
+	private static HashMap<String, OperatingSystem> types = new HashMap<String, OperatingSystemType.OperatingSystem>();
+	
+	public static final OperatingSystemWindows WINDOWS = new OperatingSystemWindows() {
+		@Override
+		public String getIdentifier() {
+			return "Windows";
+		}
+	};
+	public static final OperatingSystemLinux LINUX = new OperatingSystemLinux() {
+		@Override
+		public String getIdentifier() {
+			return "Linux";
+		}
+	};
+	public static final OperatingSystemMac MAC = new OperatingSystemMac() {
+		@Override
+		public String getIdentifier() {
+			return "Mac";
+		}
+	};
+	public static final OperatingSystem UNDEFINED = new OperatingSystem() {
+		@Override
+		public String getIdentifier() {
+			return "undefined";
+		}
+	};
+	String name;
+	
+	private OperatingSystemType(String name) {
+		this.name = name;
+	}
+	
+	private static OperatingSystem type = null;
+	public static OperatingSystem getSystemType(){
+		if(type == null){
+			type = types.get(System.getProperty("os.name"));
+			if(type == null)
+				type = UNDEFINED;
+		}
+		return type;
+	}
+	
+	
+	public static abstract class OperatingSystemWindows extends OperatingSystem{
+		public static final OperatingSystem WINDOWS_95 = new OperatingSystemWindows() {
+			public String getIdentifier() {
+				return "Windows 95";
+			};
+		};
+		public static final OperatingSystem WINDOWS_98 = new OperatingSystemWindows() {
+			public String getIdentifier() {
+				return "Windows 98";
+			};
+		};
+		public static final OperatingSystem WINDOWS_ME = new OperatingSystemWindows() {
+			public String getIdentifier() {
+				return "Windows Me";
+			};
+		};
+		public static final OperatingSystem WINDOWS_NT = new OperatingSystemWindows() {
+			public String getIdentifier() {
+				return "Windows NT";
+			};
+		};
+		public static final OperatingSystem WINDOWS_2000 = new OperatingSystemWindows() {
+			public String getIdentifier() {
+				return "Windows 2000";
+			};
+		};
+		public static final OperatingSystem WINDOWS_XP = new OperatingSystemWindows() {
+			public String getIdentifier() {
+				return "Windows XP";
+			};
+		};
+		public static final OperatingSystem WINDOWS_2003 = new OperatingSystemWindows() {
+			public String getIdentifier() {
+				return "Windows 2003";
+			};
+		};
+		public static final OperatingSystem WINDOWS_CE = new OperatingSystemWindows() {
+			public String getIdentifier() {
+				return "Windows CE";
+			};
+		};
+		public static final OperatingSystem WINDOWS_7 = new OperatingSystemWindows() {
+			public String getIdentifier() {
+				return "Windows 7";
+			};
+		};
+		public static final OperatingSystem WINDOWS_8 = new OperatingSystemWindows() {
+			public String getIdentifier() {
+				return "Windows 8";
+			};
+		};
+		public static final OperatingSystem WINDOWS_10 = new OperatingSystemWindows() {
+			public String getIdentifier() {
+				return "Windows 10";
+			};
+		};
+	}
+	public static abstract class OperatingSystemLinux extends OperatingSystem{}
+	
+	public static abstract class OperatingSystemMac extends OperatingSystem{
+		public static final OperatingSystem MAC_OS = new OperatingSystemMac() {
+			public String getIdentifier() {
+				return "Mac OS";
+			};
+		};
+		public static final OperatingSystem MAC_OS_X = new OperatingSystemMac() {
+			public String getIdentifier() {
+				return "Mac OS X";
+			};
+		};
+	}
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/OperationCalback.java b/src/main/java/dev/wolveringer/BungeeUtil/OperationCalback.java
new file mode 100644
index 0000000..2032307
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/OperationCalback.java
@@ -0,0 +1,5 @@
+package dev.wolveringer.BungeeUtil;
+
+public interface OperationCalback<T> {
+	public void done(T response);
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/PacketHandleEvent.java b/src/main/java/dev/wolveringer/BungeeUtil/PacketHandleEvent.java
new file mode 100644
index 0000000..604c3f5
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/PacketHandleEvent.java
@@ -0,0 +1,49 @@
+package dev.wolveringer.BungeeUtil;
+
+import net.md_5.bungee.api.plugin.Cancellable;
+import net.md_5.bungee.api.plugin.Event;
+import dev.wolveringer.BungeeUtil.packets.Packet;
+
+public class PacketHandleEvent<T extends Packet> extends Event implements Cancellable {
+	private boolean cancelled = false;
+	private T packet;
+	private Player player;
+
+	public PacketHandleEvent(T p, Player pl) {
+		this.packet = p;
+		this.player = pl;
+	}
+
+	public T getPacket() {
+		return packet;
+	}
+
+	public Player getPlayer() {
+		return player;
+	}
+
+	public boolean isCancelled() {
+		return cancelled;
+	}
+
+	public void setCancelled(boolean c) {
+		this.cancelled = c;
+	}
+
+	public void setPacket(T p) {
+		this.packet = p;
+	}
+
+	/**
+	 * {@code The player change dont will change the destination of the packet!!!}
+	 */
+
+	public void setPlayer(Player pl) {
+		this.player = pl;
+	}
+
+	@Override
+	public String toString() {
+		return "PacketHandleEvent@" + System.identityHashCode(this) + "[cancelled=" + this.cancelled + ", packet=" + this.packet + ", player=" + this.player + "]";
+	}
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/PacketHandler.java b/src/main/java/dev/wolveringer/BungeeUtil/PacketHandler.java
new file mode 100644
index 0000000..8e69af9
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/PacketHandler.java
@@ -0,0 +1,7 @@
+package dev.wolveringer.BungeeUtil;
+
+import dev.wolveringer.BungeeUtil.packets.Packet;
+
+public interface PacketHandler<T extends Packet> {
+	public void handle(PacketHandleEvent<T> e);
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/PacketLib.java b/src/main/java/dev/wolveringer/BungeeUtil/PacketLib.java
new file mode 100644
index 0000000..abb1bca
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/PacketLib.java
@@ -0,0 +1,186 @@
+package dev.wolveringer.BungeeUtil;
+
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map.Entry;
+
+import dev.wolveringer.BungeeUtil.packets.Packet;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayInFlying;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayInPosition;
+import lombok.AllArgsConstructor;
+import lombok.Getter;
+
+@SuppressWarnings({ "unchecked", "rawtypes" })
+public class PacketLib {
+	@AllArgsConstructor
+	@Getter
+	private static class PacketHandlerHolder implements Comparable<PacketHandlerHolder> {
+		private PacketHandler handler;
+		private int importance;
+		
+		@Override
+		public int compareTo(PacketHandlerHolder o) {
+			return Integer.compare(o.importance, importance);
+		}
+
+		@Override
+		public int hashCode() {
+			final int prime = 31;
+			int result = 1;
+			result = prime * result + ((handler == null) ? 0 : handler.hashCode());
+			//result = prime * result + importance;
+			return result;
+		}
+
+		@Override
+		public boolean equals(Object obj) {
+			if (this == obj)
+				return true;
+			if (obj == null)
+				return false;
+			if(obj instanceof PacketHandler)
+				return obj.equals(handler);
+			if (getClass() != obj.getClass())
+				return false;
+			PacketHandlerHolder other = (PacketHandlerHolder) obj;
+			if (handler == null) {
+				if (other.handler != null)
+					return false;
+			} else if (!handler.equals(other.handler))
+				return false;
+			if (importance != other.importance)
+				return false;
+			return true;
+		}
+	}
+	
+	@Deprecated
+	public static void printListener(){
+		for(Entry<Class<? extends Packet>, ArrayList<PacketHandlerHolder>> e : handlers.entrySet()){
+			StringBuilder out = new StringBuilder();
+			for(PacketHandlerHolder h : e.getValue())
+				out.append(", "+h.getHandler().toString());
+			if( e.getValue().size() > 0)
+			System.out.print(e.getKey()+" -> "+out.toString().substring(2));
+		}
+	}
+	
+	private static HashMap<Class<? extends Packet>, ArrayList<PacketHandlerHolder>> handlers = new HashMap<Class<? extends Packet>, ArrayList<PacketHandlerHolder>>() {
+		private static final long serialVersionUID = 1L;
+
+		@Override
+		public ArrayList<PacketHandlerHolder> get(Object paramObject) {
+			Object r = super.get(paramObject);
+			if(r == null)
+				try{
+					super.put((Class<? extends Packet>) paramObject, new ArrayList<PacketHandlerHolder>(){
+						private static final long serialVersionUID = 1L;
+						public void insertSorted(PacketHandlerHolder value) {
+					        super.add(value);
+					        Comparable<PacketHandlerHolder> cmp = (Comparable<PacketHandlerHolder>) value;
+					        for (int i = size()-1; i > 0 && cmp.compareTo(get(i-1)) < 0; i--)
+					            Collections.swap(this, i, i-1);
+					    }
+						public boolean add(PacketHandlerHolder value) {
+							insertSorted(value);
+							return true;
+						}
+					});
+				}catch (Exception e){
+				}
+			return super.get(paramObject);
+		}
+	};
+
+	@SuppressWarnings("serial")
+	private static HashMap<Class<? extends Packet>, ArrayList<Class<? extends Packet>>> superclazzes = new HashMap<Class<? extends Packet>, ArrayList<Class<? extends Packet>>>() {
+		@Override
+		public ArrayList<Class<? extends Packet>> get(Object paramObject) {
+			ArrayList<Class<? extends Packet>> r = super.get(paramObject);
+			if(r == null)
+				try{
+					ArrayList<Class<? extends Packet>> list = new ArrayList<Class<? extends Packet>>();
+					Class c = (Class) paramObject;
+					BungeeUtil.getInstance().debug("Sarching for subinstances of "+c);
+					if(c != Packet.class)
+						for(Class<? extends Packet> clazz : Packet.getRegisteredPackets()){
+							if(c.isAssignableFrom(clazz)){
+								list.add(clazz);
+							}
+						}
+					list.add(c);
+					r = (list = new ArrayList<>(new HashSet<>(list)));
+					for(Class x : list)
+						BungeeUtil.getInstance().debug("Found class instance of "+c+" -> "+x);
+					super.put((Class<? extends Packet>) paramObject, r);
+				}catch (Exception e){ }
+			return r;
+		}
+	};
+
+	public static void addHandler(PacketHandler h) {
+		addHandler(h, 0);
+	}
+
+	public static void addHandler(PacketHandler h,int importance) {
+		for(Class c : superclazzes.get(getPacketType(h))){
+			handlers.get(c).add(new PacketHandlerHolder(h, importance));
+		}
+	}
+
+	
+	public static void removeHandler(PacketHandler h) {
+		for(Class c : superclazzes.get(getPacketType(h))){
+			for(PacketHandlerHolder h1 : new ArrayList<>(handlers.get(c)))
+				if(h1 != null && h1.getHandler() != null && h1.getHandler().equals(h))
+					handlers.get(c).remove(h1);
+		}
+		for(PacketHandlerHolder h1 : handlers.get(Packet.class))
+			if(h1 != null && h1.getHandler() != null && h1.getHandler().equals(h))
+				handlers.get(Packet.class).remove(h1);
+	}
+	
+	public static PacketHandleEvent handle(PacketHandleEvent e) {
+		Class<? extends Packet> c = e.getPacket().getClass();
+		for(PacketHandlerHolder h : new ArrayList<>(handlers.get(c)))
+			h.handler.handle(e);
+		for(PacketHandlerHolder h : new ArrayList<>(handlers.get(Packet.class)))
+			h.handler.handle(e);
+		return e;
+	}
+
+	private static Class getPacketType(PacketHandler s) {
+		for(Type interfaces : s.getClass().getGenericInterfaces())
+			if(interfaces instanceof ParameterizedType)
+				for(Type c : ((ParameterizedType) interfaces).getActualTypeArguments())
+					try{
+						if(c.equals(Packet.class))
+							continue;
+						try{
+							return Class.forName(c.toString().split(" ")[1]);
+						}catch(ExceptionInInitializerError e){
+							System.out.println("Cant find class "+c.toString().split(" ")[1]);
+							throw e;
+						}
+					}catch (ClassNotFoundException e){
+						e.printStackTrace();
+					}
+		return Packet.class;
+	}
+	
+	public static void main(String[] args) {
+		PacketHandler handler = new PacketHandler<PacketPlayInFlying>() {
+			@Override
+			public void handle(PacketHandleEvent<PacketPlayInFlying> e) {
+				System.out.println("Handle "+e);
+			}
+		};
+		System.out.println("Type: "+getPacketType(handler));
+		addHandler(handler);
+		handle(new PacketHandleEvent(new PacketPlayInPosition(), null));
+	}
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/Player.java b/src/main/java/dev/wolveringer/BungeeUtil/Player.java
new file mode 100644
index 0000000..054cbfb
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/Player.java
@@ -0,0 +1,91 @@
+package dev.wolveringer.BungeeUtil;
+
+import net.md_5.bungee.api.connection.ProxiedPlayer;
+import dev.wolveringer.BungeeUtil.item.Item;
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayIn;
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
+import dev.wolveringer.api.bossbar.BossBarManager;
+import dev.wolveringer.api.inventory.Inventory;
+import dev.wolveringer.api.inventory.PlayerInventory;
+import dev.wolveringer.api.position.Location;
+import dev.wolveringer.api.scoreboard.Scoreboard;
+import dev.wolveringer.api.sound.SoundCategory;
+import dev.wolveringer.api.sound.SoundEffect;
+import dev.wolveringer.chat.IChatBaseComponent;
+import dev.wolveringer.network.IInitialHandler;
+
+public interface Player extends ProxiedPlayer {
+	public IInitialHandler getInitialHandler();
+	
+	public Location getLocation();
+	
+	public void setLocation(Location loc);
+
+	public Location getLastLocation();
+
+	
+	
+	public void performCommand(String command);
+	
+	public boolean isInventoryOpened();
+
+	public void openInventory(Inventory inv);
+
+	public void updateInventory();
+
+	public Inventory getInventoryView();
+	
+	public PlayerInventory getPlayerInventory();
+	
+	public void closeInventory();
+	
+	
+	public void setCursorItem(Item is);
+
+	public Item getCursorItem();
+
+	public Item getHandItem();
+	
+	public Item getOffHandItem();
+
+	public ClientVersion getVersion();
+
+	public void sendPacket(PacketPlayOut packet);
+	
+	@Deprecated
+	public void sendPacketToServer(PacketPlayIn p);
+
+	
+	public void setSelectedSlot(int slot);
+
+	public int getSelectedSlot();
+
+	
+	public void setTabHeader(IChatBaseComponent header,IChatBaseComponent footer);
+	
+	public IChatBaseComponent[] getTabHeader();
+	
+	
+	public Scoreboard getScoreboard();
+
+	public void disconnect(Exception e);
+	
+	public void playSound(SoundEffect effect);
+	
+	public void playSound(SoundEffect effect,float volume);
+	
+	public void playSound(SoundEffect effect,float volume,float pitch);
+	
+	/**
+	 * @param effect
+	 * @param location
+	 * @param volume
+	 * @param pitch (0-360)
+	 */
+	public void playSound(SoundEffect effect, Location location,float volume,float pitch);
+
+	public void playSound(SoundEffect effect, SoundCategory blocks, Location location, float f, float g);
+	
+	
+	public BossBarManager getBossBarManager();
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/RamStatistics.java b/src/main/java/dev/wolveringer/BungeeUtil/RamStatistics.java
new file mode 100644
index 0000000..cce3fbc
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/RamStatistics.java
@@ -0,0 +1,139 @@
+package dev.wolveringer.BungeeUtil;
+
+import java.util.LinkedList;
+import java.util.concurrent.TimeUnit;
+
+import dev.wolveringer.string.ColoredChar;
+import dev.wolveringer.terminal.graph.TerminalGraph;
+import dev.wolveringer.terminal.graph.TerminalGraph.Graph;
+import dev.wolveringer.terminal.graph.TerminalGraph.Point;
+import net.md_5.bungee.BungeeCord;
+import net.md_5.bungee.api.ChatColor;
+import net.md_5.bungee.api.scheduler.ScheduledTask;
+import lombok.AllArgsConstructor;
+import lombok.Getter;
+
+public class RamStatistics {
+	@AllArgsConstructor
+	public static class RamStatistic {
+		private RamStatistics handle;
+		@Getter
+		private long timestamp;
+		@Getter
+		private long usedMemory;
+		@Getter
+		private long reservedMemory;
+		@Getter
+		private long maxMemory;
+		
+		public RamStatistic getPreviousStatistic(int time,TimeUnit untit){
+			return handle.getPreviousStatistic(this,time,untit);
+		}
+	}
+	private LinkedList<RamStatistic> last = new LinkedList<RamStatistic>();
+	private Runtime runtime;
+	private ScheduledTask task;
+	
+	public RamStatistics() {
+		runtime = Runtime.getRuntime();
+	}
+	
+	public void start(){
+		if(task == null){
+			task = BungeeCord.getInstance().getScheduler().runAsync(BungeeUtil.getPluginInstance(), new Runnable() {
+				@Override
+				public void run() {
+					while (true) {
+						logCurruntRam();
+						try {
+							Thread.sleep(1000);
+						} catch (InterruptedException e) {
+						}
+					}
+				}
+			});
+		}
+	}
+	
+	protected RamStatistic getPreviousStatistic(RamStatistic currunt){
+		int index = last.indexOf(currunt);
+		if(index == -1)
+			return null;
+		if(index-1<0)
+			return null;
+		return last.get(index);
+	}
+	
+	protected RamStatistic getPreviousStatistic(RamStatistic currunt, int time, TimeUnit untit) {
+		int index = last.indexOf(currunt);
+		if(index == -1)
+			return null;
+		index = index-1;
+		while (index>0) {
+			if(last.get(index).timestamp<currunt.timestamp-untit.toMillis(time))
+				return last.get(index);
+			index--;
+		}
+		return null;
+	}
+
+	
+	public void stop(){
+		if(task != null)
+			task.cancel();
+		task = null;
+	}
+	
+	private void logCurruntRam(){
+		last.add(new RamStatistic(this,System.currentTimeMillis(),runtime.totalMemory() - runtime.freeMemory(), runtime.totalMemory(), runtime.maxMemory()));
+		recalculate();
+	}
+	
+	private void recalculate(){
+		while (last.size()> 60*60*5) { //Log for 5 Houers
+			last.pollFirst();
+		}
+	}
+	
+	public RamStatistic getLastState(){
+		return last.getLast();
+	}
+	
+	public TerminalGraph createGrath(int seconds,int divisor){
+		TerminalGraph base = new TerminalGraph();
+		
+		Graph graphUsedMemory = new Graph();
+		graphUsedMemory.setReturnZeroByNoData(true);
+		graphUsedMemory.setCharacter(new ColoredChar('#'));
+		graphUsedMemory.getCharacter().setColor(ChatColor.GREEN);
+		
+		Graph graphAllocatedMemory = new Graph();
+		graphAllocatedMemory.setReturnZeroByNoData(true);
+		graphAllocatedMemory.setCharacter(new ColoredChar('+'));
+		graphAllocatedMemory.getCharacter().setColor(ChatColor.GOLD);
+		
+		int max = 0;
+		
+		for(RamStatistic stats : this.last){
+			if(stats.getTimestamp() > System.currentTimeMillis()-seconds*1000){
+				graphUsedMemory.addPoint(new Point((int)((System.currentTimeMillis()-stats.getTimestamp())/1000), (int) stats.getUsedMemory()/divisor));
+				if(stats.getUsedMemory()/divisor > max)
+					max = (int) stats.getUsedMemory()/divisor;
+				
+				graphAllocatedMemory.addPoint(new Point((int)((System.currentTimeMillis()-stats.getTimestamp())/1000), (int) stats.getReservedMemory()/divisor));
+				if(stats.getReservedMemory()/divisor > max)
+					max = (int) stats.getReservedMemory()/divisor;
+			}
+		}
+		
+		base.addGraph(graphAllocatedMemory);
+		base.addGraph(graphUsedMemory);
+		
+		base.setStartX(seconds);
+		base.setEndX(0);
+		base.setStepX(10);
+		base.setStartY(0);
+		base.setEndY((int) (max+(max*0.1)));
+		return base;
+	}
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/RamStatisticsPainter.java b/src/main/java/dev/wolveringer/BungeeUtil/RamStatisticsPainter.java
new file mode 100644
index 0000000..ba78b0d
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/RamStatisticsPainter.java
@@ -0,0 +1,95 @@
+package dev.wolveringer.BungeeUtil;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+
+import org.fusesource.jansi.AnsiConsole;
+
+import dev.wolveringer.BungeeUtil.RamStatistics.RamStatistic;
+import dev.wolveringer.BungeeUtil.configuration.Configuration;
+import dev.wolveringer.chat.ChatColor.AnsiColorFormater;
+import dev.wolveringer.chat.ChatColor.ChatColorUtils;
+import dev.wolveringer.terminal.TerminalListener;
+import dev.wolveringer.terminal.TerminalListener.Listener;
+import jline.TerminalFactory;
+import net.md_5.bungee.BungeeCord;
+import net.md_5.bungee.api.ChatColor;
+
+public class RamStatisticsPainter implements Runnable, Listener {
+	@Override
+	public void run() {
+		while (Configuration.ramStatistics()) {
+			try {
+				Thread.sleep(100);
+			} catch (InterruptedException e) {
+			}
+			if (!BungeeUtil.getInstance().isActive())
+				return;
+			if (BungeeUtil.getInstance().ramStatistiks.getLastState() == null)
+				continue;
+			paint();
+		}
+	}
+	
+	private void paint(){
+		int mb = 1024 * 1024;
+
+		RamStatistic state = BungeeUtil.getInstance().ramStatistiks.getLastState();
+		String var1 = (state.getUsedMemory()) / mb + "";
+		String var2 = (state.getReservedMemory() - state.getUsedMemory()) / mb + "";
+		String var3 = state.getReservedMemory() / mb + "";
+		String var4 = state.getMaxMemory() / mb + "";
+
+		int var5 = 5;
+		var1 = format(var1, var5);
+		var2 = format(var2, var5);
+		var3 = format(var3, var5);
+		var4 = format(var4, var5);
+
+		int diff = 0;
+		if (state.getPreviousStatistic(10, TimeUnit.SECONDS) != null)
+			diff = (int) (((int) (state.getUsedMemory() / mb)) - ((int) (state.getPreviousStatistic(10, TimeUnit.SECONDS).getUsedMemory() / mb)));
+		String diffSpace = "";
+		for (int i = 0; i < ("(*" + Math.abs(diff) + ")").length(); i++)
+			diffSpace += " ";
+		List<String> lines = new ArrayList<>();
+		lines.add(ChatColorUtils.COLOR_CHAR + "7#####" + diffSpace.substring(0, diffSpace.length() / 2).replaceAll(" ", "#") + " " + ChatColorUtils.COLOR_CHAR + "6Heap utilization statistics [MB] " + ChatColorUtils.COLOR_CHAR + "7#####" + diffSpace.substring(0, diffSpace.length() / 2).replaceAll(" ", "#") + (diffSpace.length() % 2 != 0 ? "#" : ""));
+		lines.add(ChatColorUtils.COLOR_CHAR + "7#     " + ChatColorUtils.COLOR_CHAR + "aReserved Used Memory:      " + ChatColorUtils.COLOR_CHAR + "e" + var1 + "M " + ChatColorUtils.COLOR_CHAR + "7(" + (diff > 0 ? ChatColorUtils.COLOR_CHAR + "a+" : diff < 0 ? ChatColorUtils.COLOR_CHAR + "c-" : ChatColorUtils.COLOR_CHAR + "6Â±") + Math.abs(diff) + ChatColorUtils.COLOR_CHAR + "7)   " + ChatColorUtils.COLOR_CHAR + "7#");
+		lines.add(ChatColorUtils.COLOR_CHAR + "7#     " + ChatColorUtils.COLOR_CHAR + "aReserved Free Memory:      " + ChatColorUtils.COLOR_CHAR + "e" + var2 + "M    " + diffSpace + ChatColorUtils.COLOR_CHAR + "7#");
+		lines.add(ChatColorUtils.COLOR_CHAR + "7#     " + ChatColorUtils.COLOR_CHAR + "aReserved Memory:           " + ChatColorUtils.COLOR_CHAR + "e" + var3 + "M    " + diffSpace + ChatColorUtils.COLOR_CHAR + "7#");
+		lines.add(ChatColorUtils.COLOR_CHAR + "7#     " + ChatColorUtils.COLOR_CHAR + "a-----------------------------" + format("", var5).replaceAll(" ", "-") + "   " + diffSpace + ChatColorUtils.COLOR_CHAR + "7#");
+		lines.add(ChatColorUtils.COLOR_CHAR + "7#     " + ChatColorUtils.COLOR_CHAR + "aAllowed Reservable Memory: " + ChatColorUtils.COLOR_CHAR + "e" + var4 + "M    " + diffSpace + ChatColorUtils.COLOR_CHAR + "7#");
+		lines.add(ChatColorUtils.COLOR_CHAR + "7############################################" + diffSpace.replaceAll(" ", "#"));
+		int h = 1;
+		int w = 0;
+		for (String m : lines)
+			if (ChatColor.stripColor(m).length() > w)
+				w = ChatColor.stripColor(m).length();
+		w = TerminalFactory.get().getWidth() - w + 1;
+		for (int i = 0; i < lines.size(); i++, h++) {
+			AnsiConsole.out.print("\033[" + h + ";" + w + "H" + AnsiColorFormater.getFormater().format(lines.get(i)));
+		}
+		int cw = 2 + BungeeCord.getInstance().getConsoleReader().getCursorBuffer().cursor; //2 = Promt = ' >'
+		AnsiConsole.out.print("\033[" + TerminalFactory.get().getHeight() + ";" + cw + "H");
+		AnsiConsole.out.flush();
+	}
+
+	private String format(String in, int space) {
+		while (in.length() < space) {
+			in = in + " ";
+		}
+		return in;
+	}
+
+	@Override
+	public void onResize(int oldWidth, int oldHeight, int newWidth, int newHeight) {
+		TerminalListener.getInstance().repaintTerminal();
+		paint();
+	}
+
+	@Override
+	public void onLinesPrinted() {
+		paint();
+	}
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/bukkit/BukkitMain.java b/src/main/java/dev/wolveringer/BungeeUtil/bukkit/BukkitMain.java
new file mode 100644
index 0000000..8d985b5
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/bukkit/BukkitMain.java
@@ -0,0 +1,17 @@
+package dev.wolveringer.BungeeUtil.bukkit;
+
+/*
+import org.bukkit.Bukkit;
+import org.bukkit.plugin.java.JavaPlugin;
+
+public class BukkitMain extends JavaPlugin{
+	@Override
+	public void onEnable() {
+		Bukkit.getConsoleSender().sendMessage(""+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"7["+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"eBungeeUntil"+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"7] "+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"cBungeeUtil is only a plugin for the BungeeCord");
+	}
+
+}
+*/
+public class BukkitMain  {
+	
+}
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/configuration/Configuration.java b/src/main/java/dev/wolveringer/BungeeUtil/configuration/Configuration.java
new file mode 100644
index 0000000..e402d44
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/configuration/Configuration.java
@@ -0,0 +1,110 @@
+package dev.wolveringer.BungeeUtil.configuration;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+import dev.wolveringer.BungeeUtil.AsyncCatcher.AsyncCatcherMode;
+import dev.wolveringer.BungeeUtil.BungeeUtil;
+import dev.wolveringer.BungeeUtil.HandleErrorAction;
+import dev.wolveringer.BungeeUtil.Main;
+import dev.wolveringer.configuration.file.YamlConfiguration;
+import dev.wolveringer.strings.Messages;
+import net.md_5.bungee.BungeeCord;
+
+public class Configuration {
+	private static YamlConfiguration conf;
+	private static List<String> versionsFuture;
+	
+	public static YamlConfiguration getConfig() {
+		return conf;
+	}
+	
+	@SuppressWarnings("deprecation")
+	public static void init(){
+		conf = YamlConfiguration.loadConfiguration(new File(BungeeUtil.getPluginInstance().getDataFolder().getParentFile().getAbsolutePath()+"/BungeeUtil/"+Messages.getString("configuration.name")));
+		conf.setDefaults(YamlConfiguration.loadConfiguration(Configuration.class.getResourceAsStream("/"+Messages.getString("configuration.name"))));
+		conf.options().copyHeader(true);
+		conf.options().copyDefaults(true);
+		try{
+			conf.save(new File(BungeeUtil.getPluginInstance().getDataFolder().getParentFile().getAbsolutePath()+"/BungeeUtil/"+Messages.getString("configuration.name")));
+		}catch (IOException ex){
+			ex.printStackTrace();
+		}
+	}
+	
+	public static String getByteBuffType() {
+		return conf.getString("byteBuffType");
+	}
+	
+	public static boolean ramStatistics() {
+		return conf.getBoolean("debug.ram-statistics");
+	}
+	
+	public static boolean isTerminalColored(){
+		return conf.getBoolean("terminal.colored");
+	}
+	
+	public static boolean isTimingsActive(){
+		return conf.getBoolean(Messages.getString("configuration.timings"));
+	}
+	
+	public static int getLoadingBufferSize(){
+		return conf.getInt("loading.inject.buffer-size");
+	}
+
+	public static boolean isFastBoot(){
+		return conf.getBoolean("loading.fastboot");
+	}
+	
+	public static void setTimingsActive(boolean enabled) {
+		conf.set(Messages.getString("configuration.timings"), enabled);
+		try{
+			conf.save(new File(BungeeUtil.getPluginInstance().getDataFolder().getParentFile().getAbsolutePath()+"/BungeeUtil/"+Messages.getString("configuration.name")));
+		}catch (IOException ex){
+			ex.printStackTrace();
+		}
+	}
+	public static boolean isUpdaterActive(){
+		return conf.getBoolean(Messages.getString("configuration.updater"));
+	}
+	public static String getLastVersion(){
+		return conf.getString("lastVersion"); 
+	}
+	public static void setLastVersion(String oldVerstion){
+		if(oldVerstion == null){
+			conf.set("lastVersion", null);
+		}
+		else
+			conf.set("lastVersion", oldVerstion);
+		try {
+			conf.save(new File(BungeeUtil.getPluginInstance().getDataFolder().getParentFile().getAbsolutePath()+"/BungeeUtil/"+Messages.getString("configuration.name")));
+		} catch (IOException e) {
+		}
+	}
+	public static AsyncCatcherMode getAsyncMode(){
+		if(conf.getBoolean("async-catcher.enabled"))
+			return AsyncCatcherMode.valueOf(conf.getString("async-catcher.mode"));
+		else
+			return AsyncCatcherMode.DISABLED;
+	}
+	public static boolean isGCEnabled(){
+		return conf.getBoolean("system.gc.enabled");
+	}
+	public static boolean isDebugEnabled(){
+		return conf.getBoolean("debug.messages");
+	}
+	public static boolean isSyncInventoryClickActive(){
+		return conf.getBoolean("inventory.synchandle");
+	}
+	public static boolean isScoreboardhandleEnabled(){
+		return conf.getBoolean("utils.scoreboard");
+	}
+	public static boolean isBossBarhandleEnabled(){
+		return conf.getBoolean("utils.bossbar");
+	}
+	public static HandleErrorAction getHandleExceptionAction(){
+		return HandleErrorAction.valueOf(conf.getString("network.exception"));
+	}
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/exception/ExceptionUtils.java b/src/main/java/dev/wolveringer/BungeeUtil/exception/ExceptionUtils.java
new file mode 100644
index 0000000..3939e87
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/exception/ExceptionUtils.java
@@ -0,0 +1,121 @@
+package dev.wolveringer.BungeeUtil.exception;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+import com.mysql.jdbc.Util;
+
+import dev.wolveringer.util.UtilReflection;
+
+public class ExceptionUtils {
+	private static final String class_name;
+
+	static{
+		class_name = ExceptionUtils.class.getName();
+	}
+
+	public static StackTraceElement[] replaceStackTraceElement(StackTraceElement[] in, StackTraceElement old_stack, StackTraceElement new_stack) {
+		List<StackTraceElement> arraylist_new_stack = new ArrayList<StackTraceElement>();
+		for(StackTraceElement e : in){
+			if(e.getClassName() == old_stack.getClassName())
+				if(e.getMethodName() == old_stack.getMethodName())
+					if(e.getFileName() == old_stack.getFileName())
+						if(new_stack != null)
+							arraylist_new_stack.add(new_stack);
+						else
+							continue;
+			arraylist_new_stack.add(e);
+		}
+		return arraylist_new_stack.toArray(new StackTraceElement[arraylist_new_stack.size()]);
+	}
+
+	public static StackTraceElement[] replaceCurruntStackTraceElement(StackTraceElement[] in) {
+		return replaceStackTraceElement(in, getCurruntMethodeStackTraceElement(), null);
+	}
+
+	public static StackTraceElement getCurruntMethodeStackTraceElement() {
+		StackTraceElement[] _currunt = Thread.currentThread().getStackTrace();
+		for(StackTraceElement e : _currunt)
+			if(e != null && !e.getClassName().equals(class_name) && !e.getMethodName().equalsIgnoreCase("getStackTrace"))
+				return e;
+		return null;
+	}
+
+	public static StackTraceElement getCallerStackTraceElement() {
+		StackTraceElement[] _currunt = Thread.currentThread().getStackTrace();
+		for(int i = 0;i<_currunt.length;i++){
+			StackTraceElement e = _currunt[i];
+			if(e != null && !e.getClassName().equals(class_name) && !e.getMethodName().equalsIgnoreCase("getStackTrace")){
+				if(i+1<_currunt.length){
+					return null;
+				}
+				else
+					return _currunt[i+1];
+			}
+		}
+		return null;
+	}
+	
+	public static Throwable replaceCurruntStackTraceElement(Throwable in) {
+		return replaceStackTraceElement(in, getCurruntMethodeStackTraceElement(), null);
+	}
+
+	public static Throwable replaceStackTraceElement(Throwable in, StackTraceElement old_stack, StackTraceElement new_stack) {
+		List<StackTraceElement> arraylist_new_stack = new ArrayList<StackTraceElement>();
+		for(StackTraceElement e : in.getStackTrace()){
+			if(e.getClassName() == old_stack.getClassName())
+				if(e.getMethodName() == old_stack.getMethodName())
+					if(e.getFileName() == old_stack.getFileName())
+						if(new_stack != null)
+							arraylist_new_stack.add(new_stack);
+						else
+							continue;
+			arraylist_new_stack.add(e);
+		}
+		in.setStackTrace(arraylist_new_stack.toArray(new StackTraceElement[arraylist_new_stack.size()]));
+		return in;
+	}
+	
+	public static int getIndexOf(StackTraceElement[] in,StackTraceElement e){
+		for(int i = 0;i < in.length;i++){
+			StackTraceElement stackTraceElement = in[i];
+			if(e.getClassName() == stackTraceElement.getClassName())
+				if(e.getMethodName() == stackTraceElement.getMethodName())
+					if(e.getFileName() == stackTraceElement.getFileName())
+						return i;
+		}
+		return -1;
+	}
+	public static int getIndexOf(Throwable ex,StackTraceElement e){
+		return getIndexOf(ex.getStackTrace(), e);
+	}
+	public static int getCurrentMethodeIndex(StackTraceElement[] in){
+		return getIndexOf(in, getCurruntMethodeStackTraceElement());
+	}
+	public static int getCurrentMethodeIndex(Throwable ex){
+		return getIndexOf(ex, getCurruntMethodeStackTraceElement());
+	}
+	public static StackTraceElement[] deleteDownward(StackTraceElement[] ex,int index){
+		return Arrays.copyOf(ex, index);
+	}
+	public static StackTraceElement[] deleteUpward(StackTraceElement[] ex,int index){
+		return Arrays.copyOfRange(ex, index, ex.length);
+	}
+	public static Throwable setExceptionMessage(Throwable t,String message){
+		try{
+			UtilReflection.getField(Throwable.class, "detailMessage").set(t, message);
+		}catch(Exception e){
+			e.printStackTrace();
+		}
+		return t;
+	}
+	public static RuntimeException createRuntimeException(Throwable t){
+		if(t instanceof RuntimeException)
+			return (RuntimeException) t;
+		RuntimeException ex = new RuntimeException(t.getMessage());
+		ex.setStackTrace(t.getStackTrace());
+		UtilReflection.setField(RuntimeException.class, "cause", t.getCause() == null ? ex : t.getCause());
+		return ex;
+	}
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/GameProfile.java b/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/GameProfile.java
new file mode 100644
index 0000000..0c93751
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/GameProfile.java
@@ -0,0 +1,51 @@
+package dev.wolveringer.BungeeUtil.gameprofile;
+
+import java.util.UUID;
+
+public class GameProfile {
+	private UUID id;
+	private String name;
+	private PropertyMap properties = new PropertyMap();
+	private boolean legacy;
+
+	public GameProfile(UUID id, String name) {
+		if((id == null) && ("".equalsIgnoreCase(name)||name==null))
+			throw new IllegalArgumentException("Name and ID cannot both be blank");
+		this.id = id;
+		this.name = name;
+	}
+
+	public UUID getId() {
+		return this.id;
+	}
+
+	public String getName() {
+		return this.name;
+	}
+
+	public PropertyMap getProperties() {
+		return this.properties;
+	}
+
+	public boolean isComplete() {
+		return (this.id != null) && getName().isEmpty();
+	}
+
+	@Override
+	public String toString() {
+		return "GameProfile [id=" + id + ", name=" + name + ", properties=" + properties + ", legacy=" + legacy + "]";
+	}
+
+	public boolean isLegacy() {
+		return this.legacy;
+	}
+	public void setName(String name) {
+		this.name = name;
+	}
+	public void setId(UUID id) {
+		this.id = id;
+	}
+	public void setProperties(PropertyMap properties) {
+		this.properties = properties;
+	}
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/GameProfileSerializer.java b/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/GameProfileSerializer.java
new file mode 100644
index 0000000..8f14f9f
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/GameProfileSerializer.java
@@ -0,0 +1,97 @@
+package dev.wolveringer.BungeeUtil.gameprofile;
+
+
+import java.util.Iterator;
+import java.util.UUID;
+
+import dev.wolveringer.nbt.NBTTagCompound;
+import dev.wolveringer.nbt.NBTTagList;
+
+public class GameProfileSerializer {
+	@SuppressWarnings("rawtypes")
+	public static GameProfile deserialize(NBTTagCompound nbttagcompound) {
+		if(nbttagcompound == null)
+			return null;
+		String s = null;
+		String s1 = null;
+
+		if(nbttagcompound.hasKeyOfType("Name", 8)){
+			s = nbttagcompound.getString("Name");
+		}
+
+		if(nbttagcompound.hasKeyOfType("Id", 8)){
+			s1 = nbttagcompound.getString("Id");
+		}
+
+		UUID uuid;
+
+		try{
+			uuid = UUID.fromString(s1);
+		}catch (Throwable throwable){
+			uuid = null;
+		}
+		if(uuid == null && s==null)
+			return null;
+		GameProfile gameprofile = new GameProfile(uuid, s);
+
+		if(nbttagcompound.hasKeyOfType("Properties", 10)){
+			NBTTagCompound nbttagcompound1 = nbttagcompound.getCompound("Properties");
+			Iterator iterator = nbttagcompound1.dataKeyset().iterator();
+
+			while (iterator.hasNext()){
+				String s2 = (String) iterator.next();
+				NBTTagList nbttaglist = nbttagcompound1.getList(s2);
+
+				for(int i = 0;i < nbttaglist.size();++i){
+					NBTTagCompound nbttagcompound2 = nbttaglist.get(i);
+					String s3 = nbttagcompound2.getString("Value");
+
+					if(nbttagcompound2.hasKeyOfType("Signature", 8)){
+						gameprofile.getProperties().put(s2, new Property(s2, s3, nbttagcompound2.getString("Signature")));
+					}else{
+						gameprofile.getProperties().put(s2, new Property(s2, s3));
+					}
+				}
+			}
+		}
+
+		return gameprofile;
+	}
+
+	@SuppressWarnings("rawtypes")
+	public static NBTTagCompound serialize(NBTTagCompound nbttagcompound, GameProfile gameprofile) {
+		if(gameprofile == null)
+			return nbttagcompound;
+		if(gameprofile.getName() != null && !gameprofile.getName().isEmpty())
+			nbttagcompound.setString("Name", gameprofile.getName());
+		if(gameprofile.getId() != null)
+			nbttagcompound.setString("Id", gameprofile.getId().toString());
+
+		if(!gameprofile.getProperties().isEmpty()){
+			NBTTagCompound nbttagcompound1 = new NBTTagCompound();
+			Iterator iterator = gameprofile.getProperties().keySet().iterator();
+
+			while (iterator.hasNext()){
+				String s = (String) iterator.next();
+				NBTTagList nbttaglist = new NBTTagList();
+
+				NBTTagCompound nbttagcompound2;
+
+				for(Iterator iterator1 = gameprofile.getProperties().get(s).iterator();iterator1.hasNext();nbttaglist.add(nbttagcompound2)){
+					Property property = (Property) iterator1.next();
+
+					nbttagcompound2 = new NBTTagCompound();
+					nbttagcompound2.setString("Value", property.getValue());
+					if(property.hasSignature()){
+						nbttagcompound2.setString("Signature", property.getSignature());
+					}
+				}
+
+				nbttagcompound1.set(s, nbttaglist);
+			}
+
+			nbttagcompound.set("Properties", nbttagcompound1);
+		}
+		return nbttagcompound;
+	}
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/PlayerInfoData.java b/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/PlayerInfoData.java
new file mode 100644
index 0000000..d1874f5
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/PlayerInfoData.java
@@ -0,0 +1,67 @@
+package dev.wolveringer.BungeeUtil.gameprofile;
+
+import dev.wolveringer.chat.ChatSerializer;
+import dev.wolveringer.chat.IChatBaseComponent;
+
+public class PlayerInfoData {
+	private int ping;
+	private int gamemode;
+	private GameProfile gameprofile;
+	private IChatBaseComponent name;
+	private String username;
+	
+	public PlayerInfoData(GameProfile gameprofile, int ping, int gamemode, IChatBaseComponent tab) {
+		this.gameprofile = gameprofile;
+		this.ping = ping;
+		this.gamemode = gamemode;
+		this.name = tab;
+		this.username = gameprofile.getName();
+	}
+
+	public PlayerInfoData(GameProfile gameprofile, int ping, int gamemode2, String tab) {
+		this.gameprofile = gameprofile;
+		this.ping = ping;
+		this.gamemode = gamemode2;
+		this.username = tab;
+	}
+
+	public int getPing() {
+		return ping;
+	}
+
+	public int getGamemode() {
+		return gamemode;
+	}
+
+	public GameProfile getGameprofile() {
+		return gameprofile;
+	}
+
+	public IChatBaseComponent getName() {
+		return name;
+	}
+	
+	public void setPing(int b) {
+		this.ping = b;
+	}
+
+	public void setGamemode(int gamemode) {
+		this.gamemode = gamemode;
+	}
+
+	public void setGameprofile(GameProfile gameprofile) {
+		this.gameprofile = gameprofile;
+	}
+
+	public void setName(IChatBaseComponent name) {
+		this.name = name;
+	}
+
+	@Override
+	public String toString() {
+		return "PlayerInfoData [b=" + ping + ", gamemode=" + gamemode + ", gameprofile=" + gameprofile + ", name=" + ChatSerializer.toMessage(name) + "]";
+	}
+	public String getUsername() {
+		return username;
+	}
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/Property.java b/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/Property.java
new file mode 100644
index 0000000..0c5832d
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/Property.java
@@ -0,0 +1,38 @@
+package dev.wolveringer.BungeeUtil.gameprofile;
+
+public class Property {
+	private final String name;
+	private final String value;
+	private final String signature;
+
+	public Property(String value, String name) {
+		this(value, name, null);
+	}
+
+	public Property(String name, String value, String signature) {
+		this.name = name;
+		this.value = value;
+		this.signature = signature;
+	}
+
+	public String getName() {
+		return this.name;
+	}
+
+	public String getValue() {
+		return this.value;
+	}
+
+	public String getSignature() {
+		return this.signature;
+	}
+
+	public boolean hasSignature() {
+		return this.signature != null;
+	}
+
+	@Override
+	public String toString() {
+		return "Property@" + System.identityHashCode(this) + "[name=" + this.name + ", value=" + this.value + ", signature=" + this.signature + "]";
+	}
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/PropertyMap.java b/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/PropertyMap.java
new file mode 100644
index 0000000..5dea4a2
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/PropertyMap.java
@@ -0,0 +1,83 @@
+package dev.wolveringer.BungeeUtil.gameprofile;
+
+import java.lang.reflect.Type;
+import java.util.Iterator;
+import java.util.Map;
+
+import com.google.common.collect.ForwardingMultimap;
+import com.google.common.collect.LinkedHashMultimap;
+import com.google.common.collect.Multimap;
+import com.google.gson.JsonArray;
+import com.google.gson.JsonDeserializationContext;
+import com.google.gson.JsonDeserializer;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import com.google.gson.JsonParseException;
+import com.google.gson.JsonSerializationContext;
+import com.google.gson.JsonSerializer;
+
+public class PropertyMap extends ForwardingMultimap<String, Property> {
+	private final Multimap<String, Property> properties;
+
+	public PropertyMap() {
+		this.properties = LinkedHashMultimap.create();
+	}
+
+	protected Multimap<String, Property> delegate() {
+		return this.properties;
+	}
+
+	public static class Serializer implements JsonSerializer<PropertyMap>, JsonDeserializer<PropertyMap> {
+		@SuppressWarnings({ "rawtypes", "unchecked" })
+		public PropertyMap deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {
+			PropertyMap result = new PropertyMap();
+			Iterator i$;
+			Map.Entry<String, JsonElement> entry;
+			if((json instanceof JsonObject)){
+				JsonObject object = (JsonObject) json;
+				for(i$ = object.entrySet().iterator();i$.hasNext();){
+					entry = (Map.Entry) i$.next();
+					if((entry.getValue() instanceof JsonArray)){
+						for(JsonElement element : (JsonArray) entry.getValue()){
+							result.put(entry.getKey(), new Property((String) entry.getKey(), element.getAsString()));
+						}
+					}
+				}
+			}else if((json instanceof JsonArray)){
+				for(JsonElement element : (JsonArray) json){
+					if((element instanceof JsonObject)){
+						JsonObject object = (JsonObject) element;
+						String name = object.getAsJsonPrimitive("name").getAsString();
+						String value = object.getAsJsonPrimitive("value").getAsString();
+						if(object.has("signature")){
+							result.put(name, new Property(name, value, object.getAsJsonPrimitive("signature").getAsString()));
+						}else{
+							result.put(name, new Property(name, value));
+						}
+					}
+				}
+			}
+			return result;
+		}
+
+		public JsonElement serialize(PropertyMap src, Type typeOfSrc, JsonSerializationContext context) {
+			JsonArray result = new JsonArray();
+			for(Property property : src.values()){
+				JsonObject object = new JsonObject();
+
+				object.addProperty("name", property.getName());
+				object.addProperty("value", property.getValue());
+				if(property.hasSignature()){
+					object.addProperty("signature", property.getSignature());
+				}
+				result.add(object);
+			}
+			return result;
+		}
+	}
+
+	@Override
+	public String toString() {
+		return "PropertyMap@" + System.identityHashCode(this) + "[properties=" + this.properties + "]";
+	}
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/Skin.java b/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/Skin.java
new file mode 100644
index 0000000..4d19fb4
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/Skin.java
@@ -0,0 +1,224 @@
+package dev.wolveringer.BungeeUtil.gameprofile;
+
+import java.util.UUID;
+
+import org.json.JSONArray;
+import org.json.JSONML;
+import org.json.JSONObject;
+import org.yaml.snakeyaml.external.biz.base64Coder.Base64Coder;
+
+public class Skin {
+	protected static Skin createEmptySkin() {
+		Skin s = new Skin();
+		s.name = "";
+		s.raw_value = "";
+		s.signature = "";
+		s.value = new JSONObject();
+		s.updateRaw();
+		return s;
+	}
+
+	private String name = "textures";
+	private String raw_value;
+	private String signature;
+	private boolean empty = false;
+
+	private JSONObject value;
+
+	private Skin() {
+		empty = true;
+	}
+
+	protected Skin(JSONObject raw_profile) {
+		try {
+			if (raw_profile.has("properties")) {
+				JSONArray properties = (JSONArray) raw_profile.get("properties");
+				for (int i = 0; i < properties.length(); i++) { //TODO size == 1 ?????
+					JSONObject property = (JSONObject) properties.get(i);
+					name = (String) property.get("name");
+					raw_value = (String) property.get("value");
+					signature = (String) property.get("signature");
+				}
+			}
+			if (raw_value != null)
+				value = new JSONObject(Base64Coder.decodeString(raw_value));
+			else
+				value = new JSONObject();
+			empty = false;
+		} catch (Exception e) {
+			e.printStackTrace();
+			empty = true;
+		}
+		
+	}
+
+	protected Skin(String rawValue, String signature) {
+		try {
+			if (rawValue == null || rawValue.equalsIgnoreCase("undefined") || Base64Coder.decodeString(rawValue) == null) {
+				rawValue = Base64Coder.encodeString("{}");
+			}
+		} catch (IllegalArgumentException ex) {
+			rawValue = Base64Coder.encodeString("{}");
+		}
+		this.raw_value = rawValue;
+		this.value = new JSONObject(Base64Coder.decodeString(raw_value));
+		if (!signature.equalsIgnoreCase("undefined"))
+			this.signature = signature;
+	}
+
+	public GameProfile applay(GameProfile g) {
+		if (g.getId() == null)
+			g.setId(getUUID());
+		if (g.getName() == null)
+			g.setName(getProfileName());
+		g.getProperties().clear();
+		g.getProperties().put(name, new Property(name, raw_value, isSignatureRequired() ? signature : null));
+		return g;
+	}
+
+	public String getSkinUrl() {
+		if (hasSkin())
+			return value.getJSONObject("textures").getJSONObject("SKIN").getString("url");
+		return null;
+	}
+
+	public void setSkin(String url) {
+		empty = false;
+		if (!value.has("textures"))
+			value.put("value", new JSONObject());
+		if (!value.getJSONObject("textures").has("SKIN"))
+			value.getJSONObject("textures").put("SKIN", new JSONObject());
+		value.getJSONObject("textures").getJSONObject("SKIN").put("url", url);
+		updateRaw();
+	}
+
+	public boolean hasSkin() {
+		return value.has("textures") && value.getJSONObject("textures").has("SKIN") && value.getJSONObject("textures").getJSONObject("SKIN").has("url");
+	}
+
+	public void setCape(String url) {
+		empty = false;
+		if (!value.has("textures"))
+			value.put("value", new JSONObject());
+		if (!value.getJSONObject("textures").has("CAPE"))
+			value.getJSONObject("textures").put("CAPE", new JSONObject());
+		value.getJSONObject("textures").getJSONObject("CAPE").put("url", url);
+		updateRaw();
+	}
+
+	public String getCapeUrl() {
+		if (hasCape())
+			return value.getJSONObject("textures").getJSONObject("CAPE").getString("url");
+		return null;
+	}
+
+	public boolean hasCape() {
+		return value.has("textures") && value.getJSONObject("textures").has("CAPE") && value.getJSONObject("textures").getJSONObject("CAPE").has("url");
+	}
+
+	public UUID getUUID() {
+		return UUID.fromString(value.getString("profileId").replaceFirst("([0-9a-fA-F]{8})([0-9a-fA-F]{4})([0-9a-fA-F]{4})([0-9a-fA-F]{4})([0-9a-fA-F]+)", "$1-$2-$3-$4-$5"));
+	}
+
+	public void setUUID(UUID id) {
+		empty = false;
+		value.put("profileId", id.toString().replaceAll("-", ""));
+		updateRaw();
+	}
+
+	public boolean hasUUID() {
+		return value.has("profileId");
+	}
+
+	public String getProfileName() {
+		if (!hasProfileName())
+			return "undef";
+		return value.getString("profileName");
+	}
+
+	public boolean hasProfileName() {
+		return value.has("profileName");
+	}
+
+	public void setProfileName(String name) {
+		empty = false;
+		value.put("profileName", name);
+		updateRaw();
+	}
+
+	public boolean isPublic() {
+		return value.getBoolean("isPublic");
+	}
+
+	public void setPublic(boolean b) {
+		empty = false;
+		value.put("isPublic", b);
+		updateRaw();
+	}
+
+	public boolean isEmpty() {
+		return empty;
+	}
+
+	private void updateRaw() {
+		raw_value = Base64Coder.encodeString(value.toString());
+	}
+
+	public GameProfile toGameProfile() {
+		try {
+			return applay(new GameProfile(getUUID(), getProfileName()));
+		} catch (Exception e) {
+			return null;
+		}
+	}
+
+	public void setSignatureRequired(boolean flag) {
+		empty = false;
+		value.put("signatureRequired", flag);
+		updateRaw();
+
+	}
+
+	public boolean isSignatureRequired() {
+		return value.has("signatureRequired") && value.getBoolean("signatureRequired");
+	}
+
+	public String getSignature() {
+		if (signature == null)
+			return "undefined";
+		return signature;
+	}
+
+	public void setSignature(String signature) {
+		this.signature = signature;
+		empty = false;
+	}
+
+	public void setRawData(String string) {
+		this.raw_value = string;
+		this.value = new JSONObject(Base64Coder.decodeString(raw_value));
+	}
+
+	public String getRawData() {
+		return raw_value;
+	}
+
+	public Skin clone() {
+		Skin _new = new Skin();
+		_new.empty = empty;
+		_new.name = name;
+		_new.raw_value = raw_value;
+		_new.signature = signature;
+		_new.value = value;
+		return _new;
+	}
+
+	public String getName() {
+		return name;
+	}
+
+	@Override
+	public String toString() {
+		return value.toString();
+	}
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/SkinCache.java b/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/SkinCache.java
new file mode 100644
index 0000000..d6cbf2a
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/SkinCache.java
@@ -0,0 +1,92 @@
+package dev.wolveringer.BungeeUtil.gameprofile;
+
+import java.io.IOException;
+import java.net.URL;
+import java.util.UUID;
+import java.util.concurrent.TimeUnit;
+import java.util.logging.Level;
+
+import net.md_5.bungee.BungeeCord;
+
+import org.json.JSONObject;
+
+import com.google.common.cache.CacheBuilder;
+import com.google.common.cache.CacheLoader;
+import com.google.common.cache.LoadingCache;
+
+import dev.wolveringer.BungeeUtil.BungeeUtil;
+import dev.wolveringer.BungeeUtil.Main;
+import dev.wolveringer.BungeeUtil.OperationCalback;
+
+public class SkinCache {
+	private static final String PROFILE_URL = "https://sessionserver.mojang.com/session/minecraft/profile/";
+
+	private static LoadingCache<UUID, Skin> profileCache = CacheBuilder.newBuilder().maximumSize(500).expireAfterWrite(4, TimeUnit.HOURS).build(new CacheLoader<UUID, Skin>() {
+		public Skin load(UUID name) throws Exception {
+			return loadSkin(name);
+		};
+	});
+
+	@Deprecated
+	public static Skin getSkin(UUID uuid) {
+		if(uuid == null)
+			throw new IllegalArgumentException("UUID cant be null");
+		try{
+			return profileCache.get(uuid);
+		}catch (Exception e){
+			BungeeCord.getInstance().getLogger().log(Level.WARNING, "Cant loading Skin for " + uuid + " (Reson: " + e.getMessage() + ")");
+			return Skin.createEmptySkin();
+		}
+	}
+
+	@SuppressWarnings("unchecked")
+	public static void getSkin(final UUID uuid, final OperationCalback<Skin>... c) {
+		BungeeCord.getInstance().getScheduler().runAsync(BungeeUtil.getPluginInstance(), new Runnable() {
+			@SuppressWarnings({ "rawtypes" })
+			@Override
+			public void run() {
+				Skin s = getSkin(uuid);
+				for(OperationCalback t : c)
+					t.done(s);
+			}
+		});
+	}
+	
+	@Deprecated
+	public static Skin getSkin(String name) {
+		try{
+			return getSkin(UUIDFetcher.getUUIDOf(name));
+		}catch (Exception e){
+			e.printStackTrace();
+		}
+		return Skin.createEmptySkin();
+	}
+	
+	@SuppressWarnings("unchecked")
+	public static void getSkin(final String name, final OperationCalback<Skin>... c) {
+		BungeeCord.getInstance().getScheduler().runAsync(BungeeUtil.getPluginInstance(), new Runnable() {
+			@SuppressWarnings({ "rawtypes" })
+			@Override
+			public void run() {
+				Skin s = getSkin(name);
+				for(OperationCalback t : c)
+					t.done(s);
+			}
+		});
+	}
+
+	private static Skin loadSkin(UUID uuid) throws IOException {
+		String s = new SkinRequest().performGetRequest(new URL(PROFILE_URL + uuid.toString().replace("-", "") + "?unsigned=false"));
+		if("".equalsIgnoreCase(s) || s == null)
+			throw new IOException("Player skin not found (" + uuid + ")");
+		return new Skin(new JSONObject(s));
+	}
+	
+	public static void main(String[] args) {
+		Skin s = Skin.createEmptySkin();
+		s.setRawData("eyJ0ZXh0dXJlcyI6eyJTS0lOIjp7InVybCI6Imh0dHA6Ly90ZXh0dXJlcy5taW5lY3JhZnQubmV0L3RleHR1cmUvMjdiYmQwYjI5MTFjOTZiNWQ4N2IyZGY3NjY5MWE1MWI4YjEyYzZmZWZkNTIzMTQ2ZDhhYzVlZjFiOGVlIn19fQ==");
+		s.setSkin(SkinCache.getSkin("WolverinEN").getSkinUrl());
+		s.setUUID(UUID.randomUUID());
+		System.out.print(s.getRawData());
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/SkinFactory.java b/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/SkinFactory.java
new file mode 100644
index 0000000..12cea60
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/SkinFactory.java
@@ -0,0 +1,122 @@
+package dev.wolveringer.BungeeUtil.gameprofile;
+
+import java.io.IOException;
+import java.net.URL;
+import java.util.UUID;
+import java.util.concurrent.TimeUnit;
+import java.util.logging.Level;
+
+import net.md_5.bungee.BungeeCord;
+
+import org.json.JSONArray;
+import org.json.JSONObject;
+
+import com.google.common.cache.CacheBuilder;
+import com.google.common.cache.CacheLoader;
+import com.google.common.cache.LoadingCache;
+
+import dev.wolveringer.BungeeUtil.BungeeUtil;
+import dev.wolveringer.BungeeUtil.Main;
+import dev.wolveringer.BungeeUtil.OperationCalback;
+
+public class SkinFactory {
+	private static final String PROFILE_URL = "https://sessionserver.mojang.com/session/minecraft/profile/";
+
+	private static LoadingCache<UUID, Skin> profileCache = CacheBuilder.newBuilder().maximumSize(500).expireAfterWrite(4, TimeUnit.HOURS).build(new CacheLoader<UUID, Skin>() {
+		public Skin load(UUID name) throws Exception {
+			Skin skin = new SteveSkin();
+			try{
+				skin = loadSkin(name);
+			}catch(Exception e){
+				e.printStackTrace();
+			}
+			return skin;
+		};
+	});
+
+	@Deprecated
+	public static Skin getSkin(UUID uuid) {
+		if(uuid == null)
+			throw new IllegalArgumentException("UUID cant be null");
+		try{
+			Skin s = profileCache.get(uuid);
+			if(s instanceof SteveSkin){
+				profileCache.refresh(uuid);
+				s = profileCache.get(uuid);
+			}
+			return s.clone();
+		}catch (Exception e){
+			BungeeCord.getInstance().getLogger().log(Level.WARNING, "Cant loading Skin for " + uuid + " (Reson: " + e.getMessage() + ")");
+			return Skin.createEmptySkin();
+		}
+	}
+
+	@SuppressWarnings("unchecked")
+	public static void getSkin(final UUID uuid, final OperationCalback<Skin>... c) {
+		BungeeCord.getInstance().getScheduler().runAsync(BungeeUtil.getPluginInstance(), new Runnable() {
+			@SuppressWarnings({ "rawtypes" })
+			@Override
+			public void run() {
+				Skin s = getSkin(uuid);
+				for(OperationCalback t : c)
+					t.done(s);
+			}
+		});
+	}
+	
+	public static Skin createEmptySkin(){
+		return Skin.createEmptySkin();
+	}
+	
+	public static Skin createSkin(String rawValue,String signature){
+		JSONObject o = new JSONObject();
+		JSONArray props = new JSONArray();
+		JSONObject prop = new JSONObject();
+		prop.put("name", "textures");
+		prop.put("value", rawValue);
+		prop.put("signature", signature);
+		props.put(prop);
+		o.put("properties", props);
+		return new Skin(o);
+	}
+	
+	@Deprecated
+	public static Skin getSkin(String name) {
+		try{
+			return getSkin(UUIDFetcher.getUUIDOf(name));
+		}catch (Exception e){
+			e.printStackTrace();
+		}
+		return Skin.createEmptySkin();
+	}
+	
+	@SuppressWarnings("unchecked")
+	public static void getSkin(final String name, final OperationCalback<Skin>... c) {
+		BungeeCord.getInstance().getScheduler().runAsync(BungeeUtil.getPluginInstance(), new Runnable() {
+			@SuppressWarnings({ "rawtypes" })
+			@Override
+			public void run() {
+				Skin s = getSkin(name);
+				for(OperationCalback t : c)
+					t.done(s);
+			}
+		});
+	}
+
+	private static Skin loadSkin(UUID uuid) throws IOException {
+		String s = new SkinRequest().performGetRequest(new URL(PROFILE_URL + uuid.toString().replace("-", "") + "?unsigned=false"));
+		if("".equalsIgnoreCase(s) || s == null){
+			throw new NullPointerException("Player skin not found (" + uuid + ")");
+		}
+		return new Skin(new JSONObject(s));
+	}
+	
+	public static void main(String[] args) {
+		Skin s = Skin.createEmptySkin();
+		s.setRawData("eyJ0ZXh0dXJlcyI6eyJTS0lOIjp7InVybCI6Imh0dHA6Ly90ZXh0dXJlcy5taW5lY3JhZnQubmV0L3RleHR1cmUvMjdiYmQwYjI5MTFjOTZiNWQ4N2IyZGY3NjY5MWE1MWI4YjEyYzZmZWZkNTIzMTQ2ZDhhYzVlZjFiOGVlIn19fQ==");
+		s.setSkin(SkinFactory.getSkin("WolverinEN").getSkinUrl());
+		s.setUUID(UUID.randomUUID());
+		
+		System.out.print(s.getRawData());
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/SkinRequest.java b/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/SkinRequest.java
new file mode 100644
index 0000000..c21df04
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/SkinRequest.java
@@ -0,0 +1,46 @@
+package dev.wolveringer.BungeeUtil.gameprofile;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.HttpURLConnection;
+import java.net.URL;
+
+import org.apache.commons.io.IOUtils;
+
+import com.google.common.base.Charsets;
+
+public class SkinRequest {
+	public String performGetRequest(URL url) throws IOException {
+		HttpURLConnection connection = createUrlConnection(url);
+
+		InputStream inputStream = null;
+		try{
+			inputStream = connection.getInputStream();
+			String result = IOUtils.toString(inputStream, Charsets.UTF_8);
+			return result;
+		}catch (IOException e){
+			IOUtils.closeQuietly(inputStream);
+			inputStream = connection.getErrorStream();
+			if(inputStream != null){
+				String result = IOUtils.toString(inputStream, Charsets.UTF_8);
+				return result;
+			}
+			throw e;
+		}finally{
+			IOUtils.closeQuietly(inputStream);
+		}
+	}
+
+	protected HttpURLConnection createUrlConnection(URL url) throws IOException {
+		HttpURLConnection connection = (HttpURLConnection) url.openConnection();
+		connection.setConnectTimeout(2000);
+		connection.setReadTimeout(2000);
+		connection.setUseCaches(false);
+		connection.setRequestMethod("GET");
+		connection.setDefaultUseCaches(false);
+		connection.addRequestProperty("User-Agent", "Mozilla/5.0");
+		connection.addRequestProperty("Cache-Control", "no-cache, no-store, must-revalidate");
+		connection.addRequestProperty("Pragma", "no-cache");
+		return connection;
+	}
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/SteveSkin.java b/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/SteveSkin.java
new file mode 100644
index 0000000..5c4e1f0
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/SteveSkin.java
@@ -0,0 +1,100 @@
+package dev.wolveringer.BungeeUtil.gameprofile;
+
+import java.util.UUID;
+
+import org.json.JSONObject;
+
+public class SteveSkin extends Skin{
+
+	public SteveSkin() {
+		super(new JSONObject());
+	}
+	
+	@Override
+	public GameProfile applay(GameProfile g) {
+		return g;
+	}
+	
+	@Override
+	public String getCapeUrl() {
+		return "";
+	}
+	
+	@Override
+	public String getProfileName() {
+		return "Steve";
+	}
+
+	@Override
+	public String getRawData() {
+		return "undefined";
+	}
+	
+	@Override
+	public String getSignature() {
+		return "undefined";
+	}
+	
+	@Override
+	public String getSkinUrl() {
+		return "";
+	}
+	
+	@Override
+	public UUID getUUID() {
+		return UUID.nameUUIDFromBytes("Steve".getBytes());
+	}
+	
+	@Override
+	public boolean hasSkin() {
+		return false;
+	}
+	@Override
+	public boolean hasCape() {
+		return false;
+	}
+	@Override
+	public boolean hasProfileName() {
+		return true;
+	}
+	@Override
+	public boolean hasUUID() {
+		return false;
+	}
+	@Override
+	public boolean isEmpty() {
+		return true;
+	}
+	@Override
+	public boolean isPublic() {
+		return false;
+	}
+	@Override
+	public boolean isSignatureRequired() {
+		return false;
+	}
+	@Override
+	public void setCape(String url) {}
+	@Override
+	public void setProfileName(String name) {}
+	@Override
+	public void setPublic(boolean b) {}
+	@Override
+	public void setRawData(String string) {}
+	@Override
+	public void setSignature(String signature) {}
+	@Override
+	public void setSignatureRequired(boolean flag) {}
+	@Override
+	public void setSkin(String url) {}
+	@Override
+	public void setUUID(UUID id) {}
+	@Override
+	public GameProfile toGameProfile() {
+		return new GameProfile(getUUID(), getProfileName());
+	}
+	@Override
+	public String toString() {
+		return "Skin[Owner=Steve]";
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/Test.java b/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/Test.java
new file mode 100644
index 0000000..9741c71
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/Test.java
@@ -0,0 +1,12 @@
+package dev.wolveringer.BungeeUtil.gameprofile;
+
+import java.util.UUID;
+
+public class Test {
+	public static void main(String[] args) throws Exception {
+		UUID uuid = UUIDFetcher.getUUIDOf("WolverinDEV");
+		System.out.println("UUID: "+uuid);
+		Skin skin = SkinCache.getSkin(uuid);
+		System.out.println(skin);
+	}
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/UUIDFetcher.java b/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/UUIDFetcher.java
new file mode 100644
index 0000000..694eba2
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/UUIDFetcher.java
@@ -0,0 +1,116 @@
+package dev.wolveringer.BungeeUtil.gameprofile;
+
+import java.io.InputStreamReader;
+import java.io.OutputStream;
+import java.net.HttpURLConnection;
+import java.net.URL;
+import java.nio.ByteBuffer;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.UUID;
+import java.util.concurrent.Callable;
+import java.util.concurrent.TimeUnit;
+
+import org.json.JSONArray;
+
+import com.google.common.cache.CacheBuilder;
+import com.google.common.cache.CacheLoader;
+import com.google.common.cache.LoadingCache;
+import com.google.common.collect.ImmutableList;
+import com.google.gson.JsonArray;
+import com.google.gson.JsonObject;
+import com.google.gson.JsonParser;
+
+public class UUIDFetcher implements Callable<Map<String, UUID>> {
+	
+	private static LoadingCache<String, UUID> uuidCache = CacheBuilder.newBuilder().maximumSize(500).expireAfterWrite(4, TimeUnit.HOURS).build(new CacheLoader<String, UUID>() {
+		public UUID load(String name) throws Exception {
+			return new UUIDFetcher(Arrays.asList(name)).call().get(name);
+		};
+	});
+	
+    private static final double PROFILES_PER_REQUEST = 100;
+    private static final String PROFILE_URL = "https://api.mojang.com/profiles/minecraft";
+    private final JsonParser jsonParser = new JsonParser();
+    private final List<String> names;
+    private final boolean rateLimiting;
+ 
+    public UUIDFetcher(List<String> names, boolean rateLimiting) {
+        this.names = ImmutableList.copyOf(names);
+        this.rateLimiting = rateLimiting;
+    }
+ 
+    public UUIDFetcher(List<String> names) {
+        this(names, true);
+    }
+ 
+    public Map<String, UUID> call() throws Exception {
+        Map<String, UUID> uuidMap = new HashMap<String, UUID>();
+        int requests = (int) Math.ceil(names.size() / PROFILES_PER_REQUEST);
+        for (int i = 0; i < requests; i++) {
+            HttpURLConnection connection = createConnection();
+            JSONArray obj = new JSONArray();
+            for(String s : names.subList(i * 100, Math.min((i + 1) * 100, names.size())))
+            	obj.put(s);
+            String body = obj.toString();
+            writeBody(connection, body);
+            JsonArray array = (JsonArray) jsonParser.parse(new InputStreamReader(connection.getInputStream()));
+            for (Object profile : array) {
+            	JsonObject jsonProfile = (JsonObject) profile;
+                String id = (String) jsonProfile.get("id").getAsString();
+                String name = (String) jsonProfile.get("name").getAsString();
+                UUID uuid = UUIDFetcher.getUUID(id);
+                uuidMap.put(name, uuid);
+            }
+            if (rateLimiting && i != requests - 1) {
+                Thread.sleep(100L);
+            }
+        }
+        return uuidMap;
+    }
+ 
+    private static void writeBody(HttpURLConnection connection, String body) throws Exception {
+        OutputStream stream = connection.getOutputStream();
+        stream.write(body.getBytes());
+        stream.flush();
+        stream.close();
+    }
+ 
+    private static HttpURLConnection createConnection() throws Exception {
+        URL url = new URL(PROFILE_URL);
+        HttpURLConnection connection = (HttpURLConnection) url.openConnection();
+        connection.setRequestMethod("POST");
+        connection.setRequestProperty("Content-Type", "application/json");
+        connection.setUseCaches(false);
+        connection.setDoInput(true);
+        connection.setDoOutput(true);
+        return connection;
+    }
+ 
+    private static UUID getUUID(String id) {
+        return UUID.fromString(id.substring(0, 8) + "-" + id.substring(8, 12) + "-" + id.substring(12, 16) + "-" + id.substring(16, 20) + "-" +id.substring(20, 32));
+    }
+ 
+    public static byte[] toBytes(UUID uuid) {
+        ByteBuffer byteBuffer = ByteBuffer.wrap(new byte[16]);
+        byteBuffer.putLong(uuid.getMostSignificantBits());
+        byteBuffer.putLong(uuid.getLeastSignificantBits());
+        return byteBuffer.array();
+    }
+ 
+    public static UUID fromBytes(byte[] array) {
+        if (array.length != 16) {
+            throw new IllegalArgumentException("Illegal byte array length: " + array.length);
+        }
+        ByteBuffer byteBuffer = ByteBuffer.wrap(array);
+        long mostSignificant = byteBuffer.getLong();
+        long leastSignificant = byteBuffer.getLong();
+        return new UUID(mostSignificant, leastSignificant);
+    }
+ 
+    public static UUID getUUIDOf(String name) throws Exception {
+        return uuidCache.get(name);
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/injector/InjectFiles.java b/src/main/java/dev/wolveringer/BungeeUtil/injector/InjectFiles.java
new file mode 100644
index 0000000..6883ade
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/injector/InjectFiles.java
@@ -0,0 +1,119 @@
+package dev.wolveringer.BungeeUtil.injector;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.DataOutputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.lang.reflect.Modifier;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipInputStream;
+import java.util.zip.ZipOutputStream;
+
+import javassist.ClassPool;
+import javassist.CtClass;
+import net.md_5.bungee.BungeeCord;
+import net.md_5.bungee.UserConnection;
+import dev.wolveringer.BungeeUtil.BungeeUtil;
+import dev.wolveringer.BungeeUtil.Main;
+import dev.wolveringer.BungeeUtil.configuration.Configuration;
+import dev.wolveringer.chat.ChatColor.ChatColorUtils;
+
+public class InjectFiles {
+	public static int inject() {
+		try{
+			int modifier = UserConnection.class.getModifiers();
+
+			if(!Modifier.isFinal(modifier) && Modifier.isPublic(modifier)){
+				return -1;
+			}
+			BungeeUtil.getInstance().setInformation("\u00A7aInjection BungeeUtils. Please wait.");
+			BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR+"aStarting BungeeUtil injection.");
+			BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR+"aSet modifiers for class UserConnection.class to \"public\"");
+
+			String[] names = { "net.md_5.bungee.UserConnection.class" };
+			ClassPool cp = ClassPool.getDefault();
+			CtClass clazz = cp.getCtClass(UserConnection.class.getName());
+			clazz.setModifiers(Modifier.PUBLIC);
+			ByteArrayOutputStream bout;
+			DataOutputStream out = new DataOutputStream(bout = new ByteArrayOutputStream());
+			clazz.getClassFile().write(out);
+			InputStream[] streams = { new ByteArrayInputStream(bout.toByteArray()) };
+			File bungee_file = new File(BungeeCord.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath());
+			updateZipFile(bungee_file, names, streams);
+			return 1;
+		}catch (Exception e){
+			e.printStackTrace();
+		}
+		return 0;
+	}
+	
+	public static boolean isInjected(){
+		return !Modifier.isFinal(UserConnection.class.getModifiers()) && Modifier.isPublic(UserConnection.class.getModifiers());
+	}
+
+	private static void updateZipFile(File zipFile, String[] names, InputStream[] ins) throws IOException {
+		File tempFile = File.createTempFile(zipFile.getName(), null);
+		if(!tempFile.delete())
+			BungeeUtil.getInstance().sendMessage("Warn: Cant delte temp file.");
+		if(tempFile.exists())
+			BungeeUtil.getInstance().sendMessage("Warn: Temp target file alredy exist!");
+		if(!zipFile.exists())
+			throw new RuntimeException("Could not rename the file " + zipFile.getAbsolutePath() + " to " + tempFile.getAbsolutePath()+" (Src. not found!)");
+		int renameOk = zipFile.renameTo(tempFile)?1:0;
+		if(renameOk==0){
+			tempFile = new File(zipFile.toString()+".copy");
+			com.google.common.io.Files.copy(zipFile, tempFile);
+			renameOk = 2;
+			if(zipFile.delete()){
+				BungeeUtil.getInstance().sendMessage("Warn: Src file cant delete.");
+				renameOk = -1;
+			}
+		}
+		if(renameOk == 0)
+			throw new RuntimeException("Could not rename the file " + zipFile.getAbsolutePath() + " to " + tempFile.getAbsolutePath()+" (Directory read only? (Temp:[R:"+(tempFile.canRead()?1:0)+";W:"+(tempFile.canWrite()?1:0)+",D:"+(tempFile.canExecute()?1:0)+"],Src:[R:"+(zipFile.canRead()?1:0)+";W:"+(zipFile.canWrite()?1:0)+",D:"+(zipFile.canExecute()?1:0)+"]))");
+		if(renameOk != 1)
+			BungeeUtil.getInstance().sendMessage("Warn: Cant create temp file. Use .copy file");
+		byte[] buf = new byte[Configuration.getLoadingBufferSize()];
+		BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR+"aBuffer size: "+ChatColorUtils.COLOR_CHAR+"e"+buf.length);
+		ZipInputStream zin = new ZipInputStream(new FileInputStream(tempFile));
+		ZipOutputStream out = new ZipOutputStream(new FileOutputStream(zipFile));
+
+		ZipEntry entry = zin.getNextEntry();
+		while (entry != null){
+			String path_name = entry.getName().replaceAll("/", "\\.");
+			boolean notReplace = true;
+			for(String f : names)
+				if(f.equals(path_name)){
+					notReplace = false;
+					break;
+				}
+			if(notReplace){
+				out.putNextEntry(new ZipEntry(entry.getName()));
+				int len;
+				while ((len = zin.read(buf)) > 0)
+					out.write(buf, 0, len);
+			}
+			entry = zin.getNextEntry();
+		}
+		zin.close();
+		for(int i = 0;i < names.length;i++){
+			InputStream in = ins[i];
+			int index = names[i].lastIndexOf('.');
+			out.putNextEntry(new ZipEntry(names[i].substring(0, index).replaceAll("\\.", "/") + names[i].substring(index)));
+			int len;
+			while ((len = in.read(buf)) > 0)
+				out.write(buf, 0, len);
+			out.closeEntry();
+			in.close();
+		}
+		out.close();
+		tempFile.delete();
+		if(renameOk == -1){
+			System.exit(-1);
+		}
+	}
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/item/ClickListener.java b/src/main/java/dev/wolveringer/BungeeUtil/item/ClickListener.java
new file mode 100644
index 0000000..329d132
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/item/ClickListener.java
@@ -0,0 +1,7 @@
+package dev.wolveringer.BungeeUtil.item;
+
+import dev.wolveringer.BungeeUtil.item.ItemStack.Click;
+
+public interface ClickListener {
+	public void click(Click click);
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/item/Item.java b/src/main/java/dev/wolveringer/BungeeUtil/item/Item.java
new file mode 100644
index 0000000..eadc289
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/item/Item.java
@@ -0,0 +1,416 @@
+package dev.wolveringer.BungeeUtil.item;
+
+import java.util.LinkedHashMap;
+import java.util.Map;
+
+import dev.wolveringer.BungeeUtil.Material;
+import dev.wolveringer.BungeeUtil.MaterialData;
+import dev.wolveringer.BungeeUtil.item.itemmeta.ItemMeta;
+import dev.wolveringer.BungeeUtil.item.itemmeta.MetaFactory;
+import dev.wolveringer.configuration.serialization.ConfigurationSerializable;
+import dev.wolveringer.nbt.NBTTagCompound;
+
+public class Item{
+	/**
+	 * Required method for configuration serialization
+	 *
+	 * @param args
+	 *            map to deserialize
+	 * @return deserialized item stack
+	 * @see ConfigurationSerializable
+	 */
+	public static Item deserialize(Map<String, Object> args) {
+		Material type = Material.getMaterial((String) args.get("type"));
+		short damage = 0;
+		int amount = 1;
+
+		if(args.containsKey("damage")){
+			damage = ((Number) args.get("damage")).shortValue();
+		}
+
+		if(args.containsKey("amount")){
+			amount = (Integer) args.get("amount");
+		}
+
+		Item result = new Item(type, amount, damage);
+
+		if(args.containsKey("meta")){ // We cannot and will not have meta when enchantments (pre-ItemMeta) exist
+			Object raw = args.get("meta");
+			if(raw instanceof ItemMeta){
+				result.setTag(((ItemMeta) raw).getTag());
+			}
+		}
+
+		return result;
+	}
+
+	@SuppressWarnings("deprecation")
+	private static Material getType0(int id) {
+		Material material = Material.getMaterial(id);
+		return material == null ? Material.AIR : material;
+	}
+
+	private int amount = 0;
+	private MaterialData data = null;
+	private short durability = 0;
+	private ItemMeta meta;
+	private NBTTagCompound tag;
+	private int type = 0;
+
+	/**
+	 * Defaults stack size to 1, with no extra data
+	 *
+	 * @param type
+	 *            item material id
+	 * @deprecated Magic value
+	 */
+	@Deprecated
+	public Item(final int type) {
+		this(type, 1);
+	}
+
+	/**
+	 * An item stack with no extra data
+	 *
+	 * @param type
+	 *            item material id
+	 * @param amount
+	 *            stack size
+	 * @deprecated Magic value
+	 */
+	@Deprecated
+	public Item(final int type, final int amount) {
+		this(type, amount, (short) 0);
+	}
+
+	/**
+	 * An item stack with the specified damage / durability
+	 *
+	 * @param type
+	 *            item material id
+	 * @param amount
+	 *            stack size
+	 * @param damage
+	 *            durability / damage
+	 * @deprecated Magic value
+	 */
+	@Deprecated
+	public Item(final int type, final int amount, final short damage) {
+		this.type = type;
+		this.amount = amount;
+		this.durability = damage;
+		this.meta = MetaFactory.getItemMeta(this);
+	}
+
+	/**
+	 * @deprecated this method uses an ambiguous data byte object
+	 */
+	@Deprecated
+	public Item(final int type, final int amount, final short damage, final Byte data) {
+		this.type = type;
+		this.amount = amount;
+		this.durability = damage;
+		if(data != null){
+			createData(data);
+			this.durability = data;
+		}
+		this.meta = MetaFactory.getItemMeta(this);
+	}
+
+	/**
+	 * Creates a new item stack derived from the specified stack
+	 *
+	 * @param stack
+	 *            the stack to copy
+	 * @throws IllegalArgumentException
+	 *             if the specified stack is null or
+	 *             returns an item meta not created by the item factory
+	 */
+	public Item(final Item stack) throws IllegalArgumentException {
+		this.type = stack.getTypeId();
+		this.amount = stack.getAmount();
+		this.durability = stack.getDurability();
+		this.data = stack.getData();
+		this.tag = stack.tag;
+		this.meta = getItemMeta();
+	}
+
+	/**
+	 * Defaults stack size to 1, with no extra data
+	 *
+	 * @param type
+	 *            item material
+	 */
+	public Item(final Material type) {
+		this(type, 1);
+	}
+
+	/**
+	 * An item stack with no extra data
+	 *
+	 * @param type
+	 *            item material
+	 * @param amount
+	 *            stack size
+	 */
+	@SuppressWarnings("deprecation")
+	public Item(final Material type, final int amount) {
+		this(type.getId(), amount);
+	}
+
+	/**
+	 * An item stack with the specified damage / durabiltiy
+	 *
+	 * @param type
+	 *            item material
+	 * @param amount
+	 *            stack size
+	 * @param damage
+	 *            durability / damage
+	 */
+	@SuppressWarnings("deprecation")
+	public Item(final Material type, final int amount, final short damage) {
+		this((type == null ? Material.AIR : type).getId(), amount, damage);
+	}
+
+	/**
+	 * @deprecated this method uses an ambiguous data byte object
+	 */
+	@Deprecated
+	public Item(final Material type, final int amount, final short damage, final Byte data) {
+		this(type.getId(), amount, damage, data);
+	}
+
+	@SuppressWarnings("deprecation")
+	private void createData(final byte data) {
+		Material mat = Material.getMaterial(type);
+		if(mat == null){
+			this.data = new MaterialData(type, data);
+		}else{
+			this.data = new MaterialData(data);
+		}
+	}
+
+	@Override
+	public boolean equals(Object obj) {
+		if(this == obj){
+			return true;
+		}
+		if(!(obj instanceof Item)){
+			return false;
+		}
+
+		Item stack = (Item) obj;
+		return getAmount() == stack.getAmount() && isSimilar(stack);
+	}
+
+	/**
+	 * Gets the amount of items in this stack
+	 *
+	 * @return Amount of items in this stick
+	 */
+	public int getAmount() {
+		return amount;
+	}
+
+	/**
+	 * Gets the MaterialData for this stack of items
+	 *
+	 * @return MaterialData for this item
+	 */
+	public MaterialData getData() {
+		Material mat = getType();
+		if(data == null && mat != null){
+			data = new MaterialData(this.getDurability());
+		}
+
+		return data;
+	}
+
+	/**
+	 * Gets the durability of this item
+	 *
+	 * @return Durability of this item
+	 */
+	public short getDurability() {
+		return durability;
+	}
+
+	/**
+	 * Get a copy of this ItemStack's {@link ItemMeta}.
+	 *
+	 * @return a copy of the current ItemStack's ItemData
+	 */
+	public ItemMeta getItemMeta() {
+		return this.meta == null ? this.meta = MetaFactory.getItemMeta(this) : this.meta;
+	}
+
+	/**
+	 * Get the maximum stacksize for the material hold in this ItemStack.
+	 * (Returns -1 if it has no idea)
+	 *
+	 * @return The maximum you can stack this material to.
+	 */
+	public int getMaxStackSize() {
+		Material material = getType();
+		if(material != null){
+			return material.getMaxStackSize();
+		}
+		return -1;
+	}
+
+	public NBTTagCompound getTag() {
+		return tag;
+	}
+
+	/**
+	 * Gets the type of this item
+	 *
+	 * @return Type of the items in this stack
+	 */
+	public Material getType() {
+		return getType0(getTypeId());
+	}
+
+	/**
+	 * Gets the type id of this item
+	 *
+	 * @return Type Id of the items in this stack
+	 * @deprecated Magic value
+	 */
+	@Deprecated
+	public int getTypeId() {
+		return type;
+	}
+
+	@Override
+	public final int hashCode() {
+		int hash = 1;
+
+		hash = hash * 31 + getTypeId();
+		hash = hash * 31 + getAmount();
+		hash = hash * 31 + (getDurability() & 0xffff);
+		hash = hash * 31 + (hasItemMeta() ? meta == null ? getItemMeta().hashCode() : meta.hashCode() : 0);
+
+		return hash;
+	}
+
+	/**
+	 * Checks to see if any meta data has been defined.
+	 *
+	 * @return Returns true if some meta data has been set for this item
+	 */
+	public boolean hasItemMeta() {
+		return !MetaFactory.equals(meta, null);
+	}
+
+	/**
+	 * This method is the same as equals, but does not consider stack size
+	 * (amount).
+	 *
+	 * @param stack
+	 *            the item stack to compare to
+	 * @return true if the two stacks are equal, ignoring the amount
+	 */
+	public boolean isSimilar(Item stack) {
+		if(stack == null){
+			return false;
+		}
+		if(stack == this){
+			return true;
+		}
+		return getTypeId() == stack.getTypeId() && getDurability() == stack.getDurability() && MetaFactory.equals(getItemMeta(), stack.getItemMeta());
+	}
+
+	public Map<String, Object> serialize() {
+		Map<String, Object> result = new LinkedHashMap<String, Object>();
+
+		result.put("type", getType().name());
+
+		if(getDurability() != 0){
+			result.put("damage", getDurability());
+		}
+
+		if(getAmount() != 1){
+			result.put("amount", getAmount());
+		}
+
+		ItemMeta meta = getItemMeta();
+		if(!MetaFactory.equals(meta, null)){
+			result.put("meta", meta);
+		}
+		return result;
+	}
+
+	/**
+	 * Sets the amount of items in this stack
+	 *
+	 * @param amount
+	 *            New amount of items in this stack
+	 */
+	public void setAmount(int amount) {
+		this.amount = amount;
+	}
+
+	/**
+	 * Sets the MaterialData for this stack of items
+	 *
+	 * @param data
+	 *            New MaterialData for this item
+	 */
+	public void setData(MaterialData data) {
+		getType();
+		this.data = data;
+	}
+
+	/**
+	 * Sets the durability of this item
+	 *
+	 * @param durability
+	 *            Durability of this item
+	 */
+	public void setDurability(final short durability) {
+		this.durability = durability;
+	}
+
+	public void setTag(NBTTagCompound b) {
+		this.tag = b;
+	}
+
+	/**
+	 * Sets the type of this item
+	 * <p>
+	 * Note that in doing so you will reset the MaterialData for this stack
+	 *
+	 * @param type
+	 *            New type to set the items in this stack to
+	 */
+	@SuppressWarnings("deprecation")
+	public void setType(Material type) {
+		setTypeId(type.getId());
+	}
+
+	/**
+	 * Sets the type id of this item
+	 * <p>
+	 * Note that in doing so you will reset the MaterialData for this stack
+	 *
+	 * @param type
+	 *            New type id to set the items in this stack to
+	 * @deprecated Magic value
+	 */
+	@Deprecated
+	public void setTypeId(int type) {
+		this.type = type;
+		createData((byte) 0);
+	}
+
+	@Override
+	public String toString() {
+		return "Item@" + System.identityHashCode(this) + "[amount=" + amount + ", data=" + data + ", durability=" + durability + ", meta=" + meta + ", tag=" + tag + ", type=" + type + "]";
+	}
+
+	public boolean hasTag() {
+		return meta==null||meta.hasTag();
+	}
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/item/ItemBuilder.java b/src/main/java/dev/wolveringer/BungeeUtil/item/ItemBuilder.java
new file mode 100644
index 0000000..668bc39
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/item/ItemBuilder.java
@@ -0,0 +1,135 @@
+package dev.wolveringer.BungeeUtil.item;
+
+import java.util.ArrayList;
+
+import dev.wolveringer.BungeeUtil.Material;
+import dev.wolveringer.BungeeUtil.item.Item;
+import dev.wolveringer.BungeeUtil.item.ItemStack;
+import dev.wolveringer.BungeeUtil.item.ItemStack.Click;
+
+public class ItemBuilder {
+	public static ItemBuilder create() {
+		return new ItemBuilder();
+	}
+
+	public static ItemBuilder create(Material m) {
+		return create(m.getId());
+	}
+
+	public static ItemBuilder create(int id) {
+		return new ItemBuilder(id);
+	}
+
+	public static ItemBuilder create(Item handle) {
+		return new ItemBuilder(handle);
+	}
+
+	private int id;
+	private int sid = -1;
+	private int amouth = -1;
+	private String name;
+	private ArrayList<String> lore = new ArrayList<>();
+	private boolean glow;
+	private ClickListener listener;
+	private Item handle;
+
+	public ItemBuilder(int id) {
+		this.id = id;
+	}
+
+	public ItemBuilder(Item handle) {
+		this.handle = new Item(handle); //Copy
+	}
+
+	public ItemBuilder() {
+	}
+
+	public ItemBuilder name(String name) {
+		this.name = name;
+		return this;
+	}
+
+	public ItemBuilder lore(String lore) {
+		this.lore.add(lore);
+		return this;
+	}
+
+	public ItemBuilder glow() {
+		this.glow = true;
+		return this;
+	}
+
+	public ItemBuilder glow(boolean flag) {
+		this.glow = flag;
+		return this;
+	}
+
+	public ItemBuilder durbility(int short_) {
+		this.sid = short_;
+		return this;
+	}
+
+	public ItemBuilder amount(int n) {
+		this.amouth = n;
+		return this;
+	}
+
+	public ItemBuilder listener(ClickListener run) {
+		this.listener = run;
+		return this;
+	}
+	
+	public ItemBuilder listener(final Runnable run) {
+		this.listener = new ClickListener() {
+			@Override
+			public void click(Click click) {
+				run.run();				
+			}
+		};
+		return this;
+	}
+
+	public ItemBuilder id(int id) {
+		this.id = id;
+		return this;
+	}
+
+	public ItemBuilder material(Material m) {
+		this.id = m.getId();
+		return this;
+	}
+
+	public Item build() {
+		Item i;
+		if (handle != null) {
+			if (id != 0)
+				handle.setTypeId(id);
+			if (sid != -1)
+				handle.setDurability((short) sid);
+			if(amouth != -1)
+				handle.setAmount(amouth);
+			i = handle;
+		} else
+			i = new Item(id, amouth == -1 ? 1 : amouth, (short) (sid == -1 ? 0 : sid));
+		if (listener != null) {
+			i = new ItemStack(i) {
+				@Override
+				public void click(Click c) {
+					listener.click(c);
+				}
+			};
+		}
+		if (name != null)
+			i.getItemMeta().setDisplayName(name);
+		if (!lore.isEmpty())
+			i.getItemMeta().setLore(lore);
+		if (glow)
+			i.getItemMeta().setGlow(true);
+		return i;
+	}
+
+	public ItemBuilder clearLore() {
+		lore.clear();
+		return this;
+	}
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/item/ItemStack.java b/src/main/java/dev/wolveringer/BungeeUtil/item/ItemStack.java
new file mode 100644
index 0000000..cd38a92
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/item/ItemStack.java
@@ -0,0 +1,84 @@
+package dev.wolveringer.BungeeUtil.item;
+
+import dev.wolveringer.BungeeUtil.Material;
+import dev.wolveringer.BungeeUtil.Player;
+import dev.wolveringer.api.inventory.Inventory;
+
+public abstract class ItemStack extends Item {
+
+	public ItemStack(Item stack) throws IllegalArgumentException {
+		super(stack);
+	}
+
+	public ItemStack(Material type) {
+		super(type);
+	}
+
+	public ItemStack(Material type, int amount) {
+		super(type, amount);
+	}
+
+	public ItemStack(Material type, int amount, short damage) {
+		super(type, amount, damage);
+	}
+
+	@SuppressWarnings("deprecation")
+	public ItemStack(int type, int amount, short damage) {
+		super(type, amount, damage);
+	}
+
+	public abstract void click(Click click);
+
+	public static class Click {
+		private Player player;
+		private int slot;
+		private Inventory inventory;
+		private int mode;
+		private boolean cancel = true;
+		private Item item;
+		private boolean sync;
+		
+		public Click(Player p, int slot, Inventory inv,Item ci, int mode,boolean sync) {
+			this.player = p;
+			this.slot = slot;
+			this.inventory = inv;
+			this.mode = mode;
+			this.item = ci;
+			this.sync = sync;
+		}
+
+		public Player getPlayer() {
+			return player;
+		}
+
+		public int getSlot() {
+			return slot;
+		}
+
+		public Inventory getInventory() {
+			return inventory;
+		}
+
+		public int getMode() {
+			return mode;
+		}
+		
+		public Item getItem() {
+			return item;
+		}
+		
+		@Deprecated
+		public void setCancelled(boolean b) {
+			this.cancel = b;
+		}
+
+		@Deprecated
+		public boolean isCancelled() {
+			return cancel;
+		}
+		
+		public boolean isSyncHandle() {
+			return sync;
+		}
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/item/MultiClickItemStack.java b/src/main/java/dev/wolveringer/BungeeUtil/item/MultiClickItemStack.java
new file mode 100644
index 0000000..e79bd28
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/item/MultiClickItemStack.java
@@ -0,0 +1,41 @@
+package dev.wolveringer.BungeeUtil.item;
+
+import java.util.ArrayList;
+
+import dev.wolveringer.BungeeUtil.Material;
+
+public class MultiClickItemStack extends ItemStack{
+	private ArrayList<ClickListener> listener = new ArrayList<>();
+	public MultiClickItemStack(int type, int amount, short damage) {
+		super(type, amount, damage);
+	}
+
+	public MultiClickItemStack(Item stack) throws IllegalArgumentException {
+		super(stack);
+	}
+
+	public MultiClickItemStack(Material type, int amount, short damage) {
+		super(type, amount, damage);
+	}
+
+	public MultiClickItemStack(Material type, int amount) {
+		super(type, amount);
+	}
+
+	public MultiClickItemStack(Material type) {
+		super(type);
+	}
+	
+	public void addClickListener(ClickListener listener){
+		this.listener.add(listener);
+	}
+	public void removeListener(ClickListener listener){
+		this.listener.remove(listener);
+	}
+	
+	@Override
+	public void click(Click p) {
+		for(ClickListener c : listener)
+			c.click(p);
+	}
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/item/SyncHandle.java b/src/main/java/dev/wolveringer/BungeeUtil/item/SyncHandle.java
new file mode 100644
index 0000000..e73fc12
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/item/SyncHandle.java
@@ -0,0 +1,10 @@
+package dev.wolveringer.BungeeUtil.item;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+@Target(ElementType.METHOD)
+@Retention(RetentionPolicy.RUNTIME)
+public @interface SyncHandle {}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/item/Test.java b/src/main/java/dev/wolveringer/BungeeUtil/item/Test.java
new file mode 100644
index 0000000..6d0614b
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/item/Test.java
@@ -0,0 +1,14 @@
+package dev.wolveringer.BungeeUtil.item;
+
+import dev.wolveringer.BungeeUtil.Material;
+import dev.wolveringer.BungeeUtil.item.itemmeta.CraftItemMeta;
+
+public class Test {
+	public static void main(String[] args) {
+		ItemStack is = new ItemStack(Material.STONE){
+			@SyncHandle
+			public void click(Click click) {};
+		};
+		System.out.println(((CraftItemMeta)is.getItemMeta()).isClickSync());
+	}
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/item/itemmeta/CraftItemMeta.java b/src/main/java/dev/wolveringer/BungeeUtil/item/itemmeta/CraftItemMeta.java
new file mode 100644
index 0000000..39589f8
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/item/itemmeta/CraftItemMeta.java
@@ -0,0 +1,178 @@
+package dev.wolveringer.BungeeUtil.item.itemmeta;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Method;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+import dev.wolveringer.BungeeUtil.BungeeUtil;
+import dev.wolveringer.BungeeUtil.Main;
+import dev.wolveringer.BungeeUtil.item.Item;
+import dev.wolveringer.BungeeUtil.item.ItemStack;
+import dev.wolveringer.BungeeUtil.item.SyncHandle;
+import dev.wolveringer.BungeeUtil.item.ItemStack.Click;
+import dev.wolveringer.api.inventory.Inventory;
+import dev.wolveringer.nbt.NBTTagCompound;
+import dev.wolveringer.nbt.NBTTagList;
+import dev.wolveringer.nbt.NBTTagString;
+import dev.wolveringer.util.UtilReflection;
+
+public class CraftItemMeta implements ItemMeta {
+	protected Item item;
+	protected ArrayList<MetaListener> listener = new ArrayList<MetaListener>();
+	private int sync = -1;
+	
+	public CraftItemMeta(Item i) {
+		this.item = i;
+	}
+
+	@Override
+	public String getDisplayName() {
+		if (!getTag().hasKey("display"))
+			getTag().set("display", new NBTTagCompound());
+		return hasDisplayName() ? getTag().getCompound("display").getString("Name") : "";
+	}
+
+	@Override
+	public List<String> getLore() {
+		if (!hasLore())
+			return new ArrayList<String>();
+		List<String> l = new ArrayList<>();
+		NBTTagList x = getTag().getCompound("display").getList("Lore");
+		for (int y = 0; y < x.size(); y++)
+			l.add(x.getString(y));
+		return l;
+	}
+
+	@Override
+	public boolean hasDisplayName() {
+		return getTag() != null && getTag().hasKey("display") && getTag().getCompound("display").hasKey("Name");
+	}
+
+	@Override
+	public boolean hasLore() {
+		return getTag() != null && getTag().hasKey("display") && getTag().getCompound("display").hasKey("Lore");
+	}
+
+	@Override
+	public void setDisplayName(String name) {
+		if (!getTag().hasKey("display"))
+			getTag().set("display", new NBTTagCompound());
+		getTag().getCompound("display").set("Name", new NBTTagString(name));
+		fireUpdate();
+	}
+
+	@Override
+	public void setGlow(boolean b) {
+		if (b) {
+			if (!getTag().hasKey("ench"))
+				getTag().set("ench", new NBTTagList());
+		} else if (!b) {
+			if (getTag().hasKey("ench"))
+				getTag().remove("ench");
+		}
+		fireUpdate();
+	}
+
+	@Override
+	public boolean hasGlow() {
+		return getTag() != null && getTag().hasKey("ench");
+	}
+
+	@Override
+	public void setLore(List<String> lore) {
+		if (!getTag().hasKey("display"))
+			getTag().set("display", new NBTTagCompound());
+		NBTTagList l = new NBTTagList();
+		for (String s : lore)
+			l.add(new NBTTagString(s));
+		getTag().getCompound("display").set("Lore", l);
+		fireUpdate();
+	}
+
+	@Override
+	public boolean hasTag() {
+		return getTag() != null && !getTag().isEmpty();
+	}
+
+	public NBTTagCompound getTag() {
+		if (item.getTag() == null)
+			item.setTag(new NBTTagCompound());
+		return item.getTag();
+	}
+
+	protected void fireUpdate() {
+		for (StackTraceElement e : Thread.currentThread().getStackTrace())
+			if (e.getClassName().contains(Inventory.class.getCanonicalName() + "$2")
+					&& e.getMethodName().equalsIgnoreCase("onUpdate")) // recall
+																		// in
+																		// updateâ
+				return;
+		if (listener.size() != 0){
+			try{
+			for (MetaListener l : new ArrayList<>(listener))
+				if (l != null)
+					l.onUpdate(item);
+			}catch(NegativeArraySizeException e){
+				System.out.println("NegativeArraySizeException from ArrayList?! I'm crazy! size()->"+listener.size());
+			}
+		}
+	}
+
+	public void addMetaListener(MetaListener listener) {
+		this.listener.add(listener);
+	}
+
+	public void removeMetaListener(MetaListener listener) {
+		this.listener.remove(listener);
+	}
+
+	public boolean isClickSync(){
+		if(sync == -1){
+			if(!(item instanceof ItemStack))
+				sync = 0;
+			ItemStack is = (ItemStack) item;
+			try{
+				Method m = UtilReflection.getMethod(is.getClass(), "click", Click.class);
+				sync = m.isAnnotationPresent(SyncHandle.class) ? 1 : 0;
+				BungeeUtil.getInstance().debug((sync == 1 ? "Sync-":"Ansync-")+"Click handeling for "+m.getDeclaringClass().getName()+"#"+m.getName());
+			}catch(Exception e){
+				BungeeUtil.getInstance().debug(e, "Exception while try to detect sync handeling....");
+			}
+		}
+		return sync == 1;
+	}
+	
+	@Override
+	public String toString() {
+		return "CraftItemMeta@" + System.identityHashCode(this) + "[listener=" + listener + "]";
+	}
+
+	@Override
+	public int hashCode() {
+		final int prime = 31;
+		int result = 1;
+		result = prime * result + ((item == null) ? 0 : item.hashCode());
+		return result;
+	}
+
+	@Override
+	public boolean equals(Object obj) {
+		if (this == obj)
+			return true;
+		if (obj == null)
+			return false;
+		if (getClass() != obj.getClass())
+			return false;
+		CraftItemMeta other = (CraftItemMeta) obj;
+		if (item == null) {
+			if (other.item != null)
+				return false;
+		} else if (!item.getTag().equals(other.item.getTag()))
+			return false;
+		return true;
+	}
+
+	protected void build() {}
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/item/itemmeta/ItemMeta.java b/src/main/java/dev/wolveringer/BungeeUtil/item/itemmeta/ItemMeta.java
new file mode 100644
index 0000000..1132cdb
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/item/itemmeta/ItemMeta.java
@@ -0,0 +1,74 @@
+package dev.wolveringer.BungeeUtil.item.itemmeta;
+
+import java.util.List;
+
+import dev.wolveringer.nbt.NBTTagCompound;
+
+/**
+ * This type represents the storage mechanism for auxiliary item data.
+ * <p>
+ * An implementation will handle the creation and application for ItemMeta. This
+ * class should not be implemented by a plugin in a live environment.
+ */
+public interface ItemMeta extends Cloneable {
+
+	/**
+	 * Gets the display name that is set.
+	 * <p>
+	 * Plugins should check that hasDisplayName() returns <code>true</code>
+	 * before calling this method.
+	 *
+	 * @return the display name that is set
+	 */
+	String getDisplayName();
+
+	/**
+	 * Gets the lore that is set.
+	 * <p>
+	 * Plugins should check if hasLore() returns <code>true</code> before
+	 * calling this method.
+	 * 
+	 * @return a list of lore that is set
+	 */
+	List<String> getLore();
+
+	/**
+	 * Checks for existence of a display name.
+	 *
+	 * @return true if this has a display name
+	 */
+	boolean hasDisplayName();
+
+	/**
+	 * Checks for existence of lore.
+	 *
+	 * @return true if this has lore
+	 */
+	boolean hasLore();
+
+	/**
+	 * Sets the display name.
+	 *
+	 * @param name
+	 *            the name to set
+	 */
+	void setDisplayName(String name);
+
+	void setGlow(boolean b);
+
+	/**
+	 * Sets the lore for this item.
+	 * Removes lore when given null.
+	 *
+	 * @param lore
+	 *            the lore that will be set
+	 */
+	void setLore(List<String> lore);
+
+	boolean hasTag();
+
+	boolean hasGlow();
+
+	NBTTagCompound getTag();
+	
+}
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/item/itemmeta/MetaFactory.java b/src/main/java/dev/wolveringer/BungeeUtil/item/itemmeta/MetaFactory.java
new file mode 100644
index 0000000..ddb29f1
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/item/itemmeta/MetaFactory.java
@@ -0,0 +1,99 @@
+package dev.wolveringer.BungeeUtil.item.itemmeta;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.util.ArrayList;
+import java.util.HashMap;
+
+import javassist.util.proxy.MethodHandler;
+import javassist.util.proxy.ProxyFactory;
+import dev.wolveringer.BungeeUtil.item.Item;
+
+@SuppressWarnings({ "deprecation", "rawtypes" })
+public class MetaFactory {
+	private static ItemMetaProxy proxy = new ItemMetaProxy();
+	public static boolean equals(ItemMeta meta, Object object) {
+		if(object == null && meta == null)
+			return true;
+		else if(object == null || meta == null){
+			return false;
+		}else if(!(object instanceof ItemMeta)){
+			return false;
+		}
+		ItemMeta im = (ItemMeta) object;
+		if(!im.getLore().equals(meta.getLore())){
+			return false;
+		}
+		if(!im.getDisplayName().equalsIgnoreCase(meta.getDisplayName())){
+			return false;
+		}
+		return true;
+	}
+
+	public static ItemMeta getItemMeta(Item item) {
+		/*
+		switch (item.getType()) {
+			case SKULL_ITEM:
+				return createProxyInstance(SkullMeta.class,item);
+			default:
+				return createProxyInstance(CraftItemMeta.class,item);
+		}
+		*/
+		switch (item.getType()) {
+			case SKULL_ITEM:
+				return new SkullMeta(item);
+			default:
+				return new CraftItemMeta(item);
+		}
+	}
+
+	protected static ItemMeta createProxyInstance(Class c,Item item) {
+		ProxyFactory factor = new ProxyFactory();
+		factor.setSuperclass(c);
+		factor.setHandler(proxy);
+		try{
+			return (ItemMeta) factor.create(new Class[]{Item.class}, new Object[]{item});
+		}catch (NoSuchMethodException | IllegalArgumentException | InstantiationException | IllegalAccessException | InvocationTargetException e){
+			e.printStackTrace();
+		}
+		return new CraftItemMeta(item);
+	}
+
+	protected static class ItemMetaProxy implements MethodHandler {
+		@SuppressWarnings("serial")
+		private static HashMap<Class, ArrayList<String>> whitelist = new HashMap<Class, ArrayList<String>>(){
+			public java.util.ArrayList<String> get(Object key) {
+				if(super.get(key) == null)
+					super.put((Class) key, new ArrayList<String>());
+				return super.get(key);
+			}
+		};
+		public static void addWhiteList(Class clazz,String methode){
+			whitelist.get(clazz).add(methode);
+		}
+		@Override
+		public Object invoke(Object self, Method thisMethod, Method proceed, Object[] args) throws Throwable {
+			if(self instanceof CraftItemMeta){
+				if(thisMethod.getName().startsWith("set")){
+					for(Class c : whitelist.keySet())
+						if(isInstance(self, c))
+							if(whitelist.get(c).contains(thisMethod.getName()))
+								return proceed.invoke(self, args);
+					Object resulut = proceed.invoke(self, args); //? null
+					self.getClass().getDeclaredMethod("build").invoke(self);
+					((CraftItemMeta)self).fireUpdate();
+					return resulut;
+				}
+			}
+			return proceed.invoke(self, args);
+		}
+		private boolean isInstance(Object base,Class of){
+			try{
+				of.cast(base);
+				return true;
+			}catch(Exception e){
+				return false;
+			}
+		}
+	}
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/item/itemmeta/MetaListener.java b/src/main/java/dev/wolveringer/BungeeUtil/item/itemmeta/MetaListener.java
new file mode 100644
index 0000000..f7c639a
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/item/itemmeta/MetaListener.java
@@ -0,0 +1,7 @@
+package dev.wolveringer.BungeeUtil.item.itemmeta;
+
+import dev.wolveringer.BungeeUtil.item.Item;
+
+public interface MetaListener {
+	public void onUpdate(Item is);
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/item/itemmeta/SkullMeta.java b/src/main/java/dev/wolveringer/BungeeUtil/item/itemmeta/SkullMeta.java
new file mode 100644
index 0000000..5eccb76
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/item/itemmeta/SkullMeta.java
@@ -0,0 +1,123 @@
+package dev.wolveringer.BungeeUtil.item.itemmeta;
+
+import java.util.UUID;
+
+import net.md_5.bungee.BungeeCord;
+import dev.wolveringer.BungeeUtil.BungeeUtil;
+import dev.wolveringer.BungeeUtil.Main;
+import dev.wolveringer.BungeeUtil.OperationCalback;
+import dev.wolveringer.BungeeUtil.gameprofile.GameProfile;
+import dev.wolveringer.BungeeUtil.gameprofile.GameProfileSerializer;
+import dev.wolveringer.BungeeUtil.gameprofile.Skin;
+import dev.wolveringer.BungeeUtil.gameprofile.SkinFactory;
+import dev.wolveringer.BungeeUtil.gameprofile.UUIDFetcher;
+import dev.wolveringer.BungeeUtil.item.Item;
+import dev.wolveringer.nbt.NBTTagCompound;
+
+public class SkullMeta extends CraftItemMeta {
+
+	static{
+		MetaFactory.ItemMetaProxy.addWhiteList(SkullMeta.class, "setSkin");
+	}
+
+	GameProfile p = new GameProfile(UUID.randomUUID(), "");
+	UUID owner;
+
+	public SkullMeta(Item i) {
+		super(i);
+		if(getTag().hasKey("SkullOwner"))
+			p = GameProfileSerializer.deserialize(getTag().getCompound("SkullOwner"));
+	}
+
+	@SuppressWarnings("unchecked")
+	public void setSkin(UUID owner) {
+		this.owner = owner;
+		if(p == null)
+			p = new GameProfile(owner, "");
+		p.setId(owner);
+		SkinFactory.getSkin(owner, new OperationCalback<Skin>() {
+			public void done(Skin response) {
+				setSkin(response);
+			};
+		});
+		build();
+	}
+
+	public void setSkin(final String owner) {
+		BungeeCord.getInstance().getScheduler().runAsync(BungeeUtil.getPluginInstance(), new Runnable() {
+			@Override
+			public void run() {
+				try{
+					setSkin(UUIDFetcher.getUUIDOf(owner));
+				}catch (Exception e){
+					e.printStackTrace();
+				}
+			}
+		});
+	}
+
+	public void setSkin(Skin s) {
+		s.applay(p);
+		p.setName(p.getName().equalsIgnoreCase("") ? s.getProfileName() : p.getName());
+		build();
+	}
+
+	public void setSkullOwner(String name) {
+		if(p == null)
+			p = new GameProfile(UUID.randomUUID(), name);
+		p.setName(name);
+		build();
+	}
+
+	public GameProfile getProfile() {
+		return p;
+	}
+
+	public void setProfile(GameProfile p) {
+		this.p = p;
+		build();
+	}
+
+	@Override
+	protected void build() {
+		if(p != null)
+			getTag().set("SkullOwner", GameProfileSerializer.serialize(new NBTTagCompound(), p));
+		fireUpdate();
+	}
+
+	@Override
+	public String toString() {
+		return "SkullMeta@" + System.identityHashCode(this) + "[p=" + p + ", owner=" + owner + "]";
+	}
+
+	@Override
+	public int hashCode() {
+		final int prime = 31;
+		int result = super.hashCode();
+		result = prime * result + ((owner == null) ? 0 : owner.hashCode());
+		result = prime * result + ((p == null) ? 0 : p.hashCode());
+		return result;
+	}
+
+	@Override
+	public boolean equals(Object obj) {
+		if(this == obj)
+			return true;
+		if(!super.equals(obj))
+			return false;
+		if(getClass() != obj.getClass())
+			return false;
+		SkullMeta other = (SkullMeta) obj;
+		if(owner == null){
+			if(other.owner != null)
+				return false;
+		}else if(!owner.equals(other.owner))
+			return false;
+		if(p == null){
+			if(other.p != null)
+				return false;
+		}else if(!p.equals(other.p))
+			return false;
+		return super.equals(obj);
+	}
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/Abstract/PacketAbstract.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/Abstract/PacketAbstract.java
new file mode 100644
index 0000000..be7804d
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/Abstract/PacketAbstract.java
@@ -0,0 +1,23 @@
+package dev.wolveringer.BungeeUtil.packets.Abstract;
+
+import dev.wolveringer.BungeeUtil.packets.Packet;
+import dev.wolveringer.packet.PacketDataSerializer;
+
+@SuppressWarnings("deprecation")
+public abstract class PacketAbstract extends Packet{
+	private byte[] b;
+	
+	public PacketAbstract(int id) {
+		super(id);
+	}
+	
+	public PacketAbstract() {}
+	
+	public void readUnusedBytes(PacketDataSerializer s){
+		b = new byte[s.readableBytes()];
+		s.readBytes(b);
+	}
+	public void writeUnusedBytes(PacketDataSerializer s){
+		s.writeBytes(b);
+	}
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/Abstract/PacketPlayIn.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/Abstract/PacketPlayIn.java
new file mode 100644
index 0000000..04e0867
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/Abstract/PacketPlayIn.java
@@ -0,0 +1,3 @@
+package dev.wolveringer.BungeeUtil.packets.Abstract;
+
+public interface PacketPlayIn {}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/Abstract/PacketPlayOut.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/Abstract/PacketPlayOut.java
new file mode 100644
index 0000000..a404aef
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/Abstract/PacketPlayOut.java
@@ -0,0 +1,3 @@
+package dev.wolveringer.BungeeUtil.packets.Abstract;
+
+public interface PacketPlayOut {}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/Abstract/PacketPlayOutEntityAbstract.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/Abstract/PacketPlayOutEntityAbstract.java
new file mode 100644
index 0000000..9056f83
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/Abstract/PacketPlayOutEntityAbstract.java
@@ -0,0 +1,38 @@
+package dev.wolveringer.BungeeUtil.packets.Abstract;
+
+import dev.wolveringer.BungeeUtil.ClientVersion.BigClientVersion;
+import dev.wolveringer.packet.PacketDataSerializer;
+
+public class PacketPlayOutEntityAbstract extends PacketAbstract {
+
+	private int id;
+
+	public PacketPlayOutEntityAbstract() {}
+	
+	public PacketPlayOutEntityAbstract(int id) {
+		super(id);
+	}
+
+	@Override
+	public void read(PacketDataSerializer s) {
+		id = getVersion().getBigVersion() == BigClientVersion.v1_8 ? s.readVarInt() : s.readInt();
+		readUnusedBytes(s);
+	}
+
+	@Override
+	public void write(PacketDataSerializer s) {
+		if(getVersion().getBigVersion() == BigClientVersion.v1_8)
+			s.writeVarInt(id);
+		else
+			s.writeInt(id);
+		writeUnusedBytes(s);
+	}
+
+	public int getId() {
+		return id;
+	}
+
+	public void setId(int id) {
+		this.id = id;
+	}
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/Abstract/PacketPlayXXXHeldItemSlot.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/Abstract/PacketPlayXXXHeldItemSlot.java
new file mode 100644
index 0000000..29c4b21
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/Abstract/PacketPlayXXXHeldItemSlot.java
@@ -0,0 +1,22 @@
+package dev.wolveringer.BungeeUtil.packets.Abstract;
+
+import dev.wolveringer.BungeeUtil.packets.Packet;
+
+public abstract class PacketPlayXXXHeldItemSlot extends Packet{
+	private int slot;
+	
+	public PacketPlayXXXHeldItemSlot(byte id) {
+		super(id);
+		
+	}
+	public PacketPlayXXXHeldItemSlot(int i) {
+		super(i);
+		
+	}
+	public int getSlot() {
+		return slot;
+	}
+	public void setSlot(int slot) {
+		this.slot = slot;
+	}
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/AbstractPacketCreator.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/AbstractPacketCreator.java
new file mode 100644
index 0000000..ccb1e6c
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/AbstractPacketCreator.java
@@ -0,0 +1,194 @@
+package dev.wolveringer.BungeeUtil.packets;
+
+import io.netty.buffer.ByteBuf;
+
+import java.math.BigDecimal;
+import java.math.BigInteger;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map.Entry;
+
+import net.md_5.bungee.api.ChatColor;
+import net.md_5.bungee.protocol.Protocol;
+import net.md_5.bungee.protocol.ProtocolConstants.Direction;
+import dev.wolveringer.BungeeUtil.ClientVersion.ProtocollVersion;
+import dev.wolveringer.BungeeUtil.packets.Packet.ProtocollId;
+import dev.wolveringer.BungeeUtil.BungeeUtil;
+import dev.wolveringer.BungeeUtil.CostumPrintStream;
+import dev.wolveringer.BungeeUtil.Player;
+import dev.wolveringer.chat.ChatColor.ChatColorUtils;
+import dev.wolveringer.string.ColoredChar;
+import dev.wolveringer.terminal.table.TerminalTable;
+import dev.wolveringer.terminal.table.TerminalTable.Align;
+import dev.wolveringer.terminal.table.TerminalTable.TerminalColumn;
+import dev.wolveringer.terminal.table.TerminalTable.TerminalRow;
+
+public abstract class AbstractPacketCreator {
+	public int calculate(ProtocollVersion version, Protocol p, Direction d, Integer id) {
+		int x = ((version.ordinal() & 0xFF) << 16) | ((p.ordinal() & 0x0F) << 12) | ((d.ordinal() & 0x0F) << 8) | (id & 0xFF);
+		return x;
+	}
+
+	public ProtocollVersion getPacketVersion(int base) {
+		return ProtocollVersion.values()[((int) (base >> 16)) & 0xFF];
+	}
+
+	public int getPacketId(int base) {
+		return base & 0xFF;
+	}
+
+	public Protocol getProtocoll(int base) {
+		return Protocol.values()[((int) (base >> 12)) & 0x0F];
+	}
+
+	public Direction getDirection(int base) {
+		int size = ((int) (base >> 8)) & 0x0F;
+		if (Direction.values().length < size)
+			return Direction.TO_SERVER;
+		return Direction.values()[size];
+	}
+
+	public Packet getPacket(ProtocollVersion version, Protocol s, Direction d, ByteBuf x, Player p) {
+		if (x.readableBytes() < 1)
+			return null;
+		x.markReaderIndex().markWriterIndex();
+		Packet y = getPacket0(version, s, d, (int) x.readUnsignedByte(), x, p); // faster
+		x.resetReaderIndex().resetWriterIndex();
+		return y;
+	}
+
+	public void listPackets(CostumPrintStream out) {
+		HashMap<ProtocollVersion, HashMap<Direction, HashMap<Integer, Class<? extends Packet>>>> packets = new HashMap<ProtocollVersion, HashMap<Direction, HashMap<Integer, Class<? extends Packet>>>>();
+		for (ProtocollVersion c : ProtocollVersion.values()) {
+			if (!c.isSupported())
+				continue;
+			packets.put(c, new HashMap<Direction, HashMap<Integer, Class<? extends Packet>>>());
+			for (Direction d : Direction.values())
+				packets.get(c).put(d, new HashMap<Integer, Class<? extends Packet>>());
+		}
+
+		for (Class<? extends Packet> packet : getRegisteredPackets()) {
+			for (ProtocollVersion version : packets.keySet()) {
+				int compressed = getPacketId(version, packet);
+				if (getPacketId(compressed) != 0xFF)
+					packets.get(version).get(getDirection(compressed)).put(getPacketId(compressed), packet);
+			}
+		}
+
+		HashMap<ProtocollVersion, Integer> rowMapping = new HashMap<>();
+		List<TerminalColumn> columns = new ArrayList<>();
+		columns.add(new TerminalColumn("\u00A7eName", Align.RIGHT));
+		columns.add(new TerminalColumn("\u00A7eDirection", Align.CENTER));
+		List<ProtocollVersion> versions = Arrays.asList(ProtocollVersion.values());
+		Collections.sort(versions, new Comparator<ProtocollVersion>() {
+			@Override
+			public int compare(ProtocollVersion o1, ProtocollVersion o2) {
+				return Integer.compare(o1.getProtocollVersion(), o2.getProtocollVersion());
+			}
+		});
+		for (ProtocollVersion version : versions) {
+			if (version == ProtocollVersion.Unsupported)
+				continue;
+			rowMapping.put(version, columns.size());
+			columns.add(new TerminalColumn("\u00A7e" + version.name(), Align.CENTER));
+		}
+		TerminalTable table = new TerminalTable(columns.toArray(new TerminalColumn[0]));
+
+		HashMap<Class<? extends Packet>, String[]> packetRow = new HashMap<Class<? extends Packet>, String[]>();
+		for (Entry<ProtocollVersion, HashMap<Direction, HashMap<Integer, Class<? extends Packet>>>> protocolls : packets.entrySet()) {
+			for (Entry<Direction, HashMap<Integer, Class<? extends Packet>>> directions : protocolls.getValue().entrySet()) {
+				List<Entry<Integer, Class<? extends Packet>>> packetIds = new ArrayList<>(directions.getValue().entrySet());
+				Collections.sort(packetIds, new Comparator<Entry<Integer, Class<? extends Packet>>>() {
+					@Override
+					public int compare(Entry<Integer, Class<? extends Packet>> o1, Entry<Integer, Class<? extends Packet>> o2) {
+						return Integer.compare(o1.getKey(), o1.getKey());
+					}
+				});
+
+				for (Entry<Integer, Class<? extends Packet>> packet : packetIds) {
+					if (!packetRow.containsKey(packet.getValue())) {
+						String[] ids = new String[columns.size()];
+						Arrays.fill(ids, 2, ids.length, "\u00A76nan");
+						packetRow.put(packet.getValue(), ids);
+					}
+					String packetIdHex = "\u00A7c0x" + (Integer.toHexString(packet.getKey()).length() == 1 ? "0" : "") + Integer.toHexString(packet.getKey()).toUpperCase();
+					packetRow.get(packet.getValue())[rowMapping.get(protocolls.getKey())] = packetIdHex;
+					if (packetRow.get(packet.getValue())[0] == null) {
+						packetRow.get(packet.getValue())[0] = "\u00A76" + packet.getValue().getName().replaceAll(packet.getValue().getName().split("\\.")[packet.getValue().getName().split("\\.").length - 1], ChatColorUtils.COLOR_CHAR + "b" + packet.getValue().getName().split("\\.")[packet.getValue().getName().split("\\.").length - 1]);
+					}
+					if (packetRow.get(packet.getValue())[1] == null) {
+						packetRow.get(packet.getValue())[1] = "\u00A7a" + directions.getKey().name();
+					}
+				}
+			}
+		}
+
+		for (String[] row : packetRow.values())
+			table.addRow(row);
+		table.setRowSeperator(new TerminalTable.RowSeperator() {
+			@Override
+			public ColoredChar getSeperator(TerminalRow row, int rowIndex, int columnFrom, int columnTo) {
+				if(columnFrom < 2)
+					return new ColoredChar("|");
+				String oldPacketIds = row.getColumns()[columnFrom].get(rowIndex);
+				String newPacketIds = row.getColumns()[columnTo].get(rowIndex);
+				if(oldPacketIds.equalsIgnoreCase("\u00A76nan"))
+					oldPacketIds = "0x-1";
+				if(newPacketIds.equalsIgnoreCase("\u00A76nan"))
+					newPacketIds = "0x-1";
+				BigInteger oldPacketId = new BigInteger(ChatColor.stripColor(oldPacketIds).substring(2),16);
+				BigInteger newPacketId = new BigInteger(ChatColor.stripColor(newPacketIds).substring(2),16);
+				switch (oldPacketId.compareTo(newPacketId)) {
+				case -1:
+					return new ColoredChar("\u00A7aâ ");
+				case 0:
+					return new ColoredChar("\u00A77|");
+				case 1:
+					return new ColoredChar("\u00A7aâ ");
+				default:
+					break;
+				}
+				return new ColoredChar("\u00A75X");
+			}
+			@Override
+			public ColoredChar getDefaultSeperator() {
+				return new ColoredChar("\u00A77|");
+			}
+		});
+		
+		for (String line : table.buildLines())
+			out.println(line);
+	}
+
+	public void listPackets() {
+		listPackets(new CostumPrintStream() {
+			@Override
+			public void println(String s) {
+				BungeeUtil.getInstance().sendMessage(s);
+			}
+
+			@Override
+			public void print(String s) {
+				BungeeUtil.getInstance().sendMessage(s);
+			}
+		});
+	}
+
+	public abstract Packet getPacket0(ProtocollVersion version, Protocol protocol, Direction d, Integer id, ByteBuf b, Player p);
+
+	public abstract int loadPacket(ProtocollVersion version, Protocol p, Direction d, Integer id, Class<? extends Packet> clazz);
+
+	public abstract void registerPacket(Protocol p, Direction d, Class<? extends Packet> clazz, ProtocollId... ids);
+
+	public abstract void unregisterPacket(ProtocollVersion version, Protocol p, Direction d, Integer id);
+
+	public abstract int countPackets();
+
+	public abstract int getPacketId(ProtocollVersion version, Class<? extends Packet> clazz);
+
+	public abstract List<Class<? extends Packet>> getRegisteredPackets();
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/BetaPacket.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/BetaPacket.java
new file mode 100644
index 0000000..e332f04
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/BetaPacket.java
@@ -0,0 +1,34 @@
+package dev.wolveringer.BungeeUtil.packets;
+
+import io.netty.buffer.ByteBuf;
+
+import javax.naming.OperationNotSupportedException;
+
+import dev.wolveringer.BungeeUtil.ClientVersion;
+import dev.wolveringer.BungeeUtil.DebugProperties;
+
+public abstract class BetaPacket extends Packet{
+	
+	public BetaPacket() {}
+	
+	public BetaPacket(byte id) {
+		super(id);
+		
+	}
+	public BetaPacket(int i) {
+		super(i);
+		
+	}
+	@Override
+	protected Packet load(ByteBuf b,ClientVersion version) {
+		if(!DebugProperties.PACKET_DEVELOPMENT)
+			throw new RuntimeException(new OperationNotSupportedException("Packet is stille under development!"));
+		return super.load(b,version);
+	}
+	@Override
+	public ByteBuf getByteBuf(ClientVersion version) {
+		if(!DebugProperties.PACKET_DEVELOPMENT)
+			throw new RuntimeException(new OperationNotSupportedException("Packet is stille under development!"));
+		return super.getByteBuf(version);
+	}
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/NormalPacketCreator.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/NormalPacketCreator.java
new file mode 100644
index 0000000..7780a59
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/NormalPacketCreator.java
@@ -0,0 +1,298 @@
+package dev.wolveringer.BungeeUtil.packets;
+
+import java.lang.instrument.ClassFileTransformer;
+import java.lang.instrument.IllegalClassFormatException;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+import java.security.ProtectionDomain;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+
+import dev.wolveringer.BungeeUtil.BungeeUtil;
+import dev.wolveringer.BungeeUtil.ClientVersion;
+import dev.wolveringer.BungeeUtil.ClientVersion.ProtocollVersion;
+import dev.wolveringer.BungeeUtil.exception.ExceptionUtils;
+import dev.wolveringer.BungeeUtil.Main;
+import dev.wolveringer.BungeeUtil.Player;
+import dev.wolveringer.BungeeUtil.packets.Packet.ProtocollId;
+import dev.wolveringer.packet.PacketDataSerializer;
+import io.netty.buffer.ByteBuf;
+import lombok.AllArgsConstructor;
+import lombok.Getter;
+import net.md_5.bungee.protocol.Protocol;
+import net.md_5.bungee.protocol.ProtocolConstants.Direction;
+
+public class NormalPacketCreator extends AbstractPacketCreator {
+	@AllArgsConstructor
+	@Getter
+	private static class PacketHolder {
+		private Constructor<? extends Packet> constuctor;
+
+		public Packet newInstance() throws InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
+			return constuctor.newInstance();
+		}
+	}
+	
+	private PacketHolder[] packetsId = new PacketHolder[((ProtocollVersion.values().length & 0x0F) << 16) | ((Protocol.values().length & 0x0F) << 12) | ((Direction.values().length & 0x0F) << 8) | 0xFF]; // Calculate max packet compressed id. (0xFF = Max ID)
+	@SuppressWarnings("unchecked")
+	private HashMap<Class<? extends Packet>, Integer>[] classToId = new HashMap[ProtocollVersion.values().length];
+	
+	private List<Class<? extends Packet>> registerPackets = new ArrayList<>();
+	private boolean packetListChanged = true;
+	
+	public NormalPacketCreator() {
+		for(int i = 0;i<classToId.length;i++)
+			classToId[i] = new HashMap<>();
+	}
+	
+	@SuppressWarnings("unchecked")
+	public int getPacketId(ProtocollVersion version,Class<? extends Packet> clazz) {
+		if(version == ProtocollVersion.Unsupported){
+			throw new NullPointerException("Unsupported version!");
+		}
+		if (!clazz.getName().endsWith("$-1")) while (clazz.getName().contains("$")) {
+			clazz = (Class<? extends Packet>) clazz.getSuperclass();
+		}
+		if (!classToId[version.ordinal()].containsKey(clazz)) //throw new NullPointerException("Packet " + clazz.getName() + " not loadet.");
+			if(version.getBasedVersion().getProtocollVersion() != version)
+				return getPacketId(version.getBasedVersion().getProtocollVersion(),clazz);
+			else
+				return -1;
+		return   classToId[version.ordinal()].get(clazz);
+	}
+	
+	public List<Class<? extends Packet>> getRegisteredPackets() {
+		if (packetListChanged) {
+			registerPackets.clear();
+			for (int i = 0; i < packetsId.length; i++) {
+				if(packetsId[i] == null)
+					continue;
+				Constructor<? extends Packet> constructor = packetsId[i].getConstuctor();
+				if (constructor == null) continue;
+				registerPackets.add(constructor.getDeclaringClass());
+			}
+			packetListChanged = false;
+		}
+		return registerPackets;
+	}
+	
+	public Packet getPacket0(ProtocollVersion version,Protocol protocol, Direction d, Integer id, ByteBuf b, Player p) {
+		int compressed = calculate(version,protocol, d, id);
+		PacketHolder cons = null;
+		if ((cons = packetsId[compressed]) == null) {
+			if(version.getBasedVersion().getProtocollVersion() == version){ //Fallback (based version) (1.8-1.9)
+				return null;
+			}
+			else{
+				return getPacket0(version.getBasedVersion().getProtocollVersion(), protocol, d, id, b, p);
+			}
+		}
+		if(cons.getConstuctor() == null)
+			return null;
+		try {
+			Packet packet = cons.newInstance();
+			if (p == null || p.getVersion() == null){
+				BungeeUtil.getInstance().debug("Version of '"+(p == null ? "<Null client>" : p.getName())+"' is undefined");
+				return packet.setcompressedId(compressed).load(b, ClientVersion.UnderknownVersion);
+			}
+			else return packet.setcompressedId(compressed).load(b, p.getVersion());
+		}
+		catch (Exception e) {
+			throw ExceptionUtils.createRuntimeException(ExceptionUtils.setExceptionMessage(e, "Packet error (Version: " + (p == null ? "unknown" : p.getVersion()) + ", Readed version: "+version+", Class: " + (cons == null || cons.getConstuctor() == null ? "null" : cons.getConstuctor().getDeclaringClass().getName()) + ", Id: 0x"+Integer.toHexString(id).toUpperCase()+") -> "+e.getMessage()));
+		}
+	}
+	
+	public Packet getPacket1(ProtocollVersion version,ProtocollVersion orginalVersion,Protocol protocol, Direction d, Integer id, ByteBuf b, Player p) {
+		return null;
+	}
+	
+	public int loadPacket(ProtocollVersion version,Protocol p, Direction d, Integer id, Class<? extends Packet> clazz) {
+		//clazz = getPacketWithDefaultConstructor(clazz);
+		int compressedId = calculate(version,p, d, id);
+		classToId[version.ordinal()].put(clazz, compressedId);
+		return compressedId;
+	}
+	
+	
+	public void registerPacket(Protocol p, Direction d, Class<? extends Packet> clazz, ProtocollId... ids) {
+		//clazz = getPacketWithDefaultConstructor(clazz);
+		try {
+			for(ProtocollId id : ids)
+				if(id != null && id.isValid()){
+					packetsId[loadPacket(id.getVersion(),p, d, id.getId(), clazz)] = new PacketHolder(clazz == null ? null : (Constructor<? extends Packet>) clazz.getConstructor());
+					/*
+					if(id.getVersion().getBasedVersion().getProtocollVersion() != id.getVersion()){
+						int cid = loadPacket(id.getVersion().getBasedVersion().getProtocollVersion(),p, d, id.getId(), clazz);
+						if(packetsId[cid] == null)
+							packetsId[cid] = new PacketHolder(null);
+					}
+					*/
+				}
+		}
+		catch (NoSuchMethodException | SecurityException ex) {
+			System.out.println(clazz);
+			ex.printStackTrace();
+		}
+		packetListChanged = true;
+	}
+	
+	public void unregisterPacket(ProtocollVersion version,Protocol p, Direction d, Integer id) {
+		packetsId[calculate(version,p, d, id)] = null;
+		packetListChanged = true;
+	}
+	
+	public int countPackets() {
+		return getRegisteredPackets().size();
+	}
+	
+	/**
+	 * Try to create a default constructor.....
+	 */
+	/*
+	
+	@SuppressWarnings({ "unchecked", "deprecation" })
+	private static Class<? extends Packet> getPacketWithDefaultConstructor(final Class<? extends Packet> in) {
+		try {
+			for (Constructor<?> c : in.getConstructors())
+				if (c.getParameterTypes().length == 0) return in;
+			//for (Constructor<?> c : in.getDeclaredConstructors())
+			//	if (c.getParameterTypes().length == 0) return in;
+		}
+		catch (Exception e) {
+		}
+		try {
+			Main.sendMessage("Adding default constructor to class: " + in.getName());
+			ClassPool pool = IIInitialHandler.pool();
+			pool.insertClassPath(new ClassClassPath(in));
+			
+			
+			CtClass ct_in = pool.get(in.getName());
+			byte[] oldClassBytecode = ct_in.toBytecode();
+			ct_in.defrost();
+			//ct_in.setName(in.getName() + "$-1");
+			//ct_in.setSuperclass(pool.get(in.getName()));
+			//for(CtConstructor c : pool.get(in.getName()).getConstructors())
+			//	ct_in.addConstructor(CtNewConstructor.copy(c, ct_in, null));
+			ct_in.addConstructor(defaultConstructor(ct_in));
+			
+			Class oldClass = Class.forName(in.getName());
+			
+			ClassLoader loader = IIInitialHandler.getClassLoader();
+			final byte[] data = ct_in.toBytecode();
+			InstrumentationUtil.getInstrumentation().addTransformer(new DemoTransformer(oldClass.getName(), oldClass.getClassLoader(),data));
+			System.out.println("X1: "+InstrumentationUtil.getInstrumentation().isModifiableClass(oldClass)+":"+InstrumentationUtil.getInstrumentation().isRedefineClassesSupported()+":"+InstrumentationUtil.getInstrumentation().isRetransformClassesSupported());
+			System.out.println(oldClass);
+			InstrumentationUtil.getInstrumentation().redefineClasses(new ClassDefinition(Class.forName(in.getName()), oldClassBytecode));
+			
+			//UtilReflection.getMethod(ClassLoader.class, "defineClass", byte[].class,int.class,int.class).invoke(loader, data,0,data.length);
+			//unloadClass(IIInitialHandler.getClassLoader(), in.getName());
+			
+			
+			return (Class<? extends Packet>) IIInitialHandler.getClassLoader().loadClass(ct_in.getName());
+		}
+		catch (Exception e) {
+			e.printStackTrace();
+		}
+		return in;
+	}
+	
+	private static void unloadClass(ClassLoader loader,String clazz) throws IllegalArgumentException, IllegalAccessException{
+		 Vector<Class<?>> classes = (Vector<Class<?>>) UtilReflection.getField(ClassLoader.class, "classes").get(loader);
+		 for(Class c : new Vector<>(classes))
+			 if(c.getName().equalsIgnoreCase(clazz)){
+				 System.out.println("Removing");
+				 classes.remove(c);
+			 }
+		 System.out.println("Loaded classes: "+classes);
+	}
+	
+	private static CtConstructor defaultConstructor(CtClass declaring) throws CannotCompileException {
+		CtConstructor cons = new CtConstructor((CtClass[]) null, declaring);
+		
+		ConstPool cp = declaring.getClassFile2().getConstPool();
+		Bytecode code = new Bytecode(cp, 1, 1);
+		code.addAload(0);
+		try {
+			System.out.println(declaring.getSuperclass());
+			code.addInvokespecial(declaring.getSuperclass(), "<init>", "()V");//
+		}
+		catch (NotFoundException e) {
+			throw new CannotCompileException(e);
+		}
+		
+		code.add(Bytecode.RETURN);
+		
+		cons.getMethodInfo2().setCodeAttribute(code.toCodeAttribute());
+		return cons;
+	}
+	
+	public static void main(String[] args) throws InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException, SecurityException {
+		loadAgent();
+		Class currunt = TestPacket.class;
+		currunt = getPacketWithDefaultConstructor(currunt);
+		System.out.println(Arrays.asList(currunt.getConstructors())+":"+(TestPacket.class.isAssignableFrom(currunt)));
+		Object a = currunt.getConstructor(String.class).newInstance("Testing");
+		//TestPacket b = (TestPacket) currunt.newInstance();
+		//System.out.println(a.getTest()+":"+b.getTest());
+	}
+
+	public static void loadAgent() {
+		InstrumentationUtil.init();
+	}
+	*/
+}
+
+class TestPacket extends Packet{
+	String test = "undefined";
+	
+	public TestPacket(String test) {
+		this.test = test;
+	}
+	
+	@Override
+	public void read(PacketDataSerializer s) {
+		
+	}
+
+	@Override
+	public void write(PacketDataSerializer s) {
+		
+	}
+	public String getTest() {
+		return test;
+	}
+}
+class DemoTransformer implements ClassFileTransformer {
+    /** The internal form class name of the class to transform */
+    protected String className;
+    /** The class loader of the class */
+    protected ClassLoader classLoader;
+    private byte[] newData;
+    /**
+     * Creates a new DemoTransformer
+     * @param className The binary class name of the class to transform
+     * @param classLoader The class loader of the class
+     */
+    public DemoTransformer(String className, ClassLoader classLoader,byte[] newData) {
+        this.className = className.replace('.', '/');
+        this.classLoader = classLoader;
+        this.newData = newData;
+    }
+
+    /**
+     * {@inheritDoc}
+     * @see java.lang.instrument.ClassFileTransformer#transform(java.lang.ClassLoader, java.lang.String, java.lang.Class, java.security.ProtectionDomain, byte[])
+     */
+    @Override
+    public byte[] transform(ClassLoader loader, String className,
+            Class<?> classBeingRedefined, ProtectionDomain protectionDomain,
+            byte[] classfileBuffer) throws IllegalClassFormatException {
+        if(className.equals(this.className) && loader.equals(classLoader)) {
+        	System.out.println("Redefining");
+            return newData;
+        }
+        return classfileBuffer;
+    }
+
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/Packet.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/Packet.java
new file mode 100644
index 0000000..2d9a0cd
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/Packet.java
@@ -0,0 +1,292 @@
+package dev.wolveringer.BungeeUtil.packets;
+
+import io.netty.buffer.ByteBuf;
+import lombok.Getter;
+
+import java.util.List;
+import java.util.concurrent.atomic.AtomicLong;
+
+import net.md_5.bungee.protocol.Protocol;
+import net.md_5.bungee.protocol.ProtocolConstants.Direction;
+import dev.wolveringer.BungeeUtil.ClientVersion;
+import dev.wolveringer.BungeeUtil.ClientVersion.BigClientVersion;
+import dev.wolveringer.BungeeUtil.ClientVersion.ProtocollVersion;
+import dev.wolveringer.BungeeUtil.CostumPrintStream;
+import dev.wolveringer.BungeeUtil.Player;
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
+import dev.wolveringer.packet.ByteBuffCreator;
+import dev.wolveringer.packet.PacketDataSerializer;
+
+public abstract class Packet {
+	@Getter
+	public static class ProtocollId {
+		private ProtocollVersion version;
+		private int id;
+		
+		public ProtocollId(ProtocollVersion version, int id) {
+			this.version = version;
+			this.id = id;
+		}
+		
+		public ProtocollId(BigClientVersion version, int id) {
+			this.version = version.getProtocollVersion();
+			this.id = id;
+		}
+		
+		public boolean isValid() {
+			return id >= 0 && version != null && version != ProtocollVersion.Unsupported;
+		}
+		
+		@Override
+		public String toString() {
+			return "ProtocollId [version=" + version + ", id=" + Integer.toHexString(id) + "]";
+		}
+	}
+	
+	public static final AtomicLong classInstances = new AtomicLong();
+	
+	private static AbstractPacketCreator creator;
+	
+	public static AbstractPacketCreator getCreator() {
+		if (creator == null) {
+			creator = new NormalPacketCreator();
+		}
+		return creator;
+	}
+	
+	static {
+		registerPacket(Protocol.LOGIN, Direction.TO_CLIENT, PacketLoginDisconnect.class, new ProtocollId(BigClientVersion.v1_8, 0x00), new ProtocollId(BigClientVersion.v1_9, 0x00), new ProtocollId(BigClientVersion.v1_10, 0x00));
+		
+		registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutChat.class, new ProtocollId(BigClientVersion.v1_8, 0x02), new ProtocollId(BigClientVersion.v1_9, 0x0F), new ProtocollId(BigClientVersion.v1_10, 0x0F)); // ->0x0F
+		registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutPlayerListHeaderFooter.class, new ProtocollId(BigClientVersion.v1_8, 0x47), new ProtocollId(BigClientVersion.v1_9, 0x48), new ProtocollId(ProtocollVersion.v1_9_4, 0x47), new ProtocollId(BigClientVersion.v1_10, 0x47));// ->0x48
+		registerPacket(Protocol.GAME, Direction.TO_CLIENT, null, new ProtocollId(ProtocollVersion.v1_9_4, 0x48));
+		
+		registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutPosition.class, new ProtocollId(BigClientVersion.v1_8, 0x08), new ProtocollId(BigClientVersion.v1_9, 0x2E), new ProtocollId(BigClientVersion.v1_10, 0x2E)); // Changed -> 0x2E
+		
+		registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutEntityTeleport.class, new ProtocollId(BigClientVersion.v1_8, 0x18), new ProtocollId(BigClientVersion.v1_9, 0x4A), new ProtocollId(ProtocollVersion.v1_9_4, 0x49), new ProtocollId(BigClientVersion.v1_10, 0x49)); // Changed -> 0x2E | 1.9.4 other id!
+		registerPacket(Protocol.GAME, Direction.TO_CLIENT, null, new ProtocollId(ProtocollVersion.v1_9_4, 0x4A));
+		
+		registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutEntityHeadRotation.class, new ProtocollId(BigClientVersion.v1_8, 0x19), new ProtocollId(BigClientVersion.v1_9, 0x34), new ProtocollId(BigClientVersion.v1_10, 0x34));
+		
+		registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutTransaction.class, new ProtocollId(BigClientVersion.v1_8, 0x32), new ProtocollId(BigClientVersion.v1_9, 0x11), new ProtocollId(BigClientVersion.v1_10, 0x11)); // -> 0x11
+		registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutCloseWindow.class, new ProtocollId(BigClientVersion.v1_8, 0x2E), new ProtocollId(BigClientVersion.v1_9, 0x12), new ProtocollId(BigClientVersion.v1_10, 0x12));// -> 0x12
+		registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutOpenWindow.class, new ProtocollId(BigClientVersion.v1_8, 0x2D), new ProtocollId(BigClientVersion.v1_9, 0x13), new ProtocollId(BigClientVersion.v1_10, 0x13)); // -> 0x13
+		registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutWindowItems.class, new ProtocollId(BigClientVersion.v1_8, 0x30), new ProtocollId(BigClientVersion.v1_9, 0x14), new ProtocollId(BigClientVersion.v1_10, 0x14));// -> 0x14
+		registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutWindowData.class, new ProtocollId(BigClientVersion.v1_8, 0x31), new ProtocollId(BigClientVersion.v1_9, 0x15), new ProtocollId(BigClientVersion.v1_10, 0x15));// -> 0x15
+		registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutSetSlot.class, new ProtocollId(BigClientVersion.v1_8, 0x2F), new ProtocollId(BigClientVersion.v1_9, 0x16), new ProtocollId(BigClientVersion.v1_10, 0x16)); // -> 0x16
+		
+		registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutPluginMessage.class, new ProtocollId(BigClientVersion.v1_8, 0x3F), new ProtocollId(BigClientVersion.v1_9, 0x18), new ProtocollId(BigClientVersion.v1_10, 0x18));
+		
+		registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutEntityEquipment.class, new ProtocollId(BigClientVersion.v1_8, 0x04), new ProtocollId(BigClientVersion.v1_9, 0x3C), new ProtocollId(BigClientVersion.v1_10, 0x3C)); // Chaned
+		
+		registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutWorldParticles.class, new ProtocollId(BigClientVersion.v1_8, 0x2A), new ProtocollId(BigClientVersion.v1_9, 0x22), new ProtocollId(BigClientVersion.v1_10, 0x22));
+		
+		registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutDisconnect.class, new ProtocollId(BigClientVersion.v1_8, 0x40), new ProtocollId(BigClientVersion.v1_9, 0x1A), new ProtocollId(BigClientVersion.v1_10, 0x1A)); // 0x1A
+		
+		registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutScoreboardTeam.class, new ProtocollId(BigClientVersion.v1_8, 0x3E), new ProtocollId(BigClientVersion.v1_9, 0x41), new ProtocollId(BigClientVersion.v1_10, 0x41)); // -> 0x41
+		registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutScoreboardDisplayObjective.class, new ProtocollId(BigClientVersion.v1_8, 0x3D), new ProtocollId(BigClientVersion.v1_9, 0x38), new ProtocollId(BigClientVersion.v1_10, 0x38));// -> 0x38
+		registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutScoreboardObjective.class, new ProtocollId(BigClientVersion.v1_8, 0x3B), new ProtocollId(BigClientVersion.v1_9, 0x3F), new ProtocollId(BigClientVersion.v1_10, 0x3F)); // -> 0x3F
+		registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutScoreboardScore.class, new ProtocollId(BigClientVersion.v1_8, 0x3C), new ProtocollId(BigClientVersion.v1_9, 0x42), new ProtocollId(BigClientVersion.v1_10, 0x42)); // -> 0x42
+		
+		registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutStatistic.class, new ProtocollId(BigClientVersion.v1_8, 0x37), new ProtocollId(BigClientVersion.v1_9, 0x07), new ProtocollId(BigClientVersion.v1_10, 0x07)); // -> 0x07
+		registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutEntityDestroy.class, new ProtocollId(BigClientVersion.v1_8, 0x13), new ProtocollId(BigClientVersion.v1_9, 0x30), new ProtocollId(BigClientVersion.v1_10, 0x30));// -> 0x30
+		registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutEntityEffect.class, new ProtocollId(BigClientVersion.v1_8, 0x1D), new ProtocollId(BigClientVersion.v1_9, 0x4C), new ProtocollId(ProtocollVersion.v1_9_4, 0x4B), new ProtocollId(BigClientVersion.v1_10, 0x4B));// Changed ->
+		registerPacket(Protocol.GAME, Direction.TO_CLIENT, null, new ProtocollId(ProtocollVersion.v1_9_4, 0x4C));
+		
+		registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutRemoveEntityEffect.class, new ProtocollId(BigClientVersion.v1_8, 0x1E), new ProtocollId(BigClientVersion.v1_9, 0x31), new ProtocollId(BigClientVersion.v1_10, 0x31));
+		registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutGameStateChange.class, new ProtocollId(BigClientVersion.v1_8, 0x2B), new ProtocollId(BigClientVersion.v1_9, 0x1E), new ProtocollId(BigClientVersion.v1_10, 0x1E));// -> 0x31
+		
+		registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutPlayerInfo.class, new ProtocollId(BigClientVersion.v1_8, 0x38), new ProtocollId(BigClientVersion.v1_9, 0x2D), new ProtocollId(BigClientVersion.v1_10, 0x2D));// -> 0x2D
+		
+		registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutHeldItemSlot.class, new ProtocollId(BigClientVersion.v1_8, 0x09), new ProtocollId(BigClientVersion.v1_9, 0x37), new ProtocollId(BigClientVersion.v1_10, 0x37));// -> 0x37
+		registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutUpdateSign.class, new ProtocollId(BigClientVersion.v1_8, 0x33)); // 1.9 -> TitleEntityNBTData ;)
+		
+		registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutBossBar.class, new ProtocollId(BigClientVersion.v1_9, 0x0C), new ProtocollId(BigClientVersion.v1_10, 0x0C)); // Only 1.9 :) Best Bar-Update Ever!
+		
+		registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutNamedSoundEffect.class, new ProtocollId(BigClientVersion.v1_8, 0x29), new ProtocollId(BigClientVersion.v1_9, 0x19), new ProtocollId(ProtocollVersion.v1_9_4, 0x19), new ProtocollId(BigClientVersion.v1_10, 0x19)); // Changed
+		//registerPacket(Protocol.GAME, Direction.TO_CLIENT, null, new ProtocollId(ProtocollVersion.v1_9_4, 0x19));
+		
+		registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutNamedEntitySpawn.class, new ProtocollId(BigClientVersion.v1_8, 0x0C), new ProtocollId(BigClientVersion.v1_9, 0x05), new ProtocollId(BigClientVersion.v1_10, 0x05));
+		registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutTitle.class, new ProtocollId(BigClientVersion.v1_8, 0x45), new ProtocollId(BigClientVersion.v1_9, 0x45), new ProtocollId(BigClientVersion.v1_10, 0x45));
+		// registerPacket(Protocol.GAME, Direction.TO_CLIENT, 0x21, PacketPlayOutMapChunk.class, new ProtocollId(BigClientVersion.v1_8, 0x00), new ProtocollId(BigClientVersion.v1_9, 0x00), new ProtocollId(BigClientVersion.v1_10, 0x00); //TODO Chunk Serelizer (Premium bungee src)
+		// registerPacket(Protocol.GAME, Direction.TO_CLIENT, 0x26, PacketPlayOutMapChunkBulk.class, new ProtocollId(BigClientVersion.v1_8, 0x00), new ProtocollId(BigClientVersion.v1_9, 0x00), new ProtocollId(BigClientVersion.v1_10, 0x00); //TODO Chunk Serelizer (Premium bungee src)
+		
+		registerPacket(Protocol.GAME, Direction.TO_SERVER, PacketPlayInClientState.class, new ProtocollId(BigClientVersion.v1_8, 0x16), new ProtocollId(BigClientVersion.v1_9, 0x03), new ProtocollId(BigClientVersion.v1_10, 0x03)); // Changed
+		//
+		registerPacket(Protocol.GAME, Direction.TO_SERVER, PacketPlayInPluginMessage.class,new ProtocollId(BigClientVersion.v1_8, 0x17),  new ProtocollId(BigClientVersion.v1_9, 0x09), new ProtocollId(BigClientVersion.v1_10, 0x09));
+		
+		registerPacket(Protocol.GAME, Direction.TO_SERVER, PacketPlayInChat.class, new ProtocollId(BigClientVersion.v1_8, 0x01), new ProtocollId(BigClientVersion.v1_9, 0x02), new ProtocollId(BigClientVersion.v1_10, 0x02)); // -> 0x02
+		registerPacket(Protocol.GAME, Direction.TO_SERVER, PacketPlayInUseEntity.class, new ProtocollId(BigClientVersion.v1_8, 0x02), new ProtocollId(BigClientVersion.v1_9, 0x0A), new ProtocollId(BigClientVersion.v1_10, 0x0A)); // -> changed
+		registerPacket(Protocol.GAME, Direction.TO_SERVER, PacketPlayInHeldItemSlot.class, new ProtocollId(BigClientVersion.v1_8, 0x09), new ProtocollId(BigClientVersion.v1_9, 0x17), new ProtocollId(BigClientVersion.v1_10, 0x17));// -> 0x17
+		
+		registerPacket(Protocol.GAME, Direction.TO_SERVER, PacketPlayInPosition.class, new ProtocollId(BigClientVersion.v1_8, 0x04), new ProtocollId(BigClientVersion.v1_9, 0x0C), new ProtocollId(BigClientVersion.v1_10, 0x0C));// -> 0x0C
+		registerPacket(Protocol.GAME, Direction.TO_SERVER, PacketPlayInPositionLook.class, new ProtocollId(BigClientVersion.v1_8, 0x06), new ProtocollId(BigClientVersion.v1_9, 0x0D), new ProtocollId(BigClientVersion.v1_10, 0x0D));// -> 0x0D
+		registerPacket(Protocol.GAME, Direction.TO_SERVER, PacketPlayInLook.class, new ProtocollId(BigClientVersion.v1_8, 0x05), new ProtocollId(BigClientVersion.v1_9, 0x0E), new ProtocollId(BigClientVersion.v1_10, 0x0E));// -> 0x0E
+		
+		registerPacket(Protocol.GAME, Direction.TO_SERVER, PacketPlayInWindowClick.class, new ProtocollId(BigClientVersion.v1_8, 0x0E), new ProtocollId(BigClientVersion.v1_9, 0x07), new ProtocollId(BigClientVersion.v1_10, 0x07)); // 0x07
+		registerPacket(Protocol.GAME, Direction.TO_SERVER, PacketPlayInCloseWindow.class, new ProtocollId(BigClientVersion.v1_8, 0x0D), new ProtocollId(BigClientVersion.v1_9, 0x08), new ProtocollId(BigClientVersion.v1_10, 0x08)); // 0x08
+		registerPacket(Protocol.GAME, Direction.TO_SERVER, PacketPlayInBlockDig.class, new ProtocollId(BigClientVersion.v1_8, 0x07), new ProtocollId(BigClientVersion.v1_9, 0x13), new ProtocollId(BigClientVersion.v1_10, 0x13)); // 0x13
+		
+		registerPacket(Protocol.GAME, Direction.TO_SERVER, PacketPlayInArmAnimation.class, new ProtocollId(BigClientVersion.v1_8, 0x0A), new ProtocollId(BigClientVersion.v1_9, 0x1A), new ProtocollId(BigClientVersion.v1_10, 0x1A));
+		registerPacket(Protocol.GAME, Direction.TO_SERVER, PacketPlayInBlockPlace.class, new ProtocollId(BigClientVersion.v1_8, 0x08), new ProtocollId(BigClientVersion.v1_9, 0x1C), new ProtocollId(BigClientVersion.v1_10, 0x1C));
+		// TODO Make it working! registerPacket(Protocol.GAME, Direction.TO_SERVER, 0x12, PacketPlayInUpdateSign.class, new ProtocollId(BigClientVersion.v1_8, 0x00), new ProtocollId(BigClientVersion.v1_9, 0x00), new ProtocollId(BigClientVersion.v1_10, 0x00); //Changed from ChatComponent to String
+	}
+	
+	public static int calculate(ProtocollVersion version, Protocol p, Direction d, Integer id) {
+		return getCreator().calculate(version, p, d, id);
+	}
+	
+	public static int getPacketId(int base) {
+		return getCreator().getPacketId(base);
+	}
+	
+	public static Protocol getProtocoll(int base) {
+		return getCreator().getProtocoll(base);
+	}
+	
+	public static Direction getDirection(int base) {
+		return getCreator().getDirection(base);
+	}
+	
+	public static Packet getPacket(ProtocollVersion version, Protocol s, Direction d, ByteBuf b, Player p) {
+		return getCreator().getPacket(version, s, d, b, p);
+	}
+	
+	public static void listPackets(CostumPrintStream out) {
+		getCreator().listPackets(out);
+	}
+	
+	public static void listPackets() {
+		getCreator().listPackets();
+	}
+	
+	public static int loadPacket(ProtocollVersion version, Protocol p, Direction d, Integer id, Class<? extends Packet> clazz) {
+		return getCreator().loadPacket(version, p, d, id, clazz);
+	}
+	
+	@Deprecated
+	public static void registerPacket(Protocol p, Direction d, Integer v1_8_id, Integer v1_9_id, Class<? extends Packet> clazz) {
+		if (v1_8_id == null && v1_9_id == null) throw new RuntimeException("All packet ids are null!");
+		if (v1_8_id == null) v1_8_id = -1;
+		if (v1_9_id == null) v1_9_id = -1;
+		registerPacket(p, d, clazz, new ProtocollId(BigClientVersion.v1_8, v1_8_id), new ProtocollId(BigClientVersion.v1_9, v1_9_id));
+	}
+	
+	public static void registerPacket(Protocol p, Direction d, Class<? extends Packet> clazz, ProtocollId... ids) {
+		getCreator().registerPacket(p, d, clazz, ids);
+	}
+	
+	public static void unregisterPacket(ProtocollVersion version, Protocol p, Direction d, Integer id) {
+		getCreator().unregisterPacket(version, p, d, id);
+	}
+	
+	public static int countPackets() {
+		return getCreator().countPackets();
+	}
+	
+	public static int getPacketId(ProtocollVersion version, Class<? extends Packet> clazz) {
+		return getCreator().getPacketId(version, clazz);
+	}
+	
+	public static List<Class<? extends Packet>> getRegisteredPackets() {
+		return getCreator().getRegisteredPackets();
+	}
+	
+	/*
+	 * -------------------------------------------------------------------------
+	 * ------------------------------
+	 */
+	
+	private int compressedId = -1;
+	private transient ClientVersion version = ClientVersion.UnderknownVersion;
+	private ClientVersion readedVersion = ClientVersion.UnderknownVersion;
+	private ClientVersion writtenVersion = ClientVersion.UnderknownVersion;
+	
+	protected Packet setcompressedId(int id) {
+		this.compressedId = id;
+		return this;
+	}
+	
+	public Packet() {
+		classInstances.addAndGet(1);
+	}
+	
+	public Packet(int id) {
+		this();
+	}
+	
+	public Packet(byte id) {
+		this();
+	}
+	
+	public Protocol getProtocol() {
+		if (compressedId == -1) compressedId = getPacketId(version.getProtocollVersion(), this.getClass());
+		return getProtocoll(compressedId);
+	}
+	
+	public ByteBuf getByteBuf(ClientVersion version) {
+		this.version = version;
+		compressedId = getPacketId(version.getProtocollVersion(), this.getClass());
+		return writeToByteBuff(null, version);
+	}
+	
+	public ByteBuf writeToByteBuff(ByteBuf buf, ClientVersion version) {
+		if(getPacketId(compressedId) < 0)
+			throw new RuntimeException("Unexpected packet id ("+getPacketId(compressedId) +")");
+		PacketDataSerializer s;
+		if (buf == null) {
+			buf = ByteBuffCreator.createByteBuff();
+		}
+		if (buf instanceof PacketDataSerializer) {
+			s = (PacketDataSerializer) buf;
+		}
+		else {
+			s = PacketDataSerializer.create(getPacketId(compressedId), version, buf);
+		}
+		this.version = (writtenVersion = version);
+		this.write(s);
+		this.version = ClientVersion.UnderknownVersion;
+		return s;
+	}
+	
+	protected Packet load(ByteBuf b, ClientVersion version) {
+		this.version = (readedVersion = version);
+		read(PacketDataSerializer.create(b, version));
+		this.version = ClientVersion.UnderknownVersion;
+		if (b.readableBytes() != 0) throw new RuntimeException("Did not read all bytes from packet (" + this.getClass().getName() + ")");
+		return this;
+	}
+	
+	public abstract void read(PacketDataSerializer s);
+	
+	public void sendPacket(Player p) {
+		if (this instanceof PacketPlayOut) p.sendPacket((PacketPlayOut) this);
+		else throw new IllegalStateException("PacketPlayIn cant send to player");
+	}
+	
+	public abstract void write(PacketDataSerializer s);
+	
+	@Deprecated
+	protected BigClientVersion getBigVersion() {
+		return version.getBigVersion();
+	}
+	
+	public ClientVersion getReadedVersion() {
+		return readedVersion;
+	}
+	
+	public ClientVersion getWrittenVersion() {
+		return writtenVersion;
+	}
+	
+	@Deprecated
+	protected ClientVersion getVersion() {
+		return version;
+	}
+	
+	@Override
+	protected void finalize() throws Throwable {
+		compressedId = -1;
+		classInstances.addAndGet(-1);
+	}
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketLoginDisconnect.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketLoginDisconnect.java
new file mode 100644
index 0000000..31831c5
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketLoginDisconnect.java
@@ -0,0 +1,36 @@
+package dev.wolveringer.BungeeUtil.packets;
+
+import dev.wolveringer.chat.ChatSerializer;
+import dev.wolveringer.chat.IChatBaseComponent;
+import dev.wolveringer.packet.PacketDataSerializer;
+import dev.wolveringer.util.ByteString;
+
+public class PacketLoginDisconnect extends Packet {
+	private ByteString reson;
+
+	public PacketLoginDisconnect(String reson) {
+		this.reson = new ByteString(reson);
+	}
+
+	public PacketLoginDisconnect() {
+		super(-1);
+	}
+
+	@Override
+	public void read(PacketDataSerializer s) {
+		reson = s.readStringBytes();
+	}
+
+	@Override
+	public void write(PacketDataSerializer s) {
+		s.write(reson);
+	}
+
+	public IChatBaseComponent getReson() {
+		return ChatSerializer.fromJSON(reson.getString());
+	}
+
+	public void setReson(IChatBaseComponent reson) {
+		this.reson = new ByteString(ChatSerializer.toJSONString(reson));
+	}
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInArmAnimation.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInArmAnimation.java
new file mode 100644
index 0000000..b43716f
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInArmAnimation.java
@@ -0,0 +1,45 @@
+package dev.wolveringer.BungeeUtil.packets;
+
+import dev.wolveringer.BungeeUtil.HandType;
+import dev.wolveringer.BungeeUtil.ClientVersion.BigClientVersion;
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayIn;
+import dev.wolveringer.packet.PacketDataSerializer;
+
+public class PacketPlayInArmAnimation extends Packet implements PacketPlayIn {
+	private int id;
+	private int type;
+
+	public PacketPlayInArmAnimation() {
+		super(0x0A);
+	}
+	
+	@Override
+	public void read(PacketDataSerializer s) {
+		if(getBigVersion() == BigClientVersion.v1_7){
+			this.id = s.readInt();
+			this.type = s.readByte();
+		}else if(getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10)
+			this.type = s.readVarInt();
+		else
+			this.type = 0;
+	}
+
+	@Override
+	public void write(PacketDataSerializer s) {
+		if(getBigVersion() == BigClientVersion.v1_7){
+			s.writeInt(id);
+			s.writeByte(type);
+		}
+		else if(getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10)
+			s.writeVarInt(type);
+	}
+	
+	public HandType getArmType() {
+		return HandType.values()[type];
+	}
+
+	@Override
+	public String toString() {
+		return "PacketPlayInArmAnimation [id=" + id + ", type=" + type + "]";
+	}
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInBlockDig.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInBlockDig.java
new file mode 100644
index 0000000..d57d602
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInBlockDig.java
@@ -0,0 +1,76 @@
+package dev.wolveringer.BungeeUtil.packets;
+
+import dev.wolveringer.BungeeUtil.ClientVersion;
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayIn;
+import dev.wolveringer.api.position.BlockPosition;
+import dev.wolveringer.packet.PacketDataSerializer;
+
+public class PacketPlayInBlockDig extends Packet implements PacketPlayIn {
+	public static enum State {
+		START_DIGGING,
+		END_DIGGING,
+		FINISH_DIGGING,
+		DROP_ITEMSTACK,
+		DROP_ITEM,
+		SHOT_ARROW,
+		SWARM_HAND;
+	}
+	private State state;
+	private BlockPosition loc;
+	private int face;
+	
+	public PacketPlayInBlockDig() {
+		super(0x07);
+	}
+	
+	@Override
+	public void read(PacketDataSerializer s) {
+		if (getVersion().getVersion() <= ClientVersion.v1_8_0.getVersion()) {
+			state = State.values()[s.readByte()];
+		} else {
+			state = State.values()[s.readVarInt()];
+		}
+		loc = s.readBlockPosition();
+		face = s.readUnsignedByte();
+	}
+	
+	@Override
+	public void write(PacketDataSerializer s) {
+		if (getVersion().getVersion() <= ClientVersion.v1_8_0.getVersion()) {
+			s.writeByte(state.ordinal());
+		} else {
+			s.writeVarInt(state.ordinal());
+		}
+		s.writeBlockPosition(loc);
+		s.writeByte(face);
+	}
+
+	public State getState() {
+		return state;
+	}
+
+	public void setState(State state) {
+		this.state = state;
+	}
+
+	public BlockPosition getLocation() {
+		return loc;
+	}
+
+	public void setLocation(BlockPosition loc) {
+		this.loc = loc;
+	}
+
+	public int getFace() {
+		return face;
+	}
+
+	public void setFace(int face) {
+		this.face = face;
+	}
+
+	@Override
+	public String toString() {
+		return "PacketPlayInBlockDig [state=" + state + ", loc=" + loc + ", face=" + face + "]";
+	}
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInBlockPlace.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInBlockPlace.java
new file mode 100644
index 0000000..5f1245b
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInBlockPlace.java
@@ -0,0 +1,93 @@
+package dev.wolveringer.BungeeUtil.packets;
+
+import dev.wolveringer.BungeeUtil.HandType;
+import dev.wolveringer.BungeeUtil.ClientVersion.BigClientVersion;
+import dev.wolveringer.BungeeUtil.item.Item;
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayIn;
+import dev.wolveringer.api.position.BlockPosition;
+import dev.wolveringer.api.position.Vector3f;
+import dev.wolveringer.packet.PacketDataSerializer;
+
+public class PacketPlayInBlockPlace extends Packet implements PacketPlayIn {
+	private BlockPosition loc;
+	private int face;
+	private int hand = 0;
+	private Item item;
+	private Vector3f cursorPosition;
+
+	public PacketPlayInBlockPlace() {}
+
+	@Override
+	public void read(PacketDataSerializer s) {
+		loc = s.readBlockPosition();
+		face = (getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10) ? s.readVarInt() : s.readUnsignedByte();
+		if(getBigVersion() == BigClientVersion.v1_9  || getBigVersion() == BigClientVersion.v1_10)
+			hand = s.readVarInt();
+		if(face == 255)
+			loc.setY(255);
+		if(getBigVersion() == BigClientVersion.v1_8)
+			item = s.readItem();
+		cursorPosition = new Vector3f((float) s.readUnsignedByte() / 16.0F, (float) s.readUnsignedByte() / 16.0F, (float) s.readUnsignedByte() / 16.0F);
+	}
+
+	@Override
+	public void write(PacketDataSerializer s) {
+		s.writeBlockPosition(loc);
+		if(getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10)
+			s.writeVarInt(face);
+		else
+			s.writeByte(face);
+		if(getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10)
+			s.writeVarInt(hand);
+		if(getBigVersion() == BigClientVersion.v1_8)
+			s.writeItem(item);
+		s.writeByte((int) (cursorPosition.getX() * 16.0F));
+		s.writeByte((int) (cursorPosition.getY() * 16.0F));
+		s.writeByte((int) (cursorPosition.getZ() * 16.0F));
+	}
+
+	public HandType getHand() {
+		return HandType.values()[hand];
+	}
+	
+	public void setHand(HandType hand) {
+		this.hand = hand.ordinal();
+	}
+	
+	@Override
+	public String toString() {
+		return "PacketPlayInBlockPlace [loc=" + loc + ", face=" + face + ", item=" + item + ", cursorPosition=" + cursorPosition + "]";
+	}
+
+	public BlockPosition getLoc() {
+		return loc;
+	}
+
+	public void setLoc(BlockPosition loc) {
+		this.loc = loc;
+	}
+
+	public int getFace() {
+		return face;
+	}
+
+	public void setFace(int face) {
+		this.face = face;
+	}
+
+	public Item getItem() {
+		return item;
+	}
+
+	public void setItem(Item item) {
+		this.item = item;
+	}
+
+	public Vector3f getCursorPosition() {
+		return cursorPosition;
+	}
+
+	public void setCursorPosition(Vector3f cursorPosition) {
+		this.cursorPosition = cursorPosition;
+	}
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInChat.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInChat.java
new file mode 100644
index 0000000..f5f80d8
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInChat.java
@@ -0,0 +1,39 @@
+package dev.wolveringer.BungeeUtil.packets;
+
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayIn;
+import dev.wolveringer.packet.PacketDataSerializer;
+
+public class PacketPlayInChat extends Packet implements PacketPlayIn {
+	String msg;
+
+	//public PacketPlayInChat() {
+	//	super((byte) 0x01);
+	//}
+	
+	public PacketPlayInChat() {
+		super();
+	}
+
+	public PacketPlayInChat(String c) {
+		super((byte) 0x01);
+		this.msg = c;
+	}
+
+	public String getMessage() {
+		return msg;
+	}
+
+	@Override
+	public void read(PacketDataSerializer s) {
+		msg = s.readString(-1);
+	}
+
+	public void setMessage(String c) {
+		this.msg = c;
+	}
+
+	@Override
+	public void write(PacketDataSerializer s) {
+		s.writeString(msg);
+	}
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInClientState.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInClientState.java
new file mode 100644
index 0000000..fdbf0e4
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInClientState.java
@@ -0,0 +1,26 @@
+package dev.wolveringer.BungeeUtil.packets;
+
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
+import dev.wolveringer.packet.PacketDataSerializer;
+
+public class PacketPlayInClientState extends Packet implements PacketPlayOut{
+	private int state;
+	public PacketPlayInClientState() {
+		super(0x16);
+	}
+	public PacketPlayInClientState(int state) {
+		super(0x16);
+		this.state = state;
+	}
+	@Override
+	public void read(PacketDataSerializer serelizer) {
+		state = serelizer.readVarInt();
+	}
+	@Override
+	public void write(PacketDataSerializer serelizer) {
+		serelizer.writeVarInt(state);
+	}
+	public int getState() {
+		return state;
+	}
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInCloseWindow.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInCloseWindow.java
new file mode 100644
index 0000000..8a613da
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInCloseWindow.java
@@ -0,0 +1,31 @@
+package dev.wolveringer.BungeeUtil.packets;
+
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayIn;
+import dev.wolveringer.packet.PacketDataSerializer;
+
+public class PacketPlayInCloseWindow extends Packet implements PacketPlayIn {
+
+	private int window;
+
+	public PacketPlayInCloseWindow() {
+		super(0x0D);
+	}
+
+	public int getWindow() {
+		return window;
+	}
+
+	@Override
+	public void read(PacketDataSerializer packetdataserializer) {
+		this.window = packetdataserializer.readByte();
+	}
+
+	public void setWindow(int window) {
+		this.window = window;
+	}
+
+	@Override
+	public void write(PacketDataSerializer packetdataserializer) {
+		packetdataserializer.writeByte(this.window);
+	}
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInFlying.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInFlying.java
new file mode 100644
index 0000000..e9085bd
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInFlying.java
@@ -0,0 +1,69 @@
+package dev.wolveringer.BungeeUtil.packets;
+
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayIn;
+import dev.wolveringer.api.position.Location;
+import dev.wolveringer.packet.PacketDataSerializer;
+
+public class PacketPlayInFlying extends Packet implements PacketPlayIn {
+	protected boolean onground;
+	protected boolean hasLook = false;
+	protected boolean hasPos = false;
+	protected Location loc = new Location(0, 0, 0);
+	protected double stance;
+
+	public PacketPlayInFlying() {
+		super(-1);
+	}
+
+	public PacketPlayInFlying(int i) {
+		super(i);
+	}
+
+	public void setLocation(Location loc) {
+		if(loc.getYaw() != 0 || loc.getPitch() != 0)
+			hasLook = true;
+		if(loc.getX() != 0 && loc.getY() != 0 && loc.getZ() != 0)
+			hasPos = true;
+		this.loc = loc;
+	}
+
+	public Location getLocation() {
+		return loc.clone();
+	}
+
+	public boolean hasLook() {
+		return this.hasLook;
+	}
+
+	public boolean hasPos() {
+		return this.hasPos;
+	}
+
+	public boolean onGound() {
+		return this.onground;
+	}
+
+	@Override
+	public void read(PacketDataSerializer s) {
+		this.onground = s.readUnsignedByte() != 0;
+	}
+
+	public double stance() {
+		return this.stance;
+	}
+
+	@Override
+	public void write(PacketDataSerializer s) {
+		s.writeByte(this.onground ? 1 : 0);
+	}
+
+	protected void setOnground(boolean flag) {
+		this.onground = flag;
+	}
+
+	@Override
+	public String toString() {
+		return "PacketPlayInFlying [onground=" + onground + ", hasLook=" + hasLook + ", hasPos=" + hasPos + ", loc=" + loc + ", stance=" + stance + "]";
+	}
+	
+}
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInHeldItemSlot.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInHeldItemSlot.java
new file mode 100644
index 0000000..35f54a4
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInHeldItemSlot.java
@@ -0,0 +1,25 @@
+package dev.wolveringer.BungeeUtil.packets;
+
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayIn;
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayXXXHeldItemSlot;
+import dev.wolveringer.packet.PacketDataSerializer;
+
+public class PacketPlayInHeldItemSlot extends PacketPlayXXXHeldItemSlot implements PacketPlayIn{
+	public PacketPlayInHeldItemSlot() {
+		super(0x09);
+	}
+	
+	public PacketPlayInHeldItemSlot(int slot) {
+		this();
+		setSlot(slot);
+	}
+
+	@Override
+	public void read(PacketDataSerializer s) {
+		setSlot(s.readShort());
+	}
+	@Override
+	public void write(PacketDataSerializer s) {
+		s.writeShort(getSlot());
+	}
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInLook.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInLook.java
new file mode 100644
index 0000000..6c0e297
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInLook.java
@@ -0,0 +1,22 @@
+package dev.wolveringer.BungeeUtil.packets;
+
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayIn;
+import dev.wolveringer.api.position.Location;
+import dev.wolveringer.packet.PacketDataSerializer;
+
+public class PacketPlayInLook extends PacketPlayInFlying implements PacketPlayIn{
+	public PacketPlayInLook() {
+		super(0x05);
+	}
+	@Override
+	public void read(PacketDataSerializer s) {
+		super.setLocation(new Location(0, 0, 0,s.readFloat(),s.readFloat()));
+		super.read(s);
+	}
+	@Override
+	public void write(PacketDataSerializer s) {
+		s.writeFloat(super.getLocation().getYaw());
+		s.writeFloat(super.getLocation().getPitch());
+		super.write(s);
+	}
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInPluginMessage.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInPluginMessage.java
new file mode 100644
index 0000000..2115f27
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInPluginMessage.java
@@ -0,0 +1,86 @@
+package dev.wolveringer.BungeeUtil.packets;
+
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayIn;
+import dev.wolveringer.packet.PacketDataSerializer;
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufInputStream;
+import io.netty.buffer.ByteBufOutputStream;
+import io.netty.buffer.Unpooled;
+import lombok.NoArgsConstructor;
+import org.jsoup.helper.Validate;
+
+@SuppressWarnings("Duplicates")
+@NoArgsConstructor
+public class PacketPlayInPluginMessage extends Packet implements PacketPlayIn{
+	private String channel;
+	private ByteBuf data;
+	private ByteBufOutputStream os;
+	private ByteBufInputStream is;
+//	private int length = -1;
+
+	@Override
+	public void read(PacketDataSerializer s) {
+		int readerIndex = s.readerIndex();
+		try{
+			channel = s.readString(-1);
+			readerIndex = s.readerIndex();
+			if(s.readableBytes() + s.readerIndex() != s.writerIndex()){
+				System.out.println("Incorrect length: "+(s.readableBytes() + s.readerIndex()+" - "+s.writerIndex()));
+			}
+		}catch(Exception e){
+			channel = null;
+			e.printStackTrace();
+			s.readerIndex(readerIndex);
+		}
+		Validate.isTrue(s.readableBytes() == s.writerIndex() - s.readerIndex(), "bytebuf has drunk: " + s.readableBytes() + " " + (s.writerIndex() - s.readerIndex()));
+//		length = s.readableBytes();
+		data = s.readBytes(s.readableBytes());
+//		data = Unpooled.buffer(length);
+//		s.readBytes(data, length);
+	}
+
+	@Override
+	public void write(PacketDataSerializer s) {
+		if(channel != null)
+			s.writeString(channel);
+		try{
+			data.readerIndex(0);
+			int length = data.readableBytes();
+			s.ensureWritable(length, true);
+			s.writeBytes(data, length);
+			data.release();
+		}catch(Exception e){
+			throw e;
+		}
+	}
+	
+	public String getChannel() {
+		return channel;
+	}
+	public void setChannel(String channel) {
+		this.channel = channel;
+	}
+	public ByteBufInputStream getCopiedByteBufInputStream(){
+		return new ByteBufInputStream(data.copy());
+	}
+	
+	public ByteBuf getCopiedbyteBuff(){
+		return data.copy();
+	}
+	
+	public ByteBufInputStream getByteBufInputStream(){
+		if(is == null)
+			is = new ByteBufInputStream(data);
+		return is;
+	}
+	public ByteBufOutputStream getByteBufOutputStream(){
+		if(os == null)
+			os = new ByteBufOutputStream(data);
+		return os;
+	}
+	public void setData(ByteBuf data) {
+		this.data = data;
+		this.os = null;
+		this.is = null;
+	}
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInPosition.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInPosition.java
new file mode 100644
index 0000000..5ed1fa0
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInPosition.java
@@ -0,0 +1,36 @@
+package dev.wolveringer.BungeeUtil.packets;
+
+import dev.wolveringer.BungeeUtil.ClientVersion.BigClientVersion;
+import dev.wolveringer.api.position.Location;
+import dev.wolveringer.packet.PacketDataSerializer;
+
+public class PacketPlayInPosition extends PacketPlayInFlying {
+
+	public PacketPlayInPosition() {
+		super(0x05);
+	}
+	public PacketPlayInPosition(int id) {
+		super(id);
+	}
+
+	@Override
+	public void read(PacketDataSerializer packetdataserializer) {
+		Double x = packetdataserializer.readDouble();
+		Double y = packetdataserializer.readDouble();
+		if(getVersion().getBigVersion() == BigClientVersion.v1_7)
+			this.stance = packetdataserializer.readDouble();
+		Double z = packetdataserializer.readDouble();
+		setLocation(new Location(x, y, z));
+		super.read(packetdataserializer);
+	}
+
+	@Override
+	public void write(PacketDataSerializer packetdataserializer) {
+		packetdataserializer.writeDouble(getLocation().getX());
+		packetdataserializer.writeDouble(getLocation().getY());
+		if(getVersion().getBigVersion() == BigClientVersion.v1_7)
+			packetdataserializer.writeDouble(this.stance);
+		packetdataserializer.writeDouble(getLocation().getZ());
+		super.write(packetdataserializer);
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInPositionLook.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInPositionLook.java
new file mode 100644
index 0000000..56f9625
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInPositionLook.java
@@ -0,0 +1,39 @@
+package dev.wolveringer.BungeeUtil.packets;
+
+import dev.wolveringer.BungeeUtil.ClientVersion.BigClientVersion;
+import dev.wolveringer.api.position.Location;
+import dev.wolveringer.packet.PacketDataSerializer;
+
+public class PacketPlayInPositionLook extends PacketPlayInPosition {
+	
+	public PacketPlayInPositionLook() {}
+	
+	@Override
+	public void read(PacketDataSerializer s) {
+		Double x = s.readDouble();
+		Double y = s.readDouble();
+		if(getVersion().getBigVersion() == BigClientVersion.v1_7)
+			this.stance = s.readDouble();
+		Double z = s.readDouble();
+		setLocation(new Location(x, y, z,s.readFloat(),s.readFloat()));
+		setOnground(s.readByte()==1);
+	}
+
+	@Override
+	public void write(PacketDataSerializer packetdataserializer) {
+		packetdataserializer.writeDouble(getLocation().getX());
+		packetdataserializer.writeDouble(getLocation().getY());
+		if(getVersion().getBigVersion() == BigClientVersion.v1_7)
+			packetdataserializer.writeDouble(this.stance);
+		packetdataserializer.writeDouble(getLocation().getZ());
+		packetdataserializer.writeFloat(getLocation().getYaw());
+		packetdataserializer.writeFloat(getLocation().getPitch());
+		packetdataserializer.writeByte(onGound()?1:0);
+	}
+
+	@Override
+	public String toString() {
+		return "PacketPlayInPositionLook [onground=" + onground + ", hasLook=" + hasLook + ", hasPos=" + hasPos + ", loc=" + loc + ", stance=" + stance + "]";
+	}
+
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInUpdateSign.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInUpdateSign.java
new file mode 100644
index 0000000..c8c3bd0
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInUpdateSign.java
@@ -0,0 +1,46 @@
+package dev.wolveringer.BungeeUtil.packets;
+
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayIn;
+import dev.wolveringer.api.position.BlockPosition;
+import dev.wolveringer.chat.IChatBaseComponent;
+import dev.wolveringer.packet.PacketDataSerializer;
+
+public class PacketPlayInUpdateSign extends Packet implements PacketPlayIn {
+	private BlockPosition loc;
+	private IChatBaseComponent comps[] = new IChatBaseComponent[4];
+	
+	public PacketPlayInUpdateSign() {
+		// TODO Auto-generated constructor stub
+	}
+	
+	@Override
+	public void read(PacketDataSerializer s) {
+		loc = s.readBlockPosition();
+		comps[0] = s.readRawString();
+		comps[1] = s.readRawString();
+		comps[2] = s.readRawString();
+		comps[3] = s.readRawString();
+	}
+	
+	@Override
+	public void write(PacketDataSerializer s) {
+		s.writeBlockPosition(loc);
+		s.writeRawString(comps[0]);
+		s.writeRawString(comps[1]);
+		s.writeRawString(comps[2]);
+		s.writeRawString(comps[3]);
+	}
+	
+	public void setLines(IChatBaseComponent[] comps) {
+		this.comps = comps;
+	}
+	public void setLocation(BlockPosition loc) {
+		this.loc = loc;
+	}
+	public BlockPosition getLoc() {
+		return loc;
+	}
+	public IChatBaseComponent[] getComps() {
+		return comps;
+	}
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInUseEntity.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInUseEntity.java
new file mode 100644
index 0000000..ec8df4a
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInUseEntity.java
@@ -0,0 +1,89 @@
+package dev.wolveringer.BungeeUtil.packets;
+
+import dev.wolveringer.BungeeUtil.ClientVersion.BigClientVersion;
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayIn;
+import dev.wolveringer.api.position.Vector3f;
+import dev.wolveringer.packet.PacketDataSerializer;
+
+public class PacketPlayInUseEntity extends Packet implements PacketPlayIn {
+	public static enum Action {
+		INTERACT,
+		ATTACK,
+		INTERACT_AT;
+	}
+	
+	private int target;
+	private Action action;
+	private Vector3f location;
+	private int hand = 0;
+	
+	public PacketPlayInUseEntity() {
+		super(0x02);
+	}
+	
+	@Override
+	public void read(PacketDataSerializer s) {
+		target = getBigVersion() == BigClientVersion.v1_7 ? s.readInt() : s.readVarInt();
+		action = Action.values()[getBigVersion() == BigClientVersion.v1_7 ? s.readByte() : s.readVarInt()];
+		if ((getBigVersion() == BigClientVersion.v1_8 || getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10) && action == Action.INTERACT_AT) location = new Vector3f(s.readFloat(), s.readFloat(), s.readFloat());
+		if ((getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10) && action != Action.ATTACK) hand = s.readVarInt();
+	}
+	
+	@Override
+	public void write(PacketDataSerializer s) {
+		if (getBigVersion() == BigClientVersion.v1_7) {
+			s.writeInt(target);
+			s.writeByte(action.ordinal());
+		}
+		else if (getBigVersion() == BigClientVersion.v1_8 || getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10) {
+			s.writeVarInt(target);
+			s.writeVarInt(action.ordinal());
+			if (action == Action.INTERACT_AT) {
+				s.writeFloat(location.getX());
+				s.writeFloat(location.getY());
+				s.writeFloat(location.getZ());
+			}
+			if ((getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10) && action != Action.ATTACK) s.writeVarInt(hand);
+		}
+	}
+	
+	public Action getAction() {
+		return action;
+	}
+	
+	public void setAction(Action action) {
+		this.action = action;
+	}
+	
+	public int getTarget() {
+		return target;
+	}
+	
+	public void setTarget(int target) {
+		this.target = target;
+	}
+	
+	public Vector3f getLocation() {
+		return location;
+	}
+	
+	public void setLocation(Vector3f location) {
+		this.location = location;
+	}
+	
+	public int getHand() {
+		return hand;
+	}
+	
+	public void setHand(int hand) {
+		this.hand = hand;
+	}
+	/**
+	 *  
+	 */
+
+	@Override
+	public String toString() {
+		return "PacketPlayInUseEntity [target=" + target + ", action=" + action + ", location=" + location + ", hand=" + hand + "]";
+	}
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInWindowClick.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInWindowClick.java
new file mode 100644
index 0000000..04f57d3
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInWindowClick.java
@@ -0,0 +1,151 @@
+package dev.wolveringer.BungeeUtil.packets;
+
+import dev.wolveringer.BungeeUtil.item.Item;
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayIn;
+import dev.wolveringer.packet.PacketDataSerializer;
+
+public class PacketPlayInWindowClick extends Packet implements PacketPlayIn {
+
+	public static class Mode {
+		private static int getInt(int mode, int button) {
+			return (mode << 4) + button;
+		}
+
+		private static int getMode(int mode) {
+			return mode >> 4;
+		}
+
+		public static boolean isNormalClick(int mode) {
+			return getMode(mode) == 0 || getMode(mode) == 3 || getMode(mode) == 6;
+		}
+
+		public static boolean isShiftClick(int mode) {
+			return getMode(mode) == 1;
+		}
+
+		public static boolean isKey(int mode) {
+			return getMode(mode) == 2;
+		}
+
+		public static boolean inDrop(int mode) {
+			return getMode(mode) == 4;
+		}
+
+		public static boolean isDrag(int mode) {
+			return getMode(mode) == 5;
+		}
+
+		//public static final class Normal {
+			public static final int NORMAL_LEFT_CLICK = getInt(0, 0);
+			public static final int NORMAL_RIGHT_CLICK = getInt(0, 1);
+			public static final int NORMAL_MIDDLE_CLICK = getInt(3, 2);
+			public static final int NORMAL_DOUBLE_CLICK = getInt(6, 0);
+		//}
+
+		//public static final class Shift {
+			public static final int SHIFT_LEFT_CLICK = getInt(1, 0);
+			public static final int SHIFT_RIGHT_CLICK = getInt(1, 1);
+		//}
+
+		//public static final class Key {
+			public static final int KEY_1 = getInt(2, 0);
+			public static final int KEY_2 = getInt(2, 1);
+			public static final int KEY_3 = getInt(2, 2);
+			public static final int KEY_4 = getInt(2, 3);
+			public static final int KEY_5 = getInt(2, 4);
+			public static final int KEY_6 = getInt(2, 5);
+			public static final int KEY_7 = getInt(2, 6);
+			public static final int KEY_8 = getInt(2, 7);
+			public static final int KEY_9 = getInt(2, 8);
+		//}
+
+		//public static final class Drop {
+			public static final int DROP_ITEM = getInt(4, 0);
+			public static final int DROP_ITEM_STACK = getInt(4, 1);
+		//}
+
+		//public static final class Drag {
+			public static final int DRAG_START_LEFT = getInt(5, 0);
+			public static final int DRAG_ADD_LEFT = getInt(5, 1);
+			public static final int DRAG_END_LEFT = getInt(5, 2);
+			public static final int DRAG_START_RIGHT = getInt(5, 4);
+			public static final int DRAG_ADD_RIGHT = getInt(5, 5);
+			public static final int DRAG_END_RIGHT = getInt(5, 6);
+		//}
+	}
+
+	private short actionNumber;
+	private Item item;
+	private int mode = 0;
+	private int slot;
+	private int window;
+
+	public PacketPlayInWindowClick() {
+		super(0x0E);
+	}
+
+	@Override
+	public String toString() {
+		return "PacketPlayInWindowClick [actionNumber=" + actionNumber + ", item=" + item + ", shift=" + mode + ", slot=" + slot + ", window=" + window + "]";
+	}
+
+	public short getActionNumber() {
+		return actionNumber;
+	}
+
+	public Item getItem() {
+		return item;
+	}
+
+	public int getMode() {
+		return mode;
+	}
+
+	public int getSlot() {
+		return slot;
+	}
+
+	public int getWindow() {
+		return window;
+	}
+
+	@Override
+	public void read(PacketDataSerializer s) {
+		this.window = s.readByte();
+		this.slot = s.readShort();
+		this.mode += s.readByte();
+		this.actionNumber = s.readShort();
+		this.mode += s.readByte() << 4;
+		this.item = s.readItem();
+	}
+
+	public void setActionNumber(short actionNumber) {
+		this.actionNumber = actionNumber;
+	}
+
+	public void setItem(Item item) {
+		this.item = item;
+	}
+
+	public void setMode(int mode) {
+		this.mode = mode;
+	}
+
+	public void setSlot(int slot) {
+		this.slot = slot;
+	}
+
+	public void setWindow(int window) {
+		this.window = window;
+	}
+
+	@Override
+	public void write(PacketDataSerializer s) {
+		s.writeByte(this.window);
+		s.writeShort(this.slot);
+		s.writeByte(this.mode & 0x0F);
+		s.writeShort(this.actionNumber);
+		s.writeByte(this.mode >> 4);
+		s.writeItem(this.item);
+	}
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutBossBar.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutBossBar.java
new file mode 100644
index 0000000..2f019fc
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutBossBar.java
@@ -0,0 +1,182 @@
+package dev.wolveringer.BungeeUtil.packets;
+
+import java.util.UUID;
+
+import dev.wolveringer.BungeeUtil.ClientVersion.BigClientVersion;
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
+import dev.wolveringer.chat.IChatBaseComponent;
+import dev.wolveringer.packet.PacketDataSerializer;
+
+public class PacketPlayOutBossBar extends Packet implements PacketPlayOut{
+	public static enum Action {
+		CREATE,
+		DELETE,
+		UPDATE_HEALTH,
+		UPDATE_TITLE,
+		UPDATE_STYLE,
+		UPDATE_FLAGS;
+		
+		private Action() {}
+	}
+	public static enum BarColor {
+		PING,
+		BLUE,
+		RED,
+		GREEN,
+		YELLOW,
+		PURPLE,
+		WHITE;
+		
+		private BarColor() {}
+	}
+	public static enum BarDivision {
+		NO_DIVISION,
+		SIX_DIVISIONS,
+		TEN_DIVISIONS,
+		TWELF_DIVISIONS,
+		TWENTY_DIVISIONS;
+	}
+	private UUID barId;
+	private Action action;
+	
+	private IChatBaseComponent title;
+	private float health;
+	private BarColor color;
+	private BarDivision division;
+	private short flags;
+	
+	@SuppressWarnings("incomplete-switch")
+	@Override
+	public void read(PacketDataSerializer s) {
+		if(getBigVersion() == BigClientVersion.v1_8)
+			throw new RuntimeException("BossBar packet is 1.9-1.10 only!");
+		barId = s.readUUID();
+		int action = s.readVarInt();
+		if(action >= Action.values().length){
+			System.out.println("Boss bar wrong..... BarId: "+barId);
+			System.out.println("Avariable data: "+s.readableBytes());
+			s.skipBytes(s.readableBytes());
+		}
+		this.action = Action.values()[action];
+		switch (this.action) {
+			case CREATE:
+				title = s.readRawString();
+				health = s.readFloat();
+				color = BarColor.values()[s.readVarInt()];
+				division = BarDivision.values()[s.readVarInt()];
+				flags = s.readUnsignedByte();
+				break;
+			case UPDATE_HEALTH:
+				health = s.readFloat();
+				break;
+			case UPDATE_TITLE:
+				title = s.readRawString();
+				break;
+			case UPDATE_STYLE:
+				color = BarColor.values()[s.readVarInt()];
+				division = BarDivision.values()[s.readVarInt()];
+				break;
+			case UPDATE_FLAGS:
+				flags = s.readUnsignedByte();
+				break;
+		}
+	}
+
+	@Override
+	public void write(PacketDataSerializer s) {
+		if(getBigVersion() == BigClientVersion.v1_8)
+			throw new RuntimeException("BossBar packet is 1.9-1.10 only!");
+		s.writeUUID(barId);
+		s.writeVarInt(action.ordinal());
+		switch (action) {
+			case CREATE:
+				s.writeRawString(title);
+				s.writeFloat(health);
+				s.writeVarInt(color.ordinal());
+				s.writeVarInt(division.ordinal());
+				s.writeByte(flags);
+				break;
+			case UPDATE_HEALTH:
+				s.writeFloat(health);
+				break;
+			case UPDATE_TITLE:
+				s.writeRawString(title);
+				break;
+			case UPDATE_STYLE:
+				s.writeVarInt(color.ordinal());
+				s.writeVarInt(division.ordinal());
+				break;
+			case UPDATE_FLAGS:
+				s.writeByte(flags);
+				break;
+		}
+	}
+
+	public UUID getBarId() {
+		return barId;
+	}
+
+	public PacketPlayOutBossBar setBarId(UUID barId) {
+		this.barId = barId;
+		return this;
+	}
+
+	public Action getAction() {
+		return action;
+	}
+
+	public PacketPlayOutBossBar setAction(Action action) {
+		this.action = action;
+		return this;
+	}
+
+	public IChatBaseComponent getTitle() {
+		return title;
+	}
+
+	public PacketPlayOutBossBar setTitle(IChatBaseComponent title) {
+		this.title = title;
+		return this;
+	}
+
+	public float getHealth() {
+		return health;
+	}
+
+	public PacketPlayOutBossBar setHealth(float health) {
+		this.health = health;
+		return this;
+	}
+
+	public BarColor getColor() {
+		return color;
+	}
+
+	public PacketPlayOutBossBar setColor(BarColor color) {
+		this.color = color;
+		return this;
+	}
+
+	public BarDivision getDivision() {
+		return division;
+	}
+
+	public PacketPlayOutBossBar setDivision(BarDivision division) {
+		this.division = division;
+		return this;
+	}
+
+	public short getFlags() {
+		return flags;
+	}
+
+	public PacketPlayOutBossBar setFlags(short flags) {
+		this.flags = flags;
+		return this;
+	}
+
+	@Override
+	public String toString() {
+		return "PacketPlayOutBossBar [barId=" + barId + ", action=" + action + ", title=" + title + ", health=" + health + ", color=" + color + ", division=" + division + ", flags=" + flags + "]";
+	}
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutChat.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutChat.java
new file mode 100644
index 0000000..8e5f957
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutChat.java
@@ -0,0 +1,61 @@
+package dev.wolveringer.BungeeUtil.packets;
+
+import dev.wolveringer.BungeeUtil.ClientVersion.BigClientVersion;
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
+import dev.wolveringer.chat.ChatSerializer;
+import dev.wolveringer.chat.IChatBaseComponent;
+import dev.wolveringer.packet.PacketDataSerializer;
+import dev.wolveringer.util.ByteString;
+
+public class PacketPlayOutChat extends BetaPacket implements PacketPlayOut {
+
+	private byte modus = 0;
+	private ByteString data;
+
+	public PacketPlayOutChat() {
+		super(0x02);
+	}
+
+	public PacketPlayOutChat(IChatBaseComponent msg) {
+		super(0x02);
+		data = new ByteString(ChatSerializer.toJSONString(msg));
+	}
+
+	public IChatBaseComponent getMessage() {
+		return ChatSerializer.fromJSON(data.getString());
+	}
+
+	public void setModus(byte modus) {
+		this.modus = modus;
+	}
+
+	public byte getModus() {
+		return modus;
+	}
+
+	@Override
+	public void read(PacketDataSerializer s) {
+		data = s.readStringBytes();
+		if(getVersion().getBigVersion() == BigClientVersion.v1_8 || getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10)
+			modus = s.readByte();
+	}
+
+	public void setMessage(IChatBaseComponent c) {
+		this.data = new ByteString(ChatSerializer.toJSONString(c));
+	}
+
+	@Override
+	public void write(PacketDataSerializer s) {
+		s.writeStringBytes(data);
+		if(getVersion().getBigVersion() == BigClientVersion.v1_8 || getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10)
+			s.writeByte(modus);
+	}
+
+	public void setRawMessage(byte[] raw) {
+		this.data = new ByteString(raw);
+	}
+
+	public byte[] getRawMessage() {
+		return this.data.getBytes();
+	}
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutCloseWindow.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutCloseWindow.java
new file mode 100644
index 0000000..d3ebaf0
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutCloseWindow.java
@@ -0,0 +1,36 @@
+package dev.wolveringer.BungeeUtil.packets;
+
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
+import dev.wolveringer.packet.PacketDataSerializer;
+
+public class PacketPlayOutCloseWindow extends Packet implements PacketPlayOut{
+
+	private int window;
+
+	public PacketPlayOutCloseWindow() {
+		super(0x2E);
+	}
+
+	public PacketPlayOutCloseWindow(int window) {
+		super(0x2E);
+		this.window = window;
+	}
+
+	public int getWindow() {
+		return window;
+	}
+
+	@Override
+	public void read(PacketDataSerializer s) {
+		this.window = s.readUnsignedByte();
+	}
+
+	public void setWindow(int window) {
+		this.window = window;
+	}
+
+	@Override
+	public void write(PacketDataSerializer s) {
+		s.writeByte(this.window);
+	}
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutDisconnect.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutDisconnect.java
new file mode 100644
index 0000000..958e1f3
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutDisconnect.java
@@ -0,0 +1,33 @@
+package dev.wolveringer.BungeeUtil.packets;
+
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
+import dev.wolveringer.chat.ChatSerializer;
+import dev.wolveringer.chat.IChatBaseComponent;
+import dev.wolveringer.packet.PacketDataSerializer;
+
+public class PacketPlayOutDisconnect extends Packet implements PacketPlayOut{
+
+	private String c;
+	
+	public PacketPlayOutDisconnect() {
+	}
+	
+	public PacketPlayOutDisconnect(IChatBaseComponent c) {
+		this.c = ChatSerializer.toJSONString(c);
+	}
+	
+	@Override
+	public void read(PacketDataSerializer s) {
+		c = s.readString(-1);
+	}
+
+	@Override
+	public void write(PacketDataSerializer s) {
+		s.writeString(c);
+	}
+	
+	public IChatBaseComponent getMessage(){
+		return ChatSerializer.fromJSON(c);
+	}
+	
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutEntityDestroy.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutEntityDestroy.java
new file mode 100644
index 0000000..344f0b5
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutEntityDestroy.java
@@ -0,0 +1,46 @@
+package dev.wolveringer.BungeeUtil.packets;
+
+import dev.wolveringer.BungeeUtil.ClientVersion.BigClientVersion;
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
+import dev.wolveringer.packet.PacketDataSerializer;
+
+public class PacketPlayOutEntityDestroy extends Packet implements PacketPlayOut{
+	private int[] entitys;
+
+	public PacketPlayOutEntityDestroy() {
+	}
+
+	public PacketPlayOutEntityDestroy(int... paramVarArgs) {
+		this.entitys = paramVarArgs;
+	}
+
+	public void read(PacketDataSerializer paramPacketDataSerializer) {
+		this.entitys = new int[getVersion().getBigVersion() == BigClientVersion.v1_7?paramPacketDataSerializer.readByte():paramPacketDataSerializer.readVarInt()];
+		for(int i = 0;i < this.entitys.length;i++){
+			if(getVersion().getBigVersion() == BigClientVersion.v1_7)
+				this.entitys[i] = paramPacketDataSerializer.readInt();
+			else
+				this.entitys[i] = paramPacketDataSerializer.readVarInt();
+		}
+	}
+
+	public void write(PacketDataSerializer paramPacketDataSerializer) {
+		if(getVersion().getBigVersion() == BigClientVersion.v1_7)
+			paramPacketDataSerializer.writeByte(this.entitys.length);
+		else
+			paramPacketDataSerializer.writeVarInt(this.entitys.length);
+		for(int i = 0;i < this.entitys.length;i++){
+			if(getVersion().getBigVersion() == BigClientVersion.v1_7)
+				paramPacketDataSerializer.writeInt(this.entitys[i]);
+			else
+				paramPacketDataSerializer.writeVarInt(this.entitys[i]);
+		}
+	}
+	
+	public int[] getEntitys() {
+		return entitys;
+	}
+	public void setEntitys(int[] entitys) {
+		this.entitys = entitys;
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutEntityEffect.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutEntityEffect.java
new file mode 100644
index 0000000..7c98d7c
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutEntityEffect.java
@@ -0,0 +1,59 @@
+package dev.wolveringer.BungeeUtil.packets;
+
+import dev.wolveringer.BungeeUtil.ClientVersion.BigClientVersion;
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
+import dev.wolveringer.packet.PacketDataSerializer;
+
+public class PacketPlayOutEntityEffect extends Packet implements PacketPlayOut {
+	
+	int entity;
+	int effect;
+	int amplifier;
+	int duration;
+	boolean hidden = false;
+	
+	public PacketPlayOutEntityEffect(int entity, int effect, int amplifier, int duration, boolean hidden) {
+		this();
+		this.entity = entity;
+		this.effect = effect;
+		this.amplifier = amplifier;
+		this.duration = duration;
+		this.hidden = hidden;
+	}
+	
+	public PacketPlayOutEntityEffect() {
+		super(0x1D);
+	}
+	
+	@Override
+	public void read(PacketDataSerializer s) {
+		entity = getVersion().getBigVersion() == BigClientVersion.v1_7 ? s.readInt() : s.readVarInt();
+		effect = s.readByte();
+		amplifier = s.readByte();
+		duration = getVersion().getBigVersion() == BigClientVersion.v1_7 ? s.readShort() : s.readVarInt();
+		hidden = getVersion().getBigVersion() == BigClientVersion.v1_8 ? s.readBoolean() : (getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10) ? s.readByte() == 1 : false;
+	}
+	
+	public void write(PacketDataSerializer s) {
+		if (getVersion().getBigVersion() == BigClientVersion.v1_8 || getVersion().getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10) {
+			s.writeVarInt(entity);
+			s.writeByte(effect);
+			s.writeByte(amplifier);
+			s.writeVarInt(duration);
+			if (getBigVersion() == BigClientVersion.v1_8) s.writeBoolean(hidden);
+			else if (getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10) s.writeByte(hidden == true ? 1 : 0);
+		}
+		else if (getVersion().getBigVersion() == BigClientVersion.v1_7) {
+			s.writeInt(entity);
+			s.writeByte(effect);
+			s.writeByte(amplifier);
+			s.writeShort(duration);
+		}
+	}
+	
+	@Override
+	public String toString() {
+		return "PacketPlayOutEntityEffect [entity=" + entity + ", effect=" + effect + ", amplifier=" + amplifier + ", duration=" + duration + ", hidden=" + hidden + "]";
+	}
+	
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutEntityEquipment.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutEntityEquipment.java
new file mode 100644
index 0000000..1af5bf9
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutEntityEquipment.java
@@ -0,0 +1,74 @@
+package dev.wolveringer.BungeeUtil.packets;
+
+import dev.wolveringer.BungeeUtil.ClientVersion.BigClientVersion;
+import dev.wolveringer.BungeeUtil.item.Item;
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
+import dev.wolveringer.packet.PacketDataSerializer;
+
+public class PacketPlayOutEntityEquipment extends Packet implements PacketPlayOut{
+	public static enum Slot {
+		MAIN_HAND,
+		OFF_HAND,
+		BOOTS,
+		LEGGINS,
+		CHESTPLATE,
+		HEMELT;
+		
+		private Slot() {}
+	}
+	private int eid;
+	private Item item;
+	private Slot slot;
+
+	public PacketPlayOutEntityEquipment() {
+		super(0x04);
+	}
+
+	
+	public PacketPlayOutEntityEquipment(int eid, Item item, Slot slot) {
+		this();
+		this.eid = eid;
+		this.item = item;
+		this.slot = slot;
+	}
+
+
+
+	@Override
+	public void read(PacketDataSerializer s) {
+		eid = s.readVarInt();
+		slot = Slot.values()[(getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10) ? s.readVarInt() : s.readShort()];
+		item= s.readItem();
+	}
+
+	@Override
+	public void write(PacketDataSerializer s) {
+		s.writeVarInt(eid);
+		if(getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10)
+			s.writeVarInt(slot.ordinal());
+		else
+			s.writeShort(slot.ordinal());
+		s.writeItem(item);
+	}
+
+	
+	public int getEntityId() {
+		return eid;
+	}
+	public Item getItem() {
+		return item;
+	}
+	public Slot getSlot() {
+		return slot;
+	}
+	
+	public void setEntityId(int eid) {
+		this.eid = eid;
+	}
+	public void setItem(Item item) {
+		this.item = item;
+	}
+	public void setSlot(Slot slot) {
+		this.slot = slot;
+	}
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutEntityHeadRotation.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutEntityHeadRotation.java
new file mode 100644
index 0000000..ed1ac4c
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutEntityHeadRotation.java
@@ -0,0 +1,40 @@
+package dev.wolveringer.BungeeUtil.packets;
+
+import java.util.Random;
+
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
+import dev.wolveringer.packet.PacketDataSerializer;
+import dev.wolveringer.util.MathUtil;
+
+public class PacketPlayOutEntityHeadRotation extends Packet implements PacketPlayOut{
+	private int entityId;
+	private byte pitch;
+	
+	public PacketPlayOutEntityHeadRotation() {}
+	
+	public PacketPlayOutEntityHeadRotation(int entityId, float pitch) {
+		this.entityId = entityId;
+		this.pitch = (byte)((int)(MathUtil.pitchNormalizer(pitch) * 256.0F / 360.0F));
+	}
+
+
+
+	@Override
+	public void read(PacketDataSerializer s) {
+		entityId = s.readVarInt();
+		pitch = s.readByte();
+	}
+
+	@Override
+	public void write(PacketDataSerializer s) {
+		s.writeVarInt(entityId);
+		s.writeByte(pitch);
+	}
+	
+	public int getEntityId() {
+		return entityId;
+	}
+	public float getPitch() {
+		return pitch / 256.0F * 360.0F;
+	}
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutEntityMetadata.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutEntityMetadata.java
new file mode 100644
index 0000000..31606bf
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutEntityMetadata.java
@@ -0,0 +1,40 @@
+package dev.wolveringer.BungeeUtil.packets;
+
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
+import dev.wolveringer.api.datawatcher.DataWatcher;
+import dev.wolveringer.packet.PacketDataSerializer;
+
+public class PacketPlayOutEntityMetadata extends Packet implements PacketPlayOut {
+	private int id;
+	private DataWatcher meta;
+
+	public PacketPlayOutEntityMetadata() {
+		super(0x1C);
+	}
+
+	public PacketPlayOutEntityMetadata(int id, DataWatcher datawatcher) {
+		this();
+		this.id = id;
+		this.meta = datawatcher;
+	}
+
+	public void read(PacketDataSerializer packetdataserializer) {
+		this.id = packetdataserializer.readInt();
+		this.meta = DataWatcher.createDataWatcher(getBigVersion(),packetdataserializer);
+	}
+
+	public void write(PacketDataSerializer packetdataserializer) {
+		if(getVersion().getVersion() < 16){
+			packetdataserializer.writeInt(this.id);
+		}else{
+			packetdataserializer.writeVarInt(this.id);
+		}
+		meta.write(packetdataserializer);
+	}
+
+	@Override
+	public String toString() {
+		return "PacketPlayOutEntityMetadata@" + System.identityHashCode(this) + "[id=" + id + ", meta=" + meta + "]";
+	}
+	
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutEntityProperties.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutEntityProperties.java
new file mode 100644
index 0000000..d92ad7c
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutEntityProperties.java
@@ -0,0 +1,155 @@
+package dev.wolveringer.BungeeUtil.packets;
+
+import java.util.ArrayList;
+import java.util.UUID;
+
+import dev.wolveringer.BungeeUtil.packets.PacketPlayOutEntityProperties.EntityProperty.EntityPropertyModifier;
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
+import dev.wolveringer.packet.PacketDataSerializer;
+
+public class PacketPlayOutEntityProperties extends Packet implements PacketPlayOut{
+	public static class EntityProperty {
+		public static class EntityPropertyModifier{
+			private UUID uuid;
+			private double amount;
+			private byte operation;
+			
+			public EntityPropertyModifier(UUID uuid, double amount, byte operation) {
+				this.uuid = uuid;
+				this.amount = amount;
+				this.operation = operation;
+			}
+			
+			public double getAmount() {
+				return amount;
+			}
+			public byte getOperation() {
+				return operation;
+			}
+			public UUID getUUID() {
+				return uuid;
+			}
+
+			public void setAmount(double amount) {
+				this.amount = amount;
+			}
+			public void setOperation(byte operation) {
+				this.operation = operation;
+			}
+			public void setUUID(UUID uuid) {
+				this.uuid = uuid;
+			}
+			
+			@Override
+			public int hashCode() {
+				final int prime = 31;
+				int result = 1;
+				long temp;
+				temp = Double.doubleToLongBits(amount);
+				result = prime * result + (int) (temp ^ (temp >>> 32));
+				result = prime * result + operation;
+				result = prime * result + ((uuid == null) ? 0 : uuid.hashCode());
+				return result;
+			}
+
+			@Override
+			public boolean equals(Object obj) {
+				if (this == obj) return true;
+				if (obj == null) return false;
+				if (getClass() != obj.getClass()) return false;
+				EntityPropertyModifier other = (EntityPropertyModifier) obj;
+				if (Double.doubleToLongBits(amount) != Double.doubleToLongBits(other.amount)) return false;
+				if (operation != other.operation) return false;
+				if (uuid == null) {
+					if (other.uuid != null) return false;
+				}
+				else if (!uuid.equals(other.uuid)) return false;
+				return true;
+			}
+		}
+		private String name;
+		private double value;
+		private ArrayList<EntityPropertyModifier> modifiers = new ArrayList<>();
+		
+		public EntityProperty(String name,double value) {
+			this.name = name;
+			this.value = value;
+		}
+		
+		public String getName() {
+			return name;
+		}
+		public void setName(String name) {
+			this.name = name;
+		}
+		public double getValue() {
+			return value;
+		}
+		public void setValue(double value) {
+			this.value = value;
+		}
+		public ArrayList<EntityPropertyModifier> getModifiers() {
+			return modifiers;
+		}
+		public void addModifier(EntityPropertyModifier mod){
+			modifiers.add(mod);
+		}
+		public void removeModifier(EntityPropertyModifier mod){
+			modifiers.add(mod);
+		}
+	}
+	int entity;
+	ArrayList<EntityProperty> properties = new ArrayList<>();
+	
+	public PacketPlayOutEntityProperties() {
+		super(0x20);
+	}
+	
+	@Override
+	public void write(PacketDataSerializer s) {
+		s.writeVarInt(entity);
+		s.writeInt(properties.size());
+		for(EntityProperty prop : properties){
+			s.writeString(prop.getName());
+			s.writeDouble(prop.getValue());
+			s.writeVarInt(prop.getModifiers().size());
+			for(EntityPropertyModifier mod : prop.getModifiers()){
+				s.writeUUID(mod.getUUID());
+				s.writeDouble(mod.getAmount());
+				s.writeByte(mod.getOperation());
+			}
+		}
+	}
+	@Override
+	public void read(PacketDataSerializer s) {
+		entity = s.readVarInt();
+		int pSize = s.readInt();
+		for(int i = 0;i<pSize;i++){
+			EntityProperty prop = new EntityProperty(s.readString(-1), s.readDouble());
+			int mSize = s.readVarInt();
+			if(mSize > 0)
+				for(int j = 0;j<mSize;j++)
+					prop.addModifier(new EntityPropertyModifier(s.readUUID(), s.readDouble(), s.readByte()));
+			properties.add(prop);
+		}
+	}
+	public ArrayList<EntityProperty> getProperties() {
+		return properties;
+	}
+	public PacketPlayOutEntityProperties setProperties(ArrayList<EntityProperty> properties) {
+		this.properties = properties;
+		return this;
+	}
+	public int getEntityID() {
+		return entity;
+	}
+	public PacketPlayOutEntityProperties setEntityID(int entity) {
+		this.entity = entity;
+		return this;
+	}
+	public PacketPlayOutEntityProperties addProperty(EntityProperty prop){
+		properties.add(prop);
+		return this;
+	}
+	
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutEntityTeleport.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutEntityTeleport.java
new file mode 100644
index 0000000..971a389
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutEntityTeleport.java
@@ -0,0 +1,101 @@
+package dev.wolveringer.BungeeUtil.packets;
+
+import dev.wolveringer.BungeeUtil.ClientVersion.BigClientVersion;
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
+import dev.wolveringer.api.position.Location;
+import dev.wolveringer.packet.PacketDataSerializer;
+
+public class PacketPlayOutEntityTeleport extends Packet implements PacketPlayOut {
+	Location loc;
+	int id;
+	private boolean onGround;
+
+	public PacketPlayOutEntityTeleport() {
+		super(0x18);
+	}
+
+	public PacketPlayOutEntityTeleport(int id, Location loc) {
+		this();
+		this.loc = loc.clone();
+		this.id = id;
+	}
+
+	public PacketPlayOutEntityTeleport(int id, Location loc, boolean onGround) {
+		this(id, loc);
+		this.onGround = onGround;
+	}
+
+	public void read(PacketDataSerializer s) {
+		if(getVersion().getVersion() < 16)
+			id = s.readInt();
+		else
+			id = s.readVarInt();
+		if(getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10)
+			loc = new Location(s.readDouble(), s.readDouble(), s.readDouble(),((float)s.readByte())/ 256.0F * 360.0F,((float)s.readByte())/ 256.0F * 360.0F);
+		else
+			loc = new Location(s.readInt(), s.readInt(), s.readInt(), ((float)s.readByte())/ 256.0F * 360.0F,((float)s.readByte())/ 256.0F * 360.0F).dividide(32D);
+		if(getVersion().getVersion() >= 22){
+			onGround = s.readBoolean();
+		}
+	}
+
+	@Override
+	public void write(PacketDataSerializer s) {
+		if(getVersion().getVersion() < 16){
+			s.writeInt(id);
+		}else{
+			s.writeVarInt(id);
+		}
+		if(getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10){
+			s.writeDouble(loc.getX());
+			s.writeDouble(loc.getY());
+			s.writeDouble(loc.getZ());
+			
+			s.writeByte((int) (loc.getYaw() * 256.0F / 360.0F));
+			s.writeByte((int) (loc.getPitch() * 256.0F / 360.0F));
+		}
+		else
+		{
+			loc = loc.multiply(32D);
+			s.writeInt(loc.getBlockX());
+			s.writeInt(loc.getBlockY());
+			s.writeInt(loc.getBlockZ());
+
+			s.writeByte((int) (loc.getYaw() * 256.0F / 360.0F));
+			s.writeByte((int) (loc.getPitch() * 256.0F / 360.0F));
+		}
+		if(getVersion().getVersion() >= 22)
+			s.writeBoolean(this.onGround);
+	}
+
+	public Location getLocation() {
+		return loc.clone();
+	}
+
+	public void setLocation(Location loc) {
+		this.loc = loc.clone();
+	}
+
+	public int getId() {
+		return id;
+	}
+
+	public void setId(int id) {
+		this.id = id;
+	}
+
+	public boolean isOnGround() {
+		return onGround;
+	}
+
+	public void setOnGround(boolean onGround) {
+		this.onGround = onGround;
+	}
+	
+	public static void main(String[] args) {
+		float a = (int) (180F * 256.0F / 360.0F);
+		float b = (int) (a / 256.0F * 360.0F);
+		System.out.println("X: "+a+" Y: "+b);
+	}
+
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutGameStateChange.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutGameStateChange.java
new file mode 100644
index 0000000..921ce86
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutGameStateChange.java
@@ -0,0 +1,44 @@
+package dev.wolveringer.BungeeUtil.packets;
+
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
+import dev.wolveringer.packet.PacketDataSerializer;
+
+public class PacketPlayOutGameStateChange extends Packet implements PacketPlayOut{
+	int state;
+	float value;
+	
+	
+	public PacketPlayOutGameStateChange(int state, float value) {
+		super(0x2B);
+		this.state = state;
+		this.value = value;
+	}
+	
+	public PacketPlayOutGameStateChange() {
+		super(0x2B);
+	}
+	
+	@Override
+	public void read(PacketDataSerializer s) {
+			state = s.readByte();
+			value = s.readFloat();
+	}
+	
+	@Override
+	public void write(PacketDataSerializer s) {
+			s.writeByte(state);
+			s.writeFloat(value);
+	}
+	public float getValue() {
+		return value;
+	}
+	public int getState() {
+		return state;
+	}
+	public void setState(int state) {
+		this.state = state;
+	}
+	public void setValue(float value) {
+		this.value = value;
+	}
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutHeldItemSlot.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutHeldItemSlot.java
new file mode 100644
index 0000000..3fe214b
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutHeldItemSlot.java
@@ -0,0 +1,25 @@
+package dev.wolveringer.BungeeUtil.packets;
+
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayXXXHeldItemSlot;
+import dev.wolveringer.packet.PacketDataSerializer;
+
+
+public class PacketPlayOutHeldItemSlot extends PacketPlayXXXHeldItemSlot implements PacketPlayOut{
+	public PacketPlayOutHeldItemSlot() {
+		super(0x09);
+	}
+	
+	public PacketPlayOutHeldItemSlot(byte slot) {
+		this();
+		setSlot(slot);
+	}
+
+	@Override
+	public void read(PacketDataSerializer s) {
+		setSlot(s.readByte());
+	}
+	public void write(PacketDataSerializer s) {
+		s.writeByte(getSlot());
+	};
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutKeepAlive.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutKeepAlive.java
new file mode 100644
index 0000000..d6a0036
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutKeepAlive.java
@@ -0,0 +1,24 @@
+package dev.wolveringer.BungeeUtil.packets;
+
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
+import dev.wolveringer.packet.PacketDataSerializer;
+
+public class PacketPlayOutKeepAlive extends Packet implements PacketPlayOut{
+	int id;
+	public PacketPlayOutKeepAlive() {
+		super(0x00);
+	}
+	@Override
+	public void read(PacketDataSerializer s) {
+		id = s.readVarInt();
+	}
+	public void write(PacketDataSerializer s) {
+		s.writeVarInt(id);
+	};
+	public int getId() {
+		return id;
+	}
+	public void setId(int id) {
+		this.id = id;
+	}
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutNamedEntitySpawn.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutNamedEntitySpawn.java
new file mode 100644
index 0000000..fcaa0f4
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutNamedEntitySpawn.java
@@ -0,0 +1,160 @@
+package dev.wolveringer.BungeeUtil.packets;
+
+import java.util.Iterator;
+import java.util.UUID;
+
+import dev.wolveringer.BungeeUtil.ClientVersion.BigClientVersion;
+import dev.wolveringer.BungeeUtil.gameprofile.GameProfile;
+import dev.wolveringer.BungeeUtil.gameprofile.Property;
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOutEntityAbstract;
+import dev.wolveringer.api.datawatcher.DataWatcher;
+import dev.wolveringer.api.position.Location;
+import dev.wolveringer.nbt.MathHelper;
+import dev.wolveringer.packet.PacketDataSerializer;
+import dev.wolveringer.packet.PacketDataSerializer_v1_7;
+
+public class PacketPlayOutNamedEntitySpawn extends PacketPlayOutEntityAbstract implements PacketPlayOut{
+	private GameProfile p = new GameProfile(UUID.randomUUID(), ""+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"cError: 201");
+	private UUID uuid;
+	private Location loc;
+	private byte yaw; // yaw / 256*360
+	private byte pitch; // pitch / 256*360
+	private int item_id;
+	private DataWatcher data;
+
+	public PacketPlayOutNamedEntitySpawn() {
+		super(0x0C);
+	}
+
+	public PacketPlayOutNamedEntitySpawn(int id, UUID uuid, Location loc, int hand, DataWatcher w) {
+		super(0x0C);
+		setId(id);
+		this.uuid = uuid;
+		this.loc = loc;
+		this.yaw = ((byte) (int) (loc.getYaw() * 256.0F / 360.0F));
+		this.pitch = ((byte) (int) (loc.getPitch() * 256.0F / 360.0F));
+		this.item_id = hand;
+		this.data = w;
+		this.p = new GameProfile(uuid, ""+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"cError:-202");
+	}
+
+	@SuppressWarnings("deprecation")
+	public PacketPlayOutNamedEntitySpawn(int id, GameProfile profile, Location loc, int hand, DataWatcher w) {
+		super(0x0C);
+		setId(id);
+		this.p = profile;
+		if(profile == null)
+			throw new NullPointerException("Profile cant be null");
+		this.uuid = profile.getId();
+		this.loc = loc;
+		this.yaw = ((byte) (int) (loc.getYaw() * 256.0F / 360.0F));
+		this.pitch = ((byte) (int) (loc.getPitch() * 256.0F / 360.0F));
+		this.item_id = hand;
+		this.data = w;
+	}
+
+	@SuppressWarnings("deprecation")
+	public PacketPlayOutNamedEntitySpawn(int id, UUID uuid, Location loc, GameProfile g, int hand, DataWatcher w) {
+		super(0x0C);
+		setId(id);
+		this.p = g;
+		this.uuid = uuid;
+		this.loc = loc;
+		this.yaw = ((byte) (int) (loc.getYaw() * 256.0F / 360.0F));
+		this.pitch = ((byte) (int) (loc.getPitch() * 256.0F / 360.0F));
+		this.item_id = hand;
+		this.data = w;
+	}
+
+	public void read(PacketDataSerializer paramPacketDataSerializer) {
+		setId(paramPacketDataSerializer.readVarInt());
+		this.uuid = paramPacketDataSerializer.readUUID();
+		if(getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10)
+			loc = new Location(paramPacketDataSerializer.readDouble(), paramPacketDataSerializer.readDouble(), paramPacketDataSerializer.readDouble());
+		else
+			loc = new Location(paramPacketDataSerializer.readInt()/32, paramPacketDataSerializer.readInt()/32, paramPacketDataSerializer.readInt()/32);
+		this.yaw = paramPacketDataSerializer.readByte();
+		this.pitch = paramPacketDataSerializer.readByte();
+		if(getBigVersion() == BigClientVersion.v1_8)
+			this.item_id = paramPacketDataSerializer.readShort();
+		this.data = DataWatcher.createDataWatcher(getBigVersion(),paramPacketDataSerializer);
+	}
+
+	@SuppressWarnings("rawtypes")
+	public void write(PacketDataSerializer paramPacketDataSerializer) {
+		paramPacketDataSerializer.writeVarInt(getId());
+			paramPacketDataSerializer.writeUUID(this.uuid);
+		if(getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10){
+			paramPacketDataSerializer.writeDouble(loc.getX());
+			paramPacketDataSerializer.writeDouble(loc.getY());
+			paramPacketDataSerializer.writeDouble(loc.getZ());
+		}
+		else
+		{
+			paramPacketDataSerializer.writeInt((int)MathHelper.floor(loc.getX() * 32.0D));
+			paramPacketDataSerializer.writeInt((int)MathHelper.floor(loc.getY() * 32.0D));
+			paramPacketDataSerializer.writeInt((int)MathHelper.floor(loc.getZ() * 32.0D));
+		}
+		paramPacketDataSerializer.writeByte(this.yaw);
+		paramPacketDataSerializer.writeByte(this.pitch);
+		if(getBigVersion() == BigClientVersion.v1_8)
+			paramPacketDataSerializer.writeShort(this.item_id);
+		this.data.write(paramPacketDataSerializer);
+	}
+
+	public DataWatcher getData() {
+		return data;
+	}
+
+	public GameProfile getGameProfile() {
+		return p;
+	}
+
+	public void setGameProfile(GameProfile p) {
+		this.p = p;
+	}
+
+	public UUID getUuid() {
+		return uuid;
+	}
+
+	public void setUuid(UUID uuid) {
+		this.uuid = uuid;
+	}
+
+	public Location getLocation() {
+		return loc;
+	}
+	public void setLocation(Location loc) {
+		this.loc = loc;
+	}
+
+	public int getItem_id() {
+		return item_id;
+	}
+
+	public void setItem_id(int item_id) {
+		this.item_id = item_id;
+	}
+
+	public void setData(DataWatcher data) {
+		this.data = data;
+	}
+	
+	public byte getYaw() {
+		return yaw;
+	}
+
+	public void setYaw(byte yaw) {
+		this.yaw = yaw;
+	}
+
+	public byte getPitch() {
+		return pitch;
+	}
+
+	public void setPitch(byte pitch) {
+		this.pitch = pitch;
+	}
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutNamedSoundEffect.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutNamedSoundEffect.java
new file mode 100644
index 0000000..b70f89e
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutNamedSoundEffect.java
@@ -0,0 +1,73 @@
+package dev.wolveringer.BungeeUtil.packets;
+
+import dev.wolveringer.BungeeUtil.ClientVersion.BigClientVersion;
+import dev.wolveringer.BungeeUtil.ClientVersion.ProtocollVersion;
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
+import dev.wolveringer.api.position.Location;
+import dev.wolveringer.api.sound.SoundEffect;
+import dev.wolveringer.packet.PacketDataSerializer;
+import lombok.AllArgsConstructor;
+import lombok.Builder;
+import lombok.Data;
+import lombok.Getter;
+import lombok.Setter;
+import lombok.ToString;
+
+//1.8 -> 0x29
+@Getter
+@Setter
+@Builder
+@AllArgsConstructor
+@ToString
+public class PacketPlayOutNamedSoundEffect extends Packet implements PacketPlayOut{
+	private float volume;
+	private float pitch;
+	private Location loc;
+	private String sound;
+	private int soundCategory;
+	
+	public PacketPlayOutNamedSoundEffect() {}
+
+	@Override
+	public void read(PacketDataSerializer s) {
+		if(getBigVersion().equals(BigClientVersion.v1_10) || getBigVersion().equals(BigClientVersion.v1_9)) {
+			sound = s.readString(-1);
+			soundCategory = s.readVarInt();
+			loc = new Location(s.readInt(), s.readInt(), s.readInt()).dividide(8D);
+			volume = s.readFloat();
+			pitch = getBigVersion() == BigClientVersion.v1_10 ? s.readFloat() : s.readUnsignedByte();
+		} else if(getBigVersion() == BigClientVersion.v1_8) {
+			sound = s.readString(-1);
+			loc = new Location(s.readInt(), s.readInt(), s.readInt()).dividide(8D);
+			volume = s.readFloat();
+			pitch = s.readUnsignedByte();
+		}
+	}
+	
+	@Override
+	public void write(PacketDataSerializer s) {
+		if(getBigVersion().equals(BigClientVersion.v1_10) || getBigVersion().equals(BigClientVersion.v1_9)){
+			s.writeString(sound);
+			s.writeVarInt(soundCategory);
+			loc.multiply(8D);
+			s.writeInt(loc.getBlockX());
+			s.writeInt(loc.getBlockY());
+			s.writeInt(loc.getBlockZ());
+			loc.dividide(8D);
+			s.writeFloat(volume);
+			if(getBigVersion() == BigClientVersion.v1_10)
+				s.writeFloat(pitch);
+			else
+				s.writeByte((int) pitch);
+		} else if(getBigVersion() == BigClientVersion.v1_8){
+			s.writeString(sound);
+			loc.multiply(8D);
+			s.writeInt(loc.getBlockX());
+			s.writeInt(loc.getBlockY());
+			s.writeInt(loc.getBlockZ());
+			loc.dividide(8D);
+			s.writeFloat(volume);
+			s.writeByte((int) pitch);
+		}
+	}
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutOpenWindow.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutOpenWindow.java
new file mode 100644
index 0000000..160f713
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutOpenWindow.java
@@ -0,0 +1,111 @@
+package dev.wolveringer.BungeeUtil.packets;
+
+import dev.wolveringer.BungeeUtil.ClientVersion.BigClientVersion;
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
+import dev.wolveringer.packet.PacketDataSerializer;
+
+public class PacketPlayOutOpenWindow extends Packet implements PacketPlayOut {
+	private int horesID;
+	private boolean horse;
+	private int id;
+	private String name;
+	private int slots;
+	private String type;
+	public boolean UTF_8 = false;
+	
+	public PacketPlayOutOpenWindow() {
+		super(0x2D);
+	}
+	
+	public PacketPlayOutOpenWindow(int id, String type, String name, int slots, boolean ishorse) {
+		super(0x2D);
+		this.id = id;
+		this.type = type + "";
+		this.name = name;
+		this.slots = slots;
+		this.horse = ishorse;
+	}
+	
+	public PacketPlayOutOpenWindow(int id, String type, String name, int slots, int horse_id) {
+		this(id, type, name, slots, true);
+		this.horesID = horse_id;
+	}
+	
+	public int getHoresID() {
+		return horesID;
+	}
+	
+	public int getId() {
+		return id;
+	}
+	
+	public String getName() {
+		return name;
+	}
+	
+	public int getSlots() {
+		return slots;
+	}
+	
+	public String getType() {
+		return type;
+	}
+	
+	public boolean isHorse() {
+		return horse;
+	}
+	
+	@Override
+	public void read(PacketDataSerializer s) {
+		this.id = s.readUnsignedByte();
+		this.type = s.readString(32);
+		this.name = s.readString(-1);
+		this.slots = s.readUnsignedByte();
+		if (type.equalsIgnoreCase("EntityHorse")) this.horesID = s.readInt();
+	}
+	
+	public void setHoresID(int horesID) {
+		this.horesID = horesID;
+	}
+	
+	public void setHorse(boolean horse) {
+		this.horse = horse;
+	}
+	
+	public void setId(int id) {
+		this.id = id;
+	}
+	
+	public void setName(String name) {
+		this.name = name;
+	}
+	
+	public void setSlots(int slots) {
+		this.slots = slots;
+	}
+	
+	public void setType(String type) {
+		this.type = type;
+	}
+	
+	@Override
+	public void write(PacketDataSerializer s) {
+		s.writeByte(this.id);
+		s.writeString(this.type);
+		if (!name.startsWith("{")) {
+			if (!name.startsWith("\"")) name = "\"" + name + "\"";
+			name = "{\"translate\":" + name + "}";
+		}
+		s.writeString(this.name);
+		s.writeByte(this.slots);
+		if (this.type.equals("EntityHorse")) {
+			s.writeInt(this.horesID);
+		}
+	}
+	
+	@Override
+	public String toString() {
+		return "PacketPlayOutOpenWindow [horesID=" + horesID + ", horse=" + horse + ", id=" + id + ", name=" + name + ", slots=" + slots + ", type=" + type + "]";
+	}
+	
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutPlayerInfo.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutPlayerInfo.java
new file mode 100644
index 0000000..e32063b
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutPlayerInfo.java
@@ -0,0 +1,156 @@
+package dev.wolveringer.BungeeUtil.packets;
+
+import java.util.List;
+
+import com.google.common.collect.Lists;
+
+import dev.wolveringer.BungeeUtil.ClientVersion.BigClientVersion;
+import dev.wolveringer.BungeeUtil.gameprofile.GameProfile;
+import dev.wolveringer.BungeeUtil.gameprofile.PlayerInfoData;
+import dev.wolveringer.BungeeUtil.gameprofile.Property;
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
+import dev.wolveringer.chat.ChatSerializer;
+import dev.wolveringer.chat.IChatBaseComponent;
+import dev.wolveringer.packet.PacketDataSerializer;
+
+public class PacketPlayOutPlayerInfo extends Packet implements PacketPlayOut {
+	
+	public static enum EnumPlayerInfoAction {
+		ADD_PLAYER,
+		UPDATE_GAMEMODE,
+		UPDATE_PING,
+		UPDATE_DISPLAY_NAME,
+		REMOVE_PLAYER;
+	}
+	
+	private EnumPlayerInfoAction action;
+	private final List<PlayerInfoData> data = Lists.newArrayList();
+	
+	public boolean profile = true;
+	
+	public PacketPlayOutPlayerInfo() {
+		super(0x38);
+	}
+	
+	public PacketPlayOutPlayerInfo(EnumPlayerInfoAction paramEnumPlayerInfoAction, PlayerInfoData... player) {
+		super(0x38);
+		this.action = paramEnumPlayerInfoAction;
+		for (PlayerInfoData localEntityPlayer : player) {
+			this.data.add(localEntityPlayer);
+		}
+	}
+	
+	public void read(PacketDataSerializer s) {
+		this.action = ((EnumPlayerInfoAction) EnumPlayerInfoAction.values()[s.readVarInt()]);
+		int profiles = s.readVarInt();
+		for (int x = 0; x < profiles; x++) {
+			GameProfile gameporfile = null;
+			int ping = 0;
+			int gamemode = 0;
+			IChatBaseComponent nickname = null;
+			switch (this.action) {
+				case ADD_PLAYER:
+					gameporfile = new GameProfile(s.readUUID(), s.readString(-1));
+					int length = s.readVarInt();
+					for (int n = 0; n < length; n++) {
+						String key = s.readString(-1);
+						String value = s.readString(-1);
+						if (s.readBoolean()) {
+							gameporfile.getProperties().put(key, new Property(key, value, s.readString(-1)));
+						}
+						else {
+							gameporfile.getProperties().put(key, new Property(key, value));
+						}
+					}
+					gamemode = s.readVarInt();
+					ping = s.readVarInt();
+					if (s.readBoolean()) {
+						nickname = ChatSerializer.fromJSON(s.readString(-1));
+					}
+					break;
+				case UPDATE_GAMEMODE:
+					gameporfile = new GameProfile(s.readUUID(), null);
+					gamemode = s.readVarInt();
+					break;
+				case UPDATE_PING:
+					gameporfile = new GameProfile(s.readUUID(), null);
+					ping = s.readVarInt();
+					break;
+				case UPDATE_DISPLAY_NAME:
+					gameporfile = new GameProfile(s.readUUID(), null);
+					if (s.readBoolean()) nickname = s.readRawString();
+					break;
+				case REMOVE_PLAYER:
+					gameporfile = new GameProfile(s.readUUID(), null);
+			}
+			this.data.add(new PlayerInfoData(gameporfile, ping, gamemode, nickname));
+		}
+	}
+	
+	@SuppressWarnings("static-access")
+	public void write(PacketDataSerializer paramPacketDataSerializer) {
+		paramPacketDataSerializer.writeVarInt(this.action.ordinal());
+		paramPacketDataSerializer.writeVarInt(this.data.size());
+		for (PlayerInfoData localPlayerInfoData : this.data) {
+			switch ((this.action.ordinal() + 1)) {
+				case 1:
+					paramPacketDataSerializer.writeUUID(localPlayerInfoData.getGameprofile().getId()); // UUID
+					paramPacketDataSerializer.writeString(localPlayerInfoData.getGameprofile().getName()); // REAL NAME
+					
+					paramPacketDataSerializer.writeVarInt(localPlayerInfoData.getGameprofile().getProperties().size()); // PROPETY-SIZE
+					for (Property localProperty : localPlayerInfoData.getGameprofile().getProperties().values()) {
+						paramPacketDataSerializer.writeString(localProperty.getName()); // PROTETY NAME
+						paramPacketDataSerializer.writeString(localProperty.getValue()); // PROTETY VALUE
+						paramPacketDataSerializer.writeBoolean(localProperty.hasSignature());
+						if (localProperty.hasSignature()) paramPacketDataSerializer.writeString(localProperty.getSignature()); // PROTETY SIGNATURE
+					}
+					
+					paramPacketDataSerializer.writeVarInt(localPlayerInfoData.getGamemode()); // PROTETY GAMEMODE
+					paramPacketDataSerializer.writeVarInt(localPlayerInfoData.getPing());
+					paramPacketDataSerializer.writeBoolean(localPlayerInfoData.getName() != null);
+					if (localPlayerInfoData.getName() != null) {
+						paramPacketDataSerializer.writeRawString(localPlayerInfoData.getName());
+					}
+					break;
+				case 2:
+					paramPacketDataSerializer.writeUUID(localPlayerInfoData.getGameprofile().getId());
+					paramPacketDataSerializer.writeVarInt(localPlayerInfoData.getGamemode());
+					break;
+				case 3:
+					paramPacketDataSerializer.writeUUID(localPlayerInfoData.getGameprofile().getId());
+					paramPacketDataSerializer.writeVarInt(localPlayerInfoData.getPing());
+					break;
+				case 4:
+					paramPacketDataSerializer.writeUUID(localPlayerInfoData.getGameprofile().getId());
+					if (localPlayerInfoData.getName() == null) {
+						paramPacketDataSerializer.writeBoolean(false);
+					}
+					else {
+						paramPacketDataSerializer.writeBoolean(true);
+						paramPacketDataSerializer.writeRawString(localPlayerInfoData.getName());
+					}
+					break;
+				case 5:
+					paramPacketDataSerializer.writeUUID(localPlayerInfoData.getGameprofile().getId());
+			}
+		}
+	}
+	
+	public EnumPlayerInfoAction getAction() {
+		return action;
+	}
+	
+	public void setAction(EnumPlayerInfoAction action) {
+		this.action = action;
+	}
+	
+	public List<PlayerInfoData> getData() {
+		return data;
+	}
+	
+	@Override
+	public String toString() {
+		return "PacketPlayOutPlayerInfo [action=" + action + ", data=" + data + "]";
+	}
+	
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutPlayerListHeaderFooter.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutPlayerListHeaderFooter.java
new file mode 100644
index 0000000..35f8934
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutPlayerListHeaderFooter.java
@@ -0,0 +1,52 @@
+package dev.wolveringer.BungeeUtil.packets;
+
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
+import dev.wolveringer.chat.ChatSerializer;
+import dev.wolveringer.chat.IChatBaseComponent;
+import dev.wolveringer.packet.PacketDataSerializer;
+import dev.wolveringer.util.ByteString;
+
+public class PacketPlayOutPlayerListHeaderFooter extends Packet implements PacketPlayOut {
+	private ByteString header;
+	private ByteString footer;
+
+	public PacketPlayOutPlayerListHeaderFooter() {
+	}
+	
+	public PacketPlayOutPlayerListHeaderFooter(String header,String footer) {
+		setHeader(ChatSerializer.fromMessage(header));
+		setFooter(ChatSerializer.fromMessage(footer));
+	}
+	public PacketPlayOutPlayerListHeaderFooter(IChatBaseComponent header,IChatBaseComponent footer) {
+		setHeader(header);
+		setFooter(footer);
+	}
+
+	@Override
+	public void read(PacketDataSerializer s) {
+		header = s.readStringBytes();
+		footer = s.readStringBytes();
+	}
+
+	@Override
+	public void write(PacketDataSerializer s) {
+		s.writeStringBytes(header);
+		s.writeStringBytes(footer);
+	}
+
+	public IChatBaseComponent getHeader() {
+		return ChatSerializer.fromJSON(header.getString());
+	}
+
+	public IChatBaseComponent getFooter() {
+		return ChatSerializer.fromJSON(footer.getString());
+	}
+
+	public void setHeader(IChatBaseComponent header) {
+		this.header = new ByteString(ChatSerializer.toJSONString(header));
+	}
+
+	public void setFooter(IChatBaseComponent footer) {
+		this.footer = new ByteString(ChatSerializer.toJSONString(footer));
+	}
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutPluginMessage.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutPluginMessage.java
new file mode 100644
index 0000000..3cfa4ec
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutPluginMessage.java
@@ -0,0 +1,82 @@
+package dev.wolveringer.BungeeUtil.packets;
+
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayIn;
+import dev.wolveringer.packet.PacketDataSerializer;
+import lombok.NoArgsConstructor;
+import org.jsoup.helper.Validate;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufInputStream;
+import io.netty.buffer.ByteBufOutputStream;
+import io.netty.buffer.Unpooled;
+
+@SuppressWarnings("Duplicates")
+@NoArgsConstructor
+public class PacketPlayOutPluginMessage extends Packet implements PacketPlayIn{
+	private String channel;
+	private ByteBuf data;
+	private ByteBufOutputStream os;
+	private ByteBufInputStream is;
+//	private int length = -1;
+	
+	@Override
+	public void read(PacketDataSerializer s) {
+		int readerIndex = s.readerIndex();
+		try{
+			channel = s.readString(-1);
+			readerIndex = s.readerIndex();
+			if(s.readableBytes() + s.readerIndex() != s.writerIndex()){
+				System.out.println("Incorrect length: "+(s.readableBytes() + s.readerIndex()+" - "+s.writerIndex()));
+			}
+		}catch(Exception e){
+			channel = null;
+			e.printStackTrace();
+			s.readerIndex(readerIndex);
+		}
+//		length = s.readableBytes();
+		data = s.readBytes(s.readableBytes());
+//		data = Unpooled.buffer(length);
+//		s.readBytes(data, length);
+	}
+
+	@Override
+	public void write(PacketDataSerializer s) {
+		if(channel != null)
+			s.writeString(channel);
+		try{
+			data.readerIndex(0);
+			int length = data.readableBytes();
+			s.ensureWritable(length, true);
+			s.writeBytes(data, length);
+			data.release();
+		}catch(Exception e){
+			System.out.println("out - Buffer: "+data+" - ");
+			throw e;
+		}
+	}
+	
+	public String getChannel() {
+		return channel;
+	}
+	public void setChannel(String channel) {
+		this.channel = channel;
+	}
+	public ByteBufInputStream getCopiedByteBufInputStream(){
+		return new ByteBufInputStream(data.copy());
+	}
+	public ByteBufInputStream getByteBufInputStream(){
+		if(is == null)
+			is = new ByteBufInputStream(data);
+		return is;
+	}
+	public ByteBufOutputStream getByteBufOutputStream(){
+		if(os == null)
+			os = new ByteBufOutputStream(data);
+		return os;
+	}
+	public void setData(ByteBuf data) {
+		this.data = data;
+		this.os = null;
+		this.is = null;
+	}
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutPosition.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutPosition.java
new file mode 100644
index 0000000..07ae819
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutPosition.java
@@ -0,0 +1,70 @@
+package dev.wolveringer.BungeeUtil.packets;
+
+import dev.wolveringer.BungeeUtil.ClientVersion.BigClientVersion;
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
+import dev.wolveringer.api.position.Location;
+import dev.wolveringer.packet.PacketDataSerializer;
+public class PacketPlayOutPosition extends Packet implements PacketPlayOut{
+	private boolean ground;
+	private Location loc;
+	private byte flag;
+	private int teleportId;
+	
+	public PacketPlayOutPosition() {
+		super((byte) 0x08);
+	}
+
+	public PacketPlayOutPosition(Location loc, boolean b) {
+		super((byte) 0x08);
+		this.loc = loc;
+		this.ground = b;
+	}
+
+	public Location getLocation() {
+		return loc;
+	}
+
+	public byte getFlag() {
+		return flag;
+	}
+
+	public void setFlag(byte flag) {
+		this.flag = flag;
+	}
+
+	public int getTeleportId() {
+		return teleportId;
+	}
+	public void setTeleportId(int teleportId) {
+		this.teleportId = teleportId;
+	}
+	
+	@Override
+	public void read(PacketDataSerializer s) {
+		loc = new Location(s.readDouble(), s.readDouble(), s.readDouble(), s.readFloat(), s.readFloat());
+		flag = (byte) s.readUnsignedByte();
+		if(getVersion().getBigVersion() == BigClientVersion.v1_9  || getBigVersion() == BigClientVersion.v1_10)
+			teleportId = s.readVarInt();
+	}
+
+	public void setLocation(Location loc) {
+		this.loc = loc;
+	}
+
+	@Override
+	public void write(PacketDataSerializer s) {
+		s.writeDouble(loc.getX());
+		s.writeDouble(loc.getY());
+		s.writeDouble(loc.getZ());
+		s.writeFloat(loc.getYaw());
+		s.writeFloat(loc.getPitch());
+		s.writeByte(flag);
+		if(getVersion().getBigVersion() == BigClientVersion.v1_9  || getBigVersion() == BigClientVersion.v1_10)
+			s.writeVarInt(teleportId);
+	}
+
+	@Override
+	public String toString() {
+		return "PacketPlayOutPosition [ground=" + ground + ", loc=" + loc + ", flag=" + flag + ", teleportId=" + teleportId + "]";
+	}
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutRemoveEntityEffect.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutRemoveEntityEffect.java
new file mode 100644
index 0000000..926b265
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutRemoveEntityEffect.java
@@ -0,0 +1,50 @@
+package dev.wolveringer.BungeeUtil.packets;
+
+import dev.wolveringer.BungeeUtil.ClientVersion.BigClientVersion;
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
+import dev.wolveringer.packet.PacketDataSerializer;
+
+public class PacketPlayOutRemoveEntityEffect extends Packet implements PacketPlayOut {
+	
+	int entity;
+	int effect;
+	
+	public PacketPlayOutRemoveEntityEffect(int entity, int effect) {
+		super(0x1E);
+		this.entity = entity;
+		this.effect = effect;
+	}
+	
+	public PacketPlayOutRemoveEntityEffect() {
+		super(0x1E);
+	}
+	
+	@Override
+	public void read(PacketDataSerializer s) {
+		entity = s.readVarInt();
+		effect = s.readUnsignedByte();
+	}
+	
+	@Override
+	public void write(PacketDataSerializer s) {
+		s.writeVarInt(entity);
+		s.writeByte(effect);
+	}
+	
+	public int getEntity() {
+		return entity;
+	}
+	
+	public void setEntity(int entity) {
+		this.entity = entity;
+	}
+	
+	public int getEffect() {
+		return effect;
+	}
+	
+	public void setEffect(int effect) {
+		this.effect = effect;
+	}
+	
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutScoreboardDisplayObjective.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutScoreboardDisplayObjective.java
new file mode 100644
index 0000000..c263798
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutScoreboardDisplayObjective.java
@@ -0,0 +1,56 @@
+package dev.wolveringer.BungeeUtil.packets;
+
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
+import dev.wolveringer.packet.PacketDataSerializer;
+
+public class PacketPlayOutScoreboardDisplayObjective extends Packet implements PacketPlayOut{
+	public static enum Position {
+		LIST(0),
+		SIDEBAR(1),
+		BELOW_NAME(2);
+		
+		private int i;
+		private Position(int i) {
+			this.i = i;
+		}
+		public static Position getPosition(int i){
+			for(Position p : values())
+				if(p.i == i)
+					return p;
+			return null;
+		}
+		public int getInt(){
+			return i;
+		}
+	}
+	String name;
+	Position p;
+	
+	public PacketPlayOutScoreboardDisplayObjective() {
+		super(0x3D);
+	}
+	
+	public PacketPlayOutScoreboardDisplayObjective(String name,Position p) {
+		this();
+		this.name = name;
+		this.p = p;
+	}
+	
+	@Override
+	public void read(PacketDataSerializer s) {
+		p = Position.getPosition(s.readByte());
+		name = s.readString(-1);
+	}
+	@Override
+	public void write(PacketDataSerializer s) {
+		s.writeByte(p.i);
+		s.writeString(name);
+	}
+	
+	public String getName() {
+		return this.name;
+	}
+	public Position getPosition() {
+		return this.p;
+	}
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutScoreboardObjective.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutScoreboardObjective.java
new file mode 100644
index 0000000..667c23d
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutScoreboardObjective.java
@@ -0,0 +1,114 @@
+package dev.wolveringer.BungeeUtil.packets;
+
+import dev.wolveringer.BungeeUtil.ClientVersion.BigClientVersion;
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
+import dev.wolveringer.packet.PacketDataSerializer;
+
+public class PacketPlayOutScoreboardObjective extends Packet implements PacketPlayOut {
+	
+	public static enum Action {
+		CREATE(0), REMOVE(1), UPDATE(2);
+		
+		int i;
+		
+		private Action(int i) {
+			this.i = i;
+		}
+		
+		public static Action fromInt(int i) {
+			for (Action a : values())
+				if (a.i == i) return a;
+			return null;
+		}
+	}
+	
+	public static enum Type {
+		INTEGER("integer"), HEARTS("hearts");
+		
+		private String s;
+		
+		private Type(String s) {
+			this.s = s;
+		}
+		
+		public static Type fromString(String s) {
+			for (Type t : values())
+				if (t.s.equalsIgnoreCase(s)) return t;
+			return null;
+		}
+		
+		public String getIdentifire() {
+			return s;
+		}
+	}
+	
+	public PacketPlayOutScoreboardObjective(String scorebordName, Action action, String displayName, Type type) {
+		this();
+		this.scorebordName = scorebordName;
+		this.action = action;
+		this.displayName = displayName;
+		this.type = type;
+	}
+	
+	public PacketPlayOutScoreboardObjective() {
+		super(0x3B);
+	}
+	
+	String scorebordName;
+	Action action;
+	String displayName = "";
+	Type type = Type.INTEGER;
+	
+	@Override
+	public void read(PacketDataSerializer s) {
+		scorebordName = s.readString(-1);
+		action = Action.fromInt(s.readByte());
+		if (action.i != 1) {
+			displayName = s.readString(-1);
+			type = Type.fromString(s.readString(-1));
+		}
+	}
+	
+	@Override
+	public void write(PacketDataSerializer s) {
+		s.writeString(scorebordName);
+		s.writeByte(action.i);
+		if (action.i != 1) {
+			s.writeString(displayName);
+			s.writeString(type.getIdentifire());
+		}
+	}
+	
+	public String getScorebordName() {
+		return scorebordName;
+	}
+	
+	public void setScorebordName(String scorebordName) {
+		this.scorebordName = scorebordName;
+	}
+	
+	public Action getAction() {
+		return action;
+	}
+	
+	public void setAction(Action a) {
+		this.action = a;
+	}
+	
+	public String getDisplayName() {
+		return displayName;
+	}
+	
+	public void setDisplayName(String displayName) {
+		this.displayName = displayName;
+	}
+	
+	public Type getType() {
+		return type;
+	}
+	
+	public void setType(Type type) {
+		this.type = type;
+	}
+	
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutScoreboardScore.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutScoreboardScore.java
new file mode 100644
index 0000000..2254e0c
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutScoreboardScore.java
@@ -0,0 +1,94 @@
+package dev.wolveringer.BungeeUtil.packets;
+
+import dev.wolveringer.BungeeUtil.ClientVersion.BigClientVersion;
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
+import dev.wolveringer.packet.PacketDataSerializer;
+
+public class PacketPlayOutScoreboardScore extends Packet implements PacketPlayOut{
+
+	public static enum Action {
+		CREATE(0),
+		REMOVE(1),
+		UPDATE(0);
+		
+		int i;
+		private Action(int i) {
+			this.i = i;
+		}
+		
+		public static Action fromInt(int i){
+			for(Action a : values())
+				if(a.i == i)
+					return a;
+			return null;
+		}
+	}
+	
+	
+	public PacketPlayOutScoreboardScore(String name, String obj_name, int value, Action action) {
+		this();
+		this.name = name;
+		this.string_name = obj_name;
+		this.value = value;
+		this.action = action;
+	}
+
+	public PacketPlayOutScoreboardScore() {
+		super(0x3C);
+	}
+	
+	String name;
+	String string_name;
+	int value;
+	Action action;
+	
+	@Override
+	public void read(PacketDataSerializer s) {
+		name = s.readString(-1);
+		action = Action.fromInt(s.readByte());
+		string_name = s.readString(-1);
+		if(action.i == 0) value = PacketDataSerializer.readVarInt(s);
+	}
+
+	@Override
+	public void write(PacketDataSerializer s) {
+		s.writeString(name);
+		s.writeByte(action.i);
+		s.writeString(string_name);
+		if(action.i == 0) PacketDataSerializer.writeVarInt(value, s);
+		
+	}
+
+	public String getObjektiveName() {
+		return name;
+	}
+
+	public void setObjektiveName(String name) {
+		this.name = name;
+	}
+
+	public String getScoreName() {
+		return string_name;
+	}
+
+	public void setScoreName(String obj_name) {
+		this.string_name = obj_name;
+	}
+
+	public int getValue() {
+		return value;
+	}
+
+	public void setValue(int value) {
+		this.value = value;
+	}
+
+	public Action getAction() {
+		return action;
+	}
+
+	public void setAction(Action action) {
+		this.action = action;
+	}
+	
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutScoreboardTeam.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutScoreboardTeam.java
new file mode 100644
index 0000000..b312ee8
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutScoreboardTeam.java
@@ -0,0 +1,219 @@
+package dev.wolveringer.BungeeUtil.packets;
+
+import java.util.Arrays;
+
+import net.md_5.bungee.api.ChatColor;
+import net.md_5.bungee.protocol.packet.Team;
+import dev.wolveringer.BungeeUtil.ClientVersion.BigClientVersion;
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
+import dev.wolveringer.packet.PacketDataSerializer;
+
+public class PacketPlayOutScoreboardTeam extends Packet implements PacketPlayOut {
+	public static enum Action {
+		CREATE(0), REMOVE(1), UPDATE(2), PLAYER_ADD(3), PLAYER_REMOVE(4);
+		
+		private int b;
+		
+		private Action(int b) {
+			this.b = b;
+		}
+		
+		public int getAction() {
+			return b;
+		}
+		
+		public static Action fromInt(int x) {
+			for (Action a : values())
+				if (a.getAction() == x) return a;
+			return null;
+		}
+	}
+	
+	public static enum NameTag {
+		VISIABLE("always"), INVISIABLE("never"), TEAM_VISIABLE("hideForOtherTeams"), OTHER_VISIABLE("hideForOwnTeam");
+		
+		private String s;
+		
+		private NameTag(String s) {
+			this.s = s;
+		}
+		
+		public static NameTag fromString(String s) {
+			for (NameTag t : values())
+				if (t.s.equalsIgnoreCase(s)) return t;
+			return null;
+		}
+		
+		public String getIdentifire() {
+			return s;
+		}
+	}
+	
+	String team;
+	Action action;
+	
+	String collisionRule = "always";
+	String displayName;
+	String prefix;
+	String suffix;
+	NameTag tag = NameTag.VISIABLE;
+	int color = -1;
+	int friendly_fire = 0;
+	String[] player;
+	
+	public PacketPlayOutScoreboardTeam() {
+		super(0x3E);
+	}
+	
+	public PacketPlayOutScoreboardTeam(Team t) {
+		super(0x3E);
+		action = Action.fromInt(t.getMode());
+		team = t.getName();
+		displayName = t.getDisplayName();
+		prefix = t.getPrefix();
+		suffix = t.getSuffix();
+		tag = NameTag.fromString(t.getNameTagVisibility());
+		color = t.getColor();
+		friendly_fire = t.getFriendlyFire();
+		player = t.getPlayers();
+	}
+	
+	public PacketPlayOutScoreboardTeam(dev.wolveringer.api.scoreboard.Team team) {
+		super(0x3E);
+		this.team = team.getName();
+		this.displayName = team.getDisplayName();
+		this.prefix = team.getPrefix();
+		this.suffix = team.getSuffix();
+		this.tag = team.getTagVisibility();
+		this.color = team.getColor().ordinal();
+		this.friendly_fire = team.getFriendlyFire();
+		this.player = team.getMember().toArray(new String[0]);
+	}
+	
+	@Override
+	public void write(PacketDataSerializer s) {
+		s.writeString(team);
+		s.writeByte(action.getAction());
+		if (action.getAction() == 0 || action.getAction() == 2) {
+			s.writeString(displayName);
+			s.writeString(prefix);
+			s.writeString(suffix);
+			s.writeByte(friendly_fire);
+			if (tag == null) tag = NameTag.VISIABLE;
+			s.writeString(tag.getIdentifire());
+			if (getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10) s.writeString(collisionRule);
+			s.writeByte(color);
+		}
+		if (action.getAction() == 0 || action.getAction() == 3 || action.getAction() == 4) {
+			s.writeVarInt(player.length);
+			for (String x : player)
+				s.writeString(x);
+		}
+	}
+	
+	public void read(PacketDataSerializer s) {
+		team = s.readString(16);
+		action = Action.fromInt(s.readByte());
+		if (action.getAction() == 0 || action.getAction() == 2) {
+			displayName = s.readString(32);
+			prefix = s.readString(16);
+			suffix = s.readString(16);
+			friendly_fire = s.readByte();
+			tag = NameTag.fromString(s.readString(32));
+			if (getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10) collisionRule = s.readString(-1);
+			color = s.readByte();
+		}
+		if (action.getAction() == 0 || action.getAction() == 3 || action.getAction() == 4) {
+			int i = PacketDataSerializer.readVarInt(s);
+			player = new String[i];
+			for (int x = 0; x < i; x++)
+				player[x] = s.readString(40);
+		}
+		
+	}
+	
+	@Override
+	public String toString() {
+		return "PacketPlayOutScoreboardTeam [team=" + team + ", action=" + action + ", displayName=" + displayName + ", prefix=" + prefix + ", suffix=" + suffix + ", tag=" + tag + ", color=" + color + ", friendly_fire=" + friendly_fire + ", player=" + Arrays.toString(player) + "]";
+	}
+	
+	public String getTeam() {
+		return team;
+	}
+	
+	public void setTeam(String team) {
+		this.team = team;
+	}
+	
+	public Action getAction() {
+		return action;
+	}
+	
+	public void setAction(Action action) {
+		this.action = action;
+	}
+	
+	public String getDisplayName() {
+		return displayName;
+	}
+	
+	public void setDisplayName(String displayName) {
+		this.displayName = displayName;
+	}
+	
+	public String getPrefix() {
+		return prefix;
+	}
+	
+	public void setPrefix(String prefix) {
+		this.prefix = prefix;
+	}
+	
+	public String getSuffix() {
+		return suffix;
+	}
+	
+	public void setSuffix(String suffix) {
+		this.suffix = suffix;
+	}
+	
+	public NameTag getTag() {
+		return tag;
+	}
+	
+	public void setTag(NameTag tag) {
+		this.tag = tag;
+	}
+	
+	public ChatColor getColor() {
+		return ChatColor.values()[color == -1 ? 0 : color];
+	}
+	
+	public void setColor(ChatColor color) {
+		this.color = color.ordinal();
+	}
+	
+	public int isFriendlyFire() {
+		return friendly_fire;
+	}
+	
+	public void setFriendlyFire(int friendly_fire) {
+		this.friendly_fire = friendly_fire;
+	}
+	
+	public String[] getPlayers() {
+		return player;
+	}
+	
+	public void setPlayers(String[] player) {
+		this.player = player;
+	}
+	
+	public String getCollisionRule() {
+		return collisionRule;
+	}
+	
+	public void setCollisionRule(String collisionRule) {
+		this.collisionRule = collisionRule;
+	}
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutSetExperience.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutSetExperience.java
new file mode 100644
index 0000000..d1f3cfa
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutSetExperience.java
@@ -0,0 +1,49 @@
+package dev.wolveringer.BungeeUtil.packets;
+
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
+import dev.wolveringer.packet.PacketDataSerializer;
+
+public class PacketPlayOutSetExperience extends Packet implements PacketPlayOut{
+	float exp;
+	int level;
+	int total;
+	
+	public PacketPlayOutSetExperience() {
+		super(0x1F);
+	}
+	
+	@Override
+	public void read(PacketDataSerializer s) {
+		exp = s.readFloat();
+		level = s.readVarInt();
+		total = s.readVarInt();
+	}
+	@Override
+	public void write(PacketDataSerializer s) {
+		s.writeFloat(exp);
+		s.writeVarInt(level);
+		s.writeVarInt(total);
+	}
+	
+	public float getExp() {
+		return exp;
+	}
+	public int getLevel() {
+		return level;
+	}
+	public int getTotal() {
+		return total;
+	}
+	public PacketPlayOutSetExperience setExp(float exp) {
+		this.exp = exp;
+		return this;
+	}
+	public PacketPlayOutSetExperience setLevel(int level) {
+		this.level = level;
+		return this;
+	}
+	public PacketPlayOutSetExperience setTotal(int total) {
+		this.total = total;
+		return this;
+	}
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutSetSlot.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutSetSlot.java
new file mode 100644
index 0000000..dac7ae8
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutSetSlot.java
@@ -0,0 +1,62 @@
+package dev.wolveringer.BungeeUtil.packets;
+
+import dev.wolveringer.BungeeUtil.item.Item;
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
+import dev.wolveringer.packet.PacketDataSerializer;
+import lombok.NoArgsConstructor;
+
+@NoArgsConstructor
+public class PacketPlayOutSetSlot extends Packet implements PacketPlayOut{
+	private Item ItemStack;
+	private int slot;
+	private int window;
+
+	public PacketPlayOutSetSlot(Item itemstack, int window, int slot) {
+		this.ItemStack = itemstack == null ? null : itemstack;
+		this.window = window;
+		this.slot = slot;
+	}
+
+	public Item getItemStack() {
+		return ItemStack;
+	}
+
+	public int getSlot() {
+		return slot;
+	}
+
+	public int getWindow() {
+		return window;
+	}
+
+	@Override
+	public void read(PacketDataSerializer packetdataserializer) {
+		this.window = packetdataserializer.readByte();
+		this.slot = packetdataserializer.readShort();
+		this.ItemStack = packetdataserializer.readItem();
+	}
+
+	public void setItemStack(Item itemStack) {
+		ItemStack = itemStack;
+	}
+
+	public void setSlot(int slot) {
+		this.slot = slot;
+	}
+
+	public void setWindow(int window) {
+		this.window = window;
+	}
+
+	@Override
+	public void write(PacketDataSerializer packetdataserializer) {
+		packetdataserializer.writeByte(this.window);
+		packetdataserializer.writeShort(this.slot);
+		packetdataserializer.writeItem(this.ItemStack);
+	}
+
+	@Override
+	public String toString() {
+		return "PacketPlayOutSetSlot [ItemStack=" + ItemStack + ", slot=" + slot + ", window=" + window + "]";
+	}
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutSpawnEntity.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutSpawnEntity.java
new file mode 100644
index 0000000..c82be3f
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutSpawnEntity.java
@@ -0,0 +1,76 @@
+package dev.wolveringer.BungeeUtil.packets;
+
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
+import dev.wolveringer.api.datawatcher.DataWatcher;
+import dev.wolveringer.api.position.Location;
+import dev.wolveringer.packet.PacketDataSerializer;
+
+public class PacketPlayOutSpawnEntity extends Packet implements PacketPlayOut{
+	Location location;
+	int eid;
+	int type;
+	DataWatcher data;
+	
+	public PacketPlayOutSpawnEntity() {
+		super(0x0E);
+	}
+	
+	public PacketPlayOutSpawnEntity(Location location, int eid, int type, DataWatcher data) {
+		this();
+		this.location = location.multiply(32D);
+		this.eid = eid;
+		this.type = type;
+		this.data = data;
+	}
+
+
+
+	@Override
+	public void read(PacketDataSerializer s) {
+		eid = s.readVarInt();
+		type = s.readByte();
+		location = new Location(s.readInt(), s.readInt(), s.readInt());
+		data = DataWatcher.createDataWatcher(getBigVersion(),s);
+	}
+	@Override
+	public void write(PacketDataSerializer s) {
+		s.writeVarInt(eid);
+		s.writeByte(type);
+		s.writeInt(location.getBlockX());
+		s.writeInt(location.getBlockY());
+		s.writeInt(location.getBlockZ());
+		data.write(s);
+	}
+
+	public Location getLocation() {
+		return location.clone().dividide(32D);
+	}
+
+	public void setLocation(Location location) {
+		this.location = location.multiply(32D);
+	}
+
+	public int getEid() {
+		return eid;
+	}
+
+	public void setEid(int eid) {
+		this.eid = eid;
+	}
+
+	public int getType() {
+		return type;
+	}
+
+	public void setType(int type) {
+		this.type = type;
+	}
+
+	public DataWatcher getData() {
+		return data;
+	}
+
+	public void setData(DataWatcher data) {
+		this.data = data;
+	}
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutSpawnEntityLiving.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutSpawnEntityLiving.java
new file mode 100644
index 0000000..0d5fba8
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutSpawnEntityLiving.java
@@ -0,0 +1,132 @@
+package dev.wolveringer.BungeeUtil.packets;
+
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
+import dev.wolveringer.api.datawatcher.DataWatcher;
+import dev.wolveringer.api.position.Location;
+import dev.wolveringer.api.position.Vector;
+import dev.wolveringer.packet.PacketDataSerializer;
+
+public class PacketPlayOutSpawnEntityLiving extends BetaPacket implements PacketPlayOut{
+	private byte type;
+	private Location location;
+	private int yaw = 0;
+	private int pitch = 0;
+	private int headRotation;
+	private Vector vector = new Vector();
+	private int id;
+	private DataWatcher meta;
+	public PacketPlayOutSpawnEntityLiving(byte type, Location location, int yaw, int pitch, int headRotation, Vector vector) {
+		this();
+		this.type = type;
+		this.location = location;
+		this.yaw = yaw;
+		this.pitch = pitch;
+		this.headRotation = headRotation;
+		this.vector = vector;
+	}
+
+	public PacketPlayOutSpawnEntityLiving() {
+		super(0x0F);
+	}
+	
+	@Override
+	public void read(PacketDataSerializer s) {
+		id = s.readVarInt();
+		type = s.readByte();
+		location = new Location(s.readInt(), s.readInt(), s.readInt());
+		yaw = s.readByte();
+		pitch = s.readByte();
+		headRotation = s.readByte();
+		if(headRotation > 0)
+			vector = new Vector(s.readShort(), s.readShort(), s.readShort());
+		meta = DataWatcher.createDataWatcher(getBigVersion(),s);
+	}
+
+	@Override
+	public void write(PacketDataSerializer s) {
+		s.writeVarInt(id);
+		s.writeByte(type);
+		s.writeInt(location.getBlockX());
+		s.writeInt(location.getBlockY());
+		s.writeInt(location.getBlockZ());
+		s.writeByte(yaw);
+		s.writeByte(pitch);
+		s.writeByte(headRotation);
+		if(headRotation > 0){
+			s.writeShort(vector.getBlockX());
+			s.writeShort(vector.getBlockY());
+			s.writeShort(vector.getBlockZ());
+		}
+		if(meta == null)
+			meta = DataWatcher.createDataWatcher(getBigVersion());
+		meta.write(s);
+	}
+
+	public boolean isItemFrame() {
+		return type == 71;
+	}
+
+	public boolean isFalingBlock() {
+		return type == 70;
+	}
+
+	public byte getType() {
+		return type;
+	}
+
+	public void setType(byte type) {
+		this.type = type;
+	}
+
+	public Location getLocation() {
+		return location;
+	}
+
+	public void setLocation(Location location) {
+		this.location = location.multiply(32.0D);
+	}
+
+	public int getYaw() {
+		return yaw;
+	}
+
+	public void setYaw(int yaw) {
+		this.yaw = yaw;
+	}
+
+	public int getPitch() {
+		return pitch;
+	}
+
+	public void setPitch(int pitch) {
+		this.pitch = pitch;
+	}
+
+	public int getHeadRotation() {
+		return headRotation;
+	}
+
+	public void setHeadRotation(int headRotation) {
+		this.headRotation = headRotation;
+	}
+
+	public Vector getVector() {
+		return vector;
+	}
+
+	public void setVector(Vector vector) {
+		this.vector = vector;
+	}
+	public void setEntityID(int id) {
+		this.id = id;
+	}
+	public int getEnityID() {
+		return id;
+	}
+	public void setMeta(DataWatcher meta) {
+		this.meta = meta;
+	}
+	public DataWatcher getMeta() {
+		return meta;
+	}
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutSpawnPostition.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutSpawnPostition.java
new file mode 100644
index 0000000..c25330b
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutSpawnPostition.java
@@ -0,0 +1,27 @@
+package dev.wolveringer.BungeeUtil.packets;
+
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
+import dev.wolveringer.api.position.BlockPosition;
+import dev.wolveringer.packet.PacketDataSerializer;
+
+public class PacketPlayOutSpawnPostition extends Packet implements PacketPlayOut{
+	BlockPosition loc;
+	public PacketPlayOutSpawnPostition() {
+		super(0x05);
+	}
+	public PacketPlayOutSpawnPostition(BlockPosition loc) {
+		super(0x05);
+		this.loc = loc;
+	}
+	@Override
+	public void read(PacketDataSerializer s) {
+		loc = s.readBlockPosition();
+	}
+	@Override
+	public void write(PacketDataSerializer s) {
+		s.writeBlockPosition(loc);
+	}
+	public BlockPosition getLocation() {
+		return loc;
+	}
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutStatistic.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutStatistic.java
new file mode 100644
index 0000000..752ad40
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutStatistic.java
@@ -0,0 +1,47 @@
+package dev.wolveringer.BungeeUtil.packets;
+
+import java.util.HashMap;
+
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
+import dev.wolveringer.packet.PacketDataSerializer;
+
+public class PacketPlayOutStatistic extends Packet implements PacketPlayOut{
+
+	public PacketPlayOutStatistic() {
+		super(0x37);
+	}
+
+	private HashMap<String, Integer> stats = new HashMap<String, Integer>();
+	private int x = -2;
+
+	@Override
+	public void read(PacketDataSerializer s) {
+		int max = s.readVarInt();
+		while (max > 0){
+			stats.put(s.readString(-1), s.readVarInt());
+			max--;
+		}
+	}
+
+	@Override
+	public void write(PacketDataSerializer s) {
+		s.writeVarInt(stats.size());
+		for(String x : stats.keySet()){
+			s.writeString(x);
+			if(this.x == -2)
+				s.writeVarInt(stats.get(x));
+			else
+				s.writeVarInt(this.x);
+		}
+	}
+
+	@Deprecated
+	public void a(int i) {
+		x = i;
+	}
+
+	@Override
+	public String toString() {
+		return "PacketPlayOutStatistic [stats=" + stats + "]";
+	}
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutTitle.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutTitle.java
new file mode 100644
index 0000000..717d48b
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutTitle.java
@@ -0,0 +1,68 @@
+package dev.wolveringer.BungeeUtil.packets;
+
+import dev.wolveringer.packet.PacketDataSerializer;
+import lombok.AllArgsConstructor;
+import lombok.Builder;
+import lombok.Getter;
+import lombok.NoArgsConstructor;
+import lombok.Setter;
+
+@AllArgsConstructor
+@NoArgsConstructor
+@Builder
+@Getter
+@Setter
+public class PacketPlayOutTitle extends Packet{
+	public static enum Action {
+		SET_TITLE,
+		SET_SUBTITLE,
+		UPDATE_TIMINGS,
+		HIDE,
+		RESET;
+	}
+	
+	private Action action;
+	private String title;
+	private int fadeIn;
+	private int stay;
+	private int fadeOut;
+	
+	@Override
+	public void read(PacketDataSerializer s) {
+		action = Action.values()[s.readVarInt()];
+		switch (action) {
+		case SET_TITLE:
+		case SET_SUBTITLE:
+			title = s.readString(-1);
+			break;
+		case UPDATE_TIMINGS:
+			fadeIn = s.readInt();
+			stay = s.readInt();
+			fadeOut = s.readInt();
+		case HIDE:
+		case RESET:
+			break;
+		default:
+			break;
+		}
+	}
+
+	@Override
+	public void write(PacketDataSerializer s) {
+		s.writeVarInt(action.ordinal());
+		switch (action) {
+		case SET_SUBTITLE:
+		case SET_TITLE:
+			s.writeString(title);
+			break;
+		case UPDATE_TIMINGS:
+			s.writeInt(fadeIn);
+			s.writeInt(stay);
+			s.writeInt(fadeOut);
+			break;
+		default:
+			break;
+		}
+	}
+
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutTransaction.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutTransaction.java
new file mode 100644
index 0000000..02fd6a5
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutTransaction.java
@@ -0,0 +1,62 @@
+package dev.wolveringer.BungeeUtil.packets;
+
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
+import dev.wolveringer.packet.PacketDataSerializer;
+
+public class PacketPlayOutTransaction extends Packet implements PacketPlayOut{
+
+	private int window;
+	private short id;
+	private boolean cancel;
+
+	public PacketPlayOutTransaction() {
+		super(0x32);
+	}
+
+	public PacketPlayOutTransaction(int window, short id, boolean flag) {
+		super(0x32);
+		this.window = window;
+		this.id = id;
+		this.cancel = flag;
+	}
+
+	public void read(PacketDataSerializer packetdataserializer) {
+		this.window = packetdataserializer.readUnsignedByte();
+		this.id = packetdataserializer.readShort();
+		this.cancel = packetdataserializer.readBoolean();
+	}
+
+	public void write(PacketDataSerializer packetdataserializer) {
+		packetdataserializer.writeByte(this.window);
+		packetdataserializer.writeShort(this.id);
+		packetdataserializer.writeBoolean(this.cancel);
+	}
+
+	public String toString() {
+		return String.format("id=%d, uid=%d, accepted=%b", new Object[] { Integer.valueOf(this.window), Short.valueOf(this.id), Boolean.valueOf(this.cancel) });
+	}
+
+	public int getWindow() {
+		return window;
+	}
+
+	public void setWindow(int window) {
+		this.window = window;
+	}
+
+	public short getId() {
+		return id;
+	}
+
+	public void setId(short id) {
+		this.id = id;
+	}
+
+	public boolean isCancel() {
+		return cancel;
+	}
+
+	public void setCancel(boolean cancel) {
+		this.cancel = cancel;
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutUpdateHealth.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutUpdateHealth.java
new file mode 100644
index 0000000..561173f
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutUpdateHealth.java
@@ -0,0 +1,38 @@
+package dev.wolveringer.BungeeUtil.packets;
+
+import dev.wolveringer.BungeeUtil.ClientVersion.BigClientVersion;
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
+import dev.wolveringer.packet.PacketDataSerializer;
+
+public class PacketPlayOutUpdateHealth extends Packet implements PacketPlayOut{
+
+	float health;
+	int food;
+	float food_indicase;
+	
+	public PacketPlayOutUpdateHealth(float health, int food, float food_indicase) {
+		this();
+		this.health = health;
+		this.food = food;
+		this.food_indicase = food_indicase;
+	}
+	
+	public PacketPlayOutUpdateHealth() {
+		super(0x06);
+	}
+
+	@Override
+	public void read(PacketDataSerializer s) {
+		health = s.readFloat();
+		food = s.readVarInt();
+		food_indicase = s.readFloat();
+	}
+
+	@Override
+	public void write(PacketDataSerializer s) {
+		s.writeFloat(health);
+		s.writeVarInt(food);
+		s.writeFloat(food_indicase);
+	}
+
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutUpdateSign.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutUpdateSign.java
new file mode 100644
index 0000000..b9c1783
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutUpdateSign.java
@@ -0,0 +1,45 @@
+package dev.wolveringer.BungeeUtil.packets;
+
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
+import dev.wolveringer.api.position.BlockPosition;
+import dev.wolveringer.packet.PacketDataSerializer;
+
+public class PacketPlayOutUpdateSign extends Packet implements PacketPlayOut{
+	private BlockPosition loc;
+	private String[] lines = new String[4];
+	
+	public PacketPlayOutUpdateSign() {
+		super(0x33);
+	}
+
+	public PacketPlayOutUpdateSign(BlockPosition loc, String[] lines) {
+		super(0x33);
+		this.loc = loc;
+		this.lines = lines;
+	}
+
+	@Override
+	public void read(PacketDataSerializer s) {
+		loc = s.readBlockPosition();
+		for(int i = 0;i<4;i++)
+			lines[i] = s.readString(-1);
+	}
+	@Override
+	public void write(PacketDataSerializer s) {
+		s.writeBlockPosition(loc);
+		for(int i = 0;i<4;i++)
+			s.writeString(lines[i]);
+	}
+	public BlockPosition getLocation() {
+		return loc;
+	}
+	public void setLocation(BlockPosition loc) {
+		this.loc = loc;
+	}
+	public String[] getLines() {
+		return lines;
+	}
+	public void setLines(String[] lines) {
+		this.lines = lines;
+	}
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutWindowData.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutWindowData.java
new file mode 100644
index 0000000..126a113
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutWindowData.java
@@ -0,0 +1,61 @@
+package dev.wolveringer.BungeeUtil.packets;
+
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
+import dev.wolveringer.packet.PacketDataSerializer;
+
+public class PacketPlayOutWindowData extends Packet implements PacketPlayOut{
+	
+	private int window;
+	private short action;
+	private short value;
+	
+	public PacketPlayOutWindowData() {
+		super(0x31);
+	}
+	
+	
+	
+	public PacketPlayOutWindowData(int window, short action, short value) {
+		super(0x31);
+		this.window = window;
+		this.action = action;
+		this.value = value;
+	}
+
+	@Override
+	public void read(PacketDataSerializer s) {
+		window = s.readUnsignedByte();
+		action = s.readShort();
+		value = s.readShort();
+	}
+	@Override
+	public void write(PacketDataSerializer s) {
+		s.writeByte(window);
+		s.writeShort(action);
+		s.writeShort(value);
+	}
+
+	public int getWindow() {
+		return window;
+	}
+
+	public void setWindow(int window) {
+		this.window = window;
+	}
+
+	public short getAction() {
+		return action;
+	}
+
+	public void setAction(short action) {
+		this.action = action;
+	}
+
+	public short getValue() {
+		return value;
+	}
+
+	public void setValue(short value) {
+		this.value = value;
+	}
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutWindowItems.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutWindowItems.java
new file mode 100644
index 0000000..d92c05d
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutWindowItems.java
@@ -0,0 +1,69 @@
+package dev.wolveringer.BungeeUtil.packets;
+
+import java.util.List;
+
+import dev.wolveringer.BungeeUtil.item.Item;
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
+import dev.wolveringer.packet.PacketDataSerializer;
+
+public class PacketPlayOutWindowItems extends Packet implements PacketPlayOut {
+	private int window;
+	private Item[] items;
+
+	public PacketPlayOutWindowItems() {
+		super(0x30);
+	}
+
+	public PacketPlayOutWindowItems(int window, List<Item> list) {
+		super(0x30);
+		this.window = window;
+		this.items = new Item[list.size()];
+		for(int i = 0;i < this.items.length;++i){
+			this.items[i] = list.get(i);
+		}
+	}
+
+	public PacketPlayOutWindowItems(int i, Item... items) {
+		super(0x30);
+		this.window = i;
+		this.items = items;
+	}
+
+	@Override
+	public void read(PacketDataSerializer s) {
+		this.window = s.readUnsignedByte();
+		short items_length = s.readShort();
+
+		this.items = new Item[items_length];
+
+		for(int i = 0;i < items_length;++i){
+			this.items[i] = s.readItem();
+		}
+	}
+
+	@Override
+	public void write(PacketDataSerializer s) {
+		s.writeByte(this.window);
+		s.writeShort(this.items.length);
+		for(int i = 0;i < this.items.length;++i){
+			s.writeItem(this.items[i]);
+		}
+	}
+
+	public int getWindow() {
+		return window;
+	}
+
+	public void setWindow(int window) {
+		this.window = window;
+	}
+
+	public Item[] getItems() {
+		return items;
+	}
+
+	public void setItems(Item[] items) {
+		this.items = items;
+	}
+
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutWorldParticles.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutWorldParticles.java
new file mode 100644
index 0000000..36639a0
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutWorldParticles.java
@@ -0,0 +1,145 @@
+package dev.wolveringer.BungeeUtil.packets;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+
+import dev.wolveringer.BungeeUtil.ClientVersion.BigClientVersion;
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
+import dev.wolveringer.api.particel.ParticleEffect;
+import dev.wolveringer.api.position.Location;
+import dev.wolveringer.api.position.Vector;
+import dev.wolveringer.packet.PacketDataSerializer;
+
+public class PacketPlayOutWorldParticles extends Packet implements PacketPlayOut {
+	
+	private int count;
+	private float data;
+	private Location loc;
+	private ParticleEffect name;
+	private Vector vector;
+	
+	// 1.8
+	boolean far;
+	int[] p_data;
+	
+	public PacketPlayOutWorldParticles() {
+		super(0x2A);
+	}
+	
+	public PacketPlayOutWorldParticles(ParticleEffect s, Location loc, Vector v, float f6, int i, int... pdata) {
+		this.name = s;
+		this.loc = loc;
+		this.vector = v;
+		this.data = f6;
+		this.count = i;
+		this.p_data = pdata;
+	}
+	
+	public PacketPlayOutWorldParticles(ParticleEffect s, Location loc, Vector v, float f6, int i, boolean far, int... pdata) {
+		this.name = s;
+		this.loc = loc;
+		this.vector = v;
+		this.data = f6;
+		this.count = i;
+		this.p_data = pdata;
+		this.far = far;
+	}
+	
+	public int getCount() {
+		return count;
+	}
+	
+	public float getData() {
+		return data;
+	}
+	
+	public Location getLoc() {
+		return loc;
+	}
+	
+	public ParticleEffect getParticle() {
+		return name;
+	}
+	
+	public Vector getVector() {
+		return vector;
+	}
+	
+	@Override
+	public void read(PacketDataSerializer packetdataserializer) {
+		this.name = ParticleEffect.fromId(packetdataserializer.readInt());
+		this.far = packetdataserializer.readBoolean();
+		loc = new Location(packetdataserializer.readFloat(), packetdataserializer.readFloat(), packetdataserializer.readFloat());
+		vector = new Vector(packetdataserializer.readFloat(), packetdataserializer.readFloat(), packetdataserializer.readFloat());
+		this.data = packetdataserializer.readFloat();
+		this.count = packetdataserializer.readInt();
+		ArrayList<Integer> a = new ArrayList<Integer>();
+		while (packetdataserializer.readableBytes() > 0) {
+			a.add(packetdataserializer.readVarInt());
+		}
+		this.p_data = new int[a.size()];
+		int pos = 0;
+		for (Integer i : a) {
+			p_data[pos] = i;
+			pos++;
+		}
+	}
+	
+	public void setCount(int count) {
+		this.count = count;
+	}
+	
+	public void setData(float data) {
+		this.data = data;
+	}
+	
+	public void setLoc(Location loc) {
+		this.loc = loc;
+	}
+	
+	public void setParticle(ParticleEffect name) {
+		this.name = name;
+	}
+	
+	public void setVector(Vector vector) {
+		this.vector = vector;
+	}
+	
+	@Override
+	public String toString() {
+		return "PacketPlayOutWorldParticles [count=" + count + ", data=" + data + ", loc=" + loc + ", name=" + name + ", vector=" + vector + ", j=" + far + ", p_data=" + Arrays.toString(p_data) + "]";
+	}
+	
+	@Override
+	public void write(PacketDataSerializer packetdataserializer) {
+		packetdataserializer.writeInt(this.name.getId());
+		packetdataserializer.writeBoolean(this.far);
+		packetdataserializer.writeFloat(new Float(this.loc.getX()));
+		packetdataserializer.writeFloat(new Float(this.loc.getY()));
+		packetdataserializer.writeFloat(new Float(this.loc.getZ()));
+		packetdataserializer.writeFloat(new Float(this.vector.getX()));
+		packetdataserializer.writeFloat(new Float(this.vector.getY()));
+		packetdataserializer.writeFloat(new Float(this.vector.getZ()));
+		packetdataserializer.writeFloat(data);
+		packetdataserializer.writeInt(count);
+		for (Integer o : p_data)
+			packetdataserializer.writeVarInt((int) o);
+	}
+	
+	public boolean isFar() {
+		return far;
+	}
+	
+	public void setFar(boolean j) {
+		this.far = j;
+	}
+	
+	public int[] getMetaData() {
+		return p_data;
+	}
+	
+	public void setMetaData(int[] p_data) {
+		this.p_data = p_data;
+	}
+	
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/UnderknownPacket.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/UnderknownPacket.java
new file mode 100644
index 0000000..3e05648
--- /dev/null
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/UnderknownPacket.java
@@ -0,0 +1,20 @@
+package dev.wolveringer.BungeeUtil.packets;
+
+import dev.wolveringer.packet.PacketDataSerializer;
+
+@SuppressWarnings("deprecation")
+public class UnderknownPacket extends Packet {
+
+	byte[] data;
+
+	@Override
+	public void read(PacketDataSerializer s) {
+		data = new byte[s.readableBytes()];
+		s.readBytes(data);
+	}
+
+	@Override
+	public void write(PacketDataSerializer s) {
+		s.writeBytes(data);
+	}
+}
diff --git a/src/main/java/dev/wolveringer/NPC/Equipment.java b/src/main/java/dev/wolveringer/NPC/Equipment.java
new file mode 100644
index 0000000..ece0452
--- /dev/null
+++ b/src/main/java/dev/wolveringer/NPC/Equipment.java
@@ -0,0 +1,72 @@
+package dev.wolveringer.NPC;
+
+import dev.wolveringer.BungeeUtil.Player;
+import dev.wolveringer.BungeeUtil.item.Item;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayOutEntityEquipment;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayOutEntityEquipment.Slot;
+
+public final class Equipment {
+	//0: Hand 1: Off hand 2: boots, 3: leggings, 4: chestplate, 5: helmet
+	private NPC handle;
+	private Item[] contains = new Item[6];
+	
+	public Equipment(NPC handle) {
+		this.handle = handle;
+	}
+	
+	public Item getHelmet() {
+		return contains[5];
+	}
+	public Item getChestplate() {
+		return contains[4];
+	}
+	public Item getLeggins() {
+		return contains[3];
+	}
+	public Item getBoots() {
+		return contains[2];
+	}
+	public Item getItemInHand(){
+		return contains[0];
+	}
+	public Item getItemInOffHand(){
+		return contains[1];
+	}
+	
+	public void setHelmet(Item head) {
+		this.contains[5] = head;
+		sendUpdate(5, head);
+	}
+	public void setLeggins(Item leggins) {
+		this.contains[3] = leggins;
+		sendUpdate(3, leggins);
+	}
+	public void setBoots(Item boots) {
+		this.contains[2] = boots;
+		sendUpdate(2,boots);	
+	}
+	public void setChestplate(Item chestplate) {
+		this.contains[4] = chestplate;
+		sendUpdate(4,chestplate);
+	}
+	public void setItemInHand(Item item){
+		this.contains[0] = item;
+		sendUpdate(0, item);
+	}
+	public void setItemInOffHand(Item item){
+		this.contains[1] = item;
+		sendUpdate(1, item);
+	}
+	
+	private void sendUpdate(int slot,Item i){
+		for(Player p : handle.getViewer())
+			p.sendPacket(new PacketPlayOutEntityEquipment(handle.getEntityID(), i, Slot.values()[slot]));
+	}
+	
+	protected void sendItems(Player p){
+		for(int i = 0;i < contains.length;i++){
+			if(contains[i] != null)
+				p.sendPacket(new PacketPlayOutEntityEquipment(handle.getEntityID(), contains[i], Slot.values()[i]));
+		}
+	}
+}
diff --git a/src/main/java/dev/wolveringer/NPC/InteractListener.java b/src/main/java/dev/wolveringer/NPC/InteractListener.java
new file mode 100644
index 0000000..212fe86
--- /dev/null
+++ b/src/main/java/dev/wolveringer/NPC/InteractListener.java
@@ -0,0 +1,8 @@
+package dev.wolveringer.NPC;
+
+import dev.wolveringer.BungeeUtil.Player;
+
+public interface InteractListener {
+	public void rightClick(Player p);
+	public void leftClick(Player p);
+}
diff --git a/src/main/java/dev/wolveringer/NPC/NPC.java b/src/main/java/dev/wolveringer/NPC/NPC.java
new file mode 100644
index 0000000..d0a953b
--- /dev/null
+++ b/src/main/java/dev/wolveringer/NPC/NPC.java
@@ -0,0 +1,331 @@
+package dev.wolveringer.NPC;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Random;
+import java.util.UUID;
+
+import dev.wolveringer.BungeeUtil.ClientVersion.BigClientVersion;
+import dev.wolveringer.BungeeUtil.PacketHandleEvent;
+import dev.wolveringer.BungeeUtil.PacketHandler;
+import dev.wolveringer.BungeeUtil.PacketLib;
+import dev.wolveringer.BungeeUtil.Player;
+import dev.wolveringer.BungeeUtil.gameprofile.GameProfile;
+import dev.wolveringer.BungeeUtil.gameprofile.PlayerInfoData;
+import dev.wolveringer.BungeeUtil.gameprofile.Skin;
+import dev.wolveringer.BungeeUtil.gameprofile.SkinFactory;
+import dev.wolveringer.BungeeUtil.packets.Packet;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayInUseEntity;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayInUseEntity.Action;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayOutEntityDestroy;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayOutEntityHeadRotation;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayOutEntityTeleport;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayOutNamedEntitySpawn;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayOutPlayerInfo;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayOutPlayerInfo.EnumPlayerInfoAction;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayOutScoreboardTeam;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayOutScoreboardTeam.NameTag;
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
+import dev.wolveringer.api.datawatcher.DataWatcher;
+import dev.wolveringer.api.datawatcher.HumanDataWatcher;
+import dev.wolveringer.api.position.Location;
+import dev.wolveringer.chat.IChatBaseComponent;
+
+public final class NPC {
+	private static final Random RND_NAME = new Random();
+	private static ArrayList<String> base_names = new ArrayList<>();
+	private static int npc_count = 1000;
+	private PacketPlayOutEntityDestroy p2;
+	
+	private int ID;
+	private NPCData datawatcher = new NPCData();
+	
+	private ArrayList<Player> viewer = new ArrayList<Player>();
+	private NameSpliter name;
+	private String base_name;
+	private Location location;
+	
+	private int ping = 20;
+	
+	private GameProfile profile = new GameProfile(UUID.randomUUID(), "");
+	
+	private boolean tab;
+	
+	private ArrayList<InteractListener> listener = new ArrayList<InteractListener>();
+	
+	private IChatBaseComponent tabname = null;
+	
+	private PacketHandler<Packet> handler;
+	
+	private Equipment equipment = new Equipment(this);
+	
+	public NPC() {
+		this((System.currentTimeMillis() + "_0x" + Integer.toHexString(RND_NAME.nextInt()) + "00000000000000000").substring(0, 16));
+	}
+	
+	public NPC(String base_name) {
+		if (base_name.length() > 16) throw new NullPointerException("Base Name cant be longer than 16!");
+		if (base_names.contains(base_name)) throw new IllegalArgumentException("Base name is alredy in use!");
+		base_names.add(base_name);
+		this.ID = npc_count++;
+		this.base_name = base_name;
+		
+		this.name = new NameSpliter();
+		name.setOrginal(base_name);
+		
+		this.profile.setName(base_name);
+		this.location = new Location(0, 0, 0);
+		handler = new PacketHandler<Packet>() {
+			@SuppressWarnings("unchecked")
+			@Override
+			public void handle(PacketHandleEvent<Packet> e) {
+				if (e.getPacket() instanceof PacketPlayInUseEntity) {
+					PacketPlayInUseEntity packet = (PacketPlayInUseEntity) e.getPacket();
+					if (packet.getTarget() == ID) {
+						if (packet.getAction() == Action.ATTACK) for (InteractListener listener : (List<InteractListener>) NPC.this.listener.clone())
+							listener.leftClick(e.getPlayer());
+						else if (packet.getAction() == Action.INTERACT_AT && packet.getHand() == 0) // 1.9 sends 2 Packets (Hand 0 and hand 1)
+		                    for (InteractListener listener : (List<InteractListener>) NPC.this.listener.clone())
+							listener.rightClick(e.getPlayer());
+						e.setCancelled(true);
+					}
+				}
+			}
+		};
+		datawatcher.injektDefault();
+		PacketLib.addHandler(handler);
+		rebuild();
+	}
+	
+	public void setPing(int ping) {
+		this.ping = ping;
+		if (tab) broadcastPacket(new PacketPlayOutPlayerInfo(EnumPlayerInfoAction.UPDATE_PING, new PlayerInfoData(profile, ping, 0, tabname)));
+	}
+	
+	public int getPing() {
+		return ping;
+	}
+	
+	public void setVisiable(Player p, boolean b) {
+		if (b) if (!viewer.contains(p)) show(p);
+		else;
+		else if (viewer.contains(p)) hide(p);
+	}
+	
+	public boolean canSee(Player p) {
+		return viewer.contains(p);
+	}
+	
+	public String getName() {
+		return name.getOrginal();
+	}
+	
+	public void setName(String name) {
+		if (name.length() > 48) throw new NullPointerException(name.length() + " > 48");
+		this.name.setOrginal(name);
+		this.profile.setName(this.name.getMain());
+		rebuild();
+		for (Player p : viewer) {
+			sendDestroy(p);
+			sendSpawn(p);
+		}
+	}
+	
+	public Location getLocation() {
+		return location;
+	}
+	
+	public void setLocation(Location location) {
+		this.location = location;
+		rebuild();
+		broadcastPacket(new PacketPlayOutEntityTeleport(ID, location));
+		broadcastPacket(new PacketPlayOutEntityHeadRotation(ID, location.getYaw()));
+	}
+	
+	public HumanDataWatcher getDatawatcher() {
+		return datawatcher;
+	}
+	
+	public GameProfile getProfile() {
+		return profile;
+	}
+	
+	public void setSkin(Skin skin) {
+		skin.applay(this.profile);
+		setProfile(this.profile);
+	}
+	
+	public void setProfile(GameProfile profile) {
+		this.profile = profile;
+		if (this.profile == null) this.profile = new GameProfile(UUID.randomUUID(), this.name.getMain());
+		if (this.profile.getName() == null) {
+			System.err.print("Name of the GameProfile cant be null");
+			this.profile.setName("error");
+		}
+		rebuild();
+		ArrayList<Player> player = new ArrayList<>(viewer);
+		for (Player p : player) {
+			hide(p);
+			show(p);
+		}
+	}
+	
+	public void setTabListed(boolean listed) {
+		if (tab != listed) if (tab) broadcastPacket(new PacketPlayOutPlayerInfo(EnumPlayerInfoAction.ADD_PLAYER, new PlayerInfoData(profile, ping, 0, (IChatBaseComponent) tabname)));
+		else broadcastPacket(new PacketPlayOutPlayerInfo(EnumPlayerInfoAction.REMOVE_PLAYER, new PlayerInfoData(profile, ping, 0, tabname)));
+		this.tab = listed;
+	}
+	
+	public boolean isTabListed() {
+		return tab;
+	}
+	
+	public void setPlayerListName(IChatBaseComponent name) {
+		this.tabname = name;
+		broadcastPacket(new PacketPlayOutPlayerInfo(EnumPlayerInfoAction.UPDATE_DISPLAY_NAME, new PlayerInfoData(profile, ping, 0, tabname)));
+	}
+	
+	public IChatBaseComponent getPlayerListName() {
+		return tabname;
+	}
+	
+	public void addListener(InteractListener listener) {
+		this.listener.add(listener);
+	}
+	
+	public void removeListener(InteractListener listener) {
+		this.listener.remove(listener);
+	}
+	
+	public Equipment getEquipment() {
+		return equipment;
+	}
+	
+	private void hide(Player p) {
+		viewer.remove(p);
+		sendDestroy(p);
+	}
+	
+	private void show(Player p) {
+		viewer.add(p);
+		sendSpawn(p);
+	}
+
+	/**
+	 * Contains spelling mistake
+	 * @deprecated Use {@link #broadcastPacket(Packet a)} instead.  
+	 */
+	@Deprecated
+	private void brotcastPacket(Packet p) {
+		broadcastPacket(p);
+	}
+	
+	private void broadcastPacket(Packet p) {
+		for (Player pl : viewer)
+			pl.sendPacket((PacketPlayOut) p);
+	}
+	
+	private void sendSpawn(final Player p) {
+		p.sendPacket(new PacketPlayOutPlayerInfo(EnumPlayerInfoAction.ADD_PLAYER, new PlayerInfoData(profile, ping, 0, (IChatBaseComponent) tabname)));
+		p.sendPacket(new PacketPlayOutNamedEntitySpawn(ID, profile, location, 0, datawatcher.getWatcher(p.getVersion().getBigVersion())));
+		
+		PacketPlayOutScoreboardTeam team = new PacketPlayOutScoreboardTeam();
+		team.setTeam(base_name);
+		team.setDisplayName("Error (NCP-Team): 002");
+		team.setAction(PacketPlayOutScoreboardTeam.Action.CREATE);
+		team.setPrefix(name.getPrefix());
+		team.setSuffix(name.getSuffix());
+		team.setFriendlyFire(0);
+		team.setPlayers(new String[] { profile.getName() });
+		team.setTag(NameTag.VISIABLE);
+		p.sendPacket(team);
+		
+		p.sendPacket(new PacketPlayOutEntityHeadRotation(ID, p.getLocation().getYaw()));
+		
+		if (!tab) p.sendPacket(new PacketPlayOutPlayerInfo(EnumPlayerInfoAction.REMOVE_PLAYER, new PlayerInfoData(profile, ping, 0, tabname)));
+		else p.sendPacket(new PacketPlayOutPlayerInfo(EnumPlayerInfoAction.UPDATE_DISPLAY_NAME, new PlayerInfoData(profile, ping, 0, (IChatBaseComponent) tabname)));
+		equipment.sendItems(p);
+	}
+	
+	private void sendDestroy(Player p) {
+		if (tab) p.sendPacket(new PacketPlayOutPlayerInfo(EnumPlayerInfoAction.REMOVE_PLAYER, new PlayerInfoData(profile, ping, 0, (IChatBaseComponent) null)));
+		PacketPlayOutScoreboardTeam team = new PacketPlayOutScoreboardTeam();
+		team.setTeam(base_name);
+		team.setAction(PacketPlayOutScoreboardTeam.Action.REMOVE);
+		p.sendPacket(team);
+		p.sendPacket(p2);
+	}
+	
+	protected void rebuild() {
+		if (this.profile == null) {
+			System.err.print("NPC Profile is null. it will crash the Client");
+			this.profile = new GameProfile(UUID.randomUUID(), this.name.getMain());
+		}
+		p2 = new PacketPlayOutEntityDestroy(ID);
+	}
+	
+	public void delete() {
+		for (Player p : viewer)
+			sendDestroy(p);
+		viewer.clear();
+		try {
+			finalize();
+		}
+		catch (Throwable e) {
+			e.printStackTrace();
+		}
+	}
+	
+	public int getEntityID() {
+		return ID;
+	}
+	
+	protected ArrayList<Player> getViewer() {
+		return viewer;
+	}
+	
+	@Override
+	protected void finalize() throws Throwable {
+		PacketLib.removeHandler(handler);
+		base_names.remove(base_name);
+		super.finalize();
+	}
+}
+
+class NameSpliter {
+	private String orginal;
+	private String main, prefix, suffix;
+	
+	public String getPrefix() {
+		return prefix;
+	}
+	
+	public String getSuffix() {
+		return suffix;
+	}
+	
+	public String getMain() {
+		return main;
+	}
+	
+	public String getOrginal() {
+		return orginal;
+	}
+	
+	public void setOrginal(String orginal) {
+		this.orginal = orginal;
+		recalculate();
+	}
+	
+	private void recalculate() {
+		if (orginal.length() > 16) {
+			prefix = orginal.length() > 30 ? orginal.substring(0, 15) : "";
+			main = orginal.length() > 30 ? orginal.substring(15, orginal.length() < 30 ? orginal.length() : 30) : orginal.substring(0, 15);
+			suffix = orginal.length() > 30 ? orginal.substring(30, orginal.length() > 45 ? 45 : orginal.length()) : orginal.substring(15, orginal.length() > 30 ? 30 : orginal.length());
+		}
+		else {
+			prefix = suffix = "";
+			main = orginal;
+		}
+	}
+}
diff --git a/src/main/java/dev/wolveringer/NPC/NPCData.java b/src/main/java/dev/wolveringer/NPC/NPCData.java
new file mode 100644
index 0000000..7a53b4e
--- /dev/null
+++ b/src/main/java/dev/wolveringer/NPC/NPCData.java
@@ -0,0 +1,337 @@
+package dev.wolveringer.NPC;
+
+import com.google.common.base.Function;
+
+import dev.wolveringer.BungeeUtil.ClientVersion.BigClientVersion;
+import dev.wolveringer.api.datawatcher.DataWatcher;
+import dev.wolveringer.api.datawatcher.HumanDataWatcher;
+
+public class NPCData implements HumanDataWatcher {
+	private HumanDataWatcher v1_8;
+	private HumanDataWatcher v1_9;
+	private HumanDataWatcher v1_10;
+	
+	public NPCData() {
+		v1_8 = DataWatcher.createDataWatcher(BigClientVersion.v1_8).getSpecialDataWatcher(HumanDataWatcher.class);
+		v1_9 = DataWatcher.createDataWatcher(BigClientVersion.v1_9).getSpecialDataWatcher(HumanDataWatcher.class);
+		v1_10 = DataWatcher.createDataWatcher(BigClientVersion.v1_10).getSpecialDataWatcher(HumanDataWatcher.class);
+	}
+	
+	public boolean isSneaking() {
+		return v1_8.isSneaking();
+	}
+	
+	public void setSkinFlags(final byte flag) {
+		applay(new Function<HumanDataWatcher, Void>() {
+			@Override
+			public Void apply(HumanDataWatcher arg0) {
+				arg0.setSkinFlags(flag);
+				return null;
+			}
+		});
+	}
+	
+	public void setHealth(final float h) {
+		applay(new Function<HumanDataWatcher, Void>() {
+			@Override
+			public Void apply(HumanDataWatcher arg0) {
+				arg0.setHealth(h);
+				return null;
+			}
+		});
+	}
+	
+	public void setSneaking(final boolean flag) {
+		applay(new Function<HumanDataWatcher, Void>() {
+			@Override
+			public Void apply(HumanDataWatcher arg0) {
+				arg0.setSneaking(flag);
+				return null;
+			}
+		});
+	}
+	
+	public byte getSkinFlag() {
+		return v1_8.getSkinFlag();
+	}
+	
+	public float getHealth() {
+		return v1_8.getHealth();
+	}
+	
+	public boolean isSprinting() {
+		return v1_8.isSprinting();
+	}
+	
+	public void setCapeActive(final boolean b) {
+		applay(new Function<HumanDataWatcher, Void>() {
+			@Override
+			public Void apply(HumanDataWatcher arg0) {
+				arg0.setCapeActive(b);
+				return null;
+			}
+		});
+	}
+	
+	public void setArrows(final int amauth) {
+		applay(new Function<HumanDataWatcher, Void>() {
+			@Override
+			public Void apply(HumanDataWatcher arg0) {
+				arg0.setArrows(amauth);
+				return null;
+			}
+		});
+	}
+	
+	public void setSprinting(final boolean flag) {
+		applay(new Function<HumanDataWatcher, Void>() {
+			@Override
+			public Void apply(HumanDataWatcher arg0) {
+				arg0.setSprinting(flag);
+				return null;
+			}
+		});
+	}
+	
+	public boolean isCapeActive() {
+		return v1_8.isCapeActive();
+	}
+	
+	public int getArrows() {
+		return v1_8.getArrows();
+	}
+	
+	public boolean isInvisible() {
+		return v1_8.isInvisible();
+	}
+	
+	public void setParicelColor(final int color) {
+		applay(new Function<HumanDataWatcher, Void>() {
+			@Override
+			public Void apply(HumanDataWatcher arg0) {
+				arg0.setParicelColor(color);
+				return null;
+			}
+		});
+	}
+	
+	public void setAbsorptionHearts(final float f) {
+		applay(new Function<HumanDataWatcher, Void>() {
+			@Override
+			public Void apply(HumanDataWatcher arg0) {
+				arg0.setAbsorptionHearts(f);
+				return null;
+			}
+		});
+	}
+	
+	public void setInvisible(final boolean flag) {
+		applay(new Function<HumanDataWatcher, Void>() {
+			@Override
+			public Void apply(HumanDataWatcher arg0) {
+				arg0.setInvisible(flag);
+				return null;
+			}
+		});
+	}
+	
+	public float getAbsorptionHearts() {
+		return v1_8.getAbsorptionHearts();
+	}
+	
+	public int getParicelColor() {
+		return v1_8.getParicelColor();
+	}
+	
+	public boolean isOnFire() {
+		return v1_8.isOnFire();
+	}
+	
+	public void setParticelVisiable(final boolean flag) {
+		applay(new Function<HumanDataWatcher, Void>() {
+			@Override
+			public Void apply(HumanDataWatcher arg0) {
+				arg0.setParticelVisiable(flag);
+				return null;
+			}
+		});
+	}
+	
+	public void setScore(final int score) {
+		applay(new Function<HumanDataWatcher, Void>() {
+			@Override
+			public Void apply(HumanDataWatcher arg0) {
+				arg0.setScore(score);
+				return null;
+			}
+		});
+	}
+	
+	public int getScore() {
+		return v1_8.getScore();
+	}
+	
+	public boolean isParticelVisiable() {
+		return v1_8.isParticelVisiable();
+	}
+	
+	public void setOnFire(final boolean fire) {
+		applay(new Function<HumanDataWatcher, Void>() {
+			@Override
+			public Void apply(HumanDataWatcher arg0) {
+				arg0.setOnFire(fire);
+				return null;
+			}
+		});
+	}
+	
+	public HumanDataWatcher injektDefault() {
+		v1_9.injektDefault();
+		v1_10.injektDefault();
+		return v1_8.injektDefault();
+	}
+	
+	public void setAI(final boolean flag) {
+		v1_8.setAI(flag);
+	}
+	
+	public boolean isBlocking() {
+		return v1_8.isBlocking();
+	}
+	
+	public void setBlocking(final boolean block) {
+		applay(new Function<HumanDataWatcher, Void>() {
+			@Override
+			public Void apply(HumanDataWatcher arg0) {
+				arg0.setBlocking(block);
+				return null;
+			}
+		});
+	}
+	
+	public boolean hasAI() {
+		return v1_8.hasAI();
+	}
+	
+	public boolean isGlowing() {
+		return v1_8.isGlowing();
+	}
+	
+	public void setGlowing(final boolean glow) {
+		applay(new Function<HumanDataWatcher, Void>() {
+			@Override
+			public Void apply(HumanDataWatcher arg0) {
+				arg0.setGlowing(glow);
+				return null;
+			}
+		});
+	}
+	
+	public boolean isElytra() {
+		return v1_9.isElytra();
+	}
+	
+	public void setElytra(final boolean elytra) {
+		v1_9.setElytra(elytra);
+	}
+	
+	public int getAir() {
+		return v1_8.getAir();
+	}
+	
+	public void setAir(final int air) {
+		applay(new Function<HumanDataWatcher, Void>() {
+			@Override
+			public Void apply(HumanDataWatcher arg0) {
+				arg0.setAir(air);
+				return null;
+			}
+		});
+	}
+	
+	public void setCostumName(final String name) {
+		applay(new Function<HumanDataWatcher, Void>() {
+			@Override
+			public Void apply(HumanDataWatcher arg0) {
+				arg0.setCostumName(name);
+				return null;
+			}
+		});
+	}
+	
+	public String getCostumName() {
+		return v1_8.getCostumName();
+	}
+	
+	public boolean isCostumNameVisiable() {
+		return v1_8.isCostumNameVisiable();
+	}
+	
+	public void setCostumNameVisiable(final boolean flag) {
+		applay(new Function<HumanDataWatcher, Void>() {
+			@Override
+			public Void apply(HumanDataWatcher arg0) {
+				arg0.setCostumNameVisiable(flag);
+				return null;
+			}
+		});
+	}
+	
+	public boolean isSlient() {
+		return v1_8.isSlient();
+	}
+	
+	public void setSlient(final boolean flag) {
+		applay(new Function<HumanDataWatcher, Void>() {
+			@Override
+			public Void apply(HumanDataWatcher arg0) {
+				arg0.setSlient(flag);
+				return null;
+			}
+		});
+	}
+	
+	@Override
+	public void setApplayGravity(final boolean flag) {
+		applay(new Function<HumanDataWatcher, Void>() {
+			@Override
+			public Void apply(HumanDataWatcher arg0) {
+				arg0.setApplayGravity(flag);
+				return null;
+			}
+		});
+	}
+	
+	public DataWatcher getWatcher() {
+		return null;
+	}
+	
+	public HumanDataWatcher getV1_8() {
+		return v1_8;
+	}
+	
+	public HumanDataWatcher getV1_9() {
+		return v1_9;
+	}
+	
+	public HumanDataWatcher getV1_10() {
+		return v1_10;
+	}
+	
+	public DataWatcher getWatcher(BigClientVersion bigVersion) {
+		if (bigVersion == BigClientVersion.v1_10) return v1_10.getWatcher();
+		else if (bigVersion == BigClientVersion.v1_9) return v1_9.getWatcher();
+		else return v1_8.getWatcher();
+	}
+	
+	@Override
+	public boolean hasGravity() {
+		return v1_9.hasGravity();
+	}
+	
+	private void applay(Function<HumanDataWatcher, Void> c) {
+		c.apply(v1_8);
+		c.apply(v1_9);
+		c.apply(v1_10);
+	}
+}
diff --git a/src/main/java/dev/wolveringer/Reflect/Test/Main.java b/src/main/java/dev/wolveringer/Reflect/Test/Main.java
new file mode 100644
index 0000000..e44e5b8
--- /dev/null
+++ b/src/main/java/dev/wolveringer/Reflect/Test/Main.java
@@ -0,0 +1,40 @@
+package dev.wolveringer.Reflect.Test;
+
+import dev.wolveringer.api.position.Location;
+
+public class Main {
+    static class Friend {
+        private final String name;
+        public Friend(String name) {
+            this.name = name;
+        }
+        public String getName() {
+            return this.name;
+        }
+        public synchronized void bow(Friend bower) {
+            System.out.format("%s: %s"
+                + "  has bowed to me!%n", 
+                this.name, bower.getName());
+            bower.bowBack(this);
+        }
+        public synchronized void bowBack(Friend bower) {
+            System.out.format("%s: %s"
+                + " has bowed back to me!%n",
+                this.name, bower.getName());
+        }
+    }
+    public static void main(String[] args) {
+    	/*
+        final Friend alphonse = new Friend("Alphonse");
+        final Friend gaston = new Friend("Gaston");
+        new Thread(new Runnable() { public void run() { alphonse.bow(gaston); }  }).start();
+        new Thread(new Runnable() { public void run() { gaston.bow(alphonse); } }).start();
+        */
+    }
+   	public static Location readPosition(long l) {
+   		long val = l;
+   		return new Location((int)(val >> 38), (int)(val << 26 >> 52), (int)(val << 38 >> 38));
+   	}
+
+    
+}
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/Reflect/Test/TEST.java b/src/main/java/dev/wolveringer/Reflect/Test/TEST.java
new file mode 100644
index 0000000..82db7d0
--- /dev/null
+++ b/src/main/java/dev/wolveringer/Reflect/Test/TEST.java
@@ -0,0 +1,89 @@
+package dev.wolveringer.Reflect.Test;
+
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.util.Arrays;
+import java.util.Collections;
+
+import dev.wolveringer.BungeeUtil.packets.Packet;
+import dev.wolveringer.chat.ChatSerializer;
+
+public class TEST {
+	public static void main(String[] args) {
+		System.out.print(ChatSerializer.toJSONString(ChatSerializer.fromMessage("ï¿½aSleef-Event")));
+		/*
+		PacketHandler h = new PacketHandler() {
+			public void handle(PacketHandleEvent e) {
+				Main.sendMessage(e.getPacket());
+			};
+		};
+
+		PacketLib.addHandler(new PacketHandler<PacketPlayOutChat>() {
+			@Override
+			public void handle(PacketHandleEvent<PacketPlayOutChat> e) {
+				//Handle Packet
+			}
+		});
+		
+		PacketLib.addHandler(h);
+		PacketLib.handle(new PacketHandleEvent<PacketPlayOutChat>(new PacketPlayOutChat(), null));
+		PacketLib.handle(new PacketHandleEvent<Packet>(new PacketPlayOutCloseWindow(), null));
+		*/
+		/*
+		 * /*
+		 * String s = "HELLO: ";
+		 * for(int i = 0;i<100;i++){
+		 * try{
+		 * Thread.sleep(100);
+		 * }catch (InterruptedException e){
+		 * e.printStackTrace();
+		 * }
+		 * s+=".";
+		 * System.out.print("\r"+s);
+		 * }
+		 * long ns = System.nanoTime();
+		 * long ms = System.currentTimeMillis();
+		 * try{
+		 * Thread.sleep(1);
+		 * }catch (InterruptedException e){
+		 * e.printStackTrace();
+		 * }
+		 * System.out.print((System.nanoTime()-ns)+":"+(System.currentTimeMillis(
+		 * )-ms));
+		 */
+	}
+
+	private static Class getPacketType(Class s) {
+		for(Type interfaces : s.getGenericInterfaces())
+			for(Type c : ((ParameterizedType) interfaces).getActualTypeArguments())
+				try{
+					if(c.equals(Packet.class))
+						continue;
+					return Class.forName(c.toString().split(" ")[1]);
+				}catch (ClassNotFoundException e){
+					e.printStackTrace();
+				}
+		return Packet.class;
+	}
+
+	private static boolean checkVersion(String version1, String version2) {
+		String[] v1 = version1.split("\\.");
+		String[] v2 = version2.split("\\.");
+		for(int i = 0;i < Collections.max(Arrays.asList(v1.length, v2.length));i++){
+			if(i + 1 < v1.length && i + 1 >= v2.length)
+				return !isNotZero(Arrays.copyOfRange(v1, i + 1, v1.length));
+			else if(i + 1 < v2.length && i + 1 >= v1.length)
+				return isNotZero(Arrays.copyOfRange(v2, i + 1, v2.length));
+			else if(Integer.parseInt(v1[i]) < Integer.parseInt(v2[i]))
+				return true;
+		}
+		return false;
+	}
+
+	private static boolean isNotZero(String[] x) {
+		for(String s : x)
+			if(Integer.parseInt(s) != 0)
+				return true;
+		return false;
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/Reflect/Test/TestClass.java b/src/main/java/dev/wolveringer/Reflect/Test/TestClass.java
new file mode 100644
index 0000000..f8dc69d
--- /dev/null
+++ b/src/main/java/dev/wolveringer/Reflect/Test/TestClass.java
@@ -0,0 +1,9 @@
+package dev.wolveringer.Reflect.Test;
+
+import java.util.Arrays;
+import java.util.Collection;
+
+public class TestClass {
+	@SuppressWarnings("unused")
+	private final Collection<String> a = Arrays.asList("THIS IS A TEST STRING");
+}
diff --git a/src/main/java/dev/wolveringer/Reflect/Until.java b/src/main/java/dev/wolveringer/Reflect/Until.java
new file mode 100644
index 0000000..e0b26da
--- /dev/null
+++ b/src/main/java/dev/wolveringer/Reflect/Until.java
@@ -0,0 +1,35 @@
+package dev.wolveringer.Reflect;
+
+import io.netty.channel.Channel;
+
+import java.lang.reflect.Field;
+import java.util.Collection;
+
+import net.md_5.bungee.BungeeCord;
+import net.md_5.bungee.protocol.MinecraftDecoder;
+import net.md_5.bungee.protocol.MinecraftEncoder;
+import net.md_5.bungee.protocol.Protocol;
+
+public class Until {
+	@SuppressWarnings("unchecked")
+	public static Collection<Channel> getChannels() throws IllegalArgumentException, IllegalAccessException, NoSuchFieldException, SecurityException {
+		Field f = BungeeCord.getInstance().getClass().getField("saveThread");
+		f.setAccessible(true);
+		return (Collection<Channel>) f.get(BungeeCord.class);
+	}
+
+	public static Protocol getProtocol(Object o) {
+		try{
+			if(o == null)
+				throw new RuntimeException("Objekt is null");
+			Field f = (o instanceof MinecraftDecoder ? MinecraftDecoder.class : MinecraftEncoder.class).getDeclaredField("protocol");
+			f.setAccessible(true);
+			return (Protocol) f.get(o);
+		}catch (NoSuchFieldException e){
+			return Protocol.HANDSHAKE;
+		}catch (Exception e){
+			e.printStackTrace();
+			return Protocol.HANDSHAKE;
+		}
+	}
+}
diff --git a/src/main/java/dev/wolveringer/ServerDatReader.java b/src/main/java/dev/wolveringer/ServerDatReader.java
new file mode 100644
index 0000000..6f72201
--- /dev/null
+++ b/src/main/java/dev/wolveringer/ServerDatReader.java
@@ -0,0 +1,58 @@
+package dev.wolveringer;
+import java.io.BufferedInputStream;
+import java.io.DataInputStream;
+import java.io.DataOutput;
+import java.io.DataOutputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.OutputStream;
+import java.net.InetSocketAddress;
+import java.net.Proxy;
+import java.net.Proxy.Type;
+import java.net.Socket;
+
+import net.md_5.bungee.api.ChatColor;
+import dev.wolveringer.BungeeUtil.BungeeUtil;
+import dev.wolveringer.BungeeUtil.Main;
+import dev.wolveringer.nbt.NBTBase;
+import dev.wolveringer.nbt.NBTCompressedStreamTools;
+import dev.wolveringer.nbt.NBTTagCompound;
+import dev.wolveringer.nbt.NBTTagList;
+import dev.wolveringer.nbt.NBTTagString;
+
+public class ServerDatReader {
+	public static void main(String[] args) throws Exception {
+		System.out.print("X");
+		File f = new File("/home/wolverindev/.minecraft/servers.dat");
+		FileInputStream in = new FileInputStream(f);
+		NBTTagCompound base = NBTCompressedStreamTools.read(new DataInputStream(new BufferedInputStream(in)));
+		NBTTagList list = base.getList("servers");
+		for(NBTBase comp : list.asList()){
+			NBTTagCompound c = (NBTTagCompound) comp;
+			c.set("name", new NBTTagString("\u00A7a\u00A7l\u00A7n"+reset(c.getString("name"))));
+			BungeeUtil.getInstance().sendMessage(comp.toString());
+		}
+		//FileOutputStream out = new FileOutputStream(f);
+		//write(base, out);
+		//out.close();
+	}
+	
+	public static String reset(String  in){
+		return ChatColor.stripColor(in);
+	}
+	
+	public static void write(NBTTagCompound nbttagcompound, OutputStream outputstream) throws Exception {
+		DataOutputStream dataoutputstream = new DataOutputStream(outputstream);
+		try{
+			NBTCompressedStreamTools.write(nbttagcompound,(DataOutput) dataoutputstream);
+		}finally{
+			try{
+				dataoutputstream.close();
+			}catch (java.io.IOException e){
+				e.printStackTrace();
+			}
+		}
+	}
+	
+}
diff --git a/src/main/java/dev/wolveringer/TimingsDataReader.java b/src/main/java/dev/wolveringer/TimingsDataReader.java
new file mode 100644
index 0000000..8e6e15b
--- /dev/null
+++ b/src/main/java/dev/wolveringer/TimingsDataReader.java
@@ -0,0 +1,52 @@
+package dev.wolveringer;
+
+import dev.wolveringer.BungeeUtil.BungeeUtil;
+import dev.wolveringer.BungeeUtil.Main;
+import dev.wolveringer.hastebin.HastebinDocument;
+import dev.wolveringer.nbt.NBTCompressedStreamTools;
+import dev.wolveringer.nbt.NBTTagCompound;
+
+public class TimingsDataReader {
+	public static void main(String[] args) {
+		try{
+			NBTTagCompound s = NBTCompressedStreamTools.read(getNBTTagString());
+			BungeeUtil.getInstance().sendMessage(s.toFormatedString());
+		}catch (Exception ex){
+			ex.printStackTrace();
+		}
+	}
+
+	public static String getNBTTagString() {
+		int mode =1;
+		switch (mode) {
+			case 0:
+				return getFixedNBTTagString();
+			case 1:
+				return getHastebinNBTTag();
+			default:
+				break;
+		}
+		return "";
+	}
+
+	public static String getHastebinNBTTag() {
+		String url = "http://hastebin.com/kecotidamu";
+		HastebinDocument doc = new HastebinDocument(url);
+		doc.load();
+		boolean active = false;
+		String out = "";
+		for(String s : doc.getLines())
+			if(s.equalsIgnoreCase("Details: (Base64 NBTTag Structure)"))
+				active = true;
+			else if(s.equalsIgnoreCase(""))
+				active = false;
+			else if(active)
+				out += s;
+		return out;
+	}
+
+	public static String getFixedNBTTagString() {
+		return "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";
+	}
+	
+}
diff --git a/src/main/java/dev/wolveringer/animations/Animation.java b/src/main/java/dev/wolveringer/animations/Animation.java
new file mode 100644
index 0000000..8c9d105
--- /dev/null
+++ b/src/main/java/dev/wolveringer/animations/Animation.java
@@ -0,0 +1,10 @@
+package dev.wolveringer.animations;
+
+public class Animation {
+	private int PID;
+	
+	
+	public int getPID() {
+		return this.PID;
+	}
+}
diff --git a/src/main/java/dev/wolveringer/animations/AnimationCallback.java b/src/main/java/dev/wolveringer/animations/AnimationCallback.java
new file mode 100644
index 0000000..80a4afe
--- /dev/null
+++ b/src/main/java/dev/wolveringer/animations/AnimationCallback.java
@@ -0,0 +1,5 @@
+package dev.wolveringer.animations;
+
+public interface AnimationCallback {
+	public void done();
+}
diff --git a/src/main/java/dev/wolveringer/animations/AnimatonLoop.java b/src/main/java/dev/wolveringer/animations/AnimatonLoop.java
new file mode 100644
index 0000000..21b95c8
--- /dev/null
+++ b/src/main/java/dev/wolveringer/animations/AnimatonLoop.java
@@ -0,0 +1,5 @@
+package dev.wolveringer.animations;
+
+public class AnimatonLoop {
+
+}
diff --git a/src/main/java/dev/wolveringer/animations/inventory/InventoryViewChangeAnimations.java b/src/main/java/dev/wolveringer/animations/inventory/InventoryViewChangeAnimations.java
new file mode 100644
index 0000000..c137d9a
--- /dev/null
+++ b/src/main/java/dev/wolveringer/animations/inventory/InventoryViewChangeAnimations.java
@@ -0,0 +1,223 @@
+package dev.wolveringer.animations.inventory;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.concurrent.TimeUnit;
+
+import net.md_5.bungee.BungeeCord;
+import net.md_5.bungee.api.Callback;
+import dev.wolveringer.BungeeUtil.Main;
+import dev.wolveringer.BungeeUtil.Material;
+import dev.wolveringer.BungeeUtil.Player;
+import dev.wolveringer.BungeeUtil.item.Item;
+import dev.wolveringer.animations.inventory.InventoryViewChangeAnimations.AnimationType;
+import dev.wolveringer.api.inventory.Inventory;
+import dev.wolveringer.api.inventory.ItemContainer;
+
+public class InventoryViewChangeAnimations {
+	public static enum AnimationType {
+		SCROLL_DOWN,
+		SCROLL_UP,
+		SCROLL_LEFT;
+	}
+
+	public static void runAnimation(AnimationType type, Inventory base, ItemContainer new_contains) {
+		runAnimation(type, base, new_contains, base.getName());
+	}
+
+	public static void runAnimation(AnimationType type, Inventory base, ItemContainer new_contains, String new_name) {
+		runAnimation(type, base, new_contains, new_name, new Item(Material.WOOL));
+	}
+
+	public static void runAnimation(AnimationType type, Inventory base, ItemContainer new_contains, String new_name, Item spacer) {
+		runAnimation(type, base, new_contains, new_name, spacer, 200);
+	}
+
+	public static void runAnimation(AnimationType type, Inventory base, ItemContainer new_contains, String new_name, Item spacer,int delay) {
+		runAnimation(type, base, new_contains, new_name, spacer, delay, null);
+	}
+	
+	public static void runAnimation(AnimationType type,final Inventory base,final Inventory new_inventory, String new_name, Item spacer,int delay,final Callback<Void> callback) {
+		Callback _callback = new Callback<Void>() {
+			@Override
+			public void done(Void arg0, Throwable arg1) {
+				for(Player p : new ArrayList<>(base.getViewer()))
+					p.openInventory(new_inventory);
+				if(callback != null)
+					callback.done(arg0, arg1);
+			}
+		};
+		if(type == AnimationType.SCROLL_DOWN)
+			runScroolUpAnimation(base, new_inventory.unsave().getItemContainer(), new_name, spacer,delay,_callback);
+		else if(type == AnimationType.SCROLL_UP)
+			runScroolDownAnimation(base, new_inventory.unsave().getItemContainer(), new_name, spacer, delay,_callback);
+	}
+	
+	public static void runAnimation(AnimationType type, Inventory base, ItemContainer new_contains, String new_name, Item spacer,int delay,final Callback<Void> callback) {
+		if(type == AnimationType.SCROLL_DOWN)
+			runScroolUpAnimation(base, new_contains, new_name, spacer,delay,callback);
+		else if(type == AnimationType.SCROLL_UP)
+			runScroolDownAnimation(base, new_contains, new_name, spacer, delay,callback);
+	}
+	
+	private static void runScroolLeftAnimation(final Inventory base, final ItemContainer new_contains, final String new_name, final Item space,int delay,final Callback<Void> callback) {
+		
+	}
+	
+	private static void runScroolUpAnimation(final Inventory base, final ItemContainer new_contains, final String new_name, final Item space,int delay,final Callback<Void> callback) {
+		final Item[][] old_rows = buildCollums(base);
+		final Item[][] new_rows = buildCollums(new_contains);
+
+		final Item[][] spacer = new Item[1][9];
+		Arrays.fill(spacer[0], space);
+
+		/**
+		 * [ROW_NUMBER][ROW]
+		 */
+		final Item[][] rows = new Item[old_rows.length + new_rows.length + 1][9];
+
+		put(rows, old_rows, 0);
+		put(rows, spacer, old_rows.length);
+		put(rows, new_rows, old_rows.length + 1);
+
+		final int old_row_count = base.getSlots() / 9;
+		final int row_count = new_contains.getSize() / 9;
+		final int row_diff = row_count - old_row_count;
+
+		LimetedScheduller scheduller = new LimetedScheduller(old_rows.length + new_rows.length + 1 - row_count, delay, TimeUnit.MILLISECONDS) {
+			@Override
+			public void run(int count) {
+				base.disableUpdate();
+				if(limit - count + 1 <= row_diff){
+					base.resize(base.getSlots() + 9);
+					for(int i = count;i < count + row_count;i++)
+						if((i - count) * 9 < base.getSlots())
+							if(i < rows.length)
+								setRowContains(base, i - count, rows[i]);
+				}else{
+					boolean x = false;
+					for(int i = count;i < count + old_row_count;i++){
+						if(i < rows.length)
+							setRowContains(base, i - count, rows[i]);
+						else
+							x = true;
+					}
+					if(x)
+						base.resize(base.getSlots() - 9);
+				}
+				if(this.count ==(int) (this.limit/2) && !base.getName().equalsIgnoreCase(new_name))
+					base.setName(new_name);
+				base.enableUpdate();
+			}
+			@Override
+			public void done() {
+				if(callback != null)
+					callback.done(null, null);
+			}
+		};
+		scheduller.start();
+	}
+
+	private static void runScroolDownAnimation(final Inventory base, final ItemContainer new_contains, final String new_name, final Item space,int delay,final Callback<Void> callback) {
+		final Item[][] old_rows = buildCollums(base);
+		final Item[][] new_rows = buildCollums(new_contains);
+
+		final Item[][] spacer = new Item[1][9];
+		Arrays.fill(spacer[0], space);
+
+		/**
+		 * [ROW_NUMBER][ROW]
+		 */
+		final Item[][] rows = new Item[old_rows.length + new_rows.length + 1][9];
+
+		put(rows, new_rows, 0);
+		put(rows, spacer, new_rows.length);
+		put(rows, old_rows, new_rows.length + 1);
+
+		final int new_row_count = new_contains.getSize() / 9;
+
+		LimetedScheduller scheduller = new LimetedScheduller(old_rows.length + new_rows.length + 1  - new_row_count, delay, TimeUnit.MILLISECONDS) {
+			boolean rezised_done = false;
+			@Override
+			public void run(int c) {
+				base.disableUpdate();
+				int count = limit-c;
+				boolean resized = false;
+				if(count < 0){
+					base.enableUpdate();
+					return;
+				}
+				if(base.getSlots() / 9 < new_row_count){
+					base.resize(base.getSlots() + 9);
+					this.count-=1;
+					resized = true;
+					if((int)(base.getSlots() / 9) == new_row_count){
+						resized = false;
+						rezised_done = true;
+					}
+				}
+				if(base.getSlots() / 9 > new_row_count){
+					base.resize(base.getSlots()-9);
+					base.enableUpdate();
+					return;
+				}
+				base.clear();
+				for(int i = count;i < count+new_row_count;i++){
+					if(rows.length>i+(resized?1:0))
+						setRowContains(base, i-count, rows[i+(resized?1:0)]);
+					else
+						setRowContains(base, i-count, rows[i]);
+				}
+				if(rezised_done){
+					this.count++;
+					rezised_done = false;
+				}
+				if(this.count ==(int) (this.limit/2) && !base.getName().equalsIgnoreCase(new_name))
+					base.setName(new_name);
+				base.enableUpdate();
+			}
+			@Override
+			public void done() {
+				if(callback != null)
+					callback.done(null, null);
+			}
+		};
+		scheduller.start();
+	}
+
+	private static void put(Item[][] base, Item[][] data, int start) {
+		for(int i = start;i - start < data.length;i++){
+			base[i] = data[i - start];
+		}
+	}
+
+	private static void setRowContains(Inventory inv, int row, Item[] rowItems) {
+		for(int i = row * 9;i < row * 9 + 9;i++)
+			if(i < inv.getSlots())
+				inv.setItem(i, rowItems[i - row * 9]);
+	}
+
+	/**
+	 * @param inv
+	 * @return Item[ROW_NUMBER][ROW]
+	 */
+	private static Item[][] buildCollums(Inventory inv) {
+		Item[][] rows = new Item[inv.getSlots() / 9][9];
+		for(int x = 0;x < rows.length;x++)
+			for(int y = 0;y < rows[0].length;y++)
+				rows[x][y] = inv.getItem(x * 9 + y);
+		return rows;
+	}
+
+	/**
+	 * @param container
+	 * @return Item[ROW_NUMBER][ROW]
+	 */
+	private static Item[][] buildCollums(ItemContainer container) {
+		Item[][] rows = new Item[container.getSize() / 9][9];
+		for(int x = 0;x < rows.length;x++)
+			for(int y = 0;y < rows[0].length;y++)
+				rows[x][y] = container.getItem(x * 9 + y);
+		return rows;
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/animations/inventory/LimetedScheduller.java b/src/main/java/dev/wolveringer/animations/inventory/LimetedScheduller.java
new file mode 100644
index 0000000..6c57977
--- /dev/null
+++ b/src/main/java/dev/wolveringer/animations/inventory/LimetedScheduller.java
@@ -0,0 +1,52 @@
+package dev.wolveringer.animations.inventory;
+
+import java.util.concurrent.TimeUnit;
+
+import net.md_5.bungee.BungeeCord;
+import dev.wolveringer.BungeeUtil.BungeeUtil;
+import dev.wolveringer.BungeeUtil.Main;
+
+public abstract class LimetedScheduller implements Runnable {
+	protected int limit;
+	protected int count;
+	private int repeat_time;
+	private TimeUnit unit;
+	private int ID;
+	
+	public LimetedScheduller(int limit, int repeat_time, TimeUnit unit) {
+		this.limit = limit;
+		this.repeat_time = repeat_time;
+		this.unit = unit;
+	}
+	
+	public LimetedScheduller(int persiod,TimeUnit untim, int repeat_time, TimeUnit unit) {
+		this.limit = (int) (untim.toMillis(persiod)/unit.toMillis(repeat_time));
+		this.repeat_time = repeat_time;
+		this.unit = unit;
+	}
+
+	@Override
+	public void run() {
+		if(count > limit){
+			BungeeCord.getInstance().getScheduler().cancel(ID);
+			done();
+		}
+		run(count);
+		count++;
+	}
+
+	public abstract void run(int count);
+
+	public void done() {
+
+	}
+
+	public void start() {
+		ID = BungeeCord.getInstance().getScheduler().schedule(BungeeUtil.getPluginInstance(), this, 0, repeat_time, unit).getId();
+	}
+
+	public void stop() {
+		BungeeCord.getInstance().getScheduler().cancel(ID);
+		done();
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/animations/text/FormatTest.java b/src/main/java/dev/wolveringer/animations/text/FormatTest.java
new file mode 100644
index 0000000..bcd882d
--- /dev/null
+++ b/src/main/java/dev/wolveringer/animations/text/FormatTest.java
@@ -0,0 +1,28 @@
+package dev.wolveringer.animations.text;
+
+import dev.wolveringer.BungeeUtil.BungeeUtil;
+import dev.wolveringer.BungeeUtil.Main;
+import net.md_5.bungee.api.ChatColor;
+
+public class FormatTest {
+	public static void main(String[] args) {
+		new scroler().start();
+	}
+}
+
+class scroler extends Thread {
+	TextFormater s = new TextFormater("<scroller width=10  space=0 time=100>HELL"+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"nO THIS IS A"+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"a TEST"+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"a STRING!</scroller>XX<scroller width=10  space=0 time=150>HELLO THIS IS A TEST STRING!</scroller>XX<scroller width=10  space=0 time=200>HELLO THIS IS A TEST STRING!</scroller>");
+
+	@Override
+	public void run() {
+		while (true){
+			BungeeUtil.getInstance().sendMessage("\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n");
+			BungeeUtil.getInstance().sendMessage("\"" + ChatColor.stripColor(s.getNextString()) + "\"");
+			try{
+				Thread.sleep(s.getTick());
+			}catch (InterruptedException e){
+				e.printStackTrace();
+			}
+		}
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/animations/text/NumericUntil.java b/src/main/java/dev/wolveringer/animations/text/NumericUntil.java
new file mode 100644
index 0000000..706bbd5
--- /dev/null
+++ b/src/main/java/dev/wolveringer/animations/text/NumericUntil.java
@@ -0,0 +1,31 @@
+package dev.wolveringer.animations.text;
+
+public class NumericUntil {
+	public static long ggt(long a,long b){
+		if(a > b){
+			long h = a;
+			a = b;
+			b = h;
+		}
+		long r;
+		while (a > 0){
+			r = b % a;
+			b = a;
+			a = r;
+		}
+		return b;
+	}
+	public static long ggt(long...z){
+		if(z.length>2){
+			long nenner = ggt(z[0],z[1]);
+			for(int i = 2;i<z.length;i++)
+				nenner= ggt(nenner,z[i]);
+			return nenner;
+		}
+		else if(z.length==2)
+			return ggt(z[0],z[1]);
+		else if(z.length==1)
+			return z[0];
+		return 1;
+	}
+}
diff --git a/src/main/java/dev/wolveringer/animations/text/RunningTextFormater.java b/src/main/java/dev/wolveringer/animations/text/RunningTextFormater.java
new file mode 100644
index 0000000..76cee94
--- /dev/null
+++ b/src/main/java/dev/wolveringer/animations/text/RunningTextFormater.java
@@ -0,0 +1,53 @@
+package dev.wolveringer.animations.text;
+
+import java.util.concurrent.TimeUnit;
+
+import net.md_5.bungee.BungeeCord;
+import dev.wolveringer.BungeeUtil.BungeeUtil;
+import dev.wolveringer.BungeeUtil.Main;
+
+public abstract class RunningTextFormater {
+	private int PID = -1;
+	private TextFormater format;
+
+	public RunningTextFormater(String in) {
+		format = new TextFormater(in);
+	}
+
+	public void start(){
+		if(PID == -1){
+			BungeeCord.getInstance().getScheduler().schedule(BungeeUtil.getPluginInstance(), new Runnable() {
+				@Override
+				public void run() {
+					update(format.getNextString());
+				}
+			}, 0, format.getTick(), TimeUnit.MILLISECONDS);
+		}
+	}
+
+	public void stop() {
+		if(PID != -1){
+			BungeeCord.getInstance().getScheduler().cancel(PID);
+			PID = -1;
+		}
+	}
+	
+	public TextFormater getFormater() {
+		return this.format;
+	}
+	public abstract void update(String newText);
+	
+	public static void main(String[] args) {
+		//Starting an scroler animation with the HTML tag <scroller>
+		//Needet arguments are:
+		//  - width --> The maximung with of the scroler
+		//  - space --> Space between repeating
+		//  - time --> time per step in ms
+		RunningTextFormater scrooler = new RunningTextFormater("<scroller width=10  space=0 time=100>HELL"+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"nO THIS IS A"+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"a TEST"+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"a STRING!</scroller>XX<scroller width=10  space=0 time=150>HELLO THIS IS A TEST STRING!</scroller>XX<scroller width=10  space=0 time=200>HELLO THIS IS A TEST STRING!</scroller>") {
+			@Override
+			public void update(String newText) {
+				//this methode will run when the text is updating
+			}
+		};
+	}
+}
diff --git a/src/main/java/dev/wolveringer/animations/text/Scroller.java b/src/main/java/dev/wolveringer/animations/text/Scroller.java
new file mode 100644
index 0000000..e28cff8
--- /dev/null
+++ b/src/main/java/dev/wolveringer/animations/text/Scroller.java
@@ -0,0 +1,67 @@
+package dev.wolveringer.animations.text;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import net.md_5.bungee.api.ChatColor;
+import dev.wolveringer.chat.ChatColor.ChatColorUtils;
+
+public class Scroller {
+	private int position;
+	private List<String> list;
+	private String colour = ChatColor.RESET + "";
+
+	public Scroller(String message, int width, int spaceBetween, char colourChar) {
+		list = new ArrayList<String>();
+		if(ChatColor.stripColor(message).length() < width){
+			while (ChatColor.stripColor(message).length() < width)
+				message += " ";
+		}
+
+		if(width < 1)
+			width = 1;
+		if(spaceBetween < 0)
+			spaceBetween = 0;
+
+		if(colourChar != dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR)
+			message = ChatColor.translateAlternateColorCodes(colourChar, message);
+
+		String raw = ChatColor.stripColor(message);
+		while (raw.length() < message.length() + spaceBetween){
+			raw += " ";
+		}
+		String msg = message;
+		while (msg.length() <= message.length() + spaceBetween){
+			msg += " ";
+		}
+		String color = "";
+		for(int i = 0;i < raw.length();i++){
+			while (i - 1 >= 0 && msg.charAt(i - 1) == dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR){
+				ChatColor g = ChatColor.getByChar(msg.charAt(i));
+				if(ChatColorUtils.isColor(g)) //WORK?
+					color = g + "";
+				else
+					color += g;
+				i++;
+			}
+			while (msg.charAt(i % msg.length()) == dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR){
+				ChatColor g = ChatColor.getByChar(msg.charAt((i % msg.length()) + 1));
+				if(ChatColorUtils.isColor(g)) //WORK?
+					color = g + "";
+				else
+					color += g;
+				i += 2;
+			}
+			list.add(color + StringUntils.subStringWithoutChatcolors(msg, i > msg.length() ? msg.length() : i, i + width > msg.length() ? msg.length() : i + width) + StringUntils.subStringWithoutChatcolors(msg, 0, i + width > msg.length() ? (i + width) - msg.length() : 0));
+		}
+	}
+
+	public String next() {
+		return list.get(position++ % list.size()).substring(0);
+	}
+
+	@Override
+	public String toString() {
+		return "Scroller [position=" + position + ", list=" + list + ", colour=" + colour + "]";
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/animations/text/StringUntils.java b/src/main/java/dev/wolveringer/animations/text/StringUntils.java
new file mode 100644
index 0000000..27b838a
--- /dev/null
+++ b/src/main/java/dev/wolveringer/animations/text/StringUntils.java
@@ -0,0 +1,24 @@
+package dev.wolveringer.animations.text;
+
+public class StringUntils {
+	public static String subStringWithoutChatcolors(String s,int min,int max){
+		String out = "";
+		int pos = min;
+		int rpos = min;
+		while (rpos<max){
+			if(s.length()<pos)
+				break;
+			while (s.charAt(pos) == dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR){
+				if(s.length()<pos)
+					break;
+				pos++;
+				out += ""+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+""+s.charAt(pos);
+				pos++;
+			}
+			out+=s.charAt(pos);
+			pos++;
+			rpos++;
+		}
+		return out;
+	}
+}
diff --git a/src/main/java/dev/wolveringer/animations/text/TextFormater.java b/src/main/java/dev/wolveringer/animations/text/TextFormater.java
new file mode 100644
index 0000000..7da1bdf
--- /dev/null
+++ b/src/main/java/dev/wolveringer/animations/text/TextFormater.java
@@ -0,0 +1,109 @@
+package dev.wolveringer.animations.text;
+
+import java.util.ArrayList;
+
+import org.jsoup.Jsoup;
+import org.jsoup.nodes.Element;
+
+/**
+ * Usage:<br>
+ * Base-Text: <br>{@code <scroller width=10  space=0 time=100>HELLO THIS IS A"+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"a TEST"+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"a STRING!</scroller>XX<scroller width=10  space=0 time=150>HELLO THIS IS A TEST STRING!</scroller>XX<scroller width=10  space=0 time=200>HELLO THIS IS A TEST STRING!</scroller>}<br>
+ * Start scroler with: {@code <scroller width=<Text With>  space=<Space between end and start> time=<time per step>>}<br>
+ * @author wolverindev
+ *
+ */
+public class TextFormater {
+	private final String raw;
+	private ArrayList<SpecScroll> scroler = new ArrayList<SpecScroll>();
+	private long kgn;
+
+	public TextFormater(String raw) {
+		this.raw = loadElement(Jsoup.parse(raw.replaceAll("&", ""+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"")));
+	}
+	private String loadElement(Element e) {
+		long[] l = new long[e.getElementsByTag("scroller").size()];
+		for(int o = 0;o<e.getElementsByTag("scroller").size();o++)
+			l[o] = Integer.parseInt(e.getElementsByTag("scroller").get(o).attr("time"));
+		kgn = NumericUntil.ggt(l);
+		for(Element x : e.getElementsByTag("scroller")){
+			x.attr("sid", scroler.size() + "");
+			scroler.add(new SpecScroll(x.text(), Integer.parseInt(x.attr("width")), Integer.parseInt(x.attr("space")), (int) (Integer.parseInt(x.attr("time"))/kgn)));
+		}
+		return e.html();
+	}
+	public String getNextString() {
+		for(SpecScroll s : scroler)
+			s.runTick();
+		Element e = Jsoup.parse(raw);
+		for(Element x : e.getElementsByTag("scroller")){
+			x.html(scroler.get(Integer.parseInt(x.attr("sid"))).getMessage().replaceAll(" ", "&nbsp;"));
+		}
+		return e.text().replaceAll("&nbsp;", " ");
+	}
+
+	public long getTick() {
+		return kgn;
+	}
+
+	public String getRawMessage() {
+		return raw;
+	}
+}
+
+class SpecScroll extends Scroller {
+	private final int ft;
+	private int t;
+	private String now;
+
+	public SpecScroll(String message, int width, int spaceBetween, int tics) {
+		super(message, width, spaceBetween, dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR);
+		t = ft = tics;
+		now = super.next();
+	}
+
+	public SpecScroll runTick() {
+		t--;
+		if(t <= 0){
+			t = ft;
+			now = super.next();
+		}
+		return this;
+	}
+
+	public String getMessage() {
+		return now;
+	}
+	
+	public int getTickRate(){
+		return ft;
+	}
+
+	@Deprecated
+	@Override
+	public String next() {
+		throw new OperationNotSupportedException();
+	}
+}
+
+@SuppressWarnings("serial")
+class OperationNotSupportedException extends RuntimeException {
+	public OperationNotSupportedException() {
+		super();
+	}
+
+	public OperationNotSupportedException(String arg0, Throwable arg1, boolean arg2, boolean arg3) {
+		super(arg0, arg1, arg2, arg3);
+	}
+
+	public OperationNotSupportedException(String arg0, Throwable arg1) {
+		super(arg0, arg1);
+	}
+
+	public OperationNotSupportedException(String arg0) {
+		super(arg0);
+	}
+
+	public OperationNotSupportedException(Throwable arg0) {
+		super(arg0);
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/animations/text/TickedTextFormater.java b/src/main/java/dev/wolveringer/animations/text/TickedTextFormater.java
new file mode 100644
index 0000000..e7059ae
--- /dev/null
+++ b/src/main/java/dev/wolveringer/animations/text/TickedTextFormater.java
@@ -0,0 +1,35 @@
+package dev.wolveringer.animations.text;
+
+public class TickedTextFormater extends TextFormater{
+	private final int ft;
+	private int t;
+	private String now;
+
+	public TickedTextFormater(String raw, int ticks) {
+		super(raw);
+		t = ft = ticks;
+		now = super.getNextString();
+	}
+
+	public TickedTextFormater runTick() {
+		t--;
+		if(t <= 0){
+			t = ft;
+			now = super.getNextString();
+		}
+		return this;
+	}
+
+	public String getMessage() {
+		return now;
+	}
+	
+	public int getTickRate(){
+		return ft;
+	}
+
+	@Override
+	public String getNextString() {
+		throw new OperationNotSupportedException();
+	}
+}
diff --git a/src/main/java/dev/wolveringer/api/bossbar/BossBarListener.java b/src/main/java/dev/wolveringer/api/bossbar/BossBarListener.java
new file mode 100644
index 0000000..395ac41
--- /dev/null
+++ b/src/main/java/dev/wolveringer/api/bossbar/BossBarListener.java
@@ -0,0 +1,58 @@
+package dev.wolveringer.api.bossbar;
+
+import dev.wolveringer.BungeeUtil.PacketHandleEvent;
+import dev.wolveringer.BungeeUtil.PacketHandler;
+import dev.wolveringer.BungeeUtil.PacketLib;
+import dev.wolveringer.BungeeUtil.Player;
+import dev.wolveringer.BungeeUtil.configuration.Configuration;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayOutBossBar;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayOutBossBar.Action;
+import dev.wolveringer.api.bossbar.BossBarManager.BossBar;
+
+public class BossBarListener implements PacketHandler<PacketPlayOutBossBar>{
+	private static BossBarListener listener;
+	public static void init(){
+		if(listener == null && Configuration.isBossBarhandleEnabled())
+			PacketLib.addHandler(listener = new BossBarListener()); 
+	}
+	
+	@Override
+	public void handle(PacketHandleEvent<PacketPlayOutBossBar> e) {
+		Player player = e.getPlayer();
+		BossBarManager manager = player.getBossBarManager();
+		BossBar bar = null;
+		if(e.getPacket().getAction() != Action.CREATE){
+			bar = manager.getBossBar(e.getPacket().getBarId());
+			if(bar == null || !bar.isVisiable()) //Bar hidden / removed. Client dont need to get them
+				e.setCancelled(true);
+		}
+		
+		switch (e.getPacket().getAction()) {
+			case CREATE:
+				manager.bars.add(new BossBar(manager, e.getPacket().getBarId(), e.getPacket().getColor(), e.getPacket().getDivision(), e.getPacket().getHealth(), e.getPacket().getTitle(), true));
+				break;
+			case DELETE:
+				if(bar != null)
+					manager.bars.remove(bar);
+				break;
+			case UPDATE_HEALTH:
+				if(bar != null){
+					bar.setHealth(e.getPacket().getHealth());
+				}
+				break;
+			case UPDATE_STYLE:
+				if(bar != null){
+					bar.setColor(e.getPacket().getColor());
+					bar.setDivision(e.getPacket().getDivision());
+				}
+				break;
+			case UPDATE_TITLE:
+				if(bar != null){
+					bar.setMessage(e.getPacket().getTitle());
+				}
+				break;
+			default:
+				break;
+		}
+	}
+}
diff --git a/src/main/java/dev/wolveringer/api/bossbar/BossBarManager.java b/src/main/java/dev/wolveringer/api/bossbar/BossBarManager.java
new file mode 100644
index 0000000..d963951
--- /dev/null
+++ b/src/main/java/dev/wolveringer/api/bossbar/BossBarManager.java
@@ -0,0 +1,163 @@
+package dev.wolveringer.api.bossbar;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.UUID;
+import java.util.concurrent.TimeUnit;
+
+import dev.wolveringer.BungeeUtil.Player;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayOutBossBar;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayOutBossBar.Action;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayOutBossBar.BarColor;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayOutBossBar.BarDivision;
+import dev.wolveringer.animations.inventory.LimetedScheduller;
+import dev.wolveringer.chat.ChatSerializer;
+import dev.wolveringer.chat.IChatBaseComponent;
+import dev.wolveringer.chat.ChatColor.ChatColorUtils;
+import lombok.Getter;
+import net.md_5.bungee.api.ChatColor;
+import net.md_5.bungee.api.scheduler.ScheduledTask;
+
+public class BossBarManager {
+	
+	private static class DynamicBossBarRunner implements Runnable{
+
+		@Override
+		public void run() {
+			
+		}
+		
+	}
+	
+	@Getter
+	public static class BossBar {
+		private static float steps = 0.01F;
+		private BossBarManager manager;
+		private UUID uuid;
+		private PacketPlayOutBossBar.BarColor color;
+		private PacketPlayOutBossBar.BarDivision division;
+		private float health;
+		private IChatBaseComponent message;
+		private boolean visiable;
+		private LimetedScheduller curruntTask;
+		
+		private BossBar(BossBarManager manager) {
+			this.manager = manager;
+			uuid = UUID.randomUUID();
+			color = BarColor.PING;
+			division = BarDivision.TEN_DIVISIONS;
+			health = 0.5F;
+			message = ChatSerializer.fromMessage(ChatColorUtils.COLOR_CHAR+"cUndefined");
+		}
+		
+		public void setColor(PacketPlayOutBossBar.BarColor color) {
+			this.color = color;
+			if (visiable) this.manager.player.sendPacket(new PacketPlayOutBossBar().setBarId(uuid).setAction(Action.UPDATE_STYLE).setColor(color).setDivision(division));
+		}
+		
+		public void setDivision(PacketPlayOutBossBar.BarDivision division) {
+			this.division = division;
+			if (visiable) this.manager.player.sendPacket(new PacketPlayOutBossBar().setBarId(uuid).setAction(Action.UPDATE_STYLE).setColor(color).setDivision(division));
+		}
+		
+		public void setHealth(float value) {
+			this.health = value;
+			if (visiable) this.manager.player.sendPacket(new PacketPlayOutBossBar().setBarId(uuid).setAction(Action.UPDATE_HEALTH).setHealth(value));
+		}
+		
+		public void setMessage(IChatBaseComponent message) {
+			this.message = message;
+			if (visiable) this.manager.player.sendPacket(new PacketPlayOutBossBar().setBarId(uuid).setAction(Action.UPDATE_TITLE).setTitle(message));
+		}
+		
+		public void display() {
+			if (manager.getActiveBossBars().size() + 1 > manager.getBarLimit()) throw new RuntimeException("BossBar limit is reached!");
+			if (visiable) return;
+			visiable = true;
+			this.manager.player.sendPacket(new PacketPlayOutBossBar().setBarId(uuid).setAction(Action.CREATE).setTitle(message).setHealth(health).setColor(color).setDivision(division));
+		}
+		
+		public void hide() {
+			if (!visiable) return;
+			visiable = false;
+			this.manager.player.sendPacket(new PacketPlayOutBossBar().setBarId(uuid).setAction(Action.DELETE));
+		}
+		
+		public void dynamicChangeHealth(float health,int time,TimeUnit unit){
+			if(curruntTask != null)
+				curruntTask.stop();
+			float diff = this.health-health;
+			if(diff == 0)
+				return;
+			final float base = this.health;
+			int stepCount = (int) (diff/steps);
+			final float addPerStep = diff/stepCount;
+			int millis = (int) unit.toMillis(time);
+			int loopsTime = (int) (millis/stepCount);
+			
+			new LimetedScheduller(millis,Math.abs(loopsTime),TimeUnit.MILLISECONDS) {
+				@Override
+				public void run(int count) {
+					setHealth(base+(addPerStep*count));
+				}
+			}.start();
+		}
+		
+		protected BossBar(BossBarManager manager, UUID uuid, BarColor color, BarDivision division, float value, IChatBaseComponent message, boolean visiable) {
+			this.manager = manager;
+			this.uuid = uuid;
+			this.color = color;
+			this.division = division;
+			this.health = value;
+			this.message = message;
+			this.visiable = visiable;
+		}
+	}
+	
+	private Player player;
+	protected ArrayList<BossBar> bars = new ArrayList<>();
+	private int limit = -1;
+	
+	public BossBarManager(Player player) {
+		this.player = player;
+	}
+	
+	public BossBar getBossBar(UUID uuid) {
+		for (BossBar b : bars)
+			if (b.uuid.equals(uuid)) return b;
+		return null;
+	}
+	
+	public int getBarLimit() {
+		return limit == -1 ? Integer.MAX_VALUE : limit;
+	}
+	
+	public void setBarLimit(int limit) {
+		this.limit = limit;
+	}
+	
+	public BossBar createNewBossBar() {
+		BossBar _new = new BossBar(this);
+		bars.add(_new);
+		return _new;
+	}
+	
+	public List<BossBar> getActiveBossBars() {
+		List<BossBar> bars = new ArrayList<>();
+		for (BossBar bar : this.bars)
+			if (bar.isVisiable()) bars.add(bar);
+		return Collections.unmodifiableList(bars);
+	}
+	
+	public List<BossBar> getAllBossBars() {
+		return Collections.unmodifiableList(bars);
+	}
+	
+	public void deleteBossBar(BossBar bar) {
+		if(bar == null)
+			return;
+		bars.remove(bar);
+		bar.hide();
+	}
+}
diff --git a/src/main/java/dev/wolveringer/api/datawatcher/BlockData.java b/src/main/java/dev/wolveringer/api/datawatcher/BlockData.java
new file mode 100644
index 0000000..1fa0c8c
--- /dev/null
+++ b/src/main/java/dev/wolveringer/api/datawatcher/BlockData.java
@@ -0,0 +1,18 @@
+package dev.wolveringer.api.datawatcher;
+
+public class BlockData {
+	private int data;
+
+	public BlockData(int data) {
+		super();
+		this.data = data;
+	}
+
+	public int getData() {
+		return data;
+	}
+
+	public void setData(int data) {
+		this.data = data;
+	}
+}
diff --git a/src/main/java/dev/wolveringer/api/datawatcher/DataWatcher.java b/src/main/java/dev/wolveringer/api/datawatcher/DataWatcher.java
new file mode 100644
index 0000000..d790a8f
--- /dev/null
+++ b/src/main/java/dev/wolveringer/api/datawatcher/DataWatcher.java
@@ -0,0 +1,52 @@
+package dev.wolveringer.api.datawatcher;
+
+import dev.wolveringer.BungeeUtil.ClientVersion.BigClientVersion;
+import dev.wolveringer.api.datawatcher.impl.v1_10_DataWatcher;
+import dev.wolveringer.api.datawatcher.impl.v1_8_DataWatcher;
+import dev.wolveringer.api.datawatcher.impl.v1_9_DataWatcher;
+import dev.wolveringer.packet.PacketDataSerializer;
+
+public abstract class DataWatcher {
+	
+	public static DataWatcher createDataWatcher(BigClientVersion version){
+		return createDataWatcher(version, null);
+	}
+	
+	public static DataWatcher createDataWatcher(BigClientVersion version,PacketDataSerializer watcher){
+		switch (version) {
+			case v1_8:
+				return new v1_8_DataWatcher(watcher);
+			case v1_9:
+				return new v1_9_DataWatcher(watcher);
+			case v1_10:
+				return new v1_10_DataWatcher(watcher);
+			default:
+				throw new RuntimeException("Cant find datawatcher for "+version);
+		}
+	}
+	
+	public abstract void write(PacketDataSerializer packetdataserializer);
+	
+	public abstract void setValue(int pos, Object object);
+	
+	@Override
+	public abstract String toString();
+	
+	public abstract DataWatcher copy();
+	
+	public abstract EntityDataWatcher getEntityDataWatcher();
+	
+	public abstract <T extends EntityDataWatcher> T getSpecialDataWatcher(Class<T> clazz);
+	
+	public abstract Object get(int i);
+	
+	public abstract byte getByte(int i);
+	
+	public abstract short getShort(int i);
+	
+	public abstract int getInt(int i);
+	
+	public abstract String getString(int i);
+	
+	public abstract float getFloat(int i);
+}
diff --git a/src/main/java/dev/wolveringer/api/datawatcher/DataWatcherObjekt.java b/src/main/java/dev/wolveringer/api/datawatcher/DataWatcherObjekt.java
new file mode 100644
index 0000000..28933c7
--- /dev/null
+++ b/src/main/java/dev/wolveringer/api/datawatcher/DataWatcherObjekt.java
@@ -0,0 +1,46 @@
+package dev.wolveringer.api.datawatcher;
+
+import dev.wolveringer.BungeeUtil.ClientVersion.BigClientVersion;
+
+public class DataWatcherObjekt {
+	private final Class<?> clazz;
+	private final int pos;
+	private Object value;
+	private boolean update;
+	
+	public DataWatcherObjekt(Class<?> clazz, int pos, Object object) {
+		this.pos = pos;
+		this.value = object;
+		this.clazz = clazz;
+	}
+
+	public int getPostition() {
+		return this.pos;
+	}
+
+	public void setValue(Object object) {
+		this.value = object;
+		update = true;
+	}
+
+	public Object getValue() {
+		return this.value;
+	}
+
+	public Class<?> getType() {
+		return this.clazz;
+	}
+	
+	public boolean hasUpdate() {
+		return update;
+	}
+	
+	@Override
+	public String toString() {
+		return "[" + pos + "=" + value + " (" + value.getClass().getName().split("\\.")[value.getClass().getName().split("\\.").length - 1] + ")],";
+	}
+
+	public int getTypeId(BigClientVersion version) {
+		return 0;
+	}
+}
diff --git a/src/main/java/dev/wolveringer/api/datawatcher/Direction.java b/src/main/java/dev/wolveringer/api/datawatcher/Direction.java
new file mode 100644
index 0000000..bc23572
--- /dev/null
+++ b/src/main/java/dev/wolveringer/api/datawatcher/Direction.java
@@ -0,0 +1,17 @@
+package dev.wolveringer.api.datawatcher;
+
+public class Direction {
+	private int direction;
+
+	public Direction(int direction) {
+		this.direction = direction;
+	}
+
+	public int getDirection() {
+		return direction;
+	}
+
+	public void setDirection(int direction) {
+		this.direction = direction;
+	}
+}
diff --git a/src/main/java/dev/wolveringer/api/datawatcher/EntityDataWatcher.java b/src/main/java/dev/wolveringer/api/datawatcher/EntityDataWatcher.java
new file mode 100644
index 0000000..3fedc9f
--- /dev/null
+++ b/src/main/java/dev/wolveringer/api/datawatcher/EntityDataWatcher.java
@@ -0,0 +1,60 @@
+package dev.wolveringer.api.datawatcher;
+
+public interface EntityDataWatcher{
+	
+	public boolean isSneaking();
+
+	public void setSneaking(boolean flag);
+
+	public boolean isSprinting();
+
+	public void setSprinting(boolean flag);
+
+	public boolean isInvisible();
+
+	public void setInvisible(boolean flag);
+	
+	/**
+	 *  Minecrat 1.9
+	 */
+	
+	public boolean isOnFire();
+	
+	public void setOnFire(boolean fire);
+	
+	public boolean isBlocking();
+	
+	public void setBlocking(boolean block); 
+	
+	public boolean isGlowing();
+	
+	public void setGlowing(boolean glow); 
+	
+	public boolean isElytra();
+	
+	public void setElytra(boolean elytra); 
+	
+	public int getAir();
+	
+	public void setAir(int air);
+	
+	public void setCostumName(String name);
+	
+	public String getCostumName();
+	
+	public boolean isCostumNameVisiable();
+	
+	public void setCostumNameVisiable(boolean flag);
+	
+	public boolean isSlient();
+	
+	public void setSlient(boolean flag);
+	
+	public boolean hasGravity();
+	public void setApplayGravity(boolean flag);
+	
+	
+	public DataWatcher getWatcher();
+	
+	public EntityDataWatcher injektDefault();
+}
diff --git a/src/main/java/dev/wolveringer/api/datawatcher/HumanDataWatcher.java b/src/main/java/dev/wolveringer/api/datawatcher/HumanDataWatcher.java
new file mode 100644
index 0000000..9c4b823
--- /dev/null
+++ b/src/main/java/dev/wolveringer/api/datawatcher/HumanDataWatcher.java
@@ -0,0 +1,22 @@
+package dev.wolveringer.api.datawatcher;
+
+public interface HumanDataWatcher extends LivingEntityDataWatcher {
+	public void setSkinFlags(byte flag);
+
+	public byte getSkinFlag();
+
+	public void setCapeActive(boolean b);
+
+	public boolean isCapeActive();
+
+	public void setAbsorptionHearts(float f);
+
+	public float getAbsorptionHearts();
+
+	public void setScore(int score);
+
+	public int getScore();
+
+	@Override
+	public HumanDataWatcher injektDefault();
+}
diff --git a/src/main/java/dev/wolveringer/api/datawatcher/LivingEntityDataWatcher.java b/src/main/java/dev/wolveringer/api/datawatcher/LivingEntityDataWatcher.java
new file mode 100644
index 0000000..ff382ee
--- /dev/null
+++ b/src/main/java/dev/wolveringer/api/datawatcher/LivingEntityDataWatcher.java
@@ -0,0 +1,27 @@
+package dev.wolveringer.api.datawatcher;
+
+public interface LivingEntityDataWatcher extends EntityDataWatcher {
+
+	public void setHealth(float h);
+
+	public float getHealth();;
+
+	public void setArrows(int amauth);
+
+	public int getArrows();
+
+	public void setParicelColor(int color);
+	
+	public int getParicelColor();
+	
+	public void setParticelVisiable(boolean flag);
+	
+	public boolean isParticelVisiable();
+
+	public void setAI(boolean flag);
+	
+	public boolean hasAI();
+
+	@Override
+	public LivingEntityDataWatcher injektDefault();
+}
diff --git a/src/main/java/dev/wolveringer/api/datawatcher/OptionalBlockPosition.java b/src/main/java/dev/wolveringer/api/datawatcher/OptionalBlockPosition.java
new file mode 100644
index 0000000..fc69ade
--- /dev/null
+++ b/src/main/java/dev/wolveringer/api/datawatcher/OptionalBlockPosition.java
@@ -0,0 +1,22 @@
+package dev.wolveringer.api.datawatcher;
+
+import dev.wolveringer.api.position.BlockPosition;
+
+public class OptionalBlockPosition {
+	private BlockPosition position;
+
+	public OptionalBlockPosition(BlockPosition position) {
+		super();
+		this.position = position;
+	}
+
+	public BlockPosition getPosition() {
+		return position;
+	}
+
+	public void setPosition(BlockPosition position) {
+		this.position = position;
+	}
+	
+	
+}
diff --git a/src/main/java/dev/wolveringer/api/datawatcher/OptionalUUID.java b/src/main/java/dev/wolveringer/api/datawatcher/OptionalUUID.java
new file mode 100644
index 0000000..e135eb8
--- /dev/null
+++ b/src/main/java/dev/wolveringer/api/datawatcher/OptionalUUID.java
@@ -0,0 +1,20 @@
+package dev.wolveringer.api.datawatcher;
+
+import java.util.UUID;
+
+public class OptionalUUID {
+	private UUID uuid;
+
+	public OptionalUUID(UUID uuid) {
+		super();
+		this.uuid = uuid;
+	}
+
+	public UUID getUuid() {
+		return uuid;
+	}
+
+	public void setUuid(UUID uuid) {
+		this.uuid = uuid;
+	}
+}
diff --git a/src/main/java/dev/wolveringer/api/datawatcher/impl/DataWatcherObjekt.java b/src/main/java/dev/wolveringer/api/datawatcher/impl/DataWatcherObjekt.java
new file mode 100644
index 0000000..bae649e
--- /dev/null
+++ b/src/main/java/dev/wolveringer/api/datawatcher/impl/DataWatcherObjekt.java
@@ -0,0 +1,46 @@
+package dev.wolveringer.api.datawatcher.impl;
+
+import dev.wolveringer.BungeeUtil.ClientVersion.BigClientVersion;
+
+public class DataWatcherObjekt {
+	private final Class<?> clazz;
+	private final int pos;
+	private Object value;
+	private boolean update;
+	
+	public DataWatcherObjekt(Class<?> clazz, int pos, Object object) {
+		this.pos = pos;
+		this.value = object;
+		this.clazz = clazz;
+	}
+
+	public int getPostition() {
+		return this.pos;
+	}
+
+	public void setValue(Object object) {
+		this.value = object;
+		update = true;
+	}
+
+	public Object getValue() {
+		return this.value;
+	}
+
+	public Class<?> getType() {
+		return this.clazz;
+	}
+	
+	public boolean hasUpdate() {
+		return update;
+	}
+	
+	@Override
+	public String toString() {
+		return "[" + pos + "=" + value + " (" + value.getClass().getName().split("\\.")[value.getClass().getName().split("\\.").length - 1] + ")],";
+	}
+
+	public int getTypeId(BigClientVersion version) {
+		return 0;
+	}
+}
diff --git a/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_10_DataWatcher.java b/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_10_DataWatcher.java
new file mode 100644
index 0000000..891681e
--- /dev/null
+++ b/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_10_DataWatcher.java
@@ -0,0 +1,277 @@
+package dev.wolveringer.api.datawatcher.impl;
+
+import gnu.trove.map.TObjectIntMap;
+import gnu.trove.map.hash.TObjectIntHashMap;
+
+import java.lang.reflect.InvocationTargetException;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+
+import dev.wolveringer.BungeeUtil.item.Item;
+import dev.wolveringer.api.datawatcher.BlockData;
+import dev.wolveringer.api.datawatcher.DataWatcher;
+import dev.wolveringer.api.datawatcher.Direction;
+import dev.wolveringer.api.datawatcher.EntityDataWatcher;
+import dev.wolveringer.api.datawatcher.HumanDataWatcher;
+import dev.wolveringer.api.datawatcher.LivingEntityDataWatcher;
+import dev.wolveringer.api.datawatcher.OptionalBlockPosition;
+import dev.wolveringer.api.datawatcher.OptionalUUID;
+import dev.wolveringer.api.position.BlockPosition;
+import dev.wolveringer.api.position.Vector3f;
+import dev.wolveringer.chat.IChatBaseComponent;
+import dev.wolveringer.packet.PacketDataSerializer;
+
+@SuppressWarnings({ "rawtypes", "unchecked" })
+public class v1_10_DataWatcher extends DataWatcher{
+	private static final TObjectIntMap v1_10_classToId = new TObjectIntHashMap(10, 0.5F, -1);
+	
+	static {
+		v1_10_classToId.put(Byte.class, 0);
+		v1_10_classToId.put(Integer.class, 1);
+		v1_10_classToId.put(Float.class, 2);
+		v1_10_classToId.put(String.class, 3);
+		v1_10_classToId.put(IChatBaseComponent.class, 4);
+		v1_10_classToId.put(Item.class, 5);
+		v1_10_classToId.put(Boolean.class, 6);
+		v1_10_classToId.put(Vector3f.class, 7);
+		v1_10_classToId.put(BlockPosition.class, 8);
+		v1_10_classToId.put(OptionalBlockPosition.class, 9);
+		v1_10_classToId.put(Direction.class, 10);
+		v1_10_classToId.put(OptionalUUID.class, 11);
+		v1_10_classToId.put(BlockData.class, 12);
+		
+		v1_10_classToId.put(Short.class, 13); //old
+	}
+	
+	@SuppressWarnings("serial")
+	private List<DataWatcherObjekt> objekts = new ArrayList<DataWatcherObjekt>() {
+		public DataWatcherObjekt get(int index) {
+			return index >= size() ? null : super.get(index);
+		};
+		
+		public DataWatcherObjekt set(int index, DataWatcherObjekt element) {
+			while (size() <= index) {
+				add(null);
+			}
+			return super.set(index, element);
+		};
+	};
+	
+	@SuppressWarnings("serial")
+	private HashMap<Class, EntityDataWatcher> watchers = new HashMap<Class, EntityDataWatcher>() {
+		public EntityDataWatcher put(Class key, EntityDataWatcher value) {
+			Class _super = key.getSuperclass();
+			while (EntityDataWatcher.class.isAssignableFrom(_super) && super.get(_super) == null) {
+				super.put(_super, value);
+			}
+			return super.put(key, value);
+		};
+	};
+	
+	public v1_10_DataWatcher(PacketDataSerializer paramPacketDataSerializer) {
+		this();
+		if(paramPacketDataSerializer != null)
+		this.objekts = read(paramPacketDataSerializer);
+	}
+	
+	public v1_10_DataWatcher() {
+	}
+	
+	public void write(PacketDataSerializer packetdataserializer) {
+		Iterator iterator = objekts.iterator();
+		while (iterator.hasNext()) {
+			DataWatcherObjekt watchableobject = (DataWatcherObjekt) iterator.next();
+			if (watchableobject == null) continue;
+			write(packetdataserializer, watchableobject);
+		}
+		packetdataserializer.writeByte(255); // end
+	}
+	
+	private void write(PacketDataSerializer s, DataWatcherObjekt o) {
+			s.writeByte(o.getPostition());
+			int typeId = v1_10_classToId.get(o.getType());
+			if (typeId == 13) s.writeByte(v1_10_classToId.get(Integer.class));
+			else s.writeByte(typeId);
+			
+			switch (typeId) {
+				case 0:
+					s.writeByte((byte) o.getValue());
+					break;
+				case 1:
+					s.writeVarInt((int) o.getValue());
+					break;
+				case 2:
+					s.writeFloat((float) o.getValue());
+					break;
+				case 3:
+					s.writeString((String) o.getValue());
+					break;
+				case 4:
+					s.writeRawString((IChatBaseComponent) o.getValue());
+					break;
+				case 5:
+					s.writeItem((Item) o.getValue());
+					break;
+				case 6:
+					s.writeBoolean((boolean) o.getValue());
+					break;
+				case 7:
+					Vector3f v = (Vector3f) o.getValue();
+					s.writeFloat(v.getX());
+					s.writeFloat(v.getY());
+					s.writeFloat(v.getZ());
+					break;
+				case 8:
+					s.writeBlockPosition((BlockPosition) o.getValue());
+					break;
+				case 9:
+					OptionalBlockPosition p = (OptionalBlockPosition) o.getValue(); // Optional
+					s.writeBoolean(p.getPosition() != null);
+					if (p != null) s.writeBlockPosition(p.getPosition());
+					break;
+				case 10:
+					s.writeVarInt(((Direction) o.getValue()).getDirection()); // Direction
+					break;
+				case 11:
+					OptionalUUID uuid = (OptionalUUID) o.getValue(); // Optional
+					s.writeBoolean(uuid.getUuid() != null);
+					if (uuid != null) s.writeUUID(uuid.getUuid());
+					break;
+				case 12:
+					s.writeVarInt(((BlockData) o.getValue()).getData()); // Block
+					break; // Data
+				case 13: // Short will write as an interger
+					s.writeVarInt((Short) o.getValue());
+					break;
+				default:
+					System.out.println("Type not found ("+typeId+") ("+o.getType()+")");
+					break;
+			}
+	}
+	
+	private List read(PacketDataSerializer packetdataserializer) {
+		ArrayList arraylist = new ArrayList();
+			for (int data = packetdataserializer.readUnsignedByte(); data != 255; data = packetdataserializer.readUnsignedByte()) {
+				int pos = data;
+				int type = packetdataserializer.readUnsignedByte();
+				Object value = null;
+				switch (type) {
+					case 0:
+						value = packetdataserializer.readByte();
+						break;
+					case 1:
+						value = packetdataserializer.readVarInt();
+						break;
+					case 2:
+						value = packetdataserializer.readFloat();
+						break;
+					case 3:
+						value = packetdataserializer.readString(-1);
+						break;
+					case 4:
+						value = packetdataserializer.readRawString();
+						break;
+					case 5:
+						value = packetdataserializer.readItem();
+						break;
+					case 6:
+						value = packetdataserializer.readBoolean();
+						break;
+					case 7:
+						value = new Vector3f(packetdataserializer.readFloat(), packetdataserializer.readFloat(), packetdataserializer.readFloat());
+						break;
+					case 8:
+						value = packetdataserializer.readBlockPosition();
+						break;
+					case 9:
+						if (packetdataserializer.readBoolean()) value = new OptionalBlockPosition(packetdataserializer.readBlockPosition());
+						else value = new OptionalBlockPosition(null);
+						break;
+					case 10:
+						value = new Direction(packetdataserializer.readVarInt());
+						break;
+					case 11:
+						if (packetdataserializer.readBoolean()) value = new OptionalUUID(packetdataserializer.readUUID());
+						else value = new OptionalUUID(null);
+						break;
+					case 12:
+						value = new BlockData(packetdataserializer.readVarInt());
+						break;
+				}
+				arraylist.add(new DataWatcherObjekt(getTypeId(type), pos, value));
+		}
+		return arraylist;
+	}
+	
+	public void setValue(int pos, Object object) {
+		if (pos > 254) { throw new IllegalArgumentException("Data value id is too big with " + pos + "! (Max is " + 254 + ")"); }
+		if (objekts.get(pos) == null) objekts.set(pos, new DataWatcherObjekt(object.getClass(), pos, null));
+		objekts.get(pos).setValue(object);
+	}
+	
+	private static Class<?> getTypeId(int type) {
+			for (Object o : v1_10_classToId.keys())
+				if (v1_10_classToId.get(o) == type) return (Class<?>) o;
+		return null;
+	}
+	
+	@Override
+	public String toString() {
+		return "DataWatcher [v1_10] [objekts=" + objekts + "]";
+	}
+	
+	public DataWatcher copy() {
+		v1_10_DataWatcher watcher = new v1_10_DataWatcher();
+		watcher.objekts = new ArrayList<DataWatcherObjekt>(this.objekts);
+		return watcher;
+	}
+	
+	public EntityDataWatcher getEntityDataWatcher() {
+		return getSpecialDataWatcher(EntityDataWatcher.class);
+	}
+	
+	public <T extends EntityDataWatcher> T getSpecialDataWatcher(Class<T> clazz) {
+		if(clazz.isAssignableFrom(EntityDataWatcher.class))
+			clazz = (Class<T>) v1_10_EntityDataWatcher.class;
+		else if(clazz.isAssignableFrom(LivingEntityDataWatcher.class))
+			clazz = (Class<T>) v1_10_LivingEntityDataWatcher.class;
+		else if(clazz.isAssignableFrom(HumanDataWatcher.class))
+			clazz = (Class<T>) v1_10_HumanEntityDataWatcher.class;
+		if (watchers.get(clazz) == null) {
+			try {
+				watchers.put(clazz, clazz.getConstructor(DataWatcher.class).newInstance(this));
+			}
+			catch (InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException | NoSuchMethodException | SecurityException e) {
+				e.printStackTrace();
+			}
+		}
+		return (T) watchers.get(clazz);
+	}
+	
+	public Object get(int i) {
+		if (objekts.get(i) == null) return null;
+		return objekts.get(i).getValue();
+	}
+	
+	public byte getByte(int i) {
+		return (byte) get(i);
+	}
+	
+	public short getShort(int i) {
+		return (short) get(i);
+	}
+	
+	public int getInt(int i) {
+		return (int) get(i);
+	}
+	
+	public String getString(int i) {
+		return (String) get(i);
+	}
+	
+	public float getFloat(int i) {
+		return (float) get(i);
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_10_EntityDataWatcher.java b/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_10_EntityDataWatcher.java
new file mode 100644
index 0000000..0c7026c
--- /dev/null
+++ b/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_10_EntityDataWatcher.java
@@ -0,0 +1,160 @@
+package dev.wolveringer.api.datawatcher.impl;
+
+import dev.wolveringer.api.datawatcher.DataWatcher;
+import dev.wolveringer.api.datawatcher.EntityDataWatcher;
+
+public class v1_10_EntityDataWatcher implements EntityDataWatcher{
+	
+	protected DataWatcher watcher;
+	
+	protected v1_10_EntityDataWatcher(DataWatcher dataWatcher) {
+		this.watcher = dataWatcher;
+	}
+	
+	private boolean getPropety(int pos) {
+		return (this.watcher.getByte(0) & 1 << pos) != 0;
+	}
+	
+	private void setPropety(int pos, boolean flag) {
+		if (this.watcher.get(0) == null)
+			this.watcher.setValue(0, (byte) 0);
+		byte b0 = this.watcher.getByte(0);
+		
+		if (flag) {
+			this.watcher.setValue(0, Byte.valueOf((byte) (b0 | 1 << pos)));
+		} else {
+			this.watcher.setValue(0, Byte.valueOf((byte) (b0 & (1 << pos ^ 0xFFFFFFFF))));
+		}
+	}
+	
+	public boolean isSneaking() {
+		return getPropety(1);
+	}
+	
+	public void setSneaking(boolean flag) {
+		setPropety(1, flag);
+	}
+	
+	public boolean isSprinting() {
+		return getPropety(2);
+	}
+	
+	public void setSprinting(boolean flag) {
+		setPropety(2, flag);
+	}
+	
+	public boolean isInvisible() {
+		return getPropety(4);
+	}
+	
+	public void setInvisible(boolean flag) {
+		setPropety(4, flag);
+	}
+	
+	public EntityDataWatcher injektDefault() {
+		if (this.watcher.get(0) == null)
+			this.watcher.setValue(0, Byte.valueOf((byte) 0));
+		if (this.watcher.get(1) == null)
+			this.watcher.setValue(1, (Integer)((int) 300));
+		if (this.watcher.get(2) == null)
+			this.watcher.setValue(2, "");
+		if (this.watcher.get(3) == null)
+			this.watcher.setValue(3,false);
+		if (this.watcher.get(4) == null)
+			this.watcher.setValue(4,false);
+		return this;
+	}
+	
+	public DataWatcher getWatcher() {
+		return watcher;
+	}
+
+	@Override
+	public boolean isOnFire() {
+		return getPropety(0);
+	}
+
+	@Override
+	public void setOnFire(boolean fire) {
+		setPropety(0, fire);
+	}
+
+	@Override
+	public boolean isBlocking() {
+		return getPropety(3);
+	}
+
+	@Override
+	public void setBlocking(boolean block) {
+		setPropety(3, block);
+	}
+
+	@Override
+	public boolean isGlowing() {
+		return getPropety(6);
+	}
+
+	@Override
+	public void setGlowing(boolean glow) {
+		setPropety(6, glow);
+	}
+
+	@Override
+	public boolean isElytra() {
+		return getPropety(7);
+	}
+
+	@Override
+	public void setElytra(boolean elytra) {
+		setPropety(7, elytra);
+	}
+
+	@Override
+	public int getAir() {
+		return watcher.getInt(1);
+	}
+
+	@Override
+	public void setAir(int air) {
+		watcher.setValue(1, air);
+	}
+
+	@Override
+	public void setCostumName(String name) {
+		watcher.setValue(2, name);
+	}
+
+	@Override
+	public String getCostumName() {
+		return watcher.getString(2);
+	}
+
+	@Override
+	public boolean isCostumNameVisiable() {
+		return (boolean) watcher.get(3);
+	}
+
+	@Override
+	public void setCostumNameVisiable(boolean flag) {
+		watcher.setValue(3, flag);
+	}
+
+	@Override
+	public boolean isSlient() {
+		return (boolean) watcher.get(4);
+	}
+
+	@Override
+	public void setSlient(boolean flag) {
+		watcher.setValue(4, flag);
+	}
+	
+	@Override
+	public boolean hasGravity() {
+		return watcher.getByte(5) == 1;
+	}
+	@Override
+	public void setApplayGravity(boolean flag) {
+		watcher.setValue(5, flag ? 1 : 0);
+	}
+}
diff --git a/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_10_HumanEntityDataWatcher.java b/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_10_HumanEntityDataWatcher.java
new file mode 100644
index 0000000..342829a
--- /dev/null
+++ b/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_10_HumanEntityDataWatcher.java
@@ -0,0 +1,55 @@
+package dev.wolveringer.api.datawatcher.impl;
+
+import dev.wolveringer.api.datawatcher.DataWatcher;
+import dev.wolveringer.api.datawatcher.HumanDataWatcher;
+
+public class v1_10_HumanEntityDataWatcher extends v1_10_LivingEntityDataWatcher implements HumanDataWatcher {
+	
+	public v1_10_HumanEntityDataWatcher(DataWatcher watcher) {
+		super(watcher);
+	}
+	
+	public void setSkinFlags(byte flag) {
+		watcher.setValue(13, flag);
+	}
+	
+	public byte getSkinFlag() {
+		return watcher.getByte(13);
+	}
+	
+	public void setCapeActive(boolean b) {
+	}
+	
+	public boolean isCapeActive() {
+		return false;
+	}
+	
+	public void setAbsorptionHearts(float f) {
+		watcher.setValue(11, f);
+	}
+	
+	public float getAbsorptionHearts() {
+		return watcher.getFloat(11);
+	}
+	
+	public void setScore(int score) {
+		watcher.setValue(12, score);
+	}
+	
+	public int getScore() {
+		return watcher.getInt(12);
+	}
+	
+	public v1_10_HumanEntityDataWatcher injektDefault() {
+		super.injektDefault();
+		if (watcher.get(11) == null)
+			watcher.setValue(11, (float) 0F);
+		if (watcher.get(12) == null)
+			watcher.setValue(12, (int) 0);
+		if (watcher.get(13) == null)
+			watcher.setValue(13, (byte) 0);
+		if (watcher.get(14) == null)
+			watcher.setValue(14, (byte) 0);
+		return this;
+	}
+}
diff --git a/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_10_LivingEntityDataWatcher.java b/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_10_LivingEntityDataWatcher.java
new file mode 100644
index 0000000..b9647c9
--- /dev/null
+++ b/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_10_LivingEntityDataWatcher.java
@@ -0,0 +1,67 @@
+package dev.wolveringer.api.datawatcher.impl;
+
+import dev.wolveringer.api.datawatcher.DataWatcher;
+import dev.wolveringer.api.datawatcher.LivingEntityDataWatcher;
+import net.md_5.bungee.api.connection.ProxiedPlayer;
+
+public class v1_10_LivingEntityDataWatcher extends v1_10_EntityDataWatcher implements LivingEntityDataWatcher{
+	
+	public v1_10_LivingEntityDataWatcher(DataWatcher dataWatcher) {
+		super(dataWatcher);
+	}
+	
+	public void setHealth(float h) {
+		this.watcher.setValue(7, h);
+	}
+
+	public float getHealth() {
+		return this.watcher.getFloat(7);
+	}
+
+	public void setArrows(int amauth) {
+		this.watcher.setValue(10, (byte) amauth);
+	}
+
+	public int getArrows() {
+		return this.watcher.getByte(10);
+	}
+
+	public void setParicelColor(int color){
+		this.watcher.setValue(8, color);
+	}
+	public int getParicelColor(){
+		return this.watcher.getInt(8);
+	}
+	
+	public void setParticelVisiable(boolean flag) {
+		this.watcher.setValue(9, (byte) (flag == true ? 1 : 0));
+	}
+	public boolean isParticelVisiable(){
+		return this.watcher.getByte(9) == 1;
+	}
+
+	public void setAI(boolean flag) {
+		throw new RuntimeException("Methode not implimented in 1.10");
+	}
+
+	public boolean hasAI() {
+		throw new RuntimeException("Methode not implimented in 1.10");
+	}
+
+	@Override
+	public v1_10_LivingEntityDataWatcher injektDefault() {
+		super.injektDefault();
+		if(this.watcher.get(6) == null)
+			this.watcher.setValue(6, Byte.valueOf((byte)0));
+		if(this.watcher.get(7) == null)
+			this.watcher.setValue(7, Float.valueOf(20.0F));
+		if(this.watcher.get(8) == null)
+			this.watcher.setValue(8, Integer.valueOf(0));
+		if(this.watcher.get(9) == null)
+			this.watcher.setValue(9, false);
+		if(this.watcher.get(10) == null)
+			this.watcher.setValue(10, (int) 0);
+		return this;
+	}
+
+}
diff --git a/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_8_DataWatcher.java b/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_8_DataWatcher.java
new file mode 100644
index 0000000..4413510
--- /dev/null
+++ b/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_8_DataWatcher.java
@@ -0,0 +1,240 @@
+package dev.wolveringer.api.datawatcher.impl;
+
+import gnu.trove.map.TObjectIntMap;
+import gnu.trove.map.hash.TObjectIntHashMap;
+
+import java.lang.reflect.InvocationTargetException;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+
+import dev.wolveringer.BungeeUtil.item.Item;
+import dev.wolveringer.api.datawatcher.DataWatcher;
+import dev.wolveringer.api.datawatcher.EntityDataWatcher;
+import dev.wolveringer.api.datawatcher.HumanDataWatcher;
+import dev.wolveringer.api.datawatcher.LivingEntityDataWatcher;
+import dev.wolveringer.api.position.BlockPosition;
+import dev.wolveringer.api.position.Vector3f;
+import dev.wolveringer.packet.PacketDataSerializer;
+
+@SuppressWarnings({ "rawtypes", "unchecked" })
+public class v1_8_DataWatcher extends DataWatcher{
+	private static final TObjectIntMap v1_8_classToId = new TObjectIntHashMap(10, 0.5F, -1);
+	
+	static {
+		v1_8_classToId.put(Byte.class, 0);
+		v1_8_classToId.put(Short.class, 1);
+		v1_8_classToId.put(Integer.class, 2);
+		v1_8_classToId.put(Float.class, 3);
+		v1_8_classToId.put(String.class, 4);
+		v1_8_classToId.put(Item.class, 5);
+		v1_8_classToId.put(BlockPosition.class, 6);
+		v1_8_classToId.put(Vector3f.class, 7);
+	}
+	
+	@SuppressWarnings("serial")
+	private List<DataWatcherObjekt> objekts = new ArrayList<DataWatcherObjekt>() {
+		public DataWatcherObjekt get(int index) {
+			return index >= size() ? null : super.get(index);
+		};
+		
+		public DataWatcherObjekt set(int index, DataWatcherObjekt element) {
+			while (size() <= index) {
+				add(null);
+			}
+			return super.set(index, element);
+		};
+	};
+	
+	@SuppressWarnings("serial")
+	private HashMap<Class, EntityDataWatcher> watchers = new HashMap<Class, EntityDataWatcher>() {
+		public EntityDataWatcher put(Class key, EntityDataWatcher value) {
+			Class _super = key.getSuperclass();
+			while (EntityDataWatcher.class.isAssignableFrom(_super) && super.get(_super) == null) {
+				super.put(_super, value);
+			}
+			return super.put(key, value);
+		};
+	};
+	
+	public v1_8_DataWatcher(PacketDataSerializer paramPacketDataSerializer) {
+		this();
+		if(paramPacketDataSerializer != null)
+		this.objekts = read(paramPacketDataSerializer);
+	}
+	
+	public v1_8_DataWatcher() {}
+	
+	public void write(PacketDataSerializer packetdataserializer) {
+		Iterator iterator = objekts.iterator();
+		while (iterator.hasNext()) {
+			DataWatcherObjekt watchableobject = (DataWatcherObjekt) iterator.next();
+			if (watchableobject == null)
+				continue;
+			write(packetdataserializer, watchableobject);
+		}
+		packetdataserializer.writeByte(127);
+	}
+	
+	private void write(PacketDataSerializer s, DataWatcherObjekt o) {
+		int data = (v1_8_classToId.get(o.getType()) << 5 | o.getPostition() & 0x1F) & 0xFF;
+		s.writeByte(data);
+		switch (v1_8_classToId.get(o.getType())) {
+			case 0:
+				s.writeByte(((Byte) o.getValue()).byteValue());
+				break;
+			case 1:
+				s.writeShort(((Short) o.getValue()).shortValue());
+				break;
+			case 2:
+				s.writeInt(((Integer) o.getValue()).intValue());
+				break;
+			case 3:
+				s.writeFloat(((Float) o.getValue()).floatValue());
+				break;
+			case 4:
+				s.writeString((String) o.getValue());
+				break;
+			case 5:
+				Item itemstack = (Item) o.getValue();
+				s.writeItem(itemstack);
+				break;
+			case 6:
+				BlockPosition blockposition = (BlockPosition) o.getValue();
+				s.writeInt(blockposition.getX());
+				s.writeInt(blockposition.getY());
+				s.writeInt(blockposition.getZ());
+				break;
+			case 7:
+				Vector3f vector3f = (Vector3f) o.getValue();
+				s.writeFloat(vector3f.getX());
+				s.writeFloat(vector3f.getY());
+				s.writeFloat(vector3f.getZ());
+				break;
+			default:
+				System.out.println("Error 02");
+		}
+	}
+	
+	private List read(PacketDataSerializer packetdataserializer) {
+		ArrayList arraylist = new ArrayList();
+		for (byte data = packetdataserializer.readByte(); data != 127; data = packetdataserializer.readByte()) {
+			int type = (data & 0xE0) >> 5;
+			int position = data & 0x1F;
+			DataWatcherObjekt objekt = null;
+			switch (type) {
+				case 0:
+					objekt = new DataWatcherObjekt(getTypeId(type), position, Byte.valueOf(packetdataserializer.readByte()));
+					break;
+				
+				case 1:
+					objekt = new DataWatcherObjekt(getTypeId(type), position, Short.valueOf(packetdataserializer.readShort()));
+					break;
+				
+				case 2:
+					objekt = new DataWatcherObjekt(getTypeId(type), position, Integer.valueOf(packetdataserializer.readInt()));
+					break;
+				
+				case 3:
+					objekt = new DataWatcherObjekt(getTypeId(type), position, Float.valueOf(packetdataserializer.readFloat()));
+					break;
+				
+				case 4:
+					objekt = new DataWatcherObjekt(getTypeId(type), position, packetdataserializer.readString(32767));
+					break;
+				
+				case 5:
+					objekt = new DataWatcherObjekt(getTypeId(type), position, packetdataserializer.readItem());
+					break;
+				
+				case 6:
+					objekt = new DataWatcherObjekt(getTypeId(type), position, new BlockPosition(packetdataserializer.readInt(), packetdataserializer.readInt(), packetdataserializer.readInt()));
+					break;
+				
+				case 7:
+					objekt = new DataWatcherObjekt(getTypeId(type), position, new Vector3f(packetdataserializer.readFloat(), packetdataserializer.readFloat(), packetdataserializer.readFloat()));
+					break;
+				default:
+					System.out.println("Error 01");
+			}
+			
+			arraylist.add(objekt);
+		}
+		return arraylist;
+	}
+	
+	public void setValue(int pos, Object object) {
+		if (pos > 31) {
+			throw new IllegalArgumentException("Data value id is too big with " + pos + "! (Max is " + 31 + ")");
+		}
+		if (objekts.get(pos) == null)
+			objekts.set(pos, new DataWatcherObjekt(object.getClass(), pos, null));
+		objekts.get(pos).setValue(object);
+	}
+	
+	private static Class<?> getTypeId(int type) {
+		for (Object o : v1_8_classToId.keys())
+			if (v1_8_classToId.get(o) == type)
+				return (Class<?>) o;
+		return null;
+	}
+	
+	@Override
+	public String toString() {
+		return "DataWatcher [v1_8] [objekts=" + objekts + "]";
+	}
+	
+	public v1_8_DataWatcher copy() {
+		v1_8_DataWatcher watcher = new v1_8_DataWatcher();
+		watcher.objekts = new ArrayList<DataWatcherObjekt>(this.objekts);
+		return watcher;
+	}
+	
+	public EntityDataWatcher getEntityDataWatcher() {
+		return getSpecialDataWatcher(EntityDataWatcher.class);
+	}
+	
+	public <T extends EntityDataWatcher> T getSpecialDataWatcher(Class<T> clazz) {
+		if(clazz.isAssignableFrom(EntityDataWatcher.class))
+			clazz = (Class<T>) v1_8_EntityDataWatcher.class;
+		else if(clazz.isAssignableFrom(LivingEntityDataWatcher.class))
+			clazz = (Class<T>) v1_8_LivingEntityDataWatcher.class;
+		else if(clazz.isAssignableFrom(HumanDataWatcher.class))
+			clazz = (Class<T>) v1_8_HumanEntityDataWatcher.class;
+		if (watchers.get(clazz) == null) {
+			try {
+				watchers.put(clazz, clazz.getConstructor(DataWatcher.class).newInstance(this));
+			} catch (InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException | NoSuchMethodException | SecurityException e) {
+				e.printStackTrace();
+			}
+		}
+		return (T) watchers.get(clazz);
+	}
+	
+	public Object get(int i) {
+		if (objekts.get(i) == null)
+			return null;
+		return objekts.get(i).getValue();
+	}
+	
+	public byte getByte(int i) {
+		return (byte) get(i);
+	}
+	
+	public short getShort(int i) {
+		return (short) get(i);
+	}
+	
+	public int getInt(int i) {
+		return (int) get(i);
+	}
+	
+	public String getString(int i) {
+		return (String) get(i);
+	}
+	
+	public float getFloat(int i) {
+		return (float) get(i);
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_8_EntityDataWatcher.java b/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_8_EntityDataWatcher.java
new file mode 100644
index 0000000..69df0a0
--- /dev/null
+++ b/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_8_EntityDataWatcher.java
@@ -0,0 +1,152 @@
+package dev.wolveringer.api.datawatcher.impl;
+
+import dev.wolveringer.api.datawatcher.DataWatcher;
+import dev.wolveringer.api.datawatcher.EntityDataWatcher;
+
+public class v1_8_EntityDataWatcher implements EntityDataWatcher{
+	
+	protected DataWatcher watcher;
+	
+	protected v1_8_EntityDataWatcher(DataWatcher dataWatcher) {
+		this.watcher = dataWatcher;
+	}
+	
+	private boolean getPropety(int pos) {
+		return (this.watcher.getByte(0) & 1 << pos) != 0;
+	}
+	
+	private void setPropety(int pos, boolean flag) {
+		if (this.watcher.get(0) == null)
+			this.watcher.setValue(0, (byte) 0);
+		byte b0 = this.watcher.getByte(0);
+		
+		if (flag) {
+			this.watcher.setValue(0, Byte.valueOf((byte) (b0 | 1 << pos)));
+		} else {
+			this.watcher.setValue(0, Byte.valueOf((byte) (b0 & (1 << pos ^ 0xFFFFFFFF))));
+		}
+	}
+	
+	public boolean isSneaking() {
+		return getPropety(1);
+	}
+	
+	public void setSneaking(boolean flag) {
+		setPropety(1, flag);
+	}
+	
+	public boolean isSprinting() {
+		return getPropety(3);
+	}
+	
+	public void setSprinting(boolean flag) {
+		setPropety(3, flag);
+	}
+	
+	public boolean isInvisible() {
+		return getPropety(5);
+	}
+	
+	public void setInvisible(boolean flag) {
+		setPropety(5, flag);
+	}
+	
+	public EntityDataWatcher injektDefault() {
+		if (this.watcher.get(0) == null)
+			this.watcher.setValue(0, Byte.valueOf((byte) 0));
+		if (this.watcher.get(1) == null)
+			this.watcher.setValue(1, Short.valueOf((short) 300));
+		return this;
+	}
+	
+	public DataWatcher getWatcher() {
+		return watcher;
+	}
+
+	@Override
+	public boolean isOnFire() {
+		throw new RuntimeException("Methode not implimented in 1.8");
+	}
+
+	@Override
+	public void setOnFire(boolean fire) {
+		throw new RuntimeException("Methode not implimented in 1.8");
+	}
+
+	@Override
+	public boolean isBlocking() {
+		throw new RuntimeException("Methode not implimented in 1.8");
+	}
+
+	@Override
+	public void setBlocking(boolean block) {
+		throw new RuntimeException("Methode not implimented in 1.8");
+	}
+
+	@Override
+	public boolean isGlowing() {
+		throw new RuntimeException("Methode not implimented in 1.8");
+	}
+
+	@Override
+	public void setGlowing(boolean glow) {
+		throw new RuntimeException("Methode not implimented in 1.8");
+	}
+
+	@Override
+	public boolean isElytra() {
+		throw new RuntimeException("Methode not implimented in 1.8");
+	}
+
+	@Override
+	public void setElytra(boolean elytra) {
+		throw new RuntimeException("Methode not implimented in 1.8");
+	}
+
+	@Override
+	public int getAir() {
+		throw new RuntimeException("Methode not implimented in 1.8");
+	}
+
+	@Override
+	public void setAir(int air) {
+		throw new RuntimeException("Methode not implimented in 1.8");
+	}
+
+	@Override
+	public void setCostumName(String name) {
+		throw new RuntimeException("Methode not implimented in 1.8");
+	}
+
+	@Override
+	public String getCostumName() {
+		throw new RuntimeException("Methode not implimented in 1.8");
+	}
+
+	@Override
+	public boolean isCostumNameVisiable() {
+		throw new RuntimeException("Methode not implimented in 1.8");
+	}
+
+	@Override
+	public void setCostumNameVisiable(boolean flag) {
+		throw new RuntimeException("Methode not implimented in 1.8");
+	}
+
+	@Override
+	public boolean isSlient() {
+		throw new RuntimeException("Methode not implimented in 1.8");
+	}
+
+	@Override
+	public void setSlient(boolean flag) {
+		throw new RuntimeException("Methode not implimented in 1.8");
+	}
+	
+	@Override
+	public boolean hasGravity() {
+		return true;
+	}
+	@Override
+	public void setApplayGravity(boolean flag) {}
+}
diff --git a/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_8_HumanEntityDataWatcher.java b/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_8_HumanEntityDataWatcher.java
new file mode 100644
index 0000000..f49e21a
--- /dev/null
+++ b/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_8_HumanEntityDataWatcher.java
@@ -0,0 +1,59 @@
+package dev.wolveringer.api.datawatcher.impl;
+
+import dev.wolveringer.api.datawatcher.DataWatcher;
+import dev.wolveringer.api.datawatcher.HumanDataWatcher;
+import dev.wolveringer.api.datawatcher.LivingEntityDataWatcher;
+
+public class v1_8_HumanEntityDataWatcher extends v1_8_LivingEntityDataWatcher implements HumanDataWatcher{
+
+	public v1_8_HumanEntityDataWatcher(DataWatcher watcher) {
+		super(watcher);
+	}
+
+	public void setSkinFlags(byte flag) {
+		watcher.setValue(10, flag);
+	}
+
+	public byte getSkinFlag() {
+		return watcher.getByte(10);
+	}
+
+	public void setCapeActive(boolean b) {
+		watcher.setValue(16, (byte) (b == true ? 1 : 0));
+	}
+
+	public boolean isCapeActive() {
+		return watcher.getByte(16) == 1;
+	}
+
+	public void setAbsorptionHearts(float f) {
+		watcher.setValue(17, f);
+	}
+
+	public float getAbsorptionHearts() {
+		return watcher.getFloat(17);
+	}
+
+	public void setScore(int score) {
+		watcher.setValue(18, score);
+	}
+
+	public int getScore() {
+		return watcher.getInt(18);
+	}
+
+	@Override
+	public v1_8_HumanEntityDataWatcher injektDefault() {
+		super.injektDefault();
+		if(watcher.get(10) == null)
+			watcher.setValue(10, (byte) 0);
+		if(watcher.get(16) == null)
+			watcher.setValue(16, (byte) 0);
+		if(watcher.get(17) == null)
+			watcher.setValue(17, (float) 0F);
+		if(watcher.get(18) == null)
+			watcher.setValue(18, (int) 0);
+		return this;
+	}
+
+}
diff --git a/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_8_LivingEntityDataWatcher.java b/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_8_LivingEntityDataWatcher.java
new file mode 100644
index 0000000..0d73289
--- /dev/null
+++ b/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_8_LivingEntityDataWatcher.java
@@ -0,0 +1,95 @@
+package dev.wolveringer.api.datawatcher.impl;
+
+import dev.wolveringer.api.datawatcher.DataWatcher;
+import dev.wolveringer.api.datawatcher.LivingEntityDataWatcher;
+
+public class v1_8_LivingEntityDataWatcher extends v1_8_EntityDataWatcher implements LivingEntityDataWatcher{
+	
+	public v1_8_LivingEntityDataWatcher(DataWatcher dataWatcher) {
+		super(dataWatcher);
+
+	}
+
+	public void setCustomName(String s) {
+		this.watcher.setValue(2, s);
+	}
+
+	public String getCustomName() {
+		return this.watcher.getString(2);
+	}
+
+	public boolean hasCustomName() {
+		return this.watcher.getString(2).length() > 0;
+	}
+
+	public void setCustomNameVisible(boolean flag) {
+		this.watcher.setValue(3, Byte.valueOf((byte) (flag ? 1 : 0)));
+	}
+
+	public boolean getCustomNameVisible() {
+		return this.watcher.getByte(3) == 1;
+	}
+
+	public void setHealth(float h) {
+		this.watcher.setValue(6, h);
+	}
+
+	public float getHealth() {
+		return this.watcher.getFloat(6);
+	}
+
+	public void setArrows(int amauth) {
+		this.watcher.setValue(9, (byte) amauth);
+	}
+
+	public int getArrows() {
+		return this.watcher.getByte(9);
+	}
+
+	public void setParicelColor(int color){
+		this.watcher.setValue(7, color);
+	}
+	public int getParicelColor(){
+		return this.watcher.getInt(7);
+	}
+	
+	public void setParticelVisiable(boolean flag) {
+		this.watcher.setValue(8, (byte) (flag == true ? 1 : 0));
+	}
+	public boolean isParticelVisiable(){
+		return this.watcher.getByte(8) == 1;
+	}
+
+	public void setAI(boolean flag) {
+		this.watcher.setValue(15, Byte.valueOf((byte) (flag == true ? 0 : 1)));
+	}
+
+	public boolean hasAI() {
+		return this.watcher.getByte(15) == 0;
+	}
+
+	@Override
+	public v1_8_LivingEntityDataWatcher injektDefault() {
+		super.injektDefault();
+		if(this.watcher.get(2) == null)
+			this.watcher.setValue(2, "");
+		if(this.watcher.get(3) == null)
+			this.watcher.setValue(3, Byte.valueOf((byte) 0));
+		if(this.watcher.get(4) == null)
+			this.watcher.setValue(4, Byte.valueOf((byte) 0));
+
+		if(this.watcher.get(6) == null)
+			this.watcher.setValue(6, Float.valueOf(10.0F));
+		if(this.watcher.get(7) == null)
+			this.watcher.setValue(7, Integer.valueOf(0));
+		if(this.watcher.get(8) == null)
+			this.watcher.setValue(8, Byte.valueOf((byte) 0));
+		if(this.watcher.get(9) == null)
+			this.watcher.setValue(9, Byte.valueOf((byte) 0));
+
+		if(this.watcher.get(15) == null)
+			this.watcher.setValue(15, Byte.valueOf((byte) 0));
+		return this;
+	}
+
+}
diff --git a/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_9_DataWatcher.java b/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_9_DataWatcher.java
new file mode 100644
index 0000000..8699aee
--- /dev/null
+++ b/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_9_DataWatcher.java
@@ -0,0 +1,276 @@
+package dev.wolveringer.api.datawatcher.impl;
+
+import gnu.trove.map.TObjectIntMap;
+import gnu.trove.map.hash.TObjectIntHashMap;
+
+import java.lang.reflect.InvocationTargetException;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+
+import dev.wolveringer.BungeeUtil.item.Item;
+import dev.wolveringer.api.datawatcher.BlockData;
+import dev.wolveringer.api.datawatcher.DataWatcher;
+import dev.wolveringer.api.datawatcher.Direction;
+import dev.wolveringer.api.datawatcher.EntityDataWatcher;
+import dev.wolveringer.api.datawatcher.HumanDataWatcher;
+import dev.wolveringer.api.datawatcher.LivingEntityDataWatcher;
+import dev.wolveringer.api.datawatcher.OptionalBlockPosition;
+import dev.wolveringer.api.datawatcher.OptionalUUID;
+import dev.wolveringer.api.position.BlockPosition;
+import dev.wolveringer.api.position.Vector3f;
+import dev.wolveringer.chat.IChatBaseComponent;
+import dev.wolveringer.packet.PacketDataSerializer;
+
+@SuppressWarnings({ "rawtypes", "unchecked" })
+public class v1_9_DataWatcher extends DataWatcher{
+	private static final TObjectIntMap v1_9_classToId = new TObjectIntHashMap(10, 0.5F, -1);
+	
+	static {
+		v1_9_classToId.put(Byte.class, 0);
+		v1_9_classToId.put(Integer.class, 1);
+		v1_9_classToId.put(Float.class, 2);
+		v1_9_classToId.put(String.class, 3);
+		v1_9_classToId.put(IChatBaseComponent.class, 4);
+		v1_9_classToId.put(Item.class, 5);
+		v1_9_classToId.put(Boolean.class, 6);
+		v1_9_classToId.put(Vector3f.class, 7);
+		v1_9_classToId.put(BlockPosition.class, 8);
+		v1_9_classToId.put(OptionalBlockPosition.class, 9);
+		v1_9_classToId.put(Direction.class, 10);
+		v1_9_classToId.put(OptionalUUID.class, 11);
+		v1_9_classToId.put(BlockData.class, 12);
+		v1_9_classToId.put(Short.class, 13);
+	}
+	
+	@SuppressWarnings("serial")
+	private List<DataWatcherObjekt> objekts = new ArrayList<DataWatcherObjekt>() {
+		public DataWatcherObjekt get(int index) {
+			return index >= size() ? null : super.get(index);
+		};
+		
+		public DataWatcherObjekt set(int index, DataWatcherObjekt element) {
+			while (size() <= index) {
+				add(null);
+			}
+			return super.set(index, element);
+		};
+	};
+	
+	@SuppressWarnings("serial")
+	private HashMap<Class, EntityDataWatcher> watchers = new HashMap<Class, EntityDataWatcher>() {
+		public EntityDataWatcher put(Class key, EntityDataWatcher value) {
+			Class _super = key.getSuperclass();
+			while (EntityDataWatcher.class.isAssignableFrom(_super) && super.get(_super) == null) {
+				super.put(_super, value);
+			}
+			return super.put(key, value);
+		};
+	};
+	
+	public v1_9_DataWatcher(PacketDataSerializer paramPacketDataSerializer) {
+		this();
+		if(paramPacketDataSerializer != null)
+		this.objekts = read(paramPacketDataSerializer);
+	}
+	
+	public v1_9_DataWatcher() {
+	}
+	
+	public void write(PacketDataSerializer packetdataserializer) {
+		Iterator iterator = objekts.iterator();
+		while (iterator.hasNext()) {
+			DataWatcherObjekt watchableobject = (DataWatcherObjekt) iterator.next();
+			if (watchableobject == null) continue;
+			write(packetdataserializer, watchableobject);
+		}
+		packetdataserializer.writeByte(255); // end
+	}
+	
+	private void write(PacketDataSerializer s, DataWatcherObjekt o) {
+			s.writeByte(o.getPostition());
+			int typeId = v1_9_classToId.get(o.getType());
+			if (typeId == 13) s.writeByte(v1_9_classToId.get(Integer.class));
+			else s.writeByte(typeId);
+			
+			switch (typeId) {
+				case 0:
+					s.writeByte((byte) o.getValue());
+					break;
+				case 1:
+					s.writeVarInt((int) o.getValue());
+					break;
+				case 2:
+					s.writeFloat((float) o.getValue());
+					break;
+				case 3:
+					s.writeString((String) o.getValue());
+					break;
+				case 4:
+					s.writeRawString((IChatBaseComponent) o.getValue());
+					break;
+				case 5:
+					s.writeItem((Item) o.getValue());
+					break;
+				case 6:
+					s.writeBoolean((boolean) o.getValue());
+					break;
+				case 7:
+					Vector3f v = (Vector3f) o.getValue();
+					s.writeFloat(v.getX());
+					s.writeFloat(v.getY());
+					s.writeFloat(v.getZ());
+					break;
+				case 8:
+					s.writeBlockPosition((BlockPosition) o.getValue());
+					break;
+				case 9:
+					OptionalBlockPosition p = (OptionalBlockPosition) o.getValue(); // Optional
+					s.writeBoolean(p.getPosition() != null);
+					if (p != null) s.writeBlockPosition(p.getPosition());
+					break;
+				case 10:
+					s.writeVarInt(((Direction) o.getValue()).getDirection()); // Direction
+					break;
+				case 11:
+					OptionalUUID uuid = (OptionalUUID) o.getValue(); // Optional
+					s.writeBoolean(uuid.getUuid() != null);
+					if (uuid != null) s.writeUUID(uuid.getUuid());
+					break;
+				case 12:
+					s.writeVarInt(((BlockData) o.getValue()).getData()); // Block
+					break; // Data
+				case 13: // Short will write as an interger
+					s.writeVarInt((Short) o.getValue());
+					break;
+				default:
+					System.out.println("Type not found ("+typeId+") ("+o.getType()+")");
+					break;
+			}
+	}
+	
+	private List read(PacketDataSerializer packetdataserializer) {
+		ArrayList arraylist = new ArrayList();
+			for (int data = packetdataserializer.readUnsignedByte(); data != 255; data = packetdataserializer.readUnsignedByte()) {
+				int pos = data;
+				int type = packetdataserializer.readUnsignedByte();
+				Object value = null;
+				switch (type) {
+					case 0:
+						value = packetdataserializer.readByte();
+						break;
+					case 1:
+						value = packetdataserializer.readVarInt();
+						break;
+					case 2:
+						value = packetdataserializer.readFloat();
+						break;
+					case 3:
+						value = packetdataserializer.readString(-1);
+						break;
+					case 4:
+						value = packetdataserializer.readRawString();
+						break;
+					case 5:
+						value = packetdataserializer.readItem();
+						break;
+					case 6:
+						value = packetdataserializer.readBoolean();
+						break;
+					case 7:
+						value = new Vector3f(packetdataserializer.readFloat(), packetdataserializer.readFloat(), packetdataserializer.readFloat());
+						break;
+					case 8:
+						value = packetdataserializer.readBlockPosition();
+						break;
+					case 9:
+						if (packetdataserializer.readBoolean()) value = new OptionalBlockPosition(packetdataserializer.readBlockPosition());
+						else value = new OptionalBlockPosition(null);
+						break;
+					case 10:
+						value = new Direction(packetdataserializer.readVarInt());
+						break;
+					case 11:
+						if (packetdataserializer.readBoolean()) value = new OptionalUUID(packetdataserializer.readUUID());
+						else value = new OptionalUUID(null);
+						break;
+					case 12:
+						value = new BlockData(packetdataserializer.readVarInt());
+						break;
+				}
+				arraylist.add(new DataWatcherObjekt(getTypeId(type), pos, value));
+		}
+		return arraylist;
+	}
+	
+	public void setValue(int pos, Object object) {
+		if (pos > 254) { throw new IllegalArgumentException("Data value id is too big with " + pos + "! (Max is " + 254 + ")"); }
+		if (objekts.get(pos) == null) objekts.set(pos, new DataWatcherObjekt(object.getClass(), pos, null));
+		objekts.get(pos).setValue(object);
+	}
+	
+	private static Class<?> getTypeId(int type) {
+			for (Object o : v1_9_classToId.keys())
+				if (v1_9_classToId.get(o) == type) return (Class<?>) o;
+		return null;
+	}
+	
+	@Override
+	public String toString() {
+		return "DataWatcher [v1_9] [objekts=" + objekts + "]";
+	}
+	
+	public DataWatcher copy() {
+		v1_9_DataWatcher watcher = new v1_9_DataWatcher();
+		watcher.objekts = new ArrayList<DataWatcherObjekt>(this.objekts);
+		return watcher;
+	}
+	
+	public EntityDataWatcher getEntityDataWatcher() {
+		return getSpecialDataWatcher(EntityDataWatcher.class);
+	}
+	
+	public <T extends EntityDataWatcher> T getSpecialDataWatcher(Class<T> clazz) {
+		if(clazz.isAssignableFrom(EntityDataWatcher.class))
+			clazz = (Class<T>) v1_9_EntityDataWatcher.class;
+		else if(clazz.isAssignableFrom(LivingEntityDataWatcher.class))
+			clazz = (Class<T>) v1_9_LivingEntityDataWatcher.class;
+		else if(clazz.isAssignableFrom(HumanDataWatcher.class))
+			clazz = (Class<T>) v1_9_HumanEntityDataWatcher.class;
+		if (watchers.get(clazz) == null) {
+			try {
+				watchers.put(clazz, clazz.getConstructor(DataWatcher.class).newInstance(this));
+			}
+			catch (InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException | NoSuchMethodException | SecurityException e) {
+				e.printStackTrace();
+			}
+		}
+		return (T) watchers.get(clazz);
+	}
+	
+	public Object get(int i) {
+		if (objekts.get(i) == null) return null;
+		return objekts.get(i).getValue();
+	}
+	
+	public byte getByte(int i) {
+		return (byte) get(i);
+	}
+	
+	public short getShort(int i) {
+		return (short) get(i);
+	}
+	
+	public int getInt(int i) {
+		return (int) get(i);
+	}
+	
+	public String getString(int i) {
+		return (String) get(i);
+	}
+	
+	public float getFloat(int i) {
+		return (float) get(i);
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_9_EntityDataWatcher.java b/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_9_EntityDataWatcher.java
new file mode 100644
index 0000000..90e1bc0
--- /dev/null
+++ b/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_9_EntityDataWatcher.java
@@ -0,0 +1,158 @@
+package dev.wolveringer.api.datawatcher.impl;
+
+import dev.wolveringer.api.datawatcher.DataWatcher;
+import dev.wolveringer.api.datawatcher.EntityDataWatcher;
+
+public class v1_9_EntityDataWatcher implements EntityDataWatcher{
+	
+	protected DataWatcher watcher;
+	
+	protected v1_9_EntityDataWatcher(DataWatcher dataWatcher) {
+		this.watcher = dataWatcher;
+	}
+	
+	private boolean getPropety(int pos) {
+		return (this.watcher.getByte(0) & 1 << pos) != 0;
+	}
+	
+	private void setPropety(int pos, boolean flag) {
+		if (this.watcher.get(0) == null)
+			this.watcher.setValue(0, (byte) 0);
+		byte b0 = this.watcher.getByte(0);
+		
+		if (flag) {
+			this.watcher.setValue(0, Byte.valueOf((byte) (b0 | 1 << pos)));
+		} else {
+			this.watcher.setValue(0, Byte.valueOf((byte) (b0 & (1 << pos ^ 0xFFFFFFFF))));
+		}
+	}
+	
+	public boolean isSneaking() {
+		return getPropety(1);
+	}
+	
+	public void setSneaking(boolean flag) {
+		setPropety(1, flag);
+	}
+	
+	public boolean isSprinting() {
+		return getPropety(2);
+	}
+	
+	public void setSprinting(boolean flag) {
+		setPropety(2, flag);
+	}
+	
+	public boolean isInvisible() {
+		return getPropety(4);
+	}
+	
+	public void setInvisible(boolean flag) {
+		setPropety(4, flag);
+	}
+	
+	public EntityDataWatcher injektDefault() {
+		if (this.watcher.get(0) == null)
+			this.watcher.setValue(0, Byte.valueOf((byte) 0));
+		if (this.watcher.get(1) == null)
+			this.watcher.setValue(1, (Integer)((int) 300));
+		if (this.watcher.get(2) == null)
+			this.watcher.setValue(2, "");
+		if (this.watcher.get(3) == null)
+			this.watcher.setValue(3,false);
+		if (this.watcher.get(4) == null)
+			this.watcher.setValue(4,false);
+		return this;
+	}
+	
+	public DataWatcher getWatcher() {
+		return watcher;
+	}
+
+	@Override
+	public boolean isOnFire() {
+		return getPropety(0);
+	}
+
+	@Override
+	public void setOnFire(boolean fire) {
+		setPropety(0, fire);
+	}
+
+	@Override
+	public boolean isBlocking() {
+		return getPropety(3);
+	}
+
+	@Override
+	public void setBlocking(boolean block) {
+		setPropety(3, block);
+	}
+
+	@Override
+	public boolean isGlowing() {
+		return getPropety(6);
+	}
+
+	@Override
+	public void setGlowing(boolean glow) {
+		setPropety(6, glow);
+	}
+
+	@Override
+	public boolean isElytra() {
+		return getPropety(7);
+	}
+
+	@Override
+	public void setElytra(boolean elytra) {
+		setPropety(7, elytra);
+	}
+
+	@Override
+	public int getAir() {
+		return watcher.getInt(1);
+	}
+
+	@Override
+	public void setAir(int air) {
+		watcher.setValue(1, air);
+	}
+
+	@Override
+	public void setCostumName(String name) {
+		watcher.setValue(2, name);
+	}
+
+	@Override
+	public String getCostumName() {
+		return watcher.getString(2);
+	}
+
+	@Override
+	public boolean isCostumNameVisiable() {
+		return (boolean) watcher.get(3);
+	}
+
+	@Override
+	public void setCostumNameVisiable(boolean flag) {
+		watcher.setValue(3, flag);
+	}
+
+	@Override
+	public boolean isSlient() {
+		return (boolean) watcher.get(4);
+	}
+
+	@Override
+	public void setSlient(boolean flag) {
+		watcher.setValue(4, flag);
+	}
+	
+	@Override
+	public boolean hasGravity() {
+		return true;
+	}
+	@Override
+	public void setApplayGravity(boolean flag) {}
+}
diff --git a/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_9_HumanEntityDataWatcher.java b/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_9_HumanEntityDataWatcher.java
new file mode 100644
index 0000000..1706466
--- /dev/null
+++ b/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_9_HumanEntityDataWatcher.java
@@ -0,0 +1,55 @@
+package dev.wolveringer.api.datawatcher.impl;
+
+import dev.wolveringer.api.datawatcher.DataWatcher;
+import dev.wolveringer.api.datawatcher.HumanDataWatcher;
+
+public class v1_9_HumanEntityDataWatcher extends v1_9_LivingEntityDataWatcher implements HumanDataWatcher {
+	
+	public v1_9_HumanEntityDataWatcher(DataWatcher watcher) {
+		super(watcher);
+	}
+	
+	public void setSkinFlags(byte flag) {
+		watcher.setValue(12, flag);
+	}
+	
+	public byte getSkinFlag() {
+		return watcher.getByte(12);
+	}
+	
+	public void setCapeActive(boolean b) {
+	}
+	
+	public boolean isCapeActive() {
+		return false;
+	}
+	
+	public void setAbsorptionHearts(float f) {
+		watcher.setValue(10, f);
+	}
+	
+	public float getAbsorptionHearts() {
+		return watcher.getFloat(10);
+	}
+	
+	public void setScore(int score) {
+		watcher.setValue(11, score);
+	}
+	
+	public int getScore() {
+		return watcher.getInt(11);
+	}
+	
+	public v1_9_HumanEntityDataWatcher injektDefault() {
+		super.injektDefault();
+		if (watcher.get(10) == null)
+			watcher.setValue(10, (float) 0F);
+		if (watcher.get(11) == null)
+			watcher.setValue(11, (int) 0);
+		if (watcher.get(12) == null)
+			watcher.setValue(12, (byte) 0);
+		if (watcher.get(13) == null)
+			watcher.setValue(13, (byte) 0);
+		return this;
+	}
+}
diff --git a/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_9_LivingEntityDataWatcher.java b/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_9_LivingEntityDataWatcher.java
new file mode 100644
index 0000000..30368e9
--- /dev/null
+++ b/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_9_LivingEntityDataWatcher.java
@@ -0,0 +1,65 @@
+package dev.wolveringer.api.datawatcher.impl;
+
+import dev.wolveringer.api.datawatcher.DataWatcher;
+import dev.wolveringer.api.datawatcher.LivingEntityDataWatcher;
+
+public class v1_9_LivingEntityDataWatcher extends v1_9_EntityDataWatcher implements LivingEntityDataWatcher{
+	
+	public v1_9_LivingEntityDataWatcher(DataWatcher dataWatcher) {
+		super(dataWatcher);
+
+	}
+	
+	public void setHealth(float h) {
+		this.watcher.setValue(6, h);
+	}
+
+	public float getHealth() {
+		return this.watcher.getFloat(6);
+	}
+
+	public void setArrows(int amauth) {
+		this.watcher.setValue(9, (byte) amauth);
+	}
+
+	public int getArrows() {
+		return this.watcher.getByte(9);
+	}
+
+	public void setParicelColor(int color){
+		this.watcher.setValue(7, color);
+	}
+	public int getParicelColor(){
+		return this.watcher.getInt(7);
+	}
+	
+	public void setParticelVisiable(boolean flag) {
+		this.watcher.setValue(8, (byte) (flag == true ? 1 : 0));
+	}
+	public boolean isParticelVisiable(){
+		return this.watcher.getByte(8) == 1;
+	}
+
+	public void setAI(boolean flag) {
+		throw new RuntimeException("Methode not implimented in 1.9");
+	}
+
+	public boolean hasAI() {
+		throw new RuntimeException("Methode not implimented in 1.8");
+	}
+
+	@Override
+	public v1_9_LivingEntityDataWatcher injektDefault() {
+		super.injektDefault();
+		if(this.watcher.get(6) == null)
+			this.watcher.setValue(6, Float.valueOf(20.0F));
+		if(this.watcher.get(7) == null)
+			this.watcher.setValue(7, Integer.valueOf(0));
+		if(this.watcher.get(8) == null)
+			this.watcher.setValue(8, false);
+		if(this.watcher.get(9) == null)
+			this.watcher.setValue(9, (int) 0);
+		return this;
+	}
+
+}
diff --git a/src/main/java/dev/wolveringer/api/gui/AnvilGui.java b/src/main/java/dev/wolveringer/api/gui/AnvilGui.java
new file mode 100644
index 0000000..c13305d
--- /dev/null
+++ b/src/main/java/dev/wolveringer/api/gui/AnvilGui.java
@@ -0,0 +1,364 @@
+package dev.wolveringer.api.gui;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+
+import dev.wolveringer.BungeeUtil.Material;
+import dev.wolveringer.BungeeUtil.PacketHandleEvent;
+import dev.wolveringer.BungeeUtil.PacketHandler;
+import dev.wolveringer.BungeeUtil.PacketLib;
+import dev.wolveringer.BungeeUtil.Player;
+import dev.wolveringer.BungeeUtil.item.Item;
+import dev.wolveringer.BungeeUtil.item.ItemStack;
+import dev.wolveringer.BungeeUtil.packets.Packet;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayInCloseWindow;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayInPluginMessage;
+import dev.wolveringer.api.inventory.Inventory;
+import dev.wolveringer.api.inventory.InventoryType;
+import dev.wolveringer.chat.ChatColor.ChatColorUtils;
+import net.md_5.bungee.protocol.DefinedPacket;
+
+public class AnvilGui {
+	
+	private static class AnvilWindowSizeStringCalculator {
+		private static HashMap<Character, Double> charLength = new HashMap<>(); //Length = 1 = X
+		private static final int BOX_SIZE = 18;
+		static {
+			for(int i = 0;i<Character.MAX_VALUE;i++)
+				charLength.put((char) i, 1D);
+			charLength.put('I', 18D/26D); //26 in 
+			charLength.put('i', 18D/52D); //Todo
+			charLength.put('j', 18D/28D); 
+			charLength.put('l', 18D/34D);//Todo
+		}
+		
+		private String message;
+		
+		public AnvilWindowSizeStringCalculator(String message) {
+			this.message = message;
+		}
+		
+		public boolean boarderReached(){
+			return reachBoarder(BOX_SIZE);
+		}
+		
+		public boolean reachBoarder(int length){
+			double out = 0;
+			for(char c : message.toCharArray())
+				out+=charLength.get(c);
+			return out+1>length;
+		}
+		
+		
+	}
+	
+	private static final Item DEFAULT_CENTER_ITEM;
+	private static final Item DEFAULT_OUTPUT_ITEM;
+	
+	static {
+		DEFAULT_CENTER_ITEM = new Item(Material.BARRIER);
+		DEFAULT_CENTER_ITEM.getItemMeta().setDisplayName(ChatColorUtils.COLOR_CHAR+"r");
+		
+		DEFAULT_OUTPUT_ITEM = new Item(Material.NAME_TAG);
+		DEFAULT_OUTPUT_ITEM.getItemMeta().setDisplayName(ChatColorUtils.COLOR_CHAR+"aClick to finish");
+	}
+	
+	private Player owner;
+	private Inventory inv;
+	private String curruntMessage = "";
+	private String backgroundString = "Message here: ";
+	private Material backgroundMaterial = Material.STONE;
+	private String colorPrefix = "\u00A7a";
+	private Item centerItem = DEFAULT_CENTER_ITEM;
+	private Item outputItem = DEFAULT_OUTPUT_ITEM;
+	
+	private String curruntItemDisplayName = "";
+	
+	private boolean noBackground = false;
+	
+	private String curruntDisplayString = "";
+	
+	private ArrayList<AnvilGuiListener> listener = new ArrayList<>();
+	
+	private PacketHandler<Packet> packet = new PacketHandler<Packet>() {
+		int backgroundCount = 0;
+		
+		@Override
+		public void handle(PacketHandleEvent<Packet> e) {
+			if (e.getPacket() instanceof PacketPlayInPluginMessage) { //Message changed
+				PacketPlayInPluginMessage packet = (PacketPlayInPluginMessage) e.getPacket();
+				if (packet.getChannel().equalsIgnoreCase("MC|ItemName")) {
+					if (e.getPlayer().equals(owner) && inv != null) {
+						String message = DefinedPacket.readString(packet.getCopiedbyteBuff());
+						if(curruntItemDisplayName.equalsIgnoreCase(message) && false)
+							return;
+						curruntItemDisplayName = message;
+						if(colorPrefix.length() > message.length()) //Backspace (color prefix deleted!)
+							message = colorPrefix;
+						message = message.substring(colorPrefix.length(), message.length()); // replace
+	                                                                                         // color
+	                                                                                         // prefix
+						String handleMessage = message;
+						if (message.length() == 0 && noBackground) {
+							ItemStack item = new ItemStack(backgroundMaterial) {
+								@Override
+								public void click(Click click) {
+									click.setCancelled(true);
+								}
+							};
+							item.getItemMeta().setDisplayName(curruntItemDisplayName = colorPrefix + backgroundString);
+							inv.setItem(0, item);
+							noBackground = false;
+							handleMessage = "";
+							return;
+						}
+						
+						if (buildOutString(message, backgroundString).length() <= 1 && noBackground == false) {// Checking
+	                                                                                                           // for
+	                                                                                                           // background
+							if ((backgroundCount++ > 0)) {
+								handleMessage = "";
+								noBackground = true;
+								backgroundCount = 0;
+								String newMessage = buildOutString(backgroundString, backgroundString.substring(0, Math.min(backgroundString.length(), message.length())));
+								if (newMessage.length() == 0) {// No extra chars
+	                                                           // found!
+									if (message.length() < backgroundString.length()) {// Char
+	                                                                                   // removed!
+										newMessage = "";
+									}
+									else { // Char added at the end
+										newMessage = message.substring(backgroundString.length(), message.length());
+									}
+								}
+								ItemStack item = new ItemStack(backgroundMaterial) {
+									@Override
+									public void click(Click click) {
+										click.setCancelled(true);
+									}
+								};
+								item.getItemMeta().setDisplayName(curruntItemDisplayName = colorPrefix + newMessage);
+								inv.setItem(0, item);
+							}
+						}
+						else
+						{
+							/*
+							ItemStack item = new ItemStack(backgroundMaterial) {
+								@Override
+								public void click(Click click) {
+									click.setCancelled(true);
+								}
+							};
+							item.getItemMeta().setDisplayName(curruntItemDisplayName);
+							inv.setItem(0, item);
+							*/
+						}
+						
+						handleMessage = handleMessage.replaceFirst(backgroundString, ""); // For safty
+						handleMessage = ChatColorUtils.stripColor(handleMessage);
+						if (handleMessage.startsWith(" ")) handleMessage = handleMessage.substring(1);
+						curruntMessage = handleMessage;
+						for(AnvilGuiListener listener : new ArrayList<>(AnvilGui.this.listener))
+							listener.onMessageChange(AnvilGui.this, handleMessage);
+						if(!inv.equals(owner.getInventoryView())){
+							PacketLib.removeHandler(this);
+						}
+					//	System.out.println("Boarderreach: "+new AnvilWindowSizeStringCalculator(handleMessage).reachBoarder(18)); 
+					}
+				}
+			}
+			else if(e.getPacket() instanceof PacketPlayInCloseWindow){
+				PacketPlayInCloseWindow packet = (PacketPlayInCloseWindow) e.getPacket();
+				if(owner.equals(e.getPlayer()) && (packet.getWindow() == Inventory.ID || inv.getViewer().isEmpty())){
+					for(AnvilGuiListener listener : new ArrayList<>(AnvilGui.this.listener))
+						listener.onClose(AnvilGui.this);
+					PacketLib.removeHandler(this);
+					System.out.println("Removing this. ("+this+"/"+")");
+					PacketLib.printListener();
+				}
+			}
+		}
+		/**
+		 * 
+		 * @param in
+		 *            XXXXX
+		 * @param in2
+		 *            YYXYY
+		 * @return
+		 */
+		
+		private String buildOutString(String in, String in2) {
+			char[] ca = in.toCharArray();
+			int cpa = 0;
+			char[] cb = in2.toCharArray();
+			int cpb = 0;
+			String out = "";
+			for (; Math.max(cpa, cpb) < Math.min(ca.length, cb.length);) {
+				if (ca[cpa] == cb[cpb]) {
+					cpa++;
+					cpb++;
+				}
+				else if (cpb + 1 < cb.length && ca[cpa] == cb[cpb + 1]) {
+					out = out += new String(new char[] { cb[cpb] });
+					cpb++;
+				}
+				else if (cpa + 1 < ca.length && ca[cpa + 1] == cb[cpb]) {
+					cpa++;
+				}
+				else {
+					// System.out.print("Non one char added!");
+					break;
+				}
+			}
+			return out;
+		}
+	};
+	
+	public AnvilGui(Player owner) {
+		this.owner = owner;
+		PacketLib.addHandler(packet);
+		backgroundMaterial = Material.ENCHANTED_BOOK;
+	}
+	
+	public void addListener(AnvilGuiListener listener){
+		this.listener.add(listener);
+	}
+	public void removeListener(AnvilGuiListener listener){
+		this.listener.remove(listener);
+	}
+	
+	public void open() {
+		inv = new Inventory(InventoryType.Anvil, "This is an AnvilGuy by WolverinDEV");
+		
+		ItemStack item = new ItemStack(backgroundMaterial) {
+			@Override
+			public void click(Click click) {
+				click.setCancelled(true);
+				handleSuccessClick();
+			}
+		};
+		item.getItemMeta().setDisplayName(curruntItemDisplayName = colorPrefix + backgroundString);
+		inv.setItem(0, item);
+		
+		inv.setItem(1, new ItemStack(centerItem) {
+			@Override
+			public void click(Click click) {
+				click.setCancelled(true);
+			}
+		});
+		
+		inv.setItem(2, new ItemStack(outputItem){
+			@Override
+			public void click(Click click) {
+				click.setCancelled(true);
+				handleSuccessClick();
+			}
+		});
+		
+		owner.openInventory(inv);
+	}
+	
+	public void setBackgroundMaterial(Material backgroundMaterial) {
+		this.backgroundMaterial = backgroundMaterial;
+		ItemStack item = new ItemStack(backgroundMaterial) {
+			@Override
+			public void click(Click click) {
+				click.setCancelled(true);
+			}
+		};
+		item.getItemMeta().setDisplayName(colorPrefix+curruntMessage);
+		inv.setItem(0, item);
+	}
+	
+	public void setBackgroundMessage(String backgroundString) {
+		this.backgroundString = backgroundString;
+		if(!noBackground){
+			ItemStack item = new ItemStack(backgroundMaterial) {
+				@Override
+				public void click(Click click) {
+					click.setCancelled(true);
+				}
+			};
+			item.getItemMeta().setDisplayName(colorPrefix+backgroundString);
+			inv.setItem(0, item);
+		}
+	}
+	
+	public void setCenterItem(Item centerItem) {
+		this.centerItem = centerItem;
+		this.inv.setItem(1, centerItem);
+	}
+	
+	public Item getCenterItem() {
+		return centerItem;
+	}
+	
+	public String getBackgroundMessage() {
+		return backgroundString;
+	}
+	
+	public String getCurruntInput() {
+		return curruntMessage;
+	}
+	
+	public void setCurruntInput(String curruntName) {
+		this.curruntMessage = curruntName;
+		ItemStack item = new ItemStack(backgroundMaterial) {
+			@Override
+			public void click(Click click) {
+				click.setCancelled(true);
+			}
+		};
+		item.getItemMeta().setDisplayName(colorPrefix+curruntName);
+		inv.setItem(0, item);
+	}
+	
+	public void setColorPrefix(String prefix) {
+		if (colorPrefix.equalsIgnoreCase(prefix)) return;
+		String rawMeta = curruntItemDisplayName.substring(Math.min(colorPrefix.length(), curruntItemDisplayName.length())); //Backspace a color prefix code... fix
+		colorPrefix = prefix;
+		ItemStack item = new ItemStack(backgroundMaterial) {
+			@Override
+			public void click(Click click) {
+				click.setCancelled(true);
+			}
+		};
+		item.getItemMeta().setDisplayName(curruntItemDisplayName = colorPrefix + rawMeta);
+		inv.setItem(0, item);
+	}
+	
+	protected void handleSuccessClick(){
+		for(AnvilGuiListener listener : new ArrayList<>(AnvilGui.this.listener))
+			if(listener != null)
+			listener.onConfirmInput(AnvilGui.this, this.curruntMessage);
+		if(owner.getInventoryView() != null)
+			if(owner.getInventoryView().equals(this.inv))
+				owner.closeInventory();
+		PacketLib.removeHandler(packet);
+	}
+	
+	public void close(){
+		for(AnvilGuiListener listener : new ArrayList<>(AnvilGui.this.listener))
+			if(listener != null)
+				listener.onClose(AnvilGui.this);
+		
+		if(owner.getInventoryView() != null)
+			if(owner.getInventoryView().equals(this.inv))
+				owner.closeInventory();
+		PacketLib.removeHandler(packet);
+	}
+	
+	public void setOutputItem(Item item){
+		inv.setItem(2, new ItemStack(outputItem = item){
+			@Override
+			public void click(Click click) {
+				click.setCancelled(true);
+				handleSuccessClick();
+			}
+		});
+	}
+	public Item getOutputItem() {
+		return outputItem;
+	}
+}
diff --git a/src/main/java/dev/wolveringer/api/gui/AnvilGuiListener.java b/src/main/java/dev/wolveringer/api/gui/AnvilGuiListener.java
new file mode 100644
index 0000000..c483fb9
--- /dev/null
+++ b/src/main/java/dev/wolveringer/api/gui/AnvilGuiListener.java
@@ -0,0 +1,19 @@
+package dev.wolveringer.api.gui;
+
+public interface AnvilGuiListener {
+	/**
+	 * 
+	 * @param guy
+	 * @param newMessage
+	 * 
+	 * this event will be triggered when a player changes the displayname
+	 */
+	public void onMessageChange(AnvilGui guy, String newMessage);
+	/**
+	 * @param cuy
+	 * @param message
+	 * This methode will run when a player entered the message
+	 */
+	public void onConfirmInput(AnvilGui guy, String message);
+	public void onClose(AnvilGui guy);
+}
diff --git a/src/main/java/dev/wolveringer/api/inventory/Inventory.java b/src/main/java/dev/wolveringer/api/inventory/Inventory.java
new file mode 100644
index 0000000..bb57b5b
--- /dev/null
+++ b/src/main/java/dev/wolveringer/api/inventory/Inventory.java
@@ -0,0 +1,301 @@
+package dev.wolveringer.api.inventory;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+import dev.wolveringer.BungeeUtil.Player;
+import dev.wolveringer.BungeeUtil.item.Item;
+import dev.wolveringer.BungeeUtil.item.ItemStack;
+import dev.wolveringer.BungeeUtil.item.itemmeta.CraftItemMeta;
+import dev.wolveringer.BungeeUtil.item.itemmeta.MetaListener;
+import dev.wolveringer.BungeeUtil.packets.Packet;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayOutOpenWindow;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayOutSetSlot;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayOutWindowItems;
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
+
+/**
+ * @author WolveinGER
+ *
+ */
+public class Inventory {
+	public static interface Unsave {
+		public ItemContainer getItemContainer();
+		public List<Player> getModificableViewerList();
+		public MetaListener getItemMetaListener();
+	}
+	public static final int ID = 99;
+
+	protected ItemContainer container;
+	protected String name;
+	protected List<Player> viewer = (List<Player>) Collections.synchronizedList(new ArrayList<Player>());
+	protected InventoryType type;
+	protected boolean autoUpdate = true;
+	protected boolean clickable = true;
+	protected boolean resend_inventory = false;
+	private MetaListener imcil;
+	private Unsave unsave = new Unsave() {
+		@Override
+		public List<Player> getModificableViewerList() {
+			return viewer;
+		}
+		
+		@Override
+		public MetaListener getItemMetaListener() {
+			return imcil;
+		}
+		
+		@Override
+		public ItemContainer getItemContainer() {
+			return container;
+		}
+	};
+	public Unsave unsave() {
+		return unsave;
+	}
+	
+	public Inventory(int size, String name) {
+		this(size, name, true);
+	}
+
+	private Inventory(ItemStack[] items, String name, ArrayList<Player> viewer, InventoryType type) {
+		super();
+		this.container = new ItemContainer(items);
+		this.name = name;
+		this.viewer = viewer;
+		this.type = type;
+		this.imcil = new MetaListener() {
+			@Override
+			public void onUpdate(Item is) {
+				if(autoUpdate){
+					int slot = getSlot(is);
+					if(slot != -1)
+						broadcast(new PacketPlayOutSetSlot(is, ID, slot));
+				}
+			}
+		};
+	}
+
+	public Inventory(int size, String name, boolean check) {
+		if(size % 9 != 0 && check)
+			throw new RuntimeException(size + " % 9 != 0");
+		this.type = InventoryType.Chest;
+		this.name = name;
+		this.container = new ItemContainer(size);
+		this.imcil = new MetaListener() {
+			@Override
+			public void onUpdate(Item is) {
+				if(autoUpdate)
+					updateInventory();
+			}
+		};
+	}
+
+	public Inventory(InventoryType type, String name) {
+		this.name = name;
+		this.type = type;
+		this.container = new ItemContainer(type.getSlots());
+		this.imcil = new MetaListener() {
+			@Override
+			public void onUpdate(Item is) {
+				if(autoUpdate)
+					updateInventory();
+			}
+		};
+	}
+
+	public void addItem(ItemStack is) {
+		Item[] items = container.getContains();
+		for(int i = 0;i < items.length;i++)
+			if(items[i] == null){
+				setItem(i, is);
+				break;
+			}else if(items[i].isSimilar(is)){
+				if(items[i].getAmount() + is.getAmount() > 64){
+					is.setAmount(64 - items[i].getAmount());
+					items[i].setAmount(64);
+					setItem(i, getItemStack(items[i]));
+					addItem(is);
+				}else{
+					items[i].setAmount(items[i].getAmount() + is.getAmount());
+					setItem(i, getItemStack(items[i]));
+					break;
+				}
+			}
+	}
+	
+	/**
+	 * Contains spelling mistake
+	 * @deprecated Use {@link #broadcast(Packet a)} instead.  
+	 */
+	@Deprecated
+	private void brotcast(Packet a) {
+		broadcast(a);
+	}
+	
+	private void broadcast(Packet a) {
+		for(Player p : viewer)
+			p.sendPacket((PacketPlayOut) a);
+	}
+
+	public ItemStack[] getContains() {
+		return container.getContainsAsItemStack();
+	}
+
+	public ItemStack getItem(int slot) {
+		return getItemStack(container.getItem(slot));
+	}
+
+	public boolean hasItem(Item i) {
+		return container.hasItem(i);
+	}
+
+	public String getName() {
+		return name;
+	}
+
+	public void setName(String name) {
+		this.name = name;
+		if(autoUpdate){
+			for(Player p : viewer){
+				PacketPlayOutOpenWindow e = new PacketPlayOutOpenWindow(Inventory.ID, getType().getType(p.getVersion()), getName(), getType() == InventoryType.Chest ? getSlots() : getType().getDefaultSlots(), false);
+				e.UTF_8 = true;
+				p.sendPacket(e);
+			}
+			updateInventory();
+		}else{
+			resend_inventory = true;
+		}
+	}
+
+	public int getSlots() {
+		return container.getSize();
+	}
+	
+	public int getSlot(Item is){
+		return container.getSlot(is);
+	}
+
+	public InventoryType getType() {
+		return type;
+	}
+
+	public synchronized void setItem(int slot, ItemStack is) {
+		if(getItem(slot) != null)
+			if((CraftItemMeta) getItem(slot).getItemMeta() != null)
+				((CraftItemMeta) getItem(slot).getItemMeta()).removeMetaListener(this.imcil);
+		container.setItem(slot, is);
+		if(is != null)
+			((CraftItemMeta) is.getItemMeta()).addMetaListener(this.imcil);
+		if(autoUpdate)
+			broadcast(new PacketPlayOutSetSlot(is, ID, slot));
+	}
+
+	public void setItem(int i, Item item) {
+		setItem(i, getItemStack(item));
+	}
+
+	public List<Player> getViewer() {
+		return Collections.unmodifiableList(viewer);
+	}
+
+	public void clear() {
+		for(Item i : container.getContains())
+			if(i != null)
+			((CraftItemMeta)i.getItemMeta()).removeMetaListener(imcil);
+		container.clear();
+	}
+
+	public void resize(int size) {
+		if(type != InventoryType.Chest)
+			throw new IllegalStateException("Inventorytype isnï¿½t a Chest!");
+		container.resize(size);
+		if(autoUpdate){
+			Item[] items = container.getContains();
+			for(Player p : viewer)
+				p.sendPacket(new PacketPlayOutOpenWindow(ID, type.getType(p.getVersion()), name, items.length, false));
+			updateInventory();
+		}else{
+			resend_inventory = true;
+		}
+	}
+
+	public void fill(ItemStack is) {
+		for(int i = 0;i < getSlots();i++){
+			if(getItem(i) == null)
+				setItem(i, is);
+		}
+	}
+
+	public void replace(Item item, ItemStack replace) {
+		for(int i = 0;i < getSlots();i++){
+			if(getItem(i).equals(item))
+				setItem(i, replace);
+		}
+	}
+
+	public void updateInventory() {
+		autoUpdate = true;
+		if(resend_inventory){
+			for(Player p : viewer){
+				PacketPlayOutOpenWindow e = new PacketPlayOutOpenWindow(Inventory.ID, getType().getType(p.getVersion()), getName(), getType() == InventoryType.Chest ? getSlots() : getType().getDefaultSlots(), false);
+				e.UTF_8 = true;
+				p.sendPacket(e);
+			}
+			broadcast(new PacketPlayOutWindowItems(ID, this.container.getContains()));
+		}else{
+			broadcast(new PacketPlayOutWindowItems(ID, this.container.getContains()));
+		}
+	}
+
+	public Inventory clone() {
+		return new Inventory(container.getContainsAsItemStack(), name, new ArrayList<Player>(), type);
+	}
+
+	@Override
+	public String toString() {
+		return "Inventory{name=\""+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"r" + getName() + ""+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"r\" viewer=" + getViewer() + " ObjektID=\"" + super.toString().split("@")[1] + "\"}";
+	}
+
+	public void setContains(ItemStack[] contains) {
+		for(Item i : container.getContains())
+			((CraftItemMeta)i.getItemMeta()).removeMetaListener(imcil);
+		container.setContains(contains);
+		for(ItemStack is : contains)
+			((CraftItemMeta)is.getItemMeta()).addMetaListener(imcil);
+		if(autoUpdate)
+			updateInventory();
+	}
+
+	@Deprecated
+	public void disableUpdate() {
+		autoUpdate = false;
+	}
+
+	@Deprecated
+	public void enableUpdate() {
+		autoUpdate = true;
+		updateInventory();
+	}
+
+	public void setClickable(boolean clickable) {
+		this.clickable = clickable;
+	}
+
+	public boolean isClickable() {
+		return this.clickable;
+	}
+
+	private ItemStack getItemStack(Item is) {
+		if(is == null)
+			return null;
+		else if(is instanceof ItemStack)
+			return (ItemStack) is;
+		else
+			return new ItemStack(is) {
+				public void click(Click click) {
+				};
+			};
+	}
+}
diff --git a/src/main/java/dev/wolveringer/api/inventory/InventoryType.java b/src/main/java/dev/wolveringer/api/inventory/InventoryType.java
new file mode 100644
index 0000000..3492f1f
--- /dev/null
+++ b/src/main/java/dev/wolveringer/api/inventory/InventoryType.java
@@ -0,0 +1,39 @@
+package dev.wolveringer.api.inventory;
+
+import dev.wolveringer.BungeeUtil.ClientVersion;
+import dev.wolveringer.BungeeUtil.ClientVersion.BigClientVersion;
+
+public enum InventoryType {
+	Chest("0","minecraft:chest",36,36),
+	Workbench("1","minecraft:crafting_table",0,9),
+	Furnace("2","minecraft:furnace",3,3),
+	Dispenser("3","minecraft:dispenser",9,9),
+	EnchantmentTable("4","minecraft:enchanting_table",0,2),
+	BrewingStand("5","minecraft:brewing_stand",4,4),
+	Villager("6","minecraft:villager",3,3),
+	Beacon("7","minecraft:beacon",1,1),
+	Anvil("8","minecraft:anvil",0,3),
+	Hopper("9","minecraft:hopper",5,5),
+	Dropper("10","minecraft:dropper",9,9);
+	
+	private String type_v1_7;
+	private String type_v1_8;
+	private int aslots;
+	private int islots;
+	private InventoryType(String a,String b,int s,int i) {
+		this.type_v1_7=a;
+		this.type_v1_8=b;
+		this.aslots=s;
+		this.islots=i;
+	}
+	
+	public String getType(ClientVersion v){
+		return v.getBigVersion() == BigClientVersion.v1_7?type_v1_7:type_v1_8;
+	}
+	public int getDefaultSlots(){
+		return aslots;
+	}
+	public int getSlots(){
+		return islots;
+	}
+}
diff --git a/src/main/java/dev/wolveringer/api/inventory/ItemContainer.java b/src/main/java/dev/wolveringer/api/inventory/ItemContainer.java
new file mode 100644
index 0000000..28fce2e
--- /dev/null
+++ b/src/main/java/dev/wolveringer/api/inventory/ItemContainer.java
@@ -0,0 +1,136 @@
+package dev.wolveringer.api.inventory;
+
+import java.util.Arrays;
+
+import dev.wolveringer.BungeeUtil.Material;
+import dev.wolveringer.BungeeUtil.item.Item;
+import dev.wolveringer.BungeeUtil.item.ItemStack;
+
+public class ItemContainer {
+	private static Item[] convert(ItemStack... items) {
+		Item[] out = new Item[items.length];
+		for(int i = 0;i < items.length;i++){
+			out[i] = items[i];
+		}
+		return out;
+	}
+
+	private static ItemStack[] convert(Item... items) {
+		ItemStack[] out = new ItemStack[items.length];
+		for(int i = 0;i < items.length;i++){
+			out[i] = convert(items[i]);
+		}
+		return out;
+	}
+
+	private static ItemStack convert(Item is) {
+		if(is == null)
+			return null;
+		else if(is instanceof ItemStack)
+			return (ItemStack) is;
+		else
+			return new ItemStack(is) {
+				public void click(Click click) {
+				};
+			};
+	}
+
+	private Item[] items;
+
+	public ItemContainer(ItemStack[] items) {
+		this.items = convert(items);
+	}
+
+	public ItemContainer(int size) {
+		this.items = new Item[size];
+	}
+
+	public void addItem(Item is) {
+		for(int i = 0;i < items.length;i++)
+			if(items[i] == null){
+				setItem(i, is);
+				break;
+			}else if(items[i].isSimilar(is)){
+				if(items[i].getAmount() + is.getAmount() > 64){
+					is.setAmount(64 - items[i].getAmount());
+					items[i].setAmount(64);
+					setItem(i, items[i]);
+					addItem(is);
+				}else{
+					items[i].setAmount(items[i].getAmount() + is.getAmount());
+					setItem(i, items[i]);
+					break;
+				}
+			}
+	}
+
+	public Item[] getContains() {
+		return items;
+	}
+
+	public ItemStack[] getContainsAsItemStack() {
+		return convert(items);
+	}
+	
+	public Item getItem(int slot) {
+		return items[slot];
+	}
+
+	public boolean hasItem(Item i) {
+		for(Item is : items)
+			if(is != null)
+				if(is.equals(i))
+					return true;
+		return false;
+	}
+
+	public int getSize() {
+		return items.length;
+	}
+
+	public void setItem(int slot, Item is) {
+		if(is == null || is.getTypeId() == 0)
+			items[slot] = null;
+		else
+			items[slot] = is;
+	}
+
+	public void clear() {
+		items = new Item[items.length];
+	}
+
+	public void resize(int size) {
+		items = Arrays.copyOf(items, size);
+	}
+
+	public void fill(Item is) {
+		for(int i = 0;i < getSize();i++){
+			if(getItem(i) == null)
+				setItem(i, is);
+		}
+	}
+
+	public void replace(Item item, Item replace) {
+		for(int i = 0;i < getSize();i++){
+			if(getItem(i).equals(item))
+				setItem(i, replace);
+		}
+	}
+
+	public void setContains(Item[] contains) {
+		this.items = contains;
+	}
+	public void setContains(ItemStack[] contains) {
+		this.items = contains;
+	}
+
+	public int getSlot(Item is) {
+		for(int i = 0;i < items.length;i++){
+			if(items[i] == null && is == null)
+				return i;
+			else if(items[i] != null && items[i].equals(is))
+				return i;
+		}
+		return -1;
+	}
+}
diff --git a/src/main/java/dev/wolveringer/api/inventory/PlayerInventory.java b/src/main/java/dev/wolveringer/api/inventory/PlayerInventory.java
new file mode 100644
index 0000000..77ab5e3
--- /dev/null
+++ b/src/main/java/dev/wolveringer/api/inventory/PlayerInventory.java
@@ -0,0 +1,119 @@
+package dev.wolveringer.api.inventory;
+
+import java.util.ArrayList;
+
+import dev.wolveringer.BungeeUtil.ClientVersion.BigClientVersion;
+import dev.wolveringer.BungeeUtil.Material;
+import dev.wolveringer.BungeeUtil.Player;
+import dev.wolveringer.BungeeUtil.item.Item;
+import dev.wolveringer.BungeeUtil.item.ItemStack;
+import dev.wolveringer.BungeeUtil.packets.Packet;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayOutSetSlot;
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
+
+public final class PlayerInventory {
+	@SuppressWarnings("serial")
+	private ArrayList<Item> items = new ArrayList<Item>() {
+		public Item get(int index) {
+			while (super.size() <= index){
+				super.add(null);
+			}
+			return super.get(index);
+		};
+
+		public Item set(int index, Item element) {
+			while (super.size() <= index){
+				super.add(null);
+			}
+			return super.set(index, element);
+		};
+	};
+	private String name;
+	private ArrayList<Player> viewer = new ArrayList<Player>();
+	private int ID;
+	private Player player;
+	public PlayerInventory(Player player,int ID, String name) {
+		this.name = name;
+		this.ID = ID;
+		this.player = player;
+		getItem(45);
+	}
+
+	public PlayerInventory(Player player) {
+		this(player,0,"");
+	}
+
+	/**
+	 * Contains spelling mistake
+	 * @deprecated Use {@link #broadcast(Packet a)} instead.  
+	 */
+	@Deprecated
+	private void brotcast(Packet a) {
+		broadcast(a);
+	}
+
+	private void broadcast(Packet a) {
+		player.sendPacket((PacketPlayOut)a);
+	}
+
+	public Item[] getContains() {
+		return items.toArray(new Item[Math.min(items.size(), player.getVersion().getBigVersion() == BigClientVersion.v1_9 ? 46 : 45)]); //46/45=Max slots
+	}
+
+	public Item getItem(int slot) {
+		return items.get(slot);
+	}
+
+	public String getName() {
+		return name;
+	}
+
+	public int getSlots() {
+		return items.size();
+	}
+
+	public int getType() {
+		return 0;
+	}
+
+	public void setItem(int slot, Item is) {
+		items.set(slot, is);
+		if(player.isInventoryOpened()){
+			if(slot > 8){
+				broadcast(new PacketPlayOutSetSlot(is, Inventory.ID, slot-9+player.getInventoryView().getSlots()));
+			}
+		}
+		else
+			broadcast(new PacketPlayOutSetSlot(is, ID, slot));
+	}
+
+	public ArrayList<Player> getViewer() {
+		return viewer;
+	}
+
+	public void reset() {
+		items.clear();
+	}
+	
+	public int getFirstSlot(ItemStack is) {
+		for(int i = 0;i < items.size();i++)
+			if(items.get(i) == null){
+				return i;
+			}else if(items.get(i).isSimilar(is)){
+				if(is.getAmount() != 64)
+					return i;
+			}
+		return -1;
+	}
+	
+	@Override
+	protected void finalize() throws Throwable {
+		reset();
+	}
+
+	public void clear() {
+		int s = getSlots();
+		items.clear();
+		items.get(s);
+	}
+}
diff --git a/src/main/java/dev/wolveringer/api/inventory/ScrolingInventory.java b/src/main/java/dev/wolveringer/api/inventory/ScrolingInventory.java
new file mode 100644
index 0000000..89a1cbb
--- /dev/null
+++ b/src/main/java/dev/wolveringer/api/inventory/ScrolingInventory.java
@@ -0,0 +1,184 @@
+package dev.wolveringer.api.inventory;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+import dev.wolveringer.BungeeUtil.Material;
+import dev.wolveringer.BungeeUtil.item.Item;
+import dev.wolveringer.BungeeUtil.item.ItemStack;
+import dev.wolveringer.chat.ChatColor.ChatColorUtils;
+
+public class ScrolingInventory extends Inventory {
+
+	public ScrolingInventory(int rows, String name) {
+		super(rows * 9 + 18, name);
+		this.rows = rows;
+		nextitem.getItemMeta().setDisplayName(ChatColorUtils.COLOR_CHAR+"7next Side "+ChatColorUtils.COLOR_CHAR+"b-->");
+		backitem.getItemMeta().setDisplayName(ChatColorUtils.COLOR_CHAR+"b<-- "+ChatColorUtils.COLOR_CHAR+"7previous Side");
+		lineitem.getItemMeta().setDisplayName(ChatColorUtils.COLOR_CHAR+"a");
+		lineitem.getItemMeta().setGlow(true);
+		nothinkitem.getItemMeta().setDisplayName(ChatColorUtils.COLOR_CHAR+"cKein Item verf"+ChatColorUtils.COLOR_CHAR+"gbar");
+		update();
+	}
+
+	private List<ItemStack> items =Collections.synchronizedList(new ArrayList<ItemStack>());
+	private ItemStack[] toolitem = new ItemStack[7];
+	private int side = 0;
+	private int rows = -1;
+	private boolean autoUpdate = true;
+	private ItemStack fill;
+	private ItemStack nextitem = new ItemStack(Material.STICK) {
+		@Override
+		public void click(Click p) {
+			if(!getItemMeta().hasGlow())
+				nextSide();
+		}
+	};
+	private ItemStack backitem = new ItemStack(Material.STICK) {
+		@Override
+		public void click(Click p) {
+			if(!getItemMeta().hasGlow())
+				backSide();
+		}
+	};
+	@SuppressWarnings("deprecation")
+	private ItemStack lineitem = new ItemStack(Material.getMaterial(160), 1, (short) 15) {
+		public void click(Click p) {
+		}
+	};
+	private ItemStack nothinkitem = new ItemStack(Material.FENCE) {
+		public void click(Click p) {
+		};
+	};
+
+	public void setItem(int slot, ItemStack is) {
+		throw new RuntimeException("This Inventory is not static!");
+	}
+
+	@Override
+	public void addItem(ItemStack is) {
+		items.add(is);
+		if(autoUpdate)
+			update();
+	}
+
+	public void removeItem(ItemStack is) {
+		items.remove(is);
+		if(autoUpdate)
+			update();
+	}
+
+	public void setNextItem(Item i) {
+		nextitem = new ItemStack(i) {
+			@Override
+			public void click(Click p) {
+				nextSide();
+			}
+		};
+	}
+
+	public void setBackItem(Item i) {
+		backitem = new ItemStack(i) {
+			@Override
+			public void click(Click p) {
+				backSide();
+			}
+		};
+		update();
+	}
+
+	public void setLineItem(Item i) {
+		lineitem = new ItemStack(i) {
+			@Override
+			public void click(Click p) {
+			}
+		};
+		update();
+	}
+
+	public void setNothinkitem(Item nothinkitem) {
+		this.nothinkitem = new ItemStack(nothinkitem) {
+			@Override
+			public void click(Click c) {}
+		};
+		update();
+	}
+
+	/**
+	 * @param slot
+	 *            <=7
+	 * @param is
+	 */
+	public void setToolItem(int slot, ItemStack is) {
+		if(slot > 7)
+			throw new RuntimeException("Slot is to big!");
+		toolitem[slot] = is;
+		if(autoUpdate)
+			update();
+	}
+
+	public void nextSide() {
+		side++;
+		update();
+	}
+
+	public void backSide() {
+		side--;
+		update();
+	}
+
+	@Override
+	public void clear() {
+		items.clear();
+		if(autoUpdate)
+			update();
+	}
+
+	private void update() {
+		super.disableUpdate();
+		super.clear();
+		List<ItemStack> i = (side * (rows * 9) < items.size() ? items.subList(side * (rows * 9), (side + 1) * (rows * 9) < items.size() ? (side + 1) * (rows * 9) : items.size()) : new ArrayList<ItemStack>());
+		for(int x = 0;x < i.size();x++)
+			super.setItem(x, i.get(x));
+		if(i.size() == 0)
+			super.setItem(((rows / 2) * 9) + 4, nothinkitem);
+		for(int x = 0;x < 9;x++){
+			super.setItem((rows * 9) + x, lineitem);
+		}
+		nextitem.getItemMeta().setGlow((side + 1) * (rows * 9) >= items.size());
+		super.setItem(getSlots() - 1, nextitem);
+		backitem.getItemMeta().setGlow(side == 0);
+		super.setItem(getSlots() - 9, backitem);
+		for(int x = 0;x < 7;x++)
+			super.setItem(getSlots() - 8 + x, toolitem[x]);
+		fill(fill);
+		autoUpdate = true;
+		super.updateInventory();
+	}
+
+	@Override
+	public void disableUpdate() {
+		autoUpdate = false;
+	}
+
+	@Override
+	public void enableUpdate() {
+		autoUpdate = true;
+		update();
+	}
+
+	@Override
+	public void updateInventory() {
+		this.update();
+	}
+	@Override
+	public void fill(ItemStack is) {
+		fill = is;
+		if(fill != null)
+		for(int i = 0;i<getSlots();i++){
+			if(super.getItem(i) == null)
+				super.setItem(i, is);
+		}
+	}
+}
diff --git a/src/main/java/dev/wolveringer/api/particel/ParticleEffect.java b/src/main/java/dev/wolveringer/api/particel/ParticleEffect.java
new file mode 100644
index 0000000..305ac22
--- /dev/null
+++ b/src/main/java/dev/wolveringer/api/particel/ParticleEffect.java
@@ -0,0 +1,1211 @@
+package dev.wolveringer.api.particel;
+
+import java.awt.Color;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+
+import dev.wolveringer.BungeeUtil.Material;
+import dev.wolveringer.BungeeUtil.Player;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayOutWorldParticles;
+import dev.wolveringer.api.particel.ParticleEffect.ParticleData;
+import dev.wolveringer.api.position.Location;
+import dev.wolveringer.api.position.Vector;
+/**
+ * <b>ParticleEffect Library</b>
+ * <p>
+ * This library was created by @DarkBlade12 and allows you to display all Minecraft particle effects on a Bukkit server
+ * <p>
+ * You are welcome to use it, modify it and redistribute it under the following conditions:
+ * <ul>
+ * <li>Don't claim this class as your own
+ * <li>Don't remove this disclaimer
+ * </ul>
+ * <p>
+ * Special thanks:
+ * <ul>
+ * <li>@microgeek (original idea, names and packet parameters)
+ * <li>@ShadyPotato (1.8 names, ids and packet parameters)
+ * <li>@RingOfStorms (particle behavior)
+ * <li>@Cybermaxke (particle behavior)
+ * </ul>
+ * <p>
+ * <i>It would be nice if you provide credit to me if you use this class in a published project</i>
+ * 
+ * @author DarkBlade12
+ * @version 1.7
+ */
+public enum ParticleEffect {
+	/**
+	 * A particle effect which is displayed by exploding tnt and creepers:
+	 * <ul>
+	 * <li>It looks like a white cloud
+	 * <li>The speed value influences the velocity at which the particle flies off
+	 * </ul>
+	 */
+	EXPLOSION_NORMAL("explode", 0, -1, ParticleProperty.DIRECTIONAL),
+	/**
+	 * A particle effect which is displayed by exploding ghast fireballs and wither skulls:
+	 * <ul>
+	 * <li>It looks like a gray ball which is fading away
+	 * <li>The speed value slightly influences the size of this particle effect
+	 * </ul>
+	 */
+	EXPLOSION_LARGE("largeexplode", 1, -1),
+	/**
+	 * A particle effect which is displayed by exploding tnt and creepers:
+	 * <ul>
+	 * <li>It looks like a crowd of gray balls which are fading away
+	 * <li>The speed value has no influence on this particle effect
+	 * </ul>
+	 */
+	EXPLOSION_HUGE("hugeexplosion", 2, -1),
+	/**
+	 * A particle effect which is displayed by launching fireworks:
+	 * <ul>
+	 * <li>It looks like a white star which is sparkling
+	 * <li>The speed value influences the velocity at which the particle flies off
+	 * </ul>
+	 */
+	FIREWORKS_SPARK("fireworksSpark", 3, -1, ParticleProperty.DIRECTIONAL),
+	/**
+	 * A particle effect which is displayed by swimming entities and arrows in water:
+	 * <ul>
+	 * <li>It looks like a bubble
+	 * <li>The speed value influences the velocity at which the particle flies off
+	 * </ul>
+	 */
+	WATER_BUBBLE("bubble", 4, -1, ParticleProperty.DIRECTIONAL, ParticleProperty.REQUIRES_WATER),
+	/**
+	 * A particle effect which is displayed by swimming entities and shaking wolves:
+	 * <ul>
+	 * <li>It looks like a blue drop
+	 * <li>The speed value has no influence on this particle effect
+	 * </ul>
+	 */
+	WATER_SPLASH("splash", 5, -1, ParticleProperty.DIRECTIONAL),
+	/**
+	 * A particle effect which is displayed on water when fishing:
+	 * <ul>
+	 * <li>It looks like a blue droplet
+	 * <li>The speed value influences the velocity at which the particle flies off
+	 * </ul>
+	 */
+	WATER_WAKE("wake", 6, 7, ParticleProperty.DIRECTIONAL),
+	/**
+	 * A particle effect which is displayed by water:
+	 * <ul>
+	 * <li>It looks like a tiny blue square
+	 * <li>The speed value has no influence on this particle effect
+	 * </ul>
+	 */
+	SUSPENDED("suspended", 7, -1, ParticleProperty.REQUIRES_WATER),
+	/**
+	 * A particle effect which is displayed by air when close to bedrock and the in the void:
+	 * <ul>
+	 * <li>It looks like a tiny gray square
+	 * <li>The speed value has no influence on this particle effect
+	 * </ul>
+	 */
+	SUSPENDED_DEPTH("depthSuspend", 8, -1, ParticleProperty.DIRECTIONAL),
+	/**
+	 * A particle effect which is displayed when landing a critical hit and by arrows:
+	 * <ul>
+	 * <li>It looks like a light brown cross
+	 * <li>The speed value influences the velocity at which the particle flies off
+	 * </ul>
+	 */
+	CRIT("crit", 9, -1, ParticleProperty.DIRECTIONAL),
+	/**
+	 * A particle effect which is displayed when landing a hit with an enchanted weapon:
+	 * <ul>
+	 * <li>It looks like a cyan star
+	 * <li>The speed value influences the velocity at which the particle flies off
+	 * </ul>
+	 */
+	CRIT_MAGIC("magicCrit", 10, -1, ParticleProperty.DIRECTIONAL),
+	/**
+	 * A particle effect which is displayed by primed tnt, torches, droppers, dispensers, end portals, brewing stands and monster spawners:
+	 * <ul>
+	 * <li>It looks like a little gray cloud
+	 * <li>The speed value influences the velocity at which the particle flies off
+	 * </ul>
+	 */
+	SMOKE_NORMAL("smoke", 11, -1, ParticleProperty.DIRECTIONAL),
+	/**
+	 * A particle effect which is displayed by fire, minecarts with furnace and blazes:
+	 * <ul>
+	 * <li>It looks like a large gray cloud
+	 * <li>The speed value influences the velocity at which the particle flies off
+	 * </ul>
+	 */
+	SMOKE_LARGE("largesmoke", 12, -1, ParticleProperty.DIRECTIONAL),
+	/**
+	 * A particle effect which is displayed when splash potions or bottles o' enchanting hit something:
+	 * <ul>
+	 * <li>It looks like a white swirl
+	 * <li>The speed value causes the particle to only move upwards when set to 0
+	 * <li>Only the motion on the y-axis can be controlled, the motion on the x- and z-axis are multiplied by 0.1 when setting the values to 0
+	 * </ul>
+	 */
+	SPELL("spell", 13, -1),
+	/**
+	 * A particle effect which is displayed when instant splash potions hit something:
+	 * <ul>
+	 * <li>It looks like a white cross
+	 * <li>The speed value causes the particle to only move upwards when set to 0
+	 * <li>Only the motion on the y-axis can be controlled, the motion on the x- and z-axis are multiplied by 0.1 when setting the values to 0
+	 * </ul>
+	 */
+	SPELL_INSTANT("instantSpell", 14, -1),
+	/**
+	 * A particle effect which is displayed by entities with active potion effects:
+	 * <ul>
+	 * <li>It looks like a colored swirl
+	 * <li>The speed value causes the particle to be colored black when set to 0
+	 * <li>The particle color gets lighter when increasing the speed and darker when decreasing the speed
+	 * </ul>
+	 */
+	SPELL_MOB("mobSpell", 15, -1, ParticleProperty.COLORABLE),
+	/**
+	 * A particle effect which is displayed by entities with active potion effects applied through a beacon:
+	 * <ul>
+	 * <li>It looks like a transparent colored swirl
+	 * <li>The speed value causes the particle to be always colored black when set to 0
+	 * <li>The particle color gets lighter when increasing the speed and darker when decreasing the speed
+	 * </ul>
+	 */
+	SPELL_MOB_AMBIENT("mobSpellAmbient", 16, -1, ParticleProperty.COLORABLE),
+	/**
+	 * A particle effect which is displayed by witches:
+	 * <ul>
+	 * <li>It looks like a purple cross
+	 * <li>The speed value causes the particle to only move upwards when set to 0
+	 * <li>Only the motion on the y-axis can be controlled, the motion on the x- and z-axis are multiplied by 0.1 when setting the values to 0
+	 * </ul>
+	 */
+	SPELL_WITCH("witchMagic", 17, -1),
+	/**
+	 * A particle effect which is displayed by blocks beneath a water source:
+	 * <ul>
+	 * <li>It looks like a blue drip
+	 * <li>The speed value has no influence on this particle effect
+	 * </ul>
+	 */
+	DRIP_WATER("dripWater", 18, -1),
+	/**
+	 * A particle effect which is displayed by blocks beneath a lava source:
+	 * <ul>
+	 * <li>It looks like an orange drip
+	 * <li>The speed value has no influence on this particle effect
+	 * </ul>
+	 */
+	DRIP_LAVA("dripLava", 19, -1),
+	/**
+	 * A particle effect which is displayed when attacking a villager in a village:
+	 * <ul>
+	 * <li>It looks like a cracked gray heart
+	 * <li>The speed value has no influence on this particle effect
+	 * </ul>
+	 */
+	VILLAGER_ANGRY("angryVillager", 20, -1),
+	/**
+	 * A particle effect which is displayed when using bone meal and trading with a villager in a village:
+	 * <ul>
+	 * <li>It looks like a green star
+	 * <li>The speed value has no influence on this particle effect
+	 * </ul>
+	 */
+	VILLAGER_HAPPY("happyVillager", 21, -1, ParticleProperty.DIRECTIONAL),
+	/**
+	 * A particle effect which is displayed by mycelium:
+	 * <ul>
+	 * <li>It looks like a tiny gray square
+	 * <li>The speed value has no influence on this particle effect
+	 * </ul>
+	 */
+	TOWN_AURA("townaura", 22, -1, ParticleProperty.DIRECTIONAL),
+	/**
+	 * A particle effect which is displayed by note blocks:
+	 * <ul>
+	 * <li>It looks like a colored note
+	 * <li>The speed value causes the particle to be colored green when set to 0
+	 * </ul>
+	 */
+	NOTE("note", 23, -1, ParticleProperty.COLORABLE),
+	/**
+	 * A particle effect which is displayed by nether portals, endermen, ender pearls, eyes of ender, ender chests and dragon eggs:
+	 * <ul>
+	 * <li>It looks like a purple cloud
+	 * <li>The speed value influences the spread of this particle effect
+	 * </ul>
+	 */
+	PORTAL("portal", 24, -1, ParticleProperty.DIRECTIONAL),
+	/**
+	 * A particle effect which is displayed by enchantment tables which are nearby bookshelves:
+	 * <ul>
+	 * <li>It looks like a cryptic white letter
+	 * <li>The speed value influences the spread of this particle effect
+	 * </ul>
+	 */
+	ENCHANTMENT_TABLE("enchantmenttable", 25, -1, ParticleProperty.DIRECTIONAL),
+	/**
+	 * A particle effect which is displayed by torches, active furnaces, magma cubes and monster spawners:
+	 * <ul>
+	 * <li>It looks like a tiny flame
+	 * <li>The speed value influences the velocity at which the particle flies off
+	 * </ul>
+	 */
+	FLAME("flame", 26, -1, ParticleProperty.DIRECTIONAL),
+	/**
+	 * A particle effect which is displayed by lava:
+	 * <ul>
+	 * <li>It looks like a spark
+	 * <li>The speed value has no influence on this particle effect
+	 * </ul>
+	 */
+	LAVA("lava", 27, -1),
+	/**
+	 * A particle effect which is currently unused:
+	 * <ul>
+	 * <li>It looks like a transparent gray square
+	 * <li>The speed value has no influence on this particle effect
+	 * </ul>
+	 */
+	FOOTSTEP("footstep", 28, -1),
+	/**
+	 * A particle effect which is displayed when a mob dies:
+	 * <ul>
+	 * <li>It looks like a large white cloud
+	 * <li>The speed value influences the velocity at which the particle flies off
+	 * </ul>
+	 */
+	CLOUD("cloud", 29, -1, ParticleProperty.DIRECTIONAL),
+	/**
+	 * A particle effect which is displayed by redstone ore, powered redstone, redstone torches and redstone repeaters:
+	 * <ul>
+	 * <li>It looks like a tiny colored cloud
+	 * <li>The speed value causes the particle to be colored red when set to 0
+	 * </ul>
+	 */
+	REDSTONE("reddust", 30, -1, ParticleProperty.COLORABLE),
+	/**
+	 * A particle effect which is displayed when snowballs hit a block:
+	 * <ul>
+	 * <li>It looks like a little piece with the snowball texture
+	 * <li>The speed value has no influence on this particle effect
+	 * </ul>
+	 */
+	SNOWBALL("snowballpoof", 31, -1),
+	/**
+	 * A particle effect which is currently unused:
+	 * <ul>
+	 * <li>It looks like a tiny white cloud
+	 * <li>The speed value influences the velocity at which the particle flies off
+	 * </ul>
+	 */
+	SNOW_SHOVEL("snowshovel", 32, -1, ParticleProperty.DIRECTIONAL),
+	/**
+	 * A particle effect which is displayed by slimes:
+	 * <ul>
+	 * <li>It looks like a tiny part of the slimeball icon
+	 * <li>The speed value has no influence on this particle effect
+	 * </ul>
+	 */
+	SLIME("slime", 33, -1),
+	/**
+	 * A particle effect which is displayed when breeding and taming animals:
+	 * <ul>
+	 * <li>It looks like a red heart
+	 * <li>The speed value has no influence on this particle effect
+	 * </ul>
+	 */
+	HEART("heart", 34, -1),
+	/**
+	 * A particle effect which is displayed by barriers:
+	 * <ul>
+	 * <li>It looks like a red box with a slash through it
+	 * <li>The speed value has no influence on this particle effect
+	 * </ul>
+	 */
+	BARRIER("barrier", 35, 8),
+	/**
+	 * A particle effect which is displayed when breaking a tool or eggs hit a block:
+	 * <ul>
+	 * <li>It looks like a little piece with an item texture
+	 * </ul>
+	 */
+	ITEM_CRACK("iconcrack", 36, -1, ParticleProperty.DIRECTIONAL, ParticleProperty.REQUIRES_DATA),
+	/**
+	 * A particle effect which is displayed when breaking blocks or sprinting:
+	 * <ul>
+	 * <li>It looks like a little piece with a block texture
+	 * <li>The speed value has no influence on this particle effect
+	 * </ul>
+	 */
+	BLOCK_CRACK("blockcrack", 37, -1, ParticleProperty.REQUIRES_DATA),
+	/**
+	 * A particle effect which is displayed when falling:
+	 * <ul>
+	 * <li>It looks like a little piece with a block texture
+	 * </ul>
+	 */
+	BLOCK_DUST("blockdust", 38, 7, ParticleProperty.DIRECTIONAL, ParticleProperty.REQUIRES_DATA),
+	/**
+	 * A particle effect which is displayed when rain hits the ground:
+	 * <ul>
+	 * <li>It looks like a blue droplet
+	 * <li>The speed value has no influence on this particle effect
+	 * </ul>
+	 */
+	WATER_DROP("droplet", 39, 8),
+	/**
+	 * A particle effect which is currently unused:
+	 * <ul>
+	 * <li>It has no visual effect
+	 * </ul>
+	 */
+	ITEM_TAKE("take", 40, 8),
+	/**
+	 * A particle effect which is displayed by elder guardians:
+	 * <ul>
+	 * <li>It looks like the shape of the elder guardian
+	 * <li>The speed value has no influence on this particle effect
+	 * <li>The offset values have no influence on this particle effect
+	 * </ul>
+	 */
+	MOB_APPEARANCE("mobappearance", 41, 8),
+
+	DRAGON_BREATH("dragonbreath", 42, 9),
+	
+	END_ROD("endrod", 43, 9),
+	
+	DAMAGE_INDICATOR("damageindicator", 44, 9),
+	
+	SWEEP_ATTACK("sweepattack", 45, 9);
+	
+	private static final Map<String, ParticleEffect> NAME_MAP = new HashMap<String, ParticleEffect>();
+	private static final Map<Integer, ParticleEffect> ID_MAP = new HashMap<Integer, ParticleEffect>();
+	private final String name;
+	private final int id;
+	private final int requiredVersion;
+	private final List<ParticleProperty> properties;
+
+	// Initialize map for quick name and id lookup
+	static {
+		for (ParticleEffect effect : values()) {
+			NAME_MAP.put(effect.name, effect);
+			ID_MAP.put(effect.id, effect);
+		}
+	}
+
+	/**
+	 * Construct a new particle effect
+	 * 
+	 * @param name Name of this particle effect
+	 * @param id Id of this particle effect
+	 * @param requiredVersion Version which is required (1.x)
+	 * @param properties Properties of this particle effect
+	 */
+	private ParticleEffect(String name, int id, int requiredVersion, ParticleProperty... properties) {
+		this.name = name;
+		this.id = id;
+		this.requiredVersion = requiredVersion;
+		this.properties = Arrays.asList(properties);
+	}
+
+	/**
+	 * Returns the name of this particle effect
+	 * 
+	 * @return The name
+	 */
+	public String getName() {
+		return name;
+	}
+
+	/**
+	 * Returns the id of this particle effect
+	 * 
+	 * @return The id
+	 */
+	public int getId() {
+		return id;
+	}
+
+	/**
+	 * Returns the required version for this particle effect (1.x)
+	 * 
+	 * @return The required version
+	 */
+	public int getRequiredVersion() {
+		return requiredVersion;
+	}
+
+	/**
+	 * Determine if this particle effect has a specific property
+	 * 
+	 * @return Whether it has the property or not
+	 */
+	public boolean hasProperty(ParticleProperty property) {
+		return properties.contains(property);
+	}
+	
+	/**
+	 * Returns the particle effect with the given name
+	 * 
+	 * @param name Name of the particle effect
+	 * @return The particle effect
+	 */
+	public static ParticleEffect fromName(String name) {
+		for (Entry<String, ParticleEffect> entry : NAME_MAP.entrySet()) {
+			if (!entry.getKey().equalsIgnoreCase(name)) {
+				continue;
+			}
+			return entry.getValue();
+		}
+		return null;
+	}
+
+	/**
+	 * Returns the particle effect with the given id
+	 * 
+	 * @param id Id of the particle effect
+	 * @return The particle effect
+	 */
+	public static ParticleEffect fromId(int id) {
+		for (Entry<Integer, ParticleEffect> entry : ID_MAP.entrySet()) {
+			if (entry.getKey() != id) {
+				continue;
+			}
+			return entry.getValue();
+		}
+		return null;
+	}
+	/**
+	 * Determine if the data type for a particle effect is correct
+	 * 
+	 * @param effect Particle effect
+	 * @param data Particle data
+	 * @return Whether the data type is correct or not
+	 */
+	private static boolean isDataCorrect(ParticleEffect effect, ParticleData data) {
+		return ((effect == BLOCK_CRACK || effect == BLOCK_DUST) && data instanceof BlockData) || (effect == ITEM_CRACK && data instanceof ItemData);
+	}
+
+	/**
+	 * Determine if the color type for a particle effect is correct
+	 * 
+	 * @param effect Particle effect
+	 * @param color Particle color
+	 * @return Whether the color type is correct or not
+	 */
+	private static boolean isColorCorrect(ParticleEffect effect, ParticleColor color) {
+		return ((effect == SPELL_MOB || effect == SPELL_MOB_AMBIENT || effect == REDSTONE) && color instanceof OrdinaryColor) || (effect == NOTE && color instanceof NoteColor);
+	}
+
+	/**
+	 * Displays a particle effect which is only visible for the specified players
+	 * 
+	 * @param offsetX Maximum distance particles can fly away from the center on the x-axis
+	 * @param offsetY Maximum distance particles can fly away from the center on the y-axis
+	 * @param offsetZ Maximum distance particles can fly away from the center on the z-axis
+	 * @param speed Display speed of the particles
+	 * @param amount Amount of particles
+	 * @param center Center location of the effect
+	 * @param players Receivers of the effect
+	 * @throws ParticleVersionException If the particle effect is not supported by the server version
+	 * @throws ParticleDataException If the particle effect requires additional data
+	 * @throws IllegalArgumentException If the particle effect requires water and none is at the center location
+	 * @see ParticlePacket
+	 * @see ParticlePacket#sendTo(Location, List)
+	 */
+	public void display(float offsetX, float offsetY, float offsetZ, float speed, int amount, Location center, List<Player> players) throws  ParticleDataException, IllegalArgumentException {
+		if (hasProperty(ParticleProperty.REQUIRES_DATA)) {
+			throw new ParticleDataException("This particle effect requires additional data");
+		}
+		new ParticlePacket(this, offsetX, offsetY, offsetZ, speed, amount, true, null).sendTo(center, players);
+	}
+
+	/**
+	 * Displays a particle effect which is only visible for the specified players
+	 * 
+	 * @param offsetX Maximum distance particles can fly away from the center on the x-axis
+	 * @param offsetY Maximum distance particles can fly away from the center on the y-axis
+	 * @param offsetZ Maximum distance particles can fly away from the center on the z-axis
+	 * @param speed Display speed of the particles
+	 * @param amount Amount of particles
+	 * @param center Center location of the effect
+	 * @param players Receivers of the effect
+	 * @throws ParticleVersionException If the particle effect is not supported by the server version
+	 * @throws ParticleDataException If the particle effect requires additional data
+	 * @throws IllegalArgumentException If the particle effect requires water and none is at the center location
+	 * @see #display(float, float, float, float, int, Location, List)
+	 */
+	public void display(float offsetX, float offsetY, float offsetZ, float speed, int amount, Location center, Player... players) throws  ParticleDataException, IllegalArgumentException {
+		display(offsetX, offsetY, offsetZ, speed, amount, center, Arrays.asList(players));
+	}
+
+	/**
+	 * Displays a single particle which flies into a determined direction and is only visible for the specified players
+	 * 
+	 * @param direction Direction of the particle
+	 * @param speed Display speed of the particle
+	 * @param center Center location of the effect
+	 * @param players Receivers of the effect
+	 * @throws ParticleVersionException If the particle effect is not supported by the server version
+	 * @throws ParticleDataException If the particle effect requires additional data
+	 * @throws IllegalArgumentException If the particle effect is not directional or if it requires water and none is at the center location
+	 * @see ParticlePacket#ParticlePacket(ParticleEffect, Vector, float, boolean, ParticleData)
+	 * @see ParticlePacket#sendTo(Location, List)
+	 */
+	public void display(Vector direction, float speed, Location center, List<Player> players) throws  ParticleDataException, IllegalArgumentException {
+		if (hasProperty(ParticleProperty.REQUIRES_DATA)) {
+			throw new ParticleDataException("This particle effect requires additional data");
+		}
+		if (!hasProperty(ParticleProperty.DIRECTIONAL)) {
+			throw new IllegalArgumentException("This particle effect is not directional");
+		}
+		new ParticlePacket(this, direction, speed, true, null).sendTo(center, players);
+	}
+
+	/**
+	 * Displays a single particle which flies into a determined direction and is only visible for the specified players
+	 * 
+	 * @param direction Direction of the particle
+	 * @param speed Display speed of the particle
+	 * @param center Center location of the effect
+	 * @param players Receivers of the effect
+	 * @throws ParticleVersionException If the particle effect is not supported by the server version
+	 * @throws ParticleDataException If the particle effect requires additional data
+	 * @throws IllegalArgumentException If the particle effect is not directional or if it requires water and none is at the center location
+	 * @see #display(Vector, float, Location, List)
+	 */
+	public void display(Vector direction, float speed, Location center, Player... players) throws  ParticleDataException, IllegalArgumentException {
+		display(direction, speed, center, Arrays.asList(players));
+	}
+	/**
+	 * Displays a single particle which is colored and only visible for the specified players
+	 * 
+	 * @param color Color of the particle
+	 * @param center Center location of the effect
+	 * @param players Receivers of the effect
+	 * @throws ParticleVersionException If the particle effect is not supported by the server version
+	 * @throws ParticleColorException If the particle effect is not colorable or the color type is incorrect
+	 * @see ParticlePacket#ParticlePacket(ParticleEffect, ParticleColor, boolean)
+	 * @see ParticlePacket#sendTo(Location, List)
+	 */
+	public void display(ParticleColor color, Location center, List<Player> players) throws  ParticleColorException {
+		if (!hasProperty(ParticleProperty.COLORABLE)) {
+			throw new ParticleColorException("This particle effect is not colorable");
+		}
+		if (!isColorCorrect(this, color)) {
+			throw new ParticleColorException("The particle color type is incorrect");
+		}
+		new ParticlePacket(this, color, true).sendTo(center, players);
+	}
+
+	/**
+	 * Displays a single particle which is colored and only visible for the specified players
+	 * 
+	 * @param color Color of the particle
+	 * @param center Center location of the effect
+	 * @param players Receivers of the effect
+	 * @throws ParticleVersionException If the particle effect is not supported by the server version
+	 * @throws ParticleColorException If the particle effect is not colorable or the color type is incorrect
+	 * @see #display(ParticleColor, Location, List)
+	 */
+	public void display(ParticleColor color, Location center, Player... players) throws  ParticleColorException {
+		display(color, center, Arrays.asList(players));
+	}
+
+	/**
+	 * Displays a particle effect which requires additional data and is only visible for the specified players
+	 * 
+	 * @param data Data of the effect
+	 * @param offsetX Maximum distance particles can fly away from the center on the x-axis
+	 * @param offsetY Maximum distance particles can fly away from the center on the y-axis
+	 * @param offsetZ Maximum distance particles can fly away from the center on the z-axis
+	 * @param speed Display speed of the particles
+	 * @param amount Amount of particles
+	 * @param center Center location of the effect
+	 * @param players Receivers of the effect
+	 * @throws ParticleVersionException If the particle effect is not supported by the server version
+	 * @throws ParticleDataException If the particle effect does not require additional data or if the data type is incorrect
+	 * @see ParticlePacket
+	 * @see ParticlePacket#sendTo(Location, List)
+	 */
+	public void display(ParticleData data, float offsetX, float offsetY, float offsetZ, float speed, int amount, Location center, List<Player> players) throws  ParticleDataException {
+		if (!hasProperty(ParticleProperty.REQUIRES_DATA)) {
+			throw new ParticleDataException("This particle effect does not require additional data");
+		}
+		if (!isDataCorrect(this, data)) {
+			throw new ParticleDataException("The particle data type is incorrect");
+		}
+		new ParticlePacket(this, offsetX, offsetY, offsetZ, speed, amount, true, data).sendTo(center, players);
+	}
+
+	/**
+	 * Displays a particle effect which requires additional data and is only visible for the specified players
+	 * 
+	 * @param data Data of the effect
+	 * @param offsetX Maximum distance particles can fly away from the center on the x-axis
+	 * @param offsetY Maximum distance particles can fly away from the center on the y-axis
+	 * @param offsetZ Maximum distance particles can fly away from the center on the z-axis
+	 * @param speed Display speed of the particles
+	 * @param amount Amount of particles
+	 * @param center Center location of the effect
+	 * @param players Receivers of the effect
+	 * @throws ParticleVersionException If the particle effect is not supported by the server version
+	 * @throws ParticleDataException If the particle effect does not require additional data or if the data type is incorrect
+	 * @see #display(ParticleData, float, float, float, float, int, Location, List)
+	 */
+	public void display(ParticleData data, float offsetX, float offsetY, float offsetZ, float speed, int amount, Location center, Player... players) throws  ParticleDataException {
+		display(data, offsetX, offsetY, offsetZ, speed, amount, center, Arrays.asList(players));
+	}
+
+	/**
+	 * Displays a single particle which requires additional data that flies into a determined direction and is only visible for the specified players
+	 * 
+	 * @param data Data of the effect
+	 * @param direction Direction of the particle
+	 * @param speed Display speed of the particles
+	 * @param center Center location of the effect
+	 * @param players Receivers of the effect
+	 * @throws ParticleVersionException If the particle effect is not supported by the server version
+	 * @throws ParticleDataException If the particle effect does not require additional data or if the data type is incorrect
+	 * @see ParticlePacket
+	 * @see ParticlePacket#sendTo(Location, List)
+	 */
+	public void display(ParticleData data, Vector direction, float speed, Location center, List<Player> players) throws  ParticleDataException {
+		if (!hasProperty(ParticleProperty.REQUIRES_DATA)) {
+			throw new ParticleDataException("This particle effect does not require additional data");
+		}
+		if (!isDataCorrect(this, data)) {
+			throw new ParticleDataException("The particle data type is incorrect");
+		}
+		new ParticlePacket(this, direction, speed, true, data).sendTo(center, players);
+	}
+
+	/**
+	 * Displays a single particle which requires additional data that flies into a determined direction and is only visible for the specified players
+	 * 
+	 * @param data Data of the effect
+	 * @param direction Direction of the particle
+	 * @param speed Display speed of the particles
+	 * @param center Center location of the effect
+	 * @param players Receivers of the effect
+	 * @throws ParticleVersionException If the particle effect is not supported by the server version
+	 * @throws ParticleDataException If the particle effect does not require additional data or if the data type is incorrect
+	 * @see #display(ParticleData, Vector, float, Location, List)
+	 */
+	public void display(ParticleData data, Vector direction, float speed, Location center, Player... players) throws  ParticleDataException {
+		display(data, direction, speed, center, Arrays.asList(players));
+	}
+
+	/**
+	 * Represents the property of a particle effect
+	 * <p>
+	 * This class is part of the <b>ParticleEffect Library</b> and follows the same usage conditions
+	 * 
+	 * @author DarkBlade12
+	 * @since 1.7
+	 */
+	public static enum ParticleProperty {
+		/**
+		 * The particle effect requires water to be displayed
+		 */
+		REQUIRES_WATER,
+		/**
+		 * The particle effect requires block or item data to be displayed
+		 */
+		REQUIRES_DATA,
+		/**
+		 * The particle effect uses the offsets as direction values
+		 */
+		DIRECTIONAL,
+		/**
+		 * The particle effect uses the offsets as color values
+		 */
+		COLORABLE;
+	}
+
+	/**
+	 * Represents the particle data for effects like {@link ParticleEffect#ITEM_CRACK}, {@link ParticleEffect#BLOCK_CRACK} and {@link ParticleEffect#BLOCK_DUST}
+	 * <p>
+	 * This class is part of the <b>ParticleEffect Library</b> and follows the same usage conditions
+	 * 
+	 * @author DarkBlade12
+	 * @since 1.6
+	 */
+	public static abstract class ParticleData {
+		private final Material material;
+		private final byte data;
+		private final int[] packetData;
+
+		/**
+		 * Construct a new particle data
+		 * 
+		 * @param material Material of the item/block
+		 * @param data Data value of the item/block
+		 */
+		@SuppressWarnings("deprecation")
+		public ParticleData(Material material, byte data) {
+			this.material = material;
+			this.data = data;
+			this.packetData = new int[] { material.getId(), data };
+		}
+
+		/**
+		 * Returns the material of this data
+		 * 
+		 * @return The material
+		 */
+		public Material getMaterial() {
+			return material;
+		}
+
+		/**
+		 * Returns the data value of this data
+		 * 
+		 * @return The data value
+		 */
+		public byte getData() {
+			return data;
+		}
+
+		/**
+		 * Returns the data as an int array for packet construction
+		 * 
+		 * @return The data for the packet
+		 */
+		public int[] getPacketData() {
+			return packetData;
+		}
+
+		/**
+		 * Returns the data as a string for pre 1.8 versions
+		 * 
+		 * @return The data string for the packet
+		 */
+		public String getPacketDataString() {
+			return "_" + packetData[0] + "_" + packetData[1];
+		}
+	}
+
+	/**
+	 * Represents the item data for the {@link ParticleEffect#ITEM_CRACK} effect
+	 * <p>
+	 * This class is part of the <b>ParticleEffect Library</b> and follows the same usage conditions
+	 * 
+	 * @author DarkBlade12
+	 * @since 1.6
+	 */
+	public static class ItemData extends ParticleData {
+		/**
+		 * Construct a new item data
+		 * 
+		 * @param material Material of the item
+		 * @param data Data value of the item
+		 * @see ParticleData#ParticleData(Material, byte)
+		 */
+		public ItemData(Material material, byte data) {
+			super(material, data);
+		}
+	}
+
+	/**
+	 * Represents the block data for the {@link ParticleEffect#BLOCK_CRACK} and {@link ParticleEffect#BLOCK_DUST} effects
+	 * <p>
+	 * This class is part of the <b>ParticleEffect Library</b> and follows the same usage conditions
+	 * 
+	 * @author DarkBlade12
+	 * @since 1.6
+	 */
+	public static class BlockData extends ParticleData {
+		/**
+		 * Construct a new block data
+		 * 
+		 * @param material Material of the block
+		 * @param data Data value of the block
+		 * @throws IllegalArgumentException If the material is not a block
+		 * @see ParticleData#ParticleData(Material, byte)
+		 */
+		public BlockData(Material material, byte data) throws IllegalArgumentException {
+			super(material, data);
+			if (!material.isBlock()) {
+				throw new IllegalArgumentException("The material is not a block");
+			}
+		}
+	}
+
+	/**
+	 * Represents the color for effects like {@link ParticleEffect#SPELL_MOB}, {@link ParticleEffect#SPELL_MOB_AMBIENT}, {@link ParticleEffect#REDSTONE} and {@link ParticleEffect#NOTE}
+	 * <p>
+	 * This class is part of the <b>ParticleEffect Library</b> and follows the same usage conditions
+	 * 
+	 * @author DarkBlade12
+	 * @since 1.7
+	 */
+	public static abstract class ParticleColor {
+		/**
+		 * Returns the value for the offsetX field
+		 * 
+		 * @return The offsetX value
+		 */
+		public abstract float getValueX();
+
+		/**
+		 * Returns the value for the offsetY field
+		 * 
+		 * @return The offsetY value
+		 */
+		public abstract float getValueY();
+
+		/**
+		 * Returns the value for the offsetZ field
+		 * 
+		 * @return The offsetZ value
+		 */
+		public abstract float getValueZ();
+	}
+
+	/**
+	 * Represents the color for effects like {@link ParticleEffect#SPELL_MOB}, {@link ParticleEffect#SPELL_MOB_AMBIENT} and {@link ParticleEffect#NOTE}
+	 * <p>
+	 * This class is part of the <b>ParticleEffect Library</b> and follows the same usage conditions
+	 * 
+	 * @author DarkBlade12
+	 * @since 1.7
+	 */
+	public static class OrdinaryColor extends ParticleColor {
+		private final int red;
+		private final int green;
+		private final int blue;
+
+		/**
+		 * Construct a new ordinary color
+		 * 
+		 * @param red Red value of the RGB format
+		 * @param green Green value of the RGB format
+		 * @param blue Blue value of the RGB format
+		 * @throws IllegalArgumentException If one of the values is lower than 0 or higher than 255
+		 */
+		public OrdinaryColor(int red, int green, int blue) {
+			if (red < 0) {
+				throw new IllegalArgumentException("The red value is lower than 0");
+			}
+			if (red > 255) {
+				throw new IllegalArgumentException("The red value is higher than 255");
+			}
+			this.red = red;
+			if (green < 0) {
+				throw new IllegalArgumentException("The green value is lower than 0");
+			}
+			if (green > 255) {
+				throw new IllegalArgumentException("The green value is higher than 255");
+			}
+			this.green = green;
+			if (blue < 0) {
+				throw new IllegalArgumentException("The blue value is lower than 0");
+			}
+			if (blue > 255) {
+				throw new IllegalArgumentException("The blue value is higher than 255");
+			}
+			this.blue = blue;
+		}
+
+		/**
+		 * Construct a new ordinary color
+		 * 
+		 * @param color Bukkit color
+		 */
+		public OrdinaryColor(Color color) {
+			this(color.getRed(), color.getGreen(), color.getBlue());
+		}
+
+		/**
+		 * Returns the red value of the RGB format
+		 * 
+		 * @return The red value
+		 */
+		public int getRed() {
+			return red;
+		}
+
+		/**
+		 * Returns the green value of the RGB format
+		 * 
+		 * @return The green value
+		 */
+		public int getGreen() {
+			return green;
+		}
+
+		/**
+		 * Returns the blue value of the RGB format
+		 * 
+		 * @return The blue value
+		 */
+		public int getBlue() {
+			return blue;
+		}
+
+		/**
+		 * Returns the red value divided by 255
+		 * 
+		 * @return The offsetX value
+		 */
+		@Override
+		public float getValueX() {
+			return (float) red / 255F;
+		}
+
+		/**
+		 * Returns the green value divided by 255
+		 * 
+		 * @return The offsetY value
+		 */
+		@Override
+		public float getValueY() {
+			return (float) green / 255F;
+		}
+
+		/**
+		 * Returns the blue value divided by 255
+		 * 
+		 * @return The offsetZ value
+		 */
+		@Override
+		public float getValueZ() {
+			return (float) blue / 255F;
+		}
+	}
+
+	/**
+	 * Represents the color for the {@link ParticleEffect#NOTE} effect
+	 * <p>
+	 * This class is part of the <b>ParticleEffect Library</b> and follows the same usage conditions
+	 * 
+	 * @author DarkBlade12
+	 * @since 1.7
+	 */
+	public static class NoteColor extends ParticleColor {
+		private final int note;
+
+		/**
+		 * Construct a new note color
+		 * 
+		 * @param note Note id which determines color
+		 * @throws IllegalArgumentException If the note value is lower than 0 or higher than 24
+		 */
+		public NoteColor(int note) throws IllegalArgumentException {
+			if (note < 0) {
+				throw new IllegalArgumentException("The note value is lower than 0");
+			}
+			if (note > 24) {
+				throw new IllegalArgumentException("The note value is higher than 24");
+			}
+			this.note = note;
+		}
+
+		/**
+		 * Returns the note value divided by 24
+		 * 
+		 * @return The offsetX value
+		 */
+		@Override
+		public float getValueX() {
+			return (float) note / 24F;
+		}
+
+		/**
+		 * Returns zero because the offsetY value is unused
+		 * 
+		 * @return zero
+		 */
+		@Override
+		public float getValueY() {
+			return 0;
+		}
+
+		/**
+		 * Returns zero because the offsetZ value is unused
+		 * 
+		 * @return zero
+		 */
+		@Override
+		public float getValueZ() {
+			return 0;
+		}
+
+	}
+
+	/**
+	 * Represents a runtime exception that is thrown either if the displayed particle effect requires data and has none or vice-versa or if the data type is incorrect
+	 * <p>
+	 * This class is part of the <b>ParticleEffect Library</b> and follows the same usage conditions
+	 * 
+	 * @author DarkBlade12
+	 * @since 1.6
+	 */
+	private static final class ParticleDataException extends RuntimeException {
+		private static final long serialVersionUID = 3203085387160737484L;
+
+		/**
+		 * Construct a new particle data exception
+		 * 
+		 * @param message Message that will be logged
+		 */
+		public ParticleDataException(String message) {
+			super(message);
+		}
+	}
+
+	/**
+	 * Represents a runtime exception that is thrown either if the displayed particle effect is not colorable or if the particle color type is incorrect
+	 * <p>
+	 * This class is part of the <b>ParticleEffect Library</b> and follows the same usage conditions
+	 * 
+	 * @author DarkBlade12
+	 * @since 1.7
+	 */
+	private static final class ParticleColorException extends RuntimeException {
+		private static final long serialVersionUID = 3203085387160737484L;
+
+		/**
+		 * Construct a new particle color exception
+		 * 
+		 * @param message Message that will be logged
+		 */
+		public ParticleColorException(String message) {
+			super(message);
+		}
+	}
+
+	/**
+	 * Represents a particle effect packet with all attributes which is used for sending packets to the players
+	 * <p>
+	 * This class is part of the <b>ParticleEffect Library</b> and follows the same usage conditions
+	 * 
+	 * @author DarkBlade12
+	 * @since 1.5
+	 */
+	public static final class ParticlePacket {
+		private final ParticleEffect effect;
+		private float offsetX;
+		private final float offsetY;
+		private final float offsetZ;
+		private final float speed;
+		private final int amount;
+		private final boolean longDistance;
+		private final ParticleData data;
+		private PacketPlayOutWorldParticles packet;
+
+		/**
+		 * Construct a new particle packet
+		 * 
+		 * @param effect Particle effect
+		 * @param offsetX Maximum distance particles can fly away from the center on the x-axis
+		 * @param offsetY Maximum distance particles can fly away from the center on the y-axis
+		 * @param offsetZ Maximum distance particles can fly away from the center on the z-axis
+		 * @param speed Display speed of the particles
+		 * @param amount Amount of particles
+		 * @param longDistance Indicates whether the maximum distance is increased from 256 to 65536
+		 * @param data Data of the effect
+		 * @throws IllegalArgumentException If the speed or amount is lower than 0
+		 * @see #initialize()
+		 */
+		public ParticlePacket(ParticleEffect effect, float offsetX, float offsetY, float offsetZ, float speed, int amount, boolean longDistance, ParticleData data) throws IllegalArgumentException {
+			if (speed < 0) {
+				throw new IllegalArgumentException("The speed is lower than 0");
+			}
+			if (amount < 0) {
+				throw new IllegalArgumentException("The amount is lower than 0");
+			}
+			this.effect = effect;
+			this.offsetX = offsetX;
+			this.offsetY = offsetY;
+			this.offsetZ = offsetZ;
+			this.speed = speed;
+			this.amount = amount;
+			this.longDistance = longDistance;
+			this.data = data;
+		}
+
+		/**
+		 * Construct a new particle packet of a single particle flying into a determined direction
+		 * 
+		 * @param effect Particle effect
+		 * @param direction Direction of the particle
+		 * @param speed Display speed of the particle
+		 * @param longDistance Indicates whether the maximum distance is increased from 256 to 65536
+		 * @param data Data of the effect
+		 * @throws IllegalArgumentException If the speed is lower than 0
+		 * @see #ParticleEffect(ParticleEffect, float, float, float, float, int, boolean, ParticleData)
+		 */
+		public ParticlePacket(ParticleEffect effect, Vector direction, float speed, boolean longDistance, ParticleData data) throws IllegalArgumentException {
+			this(effect, (float) direction.getX(), (float) direction.getY(), (float) direction.getZ(), speed, 0, longDistance, data);
+		}
+
+		/**
+		 * Construct a new particle packet of a single colored particle
+		 * 
+		 * @param effect Particle effect
+		 * @param color Color of the particle
+		 * @param longDistance Indicates whether the maximum distance is increased from 256 to 65536
+		 * @see #ParticleEffect(ParticleEffect, float, float, float, float, int, boolean, ParticleData)
+		 */
+		public ParticlePacket(ParticleEffect effect, ParticleColor color, boolean longDistance) {
+			this(effect, color.getValueX(), color.getValueY(), color.getValueZ(), 1, 0, longDistance, null);
+			if (effect == ParticleEffect.REDSTONE && color instanceof OrdinaryColor && ((OrdinaryColor) color).getRed() == 0) {
+				offsetX = (float) 1 / 255F;
+			}
+		}
+
+		/**
+		 * Initializes {@link #packet} with all set values
+		 * 
+		 * @param center Center location of the effect
+		 * @throws PacketInstantiationException If instantion fails due to an unknown error
+		 */
+		private void initializePacket(Location center) {
+			if (packet != null) {
+				return;
+			}
+			packet = new PacketPlayOutWorldParticles(this.effect, center, new Vector(offsetX, offsetY, offsetZ), this.speed, this.amount,this.longDistance , data==null?new int[0]:effect == ParticleEffect.ITEM_CRACK ? data.getPacketData() : new int[] { data.getPacketData()[0] | (data.getPacketData()[1] << 12)});
+		}
+
+		/**
+		 * Sends the packet to a single player and caches it
+		 * 
+		 * @param center Center location of the effect
+		 * @param player Receiver of the packet
+		 * @throws PacketInstantiationException If instantion fails due to an unknown error
+		 * @throws PacketSendingException If sending fails due to an unknown error
+		 * @see #initializePacket(Location)
+		 */
+		public void sendTo(Location center, Player player) {
+			initializePacket(center);
+			player.sendPacket(packet);
+		}
+
+		/**
+		 * Sends the packet to all players in the list
+		 * 
+		 * @param center Center location of the effect
+		 * @param players Receivers of the packet
+		 * @throws IllegalArgumentException If the player list is empty
+		 * @see #sendTo(Location center, Player player)
+		 */
+		public void sendTo(Location center, List<Player> players) throws IllegalArgumentException {
+			if (players.isEmpty()) {
+				throw new IllegalArgumentException("The player list is empty");
+			}
+			for (Player player : players) {
+				sendTo(center, player);
+			}
+		}
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/api/position/BlockPosition.java b/src/main/java/dev/wolveringer/api/position/BlockPosition.java
new file mode 100644
index 0000000..3426246
--- /dev/null
+++ b/src/main/java/dev/wolveringer/api/position/BlockPosition.java
@@ -0,0 +1,10 @@
+package dev.wolveringer.api.position;
+
+public class BlockPosition extends Potision<Integer> {
+	public BlockPosition(int x, int y, int z) {
+		super(x, y, z);
+	}
+	public long toLong(){
+		return (x & 67108863L) << 38L | (y & 4095L) << 26L | (z & 67108863L) << 0;
+	}
+}
diff --git a/src/main/java/dev/wolveringer/api/position/Location.java b/src/main/java/dev/wolveringer/api/position/Location.java
new file mode 100644
index 0000000..09cc9c1
--- /dev/null
+++ b/src/main/java/dev/wolveringer/api/position/Location.java
@@ -0,0 +1,492 @@
+package dev.wolveringer.api.position;
+
+import dev.wolveringer.BungeeUtil.NumberConversions;
+
+/**
+ * Represents a 3-dimensional position in a world
+ */
+public class Location extends Potision<Double> implements Cloneable {
+	/**
+	 * Safely converts a double (location coordinate) to an int (block
+	 * coordinate)
+	 *
+	 * @param loc
+	 *            Precise coordinate
+	 * @return Block coordinate
+	 */
+	public static int locToBlock(double loc) {
+		return NumberConversions.floor(loc);
+	}
+
+	private float pitch;
+	private float yaw;
+
+	/**
+	 * Constructs a new Location with the given coordinates
+	 *
+	 * @param world
+	 *            The world in which this location resides
+	 * @param x
+	 *            The x-coordinate of this new location
+	 * @param y
+	 *            The y-coordinate of this new location
+	 * @param z
+	 *            The z-coordinate of this new location
+	 */
+	public Location(final double x, final double y, final double z) {
+		this(x, y, z, 0, 0);
+	}
+
+	/**
+	 * Constructs a new Location with the given coordinates and direction
+	 *
+	 * @param world
+	 *            The world in which this location resides
+	 * @param x
+	 *            The x-coordinate of this new location
+	 * @param y
+	 *            The y-coordinate of this new location
+	 * @param z
+	 *            The z-coordinate of this new location
+	 * @param yaw
+	 *            The absolute rotation on the x-plane, in degrees
+	 * @param pitch
+	 *            The absolute rotation on the y-plane, in degrees
+	 */
+	public Location(final double x, final double y, final double z, final float yaw, final float pitch) {
+		super(x,y,z);
+		this.pitch = pitch;
+		this.yaw = yaw;
+	}
+
+	/**
+	 * Adds the location by another. Not world-aware.
+	 *
+	 * @see Vector
+	 * @param x
+	 *            X coordinate
+	 * @param y
+	 *            Y coordinate
+	 * @param z
+	 *            Z coordinate
+	 * @return the same location
+	 */
+	public Location add(double x, double y, double z) {
+		this.x += x;
+		this.y += y;
+		this.z += z;
+		return this;
+	}
+
+	/**
+	 * Adds the location by another.
+	 *
+	 * @see Vector
+	 * @param vec
+	 *            The other location
+	 * @return the same location
+	 * @throws IllegalArgumentException
+	 *             for differing worlds
+	 */
+	public Location add(Location vec) {
+		if(vec == null){
+			throw new IllegalArgumentException("Cannot add Locations of differing worlds");
+		}
+
+		x += vec.x;
+		y += vec.y;
+		z += vec.z;
+		return this;
+	}
+
+	/**
+	 * Adds the location by a vector.
+	 *
+	 * @see Vector
+	 * @param vec
+	 *            Vector to use
+	 * @return the same location
+	 */
+	public Location add(Vector vec) {
+		this.x += vec.getX();
+		this.y += vec.getY();
+		this.z += vec.getZ();
+		return this;
+	}
+
+	@Override
+	public Location clone() {
+		try{
+			return (Location) super.clone();
+		}catch (CloneNotSupportedException e){
+			throw new Error(e);
+		}
+	}
+
+	/**
+	 * Get the distance between this location and another. The value of this
+	 * method is not cached and uses a costly square-root function, so do not
+	 * repeatedly call this method to get the location's magnitude. NaN will
+	 * be returned if the inner result of the sqrt() function overflows, which
+	 * will be caused if the distance is too long.
+	 *
+	 * @see Vector
+	 * @param o
+	 *            The other location
+	 * @return the distance
+	**/
+	public double distance(Location o) {
+		return Math.sqrt(distanceSquared(o));
+	}
+
+	/**
+	 * Get the squared distance between this location and another.
+	 *
+	 * @see Vector
+	 * @param o
+	 *            The other location
+	 * @return the distance
+	 * @throws IllegalArgumentException
+	 *             for differing worlds
+	 */
+	public double distanceSquared(Location o) {
+		if(o == null){
+			throw new IllegalArgumentException("Cannot measure distance to a null location");
+		}
+
+		return NumberConversions.square(x - o.x) + NumberConversions.square(y - o.y) + NumberConversions.square(z - o.z);
+	}
+
+	@Override
+	public boolean equals(Object obj) {
+		if(obj == null){
+			return false;
+		}
+		if(getClass() != obj.getClass()){
+			return false;
+		}
+		final Location other = (Location) obj;
+		if(Double.doubleToLongBits(this.x) != Double.doubleToLongBits(other.x)){
+			return false;
+		}
+		if(Double.doubleToLongBits(this.y) != Double.doubleToLongBits(other.y)){
+			return false;
+		}
+		if(Double.doubleToLongBits(this.z) != Double.doubleToLongBits(other.z)){
+			return false;
+		}
+		if(Float.floatToIntBits(this.pitch) != Float.floatToIntBits(other.pitch)){
+			return false;
+		}
+		if(Float.floatToIntBits(this.yaw) != Float.floatToIntBits(other.yaw)){
+			return false;
+		}
+		return true;
+	}
+
+	/**
+	 * Gets the floored value of the X component, indicating the block that
+	 * this location is contained with.
+	 *
+	 * @return block X
+	 */
+	public int getBlockX() {
+		return locToBlock(x);
+	}
+
+	/**
+	 * Gets the floored value of the Y component, indicating the block that
+	 * this location is contained with.
+	 *
+	 * @return block y
+	 */
+	public int getBlockY() {
+		return locToBlock(y);
+	}
+
+	/**
+	 * Gets the floored value of the Z component, indicating the block that
+	 * this location is contained with.
+	 *
+	 * @return block z
+	 */
+	public int getBlockZ() {
+		return locToBlock(z);
+	}
+
+	/**
+	 * Gets a unit-vector pointing in the direction that this Location is
+	 * facing.
+	 *
+	 * @return a vector pointing the direction of this location's
+	 *         {@link #getPitch() pitch} and {@link #getYaw() yaw}
+	 */
+	public Vector getDirection() {
+		Vector vector = new Vector();
+
+		double rotX = this.getYaw();
+		double rotY = this.getPitch();
+
+		vector.setY(-Math.sin(Math.toRadians(rotY)));
+
+		double xz = Math.cos(Math.toRadians(rotY));
+
+		vector.setX(-xz * Math.sin(Math.toRadians(rotX)));
+		vector.setZ(xz * Math.cos(Math.toRadians(rotX)));
+
+		return vector;
+	}
+
+	/**
+	 * Gets the pitch of this location, measured in degrees.
+	 * <ul>
+	 * <li>A pitch of 0 represents level forward facing.
+	 * <li>A pitch of 90 represents downward facing, or negative y direction.
+	 * <li>A pitch of -90 represents upward facing, or positive y direction.
+	 * <ul>
+	 * Increasing pitch values the equivalent of looking down.
+	 *
+	 * @return the incline's pitch
+	 */
+	public float getPitch() {
+		return pitch;
+	}
+
+	/**
+	 * Gets the yaw of this location, measured in degrees.
+	 * <ul>
+	 * <li>A yaw of 0 or 360 represents the positive z direction.
+	 * <li>A yaw of 180 represents the negative z direction.
+	 * <li>A yaw of 90 represents the negative x direction.
+	 * <li>A yaw of 270 represents the positive x direction.
+	 * </ul>
+	 * Increasing yaw values are the equivalent of turning to your
+	 * right-facing, increasing the scale of the next respective axis, and
+	 * decreasing the scale of the previous axis.
+	 *
+	 * @return the rotation's yaw
+	 */
+	public float getYaw() {
+		return yaw;
+	}
+
+	/**
+	 * Gets the magnitude of the location, defined as sqrt(x^2+y^2+z^2). The
+	 * value of this method is not cached and uses a costly square-root
+	 * function, so do not repeatedly call this method to get the location's
+	 * magnitude. NaN will be returned if the inner result of the sqrt()
+	 * function overflows, which will be caused if the length is too long. Not
+	 * world-aware and orientation independent.
+	 *
+	 * @see Vector
+	 * @return the magnitude
+	 */
+	public double length() {
+		return Math.sqrt(NumberConversions.square(x) + NumberConversions.square(y) + NumberConversions.square(z));
+	}
+
+	/**
+	 * Gets the magnitude of the location squared. Not world-aware and
+	 * orientation independent.
+	 *
+	 * @see Vector
+	 * @return the magnitude
+	 */
+	public double lengthSquared() {
+		return NumberConversions.square(x) + NumberConversions.square(y) + NumberConversions.square(z);
+	}
+
+	/**
+	 * Performs scalar multiplication, multiplying all components with a
+	 * scalar. Not world-aware.
+	 *
+	 * @param m
+	 *            The factor
+	 * @see Vector
+	 * @return the same location
+	 */
+	public Location multiply(double m) {
+		x *= m;
+		y *= m;
+		z *= m;
+		return this;
+	}
+
+	/**
+	 * @param m
+	 *            The factor
+	 * @see Vector
+	 * @return the same location
+	 */
+	public Location dividide(double m) {
+		x /= m;
+		y /= m;
+		z /= m;
+		return this;
+	}
+	
+	/**
+	 * Sets the {@link #getYaw() yaw} and {@link #getPitch() pitch} to point
+	 * in the direction of the vector.
+	 */
+	public Location setDirection(Vector vector) {
+		/*
+		 * Sin = Opp / Hyp
+		 * Cos = Adj / Hyp
+		 * Tan = Opp / Adj
+		 * x = -Opp
+		 * z = Adj
+		 */
+		final double _2PI = 2 * Math.PI;
+		final double x = vector.getX();
+		final double z = vector.getZ();
+
+		if(x == 0 && z == 0){
+			pitch = vector.getY() > 0 ? -90 : 90;
+			return this;
+		}
+
+		double theta = Math.atan2(-x, z);
+		yaw = (float) Math.toDegrees((theta + _2PI) % _2PI);
+
+		double x2 = NumberConversions.square(x);
+		double z2 = NumberConversions.square(z);
+		double xz = Math.sqrt(x2 + z2);
+		pitch = (float) Math.toDegrees(Math.atan(-vector.getY() / xz));
+
+		return this;
+	}
+
+	/**
+	 * Sets the pitch of this location, measured in degrees.
+	 * <ul>
+	 * <li>A pitch of 0 represents level forward facing.
+	 * <li>A pitch of 90 represents downward facing, or negative y direction.
+	 * <li>A pitch of -90 represents upward facing, or positive y direction.
+	 * <ul>
+	 * Increasing pitch values the equivalent of looking down.
+	 *
+	 * @param pitch
+	 *            new incline's pitch
+	 */
+	public Location setPitch(float pitch) {
+		this.pitch = pitch;
+		return this;
+	}
+
+	/**
+	 * Sets the yaw of this location, measured in degrees.
+	 * <ul>
+	 * <li>A yaw of 0 or 360 represents the positive z direction.
+	 * <li>A yaw of 180 represents the negative z direction.
+	 * <li>A yaw of 90 represents the negative x direction.
+	 * <li>A yaw of 270 represents the positive x direction.
+	 * </ul>
+	 * Increasing yaw values are the equivalent of turning to your
+	 * right-facing, increasing the scale of the next respective axis, and
+	 * decreasing the scale of the previous axis.
+	 *
+	 * @param yaw
+	 *            new rotation's yaw
+	 */
+	public Location setYaw(float yaw) {
+		this.yaw = yaw;
+		return this;
+	}
+
+	/**
+	 * Subtracts the location by another. Not world-aware and
+	 * orientation independent.
+	 *
+	 * @see Vector
+	 * @param x
+	 *            X coordinate
+	 * @param y
+	 *            Y coordinate
+	 * @param z
+	 *            Z coordinate
+	 * @return the same location
+	 */
+	public Location subtract(double x, double y, double z) {
+		this.x -= x;
+		this.y -= y;
+		this.z -= z;
+		return this;
+	}
+
+	/**
+	 * Subtracts the location by another.
+	 *
+	 * @see Vector
+	 * @param vec
+	 *            The other location
+	 * @return the same location
+	 * @throws IllegalArgumentException
+	 *             for differing worlds
+	 */
+	public Location subtract(Location vec) {
+		if(vec == null){
+			throw new IllegalArgumentException("Cannot add Locations of differing worlds");
+		}
+
+		x -= vec.x;
+		y -= vec.y;
+		z -= vec.z;
+		return this;
+	}
+
+	/**
+	 * Subtracts the location by a vector.
+	 *
+	 * @see Vector
+	 * @param vec
+	 *            The vector to use
+	 * @return the same location
+	 */
+	public Location subtract(Vector vec) {
+		this.x -= vec.getX();
+		this.y -= vec.getY();
+		this.z -= vec.getZ();
+		return this;
+	}
+
+	@Override
+	public String toString() {
+		return "Location{x=" + x + ",y=" + y + ",z=" + z + ",pitch=" + pitch + ",yaw=" + yaw + '}';
+	}
+
+	/**
+	 * Constructs a new {@link Vector} based on this Location
+	 *
+	 * @return New Vector containing the coordinates represented by this
+	 *         Location
+	 */
+	public Vector toVector() {
+		return new Vector(x, y, z);
+	}
+
+	/**
+	 * Zero this location's components. Not world-aware.
+	 *
+	 * @see Vector
+	 * @return the same location
+	 */
+	public Location zero() {
+		x = 0D;
+		y = 0D;
+		z = 0D;
+		return this;
+	}
+	
+	@Override
+	public int hashCode() {
+		int hash = 3;
+
+		hash = 19 * hash + (int) (Double.doubleToLongBits(this.x) ^ Double.doubleToLongBits(this.x) >>> 32);
+		hash = 19 * hash + (int) (Double.doubleToLongBits(this.y) ^ Double.doubleToLongBits(this.y) >>> 32);
+		hash = 19 * hash + (int) (Double.doubleToLongBits(this.z) ^ Double.doubleToLongBits(this.z) >>> 32);
+		hash = 19 * hash + Float.floatToIntBits(this.pitch);
+		hash = 19 * hash + Float.floatToIntBits(this.yaw);
+		return hash;
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/api/position/Potision.java b/src/main/java/dev/wolveringer/api/position/Potision.java
new file mode 100644
index 0000000..725d1ee
--- /dev/null
+++ b/src/main/java/dev/wolveringer/api/position/Potision.java
@@ -0,0 +1,68 @@
+package dev.wolveringer.api.position;
+
+public class Potision<T> {
+	protected T x;
+	protected T y;
+	protected T z;
+
+	public Potision(T x, T y, T z) {
+		this.x = x;
+		this.y = y;
+		this.z = z;
+	}
+
+	public T getX() {
+		return x;
+	}
+
+	public void setX(T x) {
+		this.x = x;
+	}
+
+	public T getY() {
+		return y;
+	}
+
+	public void setY(T y) {
+		this.y = y;
+	}
+
+	public T getZ() {
+		return z;
+	}
+
+	public void setZ(T z) {
+		this.z = z;
+	}
+
+	@Override
+	public int hashCode() {
+		final int prime = 31;
+		int result = 1;
+		result = prime * result + ((x == null) ? 0 : x.hashCode());
+		result = prime * result + ((y == null) ? 0 : y.hashCode());
+		result = prime * result + ((z == null) ? 0 : z.hashCode());
+		return result;
+	}
+
+	@Override
+	public boolean equals(Object obj) {
+		if (this == obj) return true;
+		if (obj == null) return false;
+		if (getClass() != obj.getClass()) return false;
+		Potision other = (Potision) obj;
+		if (x == null) {
+			if (other.x != null) return false;
+		}
+		else if (!x.equals(other.x)) return false;
+		if (y == null) {
+			if (other.y != null) return false;
+		}
+		else if (!y.equals(other.y)) return false;
+		if (z == null) {
+			if (other.z != null) return false;
+		}
+		else if (!z.equals(other.z)) return false;
+		return true;
+	}
+}
diff --git a/src/main/java/dev/wolveringer/api/position/Vector.java b/src/main/java/dev/wolveringer/api/position/Vector.java
new file mode 100644
index 0000000..792ce35
--- /dev/null
+++ b/src/main/java/dev/wolveringer/api/position/Vector.java
@@ -0,0 +1,690 @@
+package dev.wolveringer.api.position;
+
+import java.util.LinkedHashMap;
+import java.util.Map;
+import java.util.Random;
+
+import dev.wolveringer.BungeeUtil.NumberConversions;
+
+/**
+ * Represents a mutable vector. Because the components of Vectors are mutable,
+ * storing Vectors long term may be dangerous if passing code modifies the
+ * Vector later. If you want to keep around a Vector, it may be wise to call
+ * <code>clone()</code> in order to get a copy.
+ */
+
+public class Vector implements Cloneable {
+	/**
+	 * Threshold for fuzzy equals().
+	 */
+	private static final double epsilon = 0.000001;
+
+	private static Random random = new Random();
+
+	public static Vector deserialize(Map<String, Object> args) {
+		double x = 0;
+		double y = 0;
+		double z = 0;
+
+		if(args.containsKey("x")){
+			x = (Double) args.get("x");
+		}
+		if(args.containsKey("y")){
+			y = (Double) args.get("y");
+		}
+		if(args.containsKey("z")){
+			z = (Double) args.get("z");
+		}
+
+		return new Vector(x, y, z);
+	}
+
+	/**
+	 * Get the threshold used for equals().
+	 *
+	 * @return The epsilon.
+	 */
+	public static double getEpsilon() {
+		return epsilon;
+	}
+
+	/**
+	 * Gets the maximum components of two vectors.
+	 *
+	 * @param v1
+	 *            The first vector.
+	 * @param v2
+	 *            The second vector.
+	 * @return maximum
+	 */
+	public static Vector getMaximum(Vector v1, Vector v2) {
+		return new Vector(Math.max(v1.x, v2.x), Math.max(v1.y, v2.y), Math.max(v1.z, v2.z));
+	}
+
+	/**
+	 * Gets the minimum components of two vectors.
+	 *
+	 * @param v1
+	 *            The first vector.
+	 * @param v2
+	 *            The second vector.
+	 * @return minimum
+	 */
+	public static Vector getMinimum(Vector v1, Vector v2) {
+		return new Vector(Math.min(v1.x, v2.x), Math.min(v1.y, v2.y), Math.min(v1.z, v2.z));
+	}
+
+	/**
+	 * Gets a random vector with components having a random value between 0
+	 * and 1.
+	 *
+	 * @return A random vector.
+	 */
+	public static Vector getRandom() {
+		return new Vector(random.nextDouble(), random.nextDouble(), random.nextDouble());
+	}
+
+	protected double x;
+
+	protected double y;
+
+	protected double z;
+
+	/**
+	 * Construct the vector with all components as 0.
+	 */
+	public Vector() {
+		this.x = 0;
+		this.y = 0;
+		this.z = 0;
+	}
+
+	/**
+	 * Construct the vector with provided double components.
+	 *
+	 * @param x
+	 *            X component
+	 * @param y
+	 *            Y component
+	 * @param z
+	 *            Z component
+	 */
+	public Vector(double x, double y, double z) {
+		this.x = x;
+		this.y = y;
+		this.z = z;
+	}
+
+	/**
+	 * Construct the vector with provided float components.
+	 *
+	 * @param x
+	 *            X component
+	 * @param y
+	 *            Y component
+	 * @param z
+	 *            Z component
+	 */
+	public Vector(float x, float y, float z) {
+		this.x = x;
+		this.y = y;
+		this.z = z;
+	}
+
+	/**
+	 * Construct the vector with provided integer components.
+	 *
+	 * @param x
+	 *            X component
+	 * @param y
+	 *            Y component
+	 * @param z
+	 *            Z component
+	 */
+	public Vector(int x, int y, int z) {
+		this.x = x;
+		this.y = y;
+		this.z = z;
+	}
+
+	/**
+	 * Adds a vector to this one
+	 *
+	 * @param vec
+	 *            The other vector
+	 * @return the same vector
+	 */
+	public Vector add(Vector vec) {
+		x += vec.x;
+		y += vec.y;
+		z += vec.z;
+		return this;
+	}
+
+	/**
+	 * Gets the angle between this vector and another in radians.
+	 *
+	 * @param other
+	 *            The other vector
+	 * @return angle in radians
+	 */
+	public float angle(Vector other) {
+		double dot = dot(other) / (length() * other.length());
+
+		return (float) Math.acos(dot);
+	}
+
+	/**
+	 * Get a new vector.
+	 *
+	 * @return vector
+	 */
+	@Override
+	public Vector clone() {
+		try{
+			return (Vector) super.clone();
+		}catch (CloneNotSupportedException e){
+			throw new Error(e);
+		}
+	}
+
+	/**
+	 * Copies another vector
+	 *
+	 * @param vec
+	 *            The other vector
+	 * @return the same vector
+	 */
+	public Vector copy(Vector vec) {
+		x = vec.x;
+		y = vec.y;
+		z = vec.z;
+		return this;
+	}
+
+	/**
+	 * Calculates the cross product of this vector with another. The cross
+	 * product is defined as:
+	 * <ul>
+	 * <li>x = y1 * z2 - y2 * z1
+	 * <li>y = z1 * x2 - z2 * x1
+	 * <li>z = x1 * y2 - x2 * y1
+	 * </ul>
+	 *
+	 * @param o
+	 *            The other vector
+	 * @return the same vector
+	 */
+	public Vector crossProduct(Vector o) {
+		double newX = y * o.z - o.y * z;
+		double newY = z * o.x - o.z * x;
+		double newZ = x * o.y - o.x * y;
+
+		x = newX;
+		y = newY;
+		z = newZ;
+		return this;
+	}
+
+	/**
+	 * Get the distance between this vector and another. The value of this
+	 * method is not cached and uses a costly square-root function, so do not
+	 * repeatedly call this method to get the vector's magnitude. NaN will be
+	 * returned if the inner result of the sqrt() function overflows, which
+	 * will be caused if the distance is too long.
+	 *
+	 * @param o
+	 *            The other vector
+	 * @return the distance
+	 */
+	public double distance(Vector o) {
+		return Math.sqrt(NumberConversions.square(x - o.x) + NumberConversions.square(y - o.y) + NumberConversions.square(z - o.z));
+	}
+
+	/**
+	 * Get the squared distance between this vector and another.
+	 *
+	 * @param o
+	 *            The other vector
+	 * @return the distance
+	 */
+	public double distanceSquared(Vector o) {
+		return NumberConversions.square(x - o.x) + NumberConversions.square(y - o.y) + NumberConversions.square(z - o.z);
+	}
+
+	/**
+	 * Divides the vector by another.
+	 *
+	 * @param vec
+	 *            The other vector
+	 * @return the same vector
+	 */
+	public Vector divide(Vector vec) {
+		x /= vec.x;
+		y /= vec.y;
+		z /= vec.z;
+		return this;
+	}
+
+	/**
+	 * Calculates the dot product of this vector with another. The dot product
+	 * is defined as x1*x2+y1*y2+z1*z2. The returned value is a scalar.
+	 *
+	 * @param other
+	 *            The other vector
+	 * @return dot product
+	 */
+	public double dot(Vector other) {
+		return x * other.x + y * other.y + z * other.z;
+	}
+
+	/**
+	 * Checks to see if two objects are equal.
+	 * <p>
+	 * Only two Vectors can ever return true. This method uses a fuzzy match to
+	 * account for floating point errors. The epsilon can be retrieved with
+	 * epsilon.
+	 */
+	@Override
+	public boolean equals(Object obj) {
+		if(!(obj instanceof Vector)){
+			return false;
+		}
+
+		Vector other = (Vector) obj;
+
+		return Math.abs(x - other.x) < epsilon && Math.abs(y - other.y) < epsilon && Math.abs(z - other.z) < epsilon && this.getClass().equals(obj.getClass());
+	}
+
+	/**
+	 * Gets the floored value of the X component, indicating the block that
+	 * this vector is contained with.
+	 *
+	 * @return block X
+	 */
+	public int getBlockX() {
+		return NumberConversions.floor(x);
+	}
+
+	/**
+	 * Gets the floored value of the Y component, indicating the block that
+	 * this vector is contained with.
+	 *
+	 * @return block y
+	 */
+	public int getBlockY() {
+		return NumberConversions.floor(y);
+	}
+
+	/**
+	 * Gets the floored value of the Z component, indicating the block that
+	 * this vector is contained with.
+	 *
+	 * @return block z
+	 */
+	public int getBlockZ() {
+		return NumberConversions.floor(z);
+	}
+
+	/**
+	 * Gets a new midpoint vector between this vector and another.
+	 *
+	 * @param other
+	 *            The other vector
+	 * @return a new midpoint vector
+	 */
+	public Vector getMidpoint(Vector other) {
+		double x = (this.x + other.x) / 2;
+		double y = (this.y + other.y) / 2;
+		double z = (this.z + other.z) / 2;
+		return new Vector(x, y, z);
+	}
+
+	/**
+	 * Gets the X component.
+	 *
+	 * @return The X component.
+	 */
+	public double getX() {
+		return x;
+	}
+
+	/**
+	 * Gets the Y component.
+	 *
+	 * @return The Y component.
+	 */
+	public double getY() {
+		return y;
+	}
+
+	/**
+	 * Gets the Z component.
+	 *
+	 * @return The Z component.
+	 */
+	public double getZ() {
+		return z;
+	}
+
+	/**
+	 * Returns a hash code for this vector
+	 *
+	 * @return hash code
+	 */
+	@Override
+	public int hashCode() {
+		int hash = 7;
+
+		hash = 79 * hash + (int) (Double.doubleToLongBits(this.x) ^ Double.doubleToLongBits(this.x) >>> 32);
+		hash = 79 * hash + (int) (Double.doubleToLongBits(this.y) ^ Double.doubleToLongBits(this.y) >>> 32);
+		hash = 79 * hash + (int) (Double.doubleToLongBits(this.z) ^ Double.doubleToLongBits(this.z) >>> 32);
+		return hash;
+	}
+
+	/**
+	 * Returns whether this vector is in an axis-aligned bounding box.
+	 * <p>
+	 * The minimum and maximum vectors given must be truly the minimum and
+	 * maximum X, Y and Z components.
+	 *
+	 * @param min
+	 *            Minimum vector
+	 * @param max
+	 *            Maximum vector
+	 * @return whether this vector is in the AABB
+	 */
+	public boolean isInAABB(Vector min, Vector max) {
+		return x >= min.x && x <= max.x && y >= min.y && y <= max.y && z >= min.z && z <= max.z;
+	}
+
+	/**
+	 * Returns whether this vector is within a sphere.
+	 *
+	 * @param origin
+	 *            Sphere origin.
+	 * @param radius
+	 *            Sphere radius
+	 * @return whether this vector is in the sphere
+	 */
+	public boolean isInSphere(Vector origin, double radius) {
+		return NumberConversions.square(origin.x - x) + NumberConversions.square(origin.y - y) + NumberConversions.square(origin.z - z) <= NumberConversions.square(radius);
+	}
+
+	/**
+	 * Gets the magnitude of the vector, defined as sqrt(x^2+y^2+z^2). The
+	 * value of this method is not cached and uses a costly square-root
+	 * function, so do not repeatedly call this method to get the vector's
+	 * magnitude. NaN will be returned if the inner result of the sqrt()
+	 * function overflows, which will be caused if the length is too long.
+	 *
+	 * @return the magnitude
+	 */
+	public double length() {
+		return Math.sqrt(NumberConversions.square(x) + NumberConversions.square(y) + NumberConversions.square(z));
+	}
+
+	/**
+	 * Gets the magnitude of the vector squared.
+	 *
+	 * @return the magnitude
+	 */
+	public double lengthSquared() {
+		return NumberConversions.square(x) + NumberConversions.square(y) + NumberConversions.square(z);
+	}
+
+	/**
+	 * Sets this vector to the midpoint between this vector and another.
+	 *
+	 * @param other
+	 *            The other vector
+	 * @return this same vector (now a midpoint)
+	 */
+	public Vector midpoint(Vector other) {
+		x = (x + other.x) / 2;
+		y = (y + other.y) / 2;
+		z = (z + other.z) / 2;
+		return this;
+	}
+
+	/**
+	 * Performs scalar multiplication, multiplying all components with a
+	 * scalar.
+	 *
+	 * @param m
+	 *            The factor
+	 * @return the same vector
+	 */
+	public Vector multiply(double m) {
+		x *= m;
+		y *= m;
+		z *= m;
+		return this;
+	}
+
+	/**
+	 * Performs scalar multiplication, multiplying all components with a
+	 * scalar.
+	 *
+	 * @param m
+	 *            The factor
+	 * @return the same vector
+	 */
+	public Vector multiply(float m) {
+		x *= m;
+		y *= m;
+		z *= m;
+		return this;
+	}
+
+	/**
+	 * Performs scalar multiplication, multiplying all components with a
+	 * scalar.
+	 *
+	 * @param m
+	 *            The factor
+	 * @return the same vector
+	 */
+	public Vector multiply(int m) {
+		x *= m;
+		y *= m;
+		z *= m;
+		return this;
+	}
+
+	/**
+	 * Multiplies the vector by another.
+	 *
+	 * @param vec
+	 *            The other vector
+	 * @return the same vector
+	 */
+	public Vector multiply(Vector vec) {
+		x *= vec.x;
+		y *= vec.y;
+		z *= vec.z;
+		return this;
+	}
+
+	/**
+	 * Converts this vector to a unit vector (a vector with length of 1).
+	 *
+	 * @return the same vector
+	 */
+	public Vector normalize() {
+		double length = length();
+
+		x /= length;
+		y /= length;
+		z /= length;
+
+		return this;
+	}
+
+	public Map<String, Object> serialize() {
+		Map<String, Object> result = new LinkedHashMap<String, Object>();
+
+		result.put("x", getX());
+		result.put("y", getY());
+		result.put("z", getZ());
+
+		return result;
+	}
+
+	/**
+	 * Set the X component.
+	 *
+	 * @param x
+	 *            The new X component.
+	 * @return This vector.
+	 */
+	public Vector setX(double x) {
+		this.x = x;
+		return this;
+	}
+
+	/**
+	 * Set the X component.
+	 *
+	 * @param x
+	 *            The new X component.
+	 * @return This vector.
+	 */
+	public Vector setX(float x) {
+		this.x = x;
+		return this;
+	}
+
+	/**
+	 * Set the X component.
+	 *
+	 * @param x
+	 *            The new X component.
+	 * @return This vector.
+	 */
+	public Vector setX(int x) {
+		this.x = x;
+		return this;
+	}
+
+	/**
+	 * Set the Y component.
+	 *
+	 * @param y
+	 *            The new Y component.
+	 * @return This vector.
+	 */
+	public Vector setY(double y) {
+		this.y = y;
+		return this;
+	}
+
+	/**
+	 * Set the Y component.
+	 *
+	 * @param y
+	 *            The new Y component.
+	 * @return This vector.
+	 */
+	public Vector setY(float y) {
+		this.y = y;
+		return this;
+	}
+
+	/**
+	 * Set the Y component.
+	 *
+	 * @param y
+	 *            The new Y component.
+	 * @return This vector.
+	 */
+	public Vector setY(int y) {
+		this.y = y;
+		return this;
+	}
+
+	/**
+	 * Set the Z component.
+	 *
+	 * @param z
+	 *            The new Z component.
+	 * @return This vector.
+	 */
+	public Vector setZ(double z) {
+		this.z = z;
+		return this;
+	}
+
+	/**
+	 * Set the Z component.
+	 *
+	 * @param z
+	 *            The new Z component.
+	 * @return This vector.
+	 */
+	public Vector setZ(float z) {
+		this.z = z;
+		return this;
+	}
+
+	/**
+	 * Set the Z component.
+	 *
+	 * @param z
+	 *            The new Z component.
+	 * @return This vector.
+	 */
+	public Vector setZ(int z) {
+		this.z = z;
+		return this;
+	}
+
+	/**
+	 * Subtracts a vector from this one.
+	 *
+	 * @param vec
+	 *            The other vector
+	 * @return the same vector
+	 */
+	public Vector subtract(Vector vec) {
+		x -= vec.x;
+		y -= vec.y;
+		z -= vec.z;
+		return this;
+	}
+
+	/**
+	 * Gets a Location version of this vector.
+	 *
+	 * @param world
+	 *            The world to link the location to.
+	 * @param yaw
+	 *            The desired yaw.
+	 * @param pitch
+	 *            The desired pitch.
+	 * @return the location
+	 */
+	public Location toLocation(float yaw, float pitch) {
+		return new Location(x, y, z, yaw, pitch);
+	}
+
+	/**
+	 * Returns this vector's components as x,y,z.
+	 */
+	@Override
+	public String toString() {
+		return x + "," + y + "," + z;
+	}
+
+	/**
+	 * Zero this vector's components.
+	 *
+	 * @return the same vector
+	 */
+	public Vector zero() {
+		x = 0;
+		y = 0;
+		z = 0;
+		return this;
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/api/position/Vector3f.java b/src/main/java/dev/wolveringer/api/position/Vector3f.java
new file mode 100644
index 0000000..19016c5
--- /dev/null
+++ b/src/main/java/dev/wolveringer/api/position/Vector3f.java
@@ -0,0 +1,48 @@
+package dev.wolveringer.api.position;
+
+import dev.wolveringer.nbt.NBTTagFloat;
+import dev.wolveringer.nbt.NBTTagList;
+
+public class Vector3f extends Potision<Float>{
+	public Vector3f(float x, float y, float z) {
+		super(x, y, z);
+	}
+
+	public Vector3f(NBTTagList list) {
+		this(list.getFloat(0),list.getFloat(1),list.getFloat(2));
+	}
+
+	public NBTTagList toNBTTagList() {
+		NBTTagList localNBTTagList = new NBTTagList();
+		localNBTTagList.add(new NBTTagFloat(this.x));
+		localNBTTagList.add(new NBTTagFloat(this.y));
+		localNBTTagList.add(new NBTTagFloat(this.z));
+		return localNBTTagList;
+	}
+
+	public boolean equals(Object paramObject) {
+		if(!(paramObject instanceof Vector3f)){
+			return false;
+		}
+		Vector3f localVector3f = (Vector3f) paramObject;
+		return (this.x == localVector3f.x) && (this.y == localVector3f.y) && (this.z == localVector3f.z);
+	}
+
+	@Override
+	public void setX(Float x) {
+		throw new UnsupportedOperationException();
+	}
+	@Override
+	public void setY(Float y) {
+		throw new UnsupportedOperationException();
+	}
+	@Override
+	public void setZ(Float z) {
+		throw new UnsupportedOperationException();
+	}
+	
+	@Override
+	public String toString() {
+		return "Vector3f [x=" + x + ", y=" + y + ", z=" + z + "]";
+	}
+}
diff --git a/src/main/java/dev/wolveringer/api/scoreboard/Objektive.java b/src/main/java/dev/wolveringer/api/scoreboard/Objektive.java
new file mode 100644
index 0000000..9b959d4
--- /dev/null
+++ b/src/main/java/dev/wolveringer/api/scoreboard/Objektive.java
@@ -0,0 +1,129 @@
+package dev.wolveringer.api.scoreboard;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+import dev.wolveringer.BungeeUtil.BungeeUtil;
+import dev.wolveringer.BungeeUtil.Main;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayOutScoreboardDisplayObjective;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayOutScoreboardDisplayObjective.Position;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayOutScoreboardObjective;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayOutScoreboardObjective.Action;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayOutScoreboardObjective.Type;
+import dev.wolveringer.chat.ChatColor.ChatColorUtils;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayOutScoreboardScore;
+
+public final class Objektive {
+	protected Scoreboard owner;
+	protected String name;
+	protected String displayName;
+	protected Type type;
+	protected ArrayList<Score> scores = new ArrayList<>();
+	protected Position pos;
+	
+	protected Objektive(Scoreboard owner, String name) {
+		this.owner = owner;
+		this.name = this.displayName = name;
+		type = Type.INTEGER;
+	}
+
+	public void setScore(String name, int value) {
+		for(Score s : scores)
+			if(s.getName().equals(name)){
+				s.setValue(value);
+				return;
+			}
+		scores.add(new Score(this, name, 0));
+		setScore(name, value);
+	}
+
+	public int getScore(String name) {
+		for(Score s : scores)
+			if(s.getName().equals(name)){
+				return s.getValue();
+			}
+		return 0;
+	}
+
+	public List<String> getScores(){
+		ArrayList<String> out = new ArrayList<>();
+		for(Score s : scores)
+			out.add(s.name);
+		return Collections.unmodifiableList(out);
+	}
+	
+	public void removeScore(String scoreName) {
+		Score x = null;
+		for(Score s : scores)
+			if(s.getName().equals(scoreName)){
+				x = s;
+			}
+		if(x == null){
+			BungeeUtil.getInstance().debug("Removing not existing score ("+scoreName+ChatColorUtils.COLOR_CHAR+"r)");
+			return;
+		}
+		scores.remove(x);
+		owner.player.sendPacket(new PacketPlayOutScoreboardScore(x.name, getName(), -1, PacketPlayOutScoreboardScore.Action.REMOVE));
+	}
+
+	public void setDisplayName(String displayName) {
+		this.displayName = displayName;
+		sendUpdate();
+	}
+
+	public void setType(Type type) {
+		this.type = type;
+		sendUpdate();
+	}
+
+	public void display(Position position) {
+		pos = position;
+		owner.player.sendPacket(new PacketPlayOutScoreboardDisplayObjective(name, position));
+	}
+	public Position getPosition() {
+		return this.pos;
+	}
+
+	public String getDisplayName() {
+		return this.displayName;
+	}
+
+	public String getName() {
+		return this.name;
+	}
+
+	private void sendUpdate() {
+		owner.player.sendPacket(new PacketPlayOutScoreboardObjective(name, Action.UPDATE, displayName, type));
+	}
+
+	protected static class Score {
+		private Objektive owner;
+		protected String name;
+		private int value;
+
+		Score(Objektive owner, String name, int value) {
+			this.owner = owner;
+			this.name = name;
+			this.value = value;
+			owner.owner.player.sendPacket(new PacketPlayOutScoreboardScore(name, owner.getName(), value, PacketPlayOutScoreboardScore.Action.CREATE));
+		}
+
+		public void setValue(int value) {
+			this.value = value;
+			sendUpdate();
+		}
+
+		public int getValue() {
+			return this.value;
+		}
+
+		public String getName() {
+			return this.name;
+		}
+
+		private void sendUpdate() {
+			owner.owner.player.sendPacket(new PacketPlayOutScoreboardScore(name, owner.getName(), value, PacketPlayOutScoreboardScore.Action.UPDATE));
+		}
+	}
+}
diff --git a/src/main/java/dev/wolveringer/api/scoreboard/PacketListenerScoreboard.java b/src/main/java/dev/wolveringer/api/scoreboard/PacketListenerScoreboard.java
new file mode 100644
index 0000000..97af95c
--- /dev/null
+++ b/src/main/java/dev/wolveringer/api/scoreboard/PacketListenerScoreboard.java
@@ -0,0 +1,140 @@
+package dev.wolveringer.api.scoreboard;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+
+import dev.wolveringer.BungeeUtil.BungeeUtil;
+import dev.wolveringer.BungeeUtil.Main;
+import dev.wolveringer.BungeeUtil.PacketHandleEvent;
+import dev.wolveringer.BungeeUtil.PacketHandler;
+import dev.wolveringer.BungeeUtil.PacketLib;
+import dev.wolveringer.BungeeUtil.configuration.Configuration;
+import dev.wolveringer.BungeeUtil.packets.Packet;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayOutScoreboardDisplayObjective;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayOutScoreboardObjective;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayOutScoreboardObjective.Action;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayOutScoreboardScore;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayOutScoreboardTeam;
+import dev.wolveringer.api.scoreboard.Objektive.Score;
+
+public final class PacketListenerScoreboard implements PacketHandler<Packet> {
+	private static PacketListenerScoreboard listener;
+	
+	public static void init() {
+		if(Configuration.isScoreboardhandleEnabled())
+			PacketLib.addHandler(listener = new PacketListenerScoreboard());
+	}
+	
+	public static PacketListenerScoreboard getListener() {
+		return listener;
+	}
+	
+	@Override
+	public void handle(PacketHandleEvent<Packet> e) {
+		if (e.getPacket() instanceof PacketPlayOutScoreboardDisplayObjective) {
+			Scoreboard board = e.getPlayer().getScoreboard();
+			PacketPlayOutScoreboardDisplayObjective out = (PacketPlayOutScoreboardDisplayObjective) e.getPacket();
+			Objektive o = board.getObjektive(out.getName());
+			o.pos = out.getPosition();
+		}
+		else if (e.getPacket() instanceof PacketPlayOutScoreboardObjective) {
+			Scoreboard board = e.getPlayer().getScoreboard();
+			PacketPlayOutScoreboardObjective out = (PacketPlayOutScoreboardObjective) e.getPacket();
+			if (out.getAction() == Action.CREATE) {
+				Objektive obj;
+				board.server_objs.add(obj = new Objektive(board, out.getScorebordName()));
+				obj.displayName = out.getDisplayName();
+				obj.name = out.getScorebordName();
+				obj.type = out.getType();
+			}
+			else if (out.getAction() == Action.REMOVE) {
+				board.server_objs.remove(board.getObjektive(out.getScorebordName()));
+			}
+			else if (out.getAction() == Action.UPDATE) {
+				Objektive obj = board.getObjektive(out.getScorebordName());
+				if (obj == null) return;
+				obj.displayName = out.getDisplayName();
+				obj.type = out.getType();
+			}
+		}
+		else if (e.getPacket() instanceof PacketPlayOutScoreboardScore) {
+			Scoreboard board = e.getPlayer().getScoreboard();
+			PacketPlayOutScoreboardScore out = (PacketPlayOutScoreboardScore) e.getPacket();
+			if (out.getAction() == dev.wolveringer.BungeeUtil.packets.PacketPlayOutScoreboardScore.Action.CREATE || out.getAction() == dev.wolveringer.BungeeUtil.packets.PacketPlayOutScoreboardScore.Action.UPDATE) {
+				Objektive obj = board.getObjektive(out.getObjektiveName());
+				if (obj == null) board.server_objs.add(obj = new Objektive(board, out.getObjektiveName()));
+				if (obj == null) {
+					BungeeUtil.getInstance().debug("ScoreboardObjective " + out.getObjektiveName() + " for the player " + e.getPlayer().getName() + " not found!");
+					return;
+				}
+				Score x = null;
+				for (Score s : obj.scores)
+					if (s.getName().equals(out.getScoreName())) {
+						x = s;
+					}
+				if (x == null) return;
+				obj.scores.remove(x);
+				
+				obj.scores.add(new Score(obj, out.getScoreName(), out.getValue()));
+			}
+			else if (out.getAction() == dev.wolveringer.BungeeUtil.packets.PacketPlayOutScoreboardScore.Action.REMOVE) {
+				Objektive obj = board.getObjektive(out.getObjektiveName());
+				if (obj == null) {
+					BungeeUtil.getInstance().debug("ScoreboardObjective " + out.getObjektiveName() + " for the player " + e.getPlayer().getName() + " not found");
+					return;
+				}
+				Score x = null;
+				for (Score s : obj.scores)
+					if (s.getName().equals(out.getScoreName())) {
+						x = s;
+					}
+				if (x == null) return;
+				obj.scores.remove(x);
+			}
+		}
+		else if (e.getPacket() instanceof PacketPlayOutScoreboardTeam) {
+			Scoreboard board = e.getPlayer().getScoreboard();
+			PacketPlayOutScoreboardTeam out = (PacketPlayOutScoreboardTeam) e.getPacket();
+			if (out.getAction() == dev.wolveringer.BungeeUtil.packets.PacketPlayOutScoreboardTeam.Action.CREATE) {
+				Team t = new Team(board, out.getTeam());
+				if(t == null)
+					return;
+				t.color = out.getColor();
+				t.displayName = out.getDisplayName();
+				t.friendly_fire = out.isFriendlyFire();
+				t.prefix = out.getPrefix();
+				t.suffix = out.getSuffix();
+				t.tag = out.getTag();
+				t.member = new ArrayList<>(Arrays.asList(out.getPlayers()));
+				board.server_teams.add(t);
+			}
+			else if (out.getAction() == dev.wolveringer.BungeeUtil.packets.PacketPlayOutScoreboardTeam.Action.PLAYER_ADD) {
+				Team t = board.getTeam(out.getTeam());
+				if(t == null)
+					return;
+				t.member.addAll(new ArrayList<>(Arrays.asList(out.getPlayers())));
+			}
+			else if (out.getAction() == dev.wolveringer.BungeeUtil.packets.PacketPlayOutScoreboardTeam.Action.PLAYER_REMOVE) {
+				Team t = board.getTeam(out.getTeam());
+				if(t == null)
+					return;
+				t.member.removeAll(new ArrayList<>(Arrays.asList(out.getPlayers())));
+			}
+			else if (out.getAction() == dev.wolveringer.BungeeUtil.packets.PacketPlayOutScoreboardTeam.Action.REMOVE) {
+				Team t = board.getTeam(out.getTeam());
+				if(t == null)
+					return;
+				board.server_teams.remove(t);
+			}
+			else if (out.getAction() == dev.wolveringer.BungeeUtil.packets.PacketPlayOutScoreboardTeam.Action.UPDATE) {
+				Team t = board.getTeam(out.getTeam());
+				t.color = out.getColor();
+				t.displayName = out.getDisplayName();
+				t.friendly_fire = out.isFriendlyFire();
+				t.prefix = out.getPrefix();
+				t.suffix = out.getSuffix();
+				t.tag = out.getTag();
+			}
+		}
+	}
+}
diff --git a/src/main/java/dev/wolveringer/api/scoreboard/Scoreboard.java b/src/main/java/dev/wolveringer/api/scoreboard/Scoreboard.java
new file mode 100644
index 0000000..10b0eaf
--- /dev/null
+++ b/src/main/java/dev/wolveringer/api/scoreboard/Scoreboard.java
@@ -0,0 +1,109 @@
+package dev.wolveringer.api.scoreboard;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+import dev.wolveringer.BungeeUtil.AsyncCatcher;
+import dev.wolveringer.BungeeUtil.Player;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayOutScoreboardObjective;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayOutScoreboardObjective.Action;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayOutScoreboardObjective.Type;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayOutScoreboardTeam;
+
+public final class Scoreboard {
+	@SuppressWarnings({ "serial", "unused" })
+	private static class ScoreboardAlredyExistException extends RuntimeException {
+		public ScoreboardAlredyExistException(String message) {
+			super(message);
+		}
+	}
+
+	protected Player player;
+	private ArrayList<Objektive> objs = new ArrayList<>();
+	private ArrayList<Team> teams = new ArrayList<>();
+
+	protected ArrayList<Team> server_teams = new ArrayList<>();
+	protected ArrayList<Objektive> server_objs = new ArrayList<>();
+	
+	public Scoreboard(Player player) {
+		//if(player.getScoreboard() != null)
+		//	throw new ScoreboardAlredyExistException("Player " + player.getName() + " has alredy a Scoreboard");
+		this.player = player;
+	}
+
+	public Objektive createObjektive(String name, Type t) {
+		if(getObjektive(name) != null)
+			return getObjektive(name);
+		Objektive o = new Objektive(this, name);
+		objs.add(o);
+		player.sendPacket(new PacketPlayOutScoreboardObjective(name, Action.CREATE, o.getDisplayName(), t));
+		return o;
+	}
+
+	public Objektive getObjektive(String name) {
+		for(Objektive o : objs)
+			if(o.getName().equals(name))
+				return o;
+		for(Objektive o : server_objs)
+			if(o.getName().equals(name))
+				return o;
+		return null;
+	}
+
+	public void removeObjektive(String name) {
+		Objektive o = getObjektive(name);
+		if(o == null)
+			return;
+		AsyncCatcher.catchOp("Async scoreboard changing");
+		player.sendPacket(new PacketPlayOutScoreboardObjective(name, Action.REMOVE, o.getDisplayName(), Type.INTEGER));
+		if(objs.remove(o) && !server_objs.remove(o)){ //Check if proxy side board
+			for(Objektive var0 : server_objs)
+				if(var0.getPosition() == o.getPosition()){
+					var0.display(o.getPosition());
+					break;
+				}
+		}
+	}
+	
+	public List<Objektive> getObjektives(){
+		return Collections.unmodifiableList(objs);
+	}
+
+	public Team createTeam(String name) {
+		if(getTeam(name) != null)
+			return getTeam(name);
+		Team t = new Team(this, name);
+		teams.add(t);
+		return t;
+	}
+
+	public void removeTeam(String name) {
+		Team t = getTeam(name);
+		if(t != null){
+			teams.remove(t);
+			PacketPlayOutScoreboardTeam x = new PacketPlayOutScoreboardTeam(t);
+			x.setAction(dev.wolveringer.BungeeUtil.packets.PacketPlayOutScoreboardTeam.Action.REMOVE);
+			player.sendPacket(x);
+		}
+	}
+
+	public Team getTeam(String name) {
+		for(Team t : teams)
+			if(t.getName().equals(name))
+				return t;
+		for(Team t : server_teams)
+			if(t.getName().equals(name))
+				return t;
+		return null;
+	}
+
+	public List<Team> getTeams(){
+		return Collections.unmodifiableList(teams);
+	}
+	
+	@Override
+	public String toString() {
+		return "Scoreboard [Owner="+player.getName()+",Objekt-Count="+(objs.size()+server_objs.size())+"(Bungee: "+objs.size()+"/Server: "+server_objs.size()+"),Team-Count="+(teams.size()+server_teams.size())+"(Bungee:"+teams.size()+"/Server:"+server_teams.size()+")]";
+	}
+}
diff --git a/src/main/java/dev/wolveringer/api/scoreboard/Team.java b/src/main/java/dev/wolveringer/api/scoreboard/Team.java
new file mode 100644
index 0000000..791d1b1
--- /dev/null
+++ b/src/main/java/dev/wolveringer/api/scoreboard/Team.java
@@ -0,0 +1,94 @@
+package dev.wolveringer.api.scoreboard;
+
+import java.util.ArrayList;
+
+import net.md_5.bungee.api.ChatColor;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayOutScoreboardTeam;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayOutScoreboardTeam.Action;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayOutScoreboardTeam.NameTag;
+
+public final class Team {
+	protected Scoreboard owner;
+	protected ChatColor color = ChatColor.WHITE;
+	protected String name;
+	protected String displayName;
+	protected String prefix = "";
+	protected String suffix = "";
+	protected NameTag tag = NameTag.VISIABLE;
+	protected int friendly_fire = 0;
+	protected ArrayList<String> member = new ArrayList<>();
+	
+	public Team(Scoreboard owner,String name) {
+		this.owner = owner;
+		this.name = name;
+	}
+	
+	public void setColor(ChatColor color) {
+		this.color = color;
+		sendUpdate();
+	}
+	public void setDisplayName(String displayName) {
+		this.displayName = displayName;
+		sendUpdate();
+	}
+	public void addMember(String name){
+		member.add(name);
+		PacketPlayOutScoreboardTeam team = new PacketPlayOutScoreboardTeam(this);
+		team.setAction(Action.PLAYER_ADD);
+		team.setPlayers(new String[]{name});
+		owner.player.sendPacket(team);
+	}
+	public void removeMember(String name){
+		member.remove(name);
+		PacketPlayOutScoreboardTeam team = new PacketPlayOutScoreboardTeam(this);
+		team.setAction(Action.PLAYER_REMOVE);
+		team.setPlayers(new String[]{name});
+		owner.player.sendPacket(team);
+	}
+	public void setPrefix(String prefix) {
+		this.prefix = prefix;
+		sendUpdate();
+	}
+	public void setSuffix(String suffix) {
+		this.suffix = suffix;
+		sendUpdate();
+	}
+	public void setTagVisibility(NameTag tag) {
+		this.tag = tag;
+		sendUpdate();
+	}
+	public void setFriendlyFire(int friendly_fire) {
+		this.friendly_fire = friendly_fire;
+		sendUpdate();
+	}
+	
+	public ChatColor getColor() {
+		return this.color;
+	}
+	public String getDisplayName() {
+		return this.displayName;
+	}
+	public ArrayList<String> getMember() {
+		return this.member;
+	}
+	public String getName() {
+		return this.name;
+	}
+	public String getPrefix() {
+		return this.prefix;
+	}
+	public String getSuffix() {
+		return this.suffix;
+	}
+	public NameTag getTagVisibility() {
+		return this.tag;
+	}
+	public int getFriendlyFire() {
+		return this.friendly_fire;
+	}
+	private void sendUpdate(){
+		PacketPlayOutScoreboardTeam team = new PacketPlayOutScoreboardTeam(this);
+		team.setAction(Action.UPDATE);
+		owner.player.sendPacket(team);
+	}
+}
diff --git a/src/main/java/dev/wolveringer/api/sound/SoundCategory.java b/src/main/java/dev/wolveringer/api/sound/SoundCategory.java
new file mode 100644
index 0000000..727eb8a
--- /dev/null
+++ b/src/main/java/dev/wolveringer/api/sound/SoundCategory.java
@@ -0,0 +1,24 @@
+package dev.wolveringer.api.sound;
+
+public enum SoundCategory {
+	MASTER("master"),
+	MUSIC("music"),
+	RECORDS("record"),
+	WEATHER("weather"),
+	BLOCKS("block"),
+	HOSTILE("hostile"),
+	NEUTRAL("neutral"),
+	PLAYERS("player"),
+	AMBIENT("ambient"),
+	VOICE("voice");
+	
+	private String name;
+	
+	private SoundCategory(String name) {
+		this.name = name;
+	}
+	
+	public String getName() {
+		return name;
+	}
+}
diff --git a/src/main/java/dev/wolveringer/api/sound/SoundEffect.java b/src/main/java/dev/wolveringer/api/sound/SoundEffect.java
new file mode 100644
index 0000000..55d239e
--- /dev/null
+++ b/src/main/java/dev/wolveringer/api/sound/SoundEffect.java
@@ -0,0 +1,1423 @@
+package dev.wolveringer.api.sound;
+
+import java.util.HashMap;
+
+import dev.wolveringer.BungeeUtil.ClientVersion.BigClientVersion;
+
+public enum SoundEffect {
+	
+	/**
+	 * @author essem 
+	 * 
+	 */
+	
+	AMBIENT_CAVE,
+	BLOCK_ANVIL_BREAK,
+	BLOCK_ANVIL_DESTROY,
+	BLOCK_ANVIL_FALL,
+	BLOCK_ANVIL_HIT,
+	BLOCK_ANVIL_LAND,
+	BLOCK_ANVIL_PLACE,
+	BLOCK_ANVIL_STEP,
+	BLOCK_ANVIL_USE,
+	BLOCK_BREWING_STAND_BREW,
+	BLOCK_CHEST_CLOSE,
+	BLOCK_CHEST_LOCKED,
+	BLOCK_CHEST_OPEN,
+	BLOCK_CHORUS_FLOWER_DEATH,
+	BLOCK_CHORUS_FLOWER_GROW,
+	BLOCK_CLOTH_BREAK,
+	BLOCK_CLOTH_FALL,
+	BLOCK_CLOTH_HIT,
+	BLOCK_CLOTH_PLACE,
+	BLOCK_CLOTH_STEP,
+	BLOCK_COMPARATOR_CLICK,
+	BLOCK_DISPENSER_DISPENSE,
+	BLOCK_DISPENSER_FAIL,
+	BLOCK_DISPENSER_LAUNCH,
+	BLOCK_ENCHANTMENT_TABLE_USE,
+	BLOCK_END_GATEWAY_SPAWN,
+	BLOCK_ENDERCHEST_CLOSE,
+	BLOCK_ENDERCHEST_OPEN,
+	BLOCK_FENCE_GATE_CLOSE,
+	BLOCK_FENCE_GATE_OPEN,
+	BLOCK_FIRE_AMBIENT,
+	BLOCK_FIRE_EXTINGUISH,
+	BLOCK_FURNACE_FIRE_CRACKLE,
+	BLOCK_GLASS_BREAK,
+	BLOCK_GLASS_FALL,
+	BLOCK_GLASS_HIT,
+	BLOCK_GLASS_PLACE,
+	BLOCK_GLASS_STEP,
+	BLOCK_GRASS_BREAK,
+	BLOCK_GRASS_FALL,
+	BLOCK_GRASS_HIT,
+	BLOCK_GRASS_PLACE,
+	BLOCK_GRASS_STEP,
+	BLOCK_GRAVEL_BREAK,
+	BLOCK_GRAVEL_FALL,
+	BLOCK_GRAVEL_HIT,
+	BLOCK_GRAVEL_PLACE,
+	BLOCK_GRAVEL_STEP,
+	BLOCK_IRON_DOOR_CLOSE,
+	BLOCK_IRON_DOOR_OPEN,
+	BLOCK_IRON_TRAPDOOR_CLOSE,
+	BLOCK_IRON_TRAPDOOR_OPEN,
+	BLOCK_LADDER_BREAK,
+	BLOCK_LADDER_FALL,
+	BLOCK_LADDER_HIT,
+	BLOCK_LADDER_PLACE,
+	BLOCK_LADDER_STEP,
+	BLOCK_LAVA_AMBIENT,
+	BLOCK_LAVA_EXTINGUISH,
+	BLOCK_LAVA_POP,
+	BLOCK_LEVER_CLICK,
+	BLOCK_METAL_BREAK,
+	BLOCK_METAL_FALL,
+	BLOCK_METAL_HIT,
+	BLOCK_METAL_PLACE,
+	BLOCK_METAL_PRESSUREPLATE_CLICK_OFF,
+	BLOCK_METAL_PRESSUREPLATE_CLICK_ON,
+	BLOCK_METAL_STEP,
+	BLOCK_NOTE_BASEDRUM,
+	BLOCK_NOTE_BASS,
+	BLOCK_NOTE_HARP,
+	BLOCK_NOTE_HAT,
+	BLOCK_NOTE_PLING,
+	BLOCK_NOTE_SNARE,
+	BLOCK_PISTON_CONTRACT,
+	BLOCK_PISTON_EXTEND,
+	BLOCK_PORTAL_AMBIENT,
+	BLOCK_PORTAL_TRAVEL,
+	BLOCK_PORTAL_TRIGGER,
+	BLOCK_REDSTONE_TORCH_BURNOUT,
+	BLOCK_SAND_BREAK,
+	BLOCK_SAND_FALL,
+	BLOCK_SAND_HIT,
+	BLOCK_SAND_PLACE,
+	BLOCK_SAND_STEP,
+	BLOCK_SLIME_BREAK,
+	BLOCK_SLIME_FALL,
+	BLOCK_SLIME_HIT,
+	BLOCK_SLIME_PLACE,
+	BLOCK_SLIME_STEP,
+	BLOCK_SNOW_BREAK,
+	BLOCK_SNOW_FALL,
+	BLOCK_SNOW_HIT,
+	BLOCK_SNOW_PLACE,
+	BLOCK_SNOW_STEP,
+	BLOCK_STONE_BREAK,
+	BLOCK_STONE_BUTTON_CLICK_OFF,
+	BLOCK_STONE_BUTTON_CLICK_ON,
+	BLOCK_STONE_FALL,
+	BLOCK_STONE_HIT,
+	BLOCK_STONE_PLACE,
+	BLOCK_STONE_PRESSUREPLATE_CLICK_OFF,
+	BLOCK_STONE_PRESSUREPLATE_CLICK_ON,
+	BLOCK_STONE_STEP,
+	BLOCK_TRIPWIRE_ATTACH,
+	BLOCK_TRIPWIRE_CLICK_OFF,
+	BLOCK_TRIPWIRE_CLICK_ON,
+	BLOCK_TRIPWIRE_DETACH,
+	BLOCK_WATER_AMBIENT,
+	BLOCK_WATERLILY_PLACE,
+	BLOCK_WOOD_BREAK,
+	BLOCK_WOOD_BUTTON_CLICK_OFF,
+	BLOCK_WOOD_BUTTON_CLICK_ON,
+	BLOCK_WOOD_FALL,
+	BLOCK_WOOD_HIT,
+	BLOCK_WOOD_PLACE,
+	BLOCK_WOOD_PRESSUREPLATE_CLICK_OFF,
+	BLOCK_WOOD_PRESSUREPLATE_CLICK_ON,
+	BLOCK_WOOD_STEP,
+	BLOCK_WOODEN_DOOR_CLOSE,
+	BLOCK_WOODEN_DOOR_OPEN,
+	BLOCK_WOODEN_TRAPDOOR_CLOSE,
+	BLOCK_WOODEN_TRAPDOOR_OPEN,
+	ENCHANT_THORNS_HIT,
+	ENTITY_ARMORSTAND_BREAK,
+	ENTITY_ARMORSTAND_FALL,
+	ENTITY_ARMORSTAND_HIT,
+	ENTITY_ARMORSTAND_PLACE,
+	ENTITY_ARROW_HIT,
+	ENTITY_ARROW_HIT_PLAYER,
+	ENTITY_ARROW_SHOOT,
+	ENTITY_BAT_AMBIENT,
+	ENTITY_BAT_DEATH,
+	ENTITY_BAT_HURT,
+	ENTITY_BAT_LOOP,
+	ENTITY_BAT_TAKEOFF,
+	ENTITY_BLAZE_AMBIENT,
+	ENTITY_BLAZE_BURN,
+	ENTITY_BLAZE_DEATH,
+	ENTITY_BLAZE_HURT,
+	ENTITY_BLAZE_SHOOT,
+	ENTITY_BOBBER_SPLASH,
+	ENTITY_BOBBER_THROW,
+	ENTITY_CAT_AMBIENT,
+	ENTITY_CAT_DEATH,
+	ENTITY_CAT_HISS,
+	ENTITY_CAT_HURT,
+	ENTITY_CAT_PURR,
+	ENTITY_CAT_PURREOW,
+	ENTITY_CHICKEN_AMBIENT,
+	ENTITY_CHICKEN_DEATH,
+	ENTITY_CHICKEN_EGG,
+	ENTITY_CHICKEN_HURT,
+	ENTITY_CHICKEN_STEP,
+	ENTITY_COW_AMBIENT,
+	ENTITY_COW_DEATH,
+	ENTITY_COW_HURT,
+	ENTITY_COW_MILK,
+	ENTITY_COW_STEP,
+	ENTITY_CREEPER_DEATH,
+	ENTITY_CREEPER_HURT,
+	ENTITY_CREEPER_PRIMED,
+	ENTITY_DONKEY_AMBIENT,
+	ENTITY_DONKEY_ANGRY,
+	ENTITY_DONKEY_CHEST,
+	ENTITY_DONKEY_DEATH,
+	ENTITY_DONKEY_HURT,
+	ENTITY_EGG_THROW,
+	ENTITY_ELDER_GUARDIAN_AMBIENT,
+	ENTITY_ELDER_GUARDIAN_AMBIENT_LAND,
+	ENTITY_ELDER_GUARDIAN_CURSE,
+	ENTITY_ELDER_GUARDIAN_DEATH,
+	ENTITY_ELDER_GUARDIAN_DEATH_LAND,
+	ENTITY_ELDER_GUARDIAN_HURT,
+	ENTITY_ELDER_GUARDIAN_HURT_LAND,
+	ENTITY_ENDERDRAGON_AMBIENT,
+	ENTITY_ENDERDRAGON_DEATH,
+	ENTITY_ENDERDRAGON_FIREBALL_EXPLODE,
+	ENTITY_ENDERDRAGON_FLAP,
+	ENTITY_ENDERDRAGON_GROWL,
+	ENTITY_ENDERDRAGON_HURT,
+	ENTITY_ENDERDRAGON_SHOOT,
+	ENTITY_ENDEREYE_LAUNCH,
+	ENTITY_ENDERMEN_AMBIENT,
+	ENTITY_ENDERMEN_DEATH,
+	ENTITY_ENDERMEN_HURT,
+	ENTITY_ENDERMEN_SCREAM,
+	ENTITY_ENDERMEN_STARE,
+	ENTITY_ENDERMEN_TELEPORT,
+	ENTITY_ENDERMITE_AMBIENT,
+	ENTITY_ENDERMITE_DEATH,
+	ENTITY_ENDERMITE_HURT,
+	ENTITY_ENDERMITE_STEP,
+	ENTITY_ENDERPEARL_THROW,
+	ENTITY_EXPERIENCE_BOTTLE_THROW,
+	ENTITY_EXPERIENCE_ORB_PICKUP,
+	ENTITY_EXPERIENCE_ORB_TOUCH,
+	ENTITY_FIREWORK_BLAST,
+	ENTITY_FIREWORK_BLAST_FAR,
+	ENTITY_FIREWORK_LARGE_BLAST,
+	ENTITY_FIREWORK_LARGE_BLAST_FAR,
+	ENTITY_FIREWORK_LAUNCH,
+	ENTITY_FIREWORK_SHOOT,
+	ENTITY_FIREWORK_TWINKLE,
+	ENTITY_FIREWORK_TWINKLE_FAR,
+	ENTITY_GENERIC_BIG_FALL,
+	ENTITY_GENERIC_BURN,
+	ENTITY_GENERIC_DEATH,
+	ENTITY_GENERIC_DRINK,
+	ENTITY_GENERIC_EAT,
+	ENTITY_GENERIC_EXPLODE,
+	ENTITY_GENERIC_EXTINGUISH_FIRE,
+	ENTITY_GENERIC_HURT,
+	ENTITY_GENERIC_SMALL_FALL,
+	ENTITY_GENERIC_SPLASH,
+	ENTITY_GENERIC_SWIM,
+	ENTITY_GHAST_AMBIENT,
+	ENTITY_GHAST_DEATH,
+	ENTITY_GHAST_HURT,
+	ENTITY_GHAST_SCREAM,
+	ENTITY_GHAST_SHOOT,
+	ENTITY_GHAST_WARN,
+	ENTITY_GUARDIAN_AMBIENT,
+	ENTITY_GUARDIAN_AMBIENT_LAND,
+	ENTITY_GUARDIAN_ATTACK,
+	ENTITY_GUARDIAN_DEATH,
+	ENTITY_GUARDIAN_DEATH_LAND,
+	ENTITY_GUARDIAN_FLOP,
+	ENTITY_GUARDIAN_HURT,
+	ENTITY_GUARDIAN_HURT_LAND,
+	ENTITY_HORSE_AMBIENT,
+	ENTITY_HORSE_ANGRY,
+	ENTITY_HORSE_ARMOR,
+	ENTITY_HORSE_BREATHE,
+	ENTITY_HORSE_DEATH,
+	ENTITY_HORSE_EAT,
+	ENTITY_HORSE_GALLOP,
+	ENTITY_HORSE_HURT,
+	ENTITY_HORSE_JUMP,
+	ENTITY_HORSE_LAND,
+	ENTITY_HORSE_SADDLE,
+	ENTITY_HORSE_STEP,
+	ENTITY_HORSE_STEP_WOOD,
+	ENTITY_HOSTILE_BIG_FALL,
+	ENTITY_HOSTILE_DEATH,
+	ENTITY_HOSTILE_HURT,
+	ENTITY_HOSTILE_SMALL_FALL,
+	ENTITY_HOSTILE_SPLASH,
+	ENTITY_HOSTILE_SWIM,
+	ENTITY_HUSK_AMBIENT,
+	ENTITY_HUSK_DEATH,
+	ENTITY_HUSK_HURT,
+	ENTITY_HUSK_STEP,
+	ENTITY_IRONGOLEM_ATTACK,
+	ENTITY_IRONGOLEM_DEATH,
+	ENTITY_IRONGOLEM_HURT,
+	ENTITY_IRONGOLEM_STEP,
+	ENTITY_ITEM_BREAK,
+	ENTITY_ITEM_PICKUP,
+	ENTITY_ITEMFRAME_ADD_ITEM,
+	ENTITY_ITEMFRAME_BREAK,
+	ENTITY_ITEMFRAME_PLACE,
+	ENTITY_ITEMFRAME_REMOVE_ITEM,
+	ENTITY_ITEMFRAME_ROTATE_ITEM,
+	ENTITY_LEASHKNOT_BREAK,
+	ENTITY_LEASHKNOT_PLACE,
+	ENTITY_LIGHTNING_IMPACT,
+	ENTITY_LIGHTNING_THUNDER,
+	ENTITY_LINGERINGPOTION_THROW,
+	ENTITY_MAGMACUBE_DEATH,
+	ENTITY_MAGMACUBE_HURT,
+	ENTITY_MAGMACUBE_JUMP,
+	ENTITY_MAGMACUBE_SQUISH,
+	ENTITY_MINECART_INSIDE,
+	ENTITY_MINECART_RIDING,
+	ENTITY_MOOSHROOM_SHEAR,
+	ENTITY_MULE_AMBIENT,
+	ENTITY_MULE_DEATH,
+	ENTITY_MULE_HURT,
+	ENTITY_PAINTING_BREAK,
+	ENTITY_PAINTING_PLACE,
+	ENTITY_PIG_AMBIENT,
+	ENTITY_PIG_DEATH,
+	ENTITY_PIG_HURT,
+	ENTITY_PIG_SADDLE,
+	ENTITY_PIG_STEP,
+	ENTITY_PLAYER_ATTACK_CRIT,
+	ENTITY_PLAYER_ATTACK_KNOCKBACK,
+	ENTITY_PLAYER_ATTACK_NODAMAGE,
+	ENTITY_PLAYER_ATTACK_STRONG,
+	ENTITY_PLAYER_ATTACK_SWEEP,
+	ENTITY_PLAYER_ATTACK_WEAK,
+	ENTITY_PLAYER_BIG_FALL,
+	ENTITY_PLAYER_BREATH,
+	ENTITY_PLAYER_BURP,
+	ENTITY_PLAYER_DEATH,
+	ENTITY_PLAYER_HURT,
+	ENTITY_PLAYER_LEVELUP,
+	ENTITY_PLAYER_SMALL_FALL,
+	ENTITY_PLAYER_SPLASH,
+	ENTITY_PLAYER_SWIM,
+	ENTITY_POLAR_BEAR_AMBIENT,
+	ENTITY_POLAR_BEAR_BABY_AMBIENT,
+	ENTITY_POLAR_BEAR_DEATH,
+	ENTITY_POLAR_BEAR_HURT,
+	ENTITY_POLAR_BEAR_STEP,
+	ENTITY_POLAR_BEAR_WARNING,
+	ENTITY_RABBIT_AMBIENT,
+	ENTITY_RABBIT_ATTACK,
+	ENTITY_RABBIT_DEATH,
+	ENTITY_RABBIT_HURT,
+	ENTITY_RABBIT_JUMP,
+	ENTITY_SHEEP_AMBIENT,
+	ENTITY_SHEEP_DEATH,
+	ENTITY_SHEEP_HURT,
+	ENTITY_SHEEP_SHEAR,
+	ENTITY_SHEEP_STEP,
+	ENTITY_SHULKER_AMBIENT,
+	ENTITY_SHULKER_BULLET_HIT,
+	ENTITY_SHULKER_BULLET_HURT,
+	ENTITY_SHULKER_CLOSE,
+	ENTITY_SHULKER_DEATH,
+	ENTITY_SHULKER_HURT,
+	ENTITY_SHULKER_HURT_CLOSED,
+	ENTITY_SHULKER_OPEN,
+	ENTITY_SHULKER_SHOOT,
+	ENTITY_SHULKER_TELEPORT,
+	ENTITY_SILVERFISH_AMBIENT,
+	ENTITY_SILVERFISH_DEATH,
+	ENTITY_SILVERFISH_HURT,
+	ENTITY_SILVERFISH_STEP,
+	ENTITY_SKELETON_AMBIENT,
+	ENTITY_SKELETON_DEATH,
+	ENTITY_SKELETON_HORSE_AMBIENT,
+	ENTITY_SKELETON_HORSE_DEATH,
+	ENTITY_SKELETON_HORSE_HURT,
+	ENTITY_SKELETON_HURT,
+	ENTITY_SKELETON_SHOOT,
+	ENTITY_SKELETON_STEP,
+	ENTITY_SLIME_ATTACK,
+	ENTITY_SLIME_DEATH,
+	ENTITY_SLIME_HURT,
+	ENTITY_SLIME_JUMP,
+	ENTITY_SLIME_SQUISH,
+	ENTITY_SMALL_MAGMACUBE_DEATH,
+	ENTITY_SMALL_MAGMACUBE_HURT,
+	ENTITY_SMALL_MAGMACUBE_SQUISH,
+	ENTITY_SMALL_SLIME_DEATH,
+	ENTITY_SMALL_SLIME_HURT,
+	ENTITY_SMALL_SLIME_JUMP,
+	ENTITY_SMALL_SLIME_SQUISH,
+	ENTITY_SNOWBALL_THROW,
+	ENTITY_SNOWMAN_AMBIENT,
+	ENTITY_SNOWMAN_DEATH,
+	ENTITY_SNOWMAN_HURT,
+	ENTITY_SNOWMAN_SHOOT,
+	ENTITY_SPIDER_AMBIENT,
+	ENTITY_SPIDER_DEATH,
+	ENTITY_SPIDER_HURT,
+	ENTITY_SPIDER_STEP,
+	ENTITY_SPLASH_POTION_BREAK,
+	ENTITY_SPLASH_POTION_THROW,
+	ENTITY_SQUID_AMBIENT,
+	ENTITY_SQUID_DEATH,
+	ENTITY_SQUID_HURT,
+	ENTITY_STRAY_AMBIENT,
+	ENTITY_STRAY_DEATH,
+	ENTITY_STRAY_HURT,
+	ENTITY_STRAY_STEP,
+	ENTITY_TNT_PRIMED,
+	ENTITY_VILLAGER_AMBIENT,
+	ENTITY_VILLAGER_DEATH,
+	ENTITY_VILLAGER_HURT,
+	ENTITY_VILLAGER_NO,
+	ENTITY_VILLAGER_TRADING,
+	ENTITY_VILLAGER_YES,
+	ENTITY_WITCH_AMBIENT,
+	ENTITY_WITCH_DEATH,
+	ENTITY_WITCH_DRINK,
+	ENTITY_WITCH_HURT,
+	ENTITY_WITCH_THROW,
+	ENTITY_WITHER_AMBIENT,
+	ENTITY_WITHER_BREAK_BLOCK,
+	ENTITY_WITHER_DEATH,
+	ENTITY_WITHER_HURT,
+	ENTITY_WITHER_SHOOT,
+	ENTITY_WITHER_SKELETON_AMBIENT,
+	ENTITY_WITHER_SKELETON_DEATH,
+	ENTITY_WITHER_SKELETON_HURT,
+	ENTITY_WITHER_SKELETON_STEP,
+	ENTITY_WITHER_SPAWN,
+	ENTITY_WOLF_AMBIENT,
+	ENTITY_WOLF_DEATH,
+	ENTITY_WOLF_GROWL,
+	ENTITY_WOLF_HOWL,
+	ENTITY_WOLF_HURT,
+	ENTITY_WOLF_PANT,
+	ENTITY_WOLF_SHAKE,
+	ENTITY_WOLF_STEP,
+	ENTITY_WOLF_WHINE,
+	ENTITY_ZOMBIE_AMBIENT,
+	ENTITY_ZOMBIE_ATTACK_DOOR_WOOD,
+	ENTITY_ZOMBIE_ATTACK_IRON_DOOR,
+	ENTITY_ZOMBIE_BREAK_DOOR_WOOD,
+	ENTITY_ZOMBIE_DEATH,
+	ENTITY_ZOMBIE_HORSE_AMBIENT,
+	ENTITY_ZOMBIE_HORSE_DEATH,
+	ENTITY_ZOMBIE_HORSE_HURT,
+	ENTITY_ZOMBIE_HURT,
+	ENTITY_ZOMBIE_INFECT,
+	ENTITY_ZOMBIE_PIG_AMBIENT,
+	ENTITY_ZOMBIE_PIG_ANGRY,
+	ENTITY_ZOMBIE_PIG_DEATH,
+	ENTITY_ZOMBIE_PIG_HURT,
+	ENTITY_ZOMBIE_STEP,
+	ENTITY_ZOMBIE_VILLAGER_AMBIENT,
+	ENTITY_ZOMBIE_VILLAGER_CONVERTED,
+	ENTITY_ZOMBIE_VILLAGER_CURE,
+	ENTITY_ZOMBIE_VILLAGER_DEATH,
+	ENTITY_ZOMBIE_VILLAGER_HURT,
+	ENTITY_ZOMBIE_VILLAGER_STEP,
+	ITEM_ARMOR_EQUIP_CHAIN,
+	ITEM_ARMOR_EQUIP_DIAMOND,
+	ITEM_ARMOR_EQUIP_GENERIC,
+	ITEM_ARMOR_EQUIP_GOLD,
+	ITEM_ARMOR_EQUIP_IRON,
+	ITEM_ARMOR_EQUIP_LEATHER,
+	ITEM_BOTTLE_FILL,
+	ITEM_BOTTLE_FILL_DRAGONBREATH,
+	ITEM_BUCKET_EMPTY,
+	ITEM_BUCKET_EMPTY_LAVA,
+	ITEM_BUCKET_FILL,
+	ITEM_BUCKET_FILL_LAVA,
+	ITEM_CHORUS_FRUIT_TELEPORT,
+	ITEM_ELYTRA_FLYING,
+	ITEM_FIRECHARGE_USE,
+	ITEM_FLINTANDSTEEL_USE,
+	ITEM_HOE_TILL,
+	ITEM_SHIELD_BLOCK,
+	ITEM_SHIELD_BREAK,
+	ITEM_SHOVEL_FLATTEN,
+	MUSIC_CREATIVE,
+	MUSIC_CREDITS,
+	MUSIC_DRAGON,
+	MUSIC_END,
+	MUSIC_GAME,
+	MUSIC_MENU,
+	MUSIC_NETHER,
+	RECORD_11,
+	RECORD_13,
+	RECORD_BLOCKS,
+	RECORD_CAT,
+	RECORD_CHIRP,
+	RECORD_FAR,
+	RECORD_MALL,
+	RECORD_MELLOHI,
+	RECORD_STAL,
+	RECORD_STRAD,
+	RECORD_WAIT,
+	RECORD_WARD,
+	UI_BUTTON_CLICK,
+	WEATHER_RAIN,
+	WEATHER_RAIN_ABOVE;
+	//...
+	
+	static {
+		//1.10
+		addSound(AMBIENT_CAVE, BigClientVersion.v1_10, "ambient.cave");
+		addSound(BLOCK_ANVIL_BREAK, BigClientVersion.v1_10, "block.anvil.break");
+		addSound(BLOCK_ANVIL_DESTROY, BigClientVersion.v1_10, "block.anvil.destroy");
+		addSound(BLOCK_ANVIL_FALL, BigClientVersion.v1_10, "block.anvil.fall");
+		addSound(BLOCK_ANVIL_HIT, BigClientVersion.v1_10, "block.anvil.hit");
+		addSound(BLOCK_ANVIL_LAND, BigClientVersion.v1_10, "block.anvil.land");
+		addSound(BLOCK_ANVIL_PLACE, BigClientVersion.v1_10, "block.anvil.place");
+		addSound(BLOCK_ANVIL_STEP, BigClientVersion.v1_10, "block.anvil.step");
+		addSound(BLOCK_ANVIL_USE, BigClientVersion.v1_10, "block.anvil.use");
+		addSound(BLOCK_BREWING_STAND_BREW, BigClientVersion.v1_10, "block.brewing_stand.brew");
+		addSound(BLOCK_CHEST_CLOSE, BigClientVersion.v1_10, "block.chest.close");
+		addSound(BLOCK_CHEST_LOCKED, BigClientVersion.v1_10, "block.chest.locked");
+		addSound(BLOCK_CHEST_OPEN, BigClientVersion.v1_10, "block.chest.open");
+		addSound(BLOCK_CHORUS_FLOWER_DEATH, BigClientVersion.v1_10, "block.chorus_flower.death");
+		addSound(BLOCK_CHORUS_FLOWER_GROW, BigClientVersion.v1_10, "block.chorus_flower.grow");
+		addSound(BLOCK_CLOTH_BREAK, BigClientVersion.v1_10, "block.cloth.break");
+		addSound(BLOCK_CLOTH_FALL, BigClientVersion.v1_10, "block.cloth.fall");
+		addSound(BLOCK_CLOTH_HIT, BigClientVersion.v1_10, "block.cloth.hit");
+		addSound(BLOCK_CLOTH_PLACE, BigClientVersion.v1_10, "block.cloth.place");
+		addSound(BLOCK_CLOTH_STEP, BigClientVersion.v1_10, "block.cloth.step");
+		addSound(BLOCK_COMPARATOR_CLICK, BigClientVersion.v1_10, "block.comparator.click");
+		addSound(BLOCK_DISPENSER_DISPENSE, BigClientVersion.v1_10, "block.dispenser.dispense");
+		addSound(BLOCK_DISPENSER_FAIL, BigClientVersion.v1_10, "block.dispenser.fail");
+		addSound(BLOCK_DISPENSER_LAUNCH, BigClientVersion.v1_10, "block.dispenser.launch");
+		addSound(BLOCK_ENCHANTMENT_TABLE_USE, BigClientVersion.v1_10, "block.enchantment_table.use");
+		addSound(BLOCK_END_GATEWAY_SPAWN, BigClientVersion.v1_10, "block.end_gateway.spawn");
+		addSound(BLOCK_ENDERCHEST_CLOSE, BigClientVersion.v1_10, "block.enderchest.close");
+		addSound(BLOCK_ENDERCHEST_OPEN, BigClientVersion.v1_10, "block.enderchest.open");
+		addSound(BLOCK_FENCE_GATE_CLOSE, BigClientVersion.v1_10, "block.fence_gate.close");
+		addSound(BLOCK_FENCE_GATE_OPEN, BigClientVersion.v1_10, "block.fence_gate.open");
+		addSound(BLOCK_FIRE_AMBIENT, BigClientVersion.v1_10, "block.fire.ambient");
+		addSound(BLOCK_FIRE_EXTINGUISH, BigClientVersion.v1_10, "block.fire.extinguish");
+		addSound(BLOCK_FURNACE_FIRE_CRACKLE, BigClientVersion.v1_10, "block.furnace.fire_crackle");
+		addSound(BLOCK_GLASS_BREAK, BigClientVersion.v1_10, "block.glass.break");
+		addSound(BLOCK_GLASS_FALL, BigClientVersion.v1_10, "block.glass.fall");
+		addSound(BLOCK_GLASS_HIT, BigClientVersion.v1_10, "block.glass.hit");
+		addSound(BLOCK_GLASS_PLACE, BigClientVersion.v1_10, "block.glass.place");
+		addSound(BLOCK_GLASS_STEP, BigClientVersion.v1_10, "block.glass.step");
+		addSound(BLOCK_GRASS_BREAK, BigClientVersion.v1_10, "block.grass.break");
+		addSound(BLOCK_GRASS_FALL, BigClientVersion.v1_10, "block.grass.fall");
+		addSound(BLOCK_GRASS_HIT, BigClientVersion.v1_10, "block.grass.hit");
+		addSound(BLOCK_GRASS_PLACE, BigClientVersion.v1_10, "block.grass.place");
+		addSound(BLOCK_GRASS_STEP, BigClientVersion.v1_10, "block.grass.step");
+		addSound(BLOCK_GRAVEL_BREAK, BigClientVersion.v1_10, "block.gravel.break");
+		addSound(BLOCK_GRAVEL_FALL, BigClientVersion.v1_10, "block.gravel.fall");
+		addSound(BLOCK_GRAVEL_HIT, BigClientVersion.v1_10, "block.gravel.hit");
+		addSound(BLOCK_GRAVEL_PLACE, BigClientVersion.v1_10, "block.gravel.place");
+		addSound(BLOCK_GRAVEL_STEP, BigClientVersion.v1_10, "block.gravel.step");
+		addSound(BLOCK_IRON_DOOR_CLOSE, BigClientVersion.v1_10, "block.iron_door.close");
+		addSound(BLOCK_IRON_DOOR_OPEN, BigClientVersion.v1_10, "block.iron_door.open");
+		addSound(BLOCK_IRON_TRAPDOOR_CLOSE, BigClientVersion.v1_10, "block.iron_trapdoor.close");
+		addSound(BLOCK_IRON_TRAPDOOR_OPEN, BigClientVersion.v1_10, "block.iron_trapdoor.open");
+		addSound(BLOCK_LADDER_BREAK, BigClientVersion.v1_10, "block.ladder.break");
+		addSound(BLOCK_LADDER_FALL, BigClientVersion.v1_10, "block.ladder.fall");
+		addSound(BLOCK_LADDER_HIT, BigClientVersion.v1_10, "block.ladder.hit");
+		addSound(BLOCK_LADDER_PLACE, BigClientVersion.v1_10, "block.ladder.place");
+		addSound(BLOCK_LADDER_STEP, BigClientVersion.v1_10, "block.ladder.step");
+		addSound(BLOCK_LAVA_AMBIENT, BigClientVersion.v1_10, "block.lava.ambient");
+		addSound(BLOCK_LAVA_EXTINGUISH, BigClientVersion.v1_10, "block.lava.extinguish");
+		addSound(BLOCK_LAVA_POP, BigClientVersion.v1_10, "block.lava.pop");
+		addSound(BLOCK_LEVER_CLICK, BigClientVersion.v1_10, "block.lever.click");
+		addSound(BLOCK_METAL_BREAK, BigClientVersion.v1_10, "block.metal.break");
+		addSound(BLOCK_METAL_FALL, BigClientVersion.v1_10, "block.metal.fall");
+		addSound(BLOCK_METAL_HIT, BigClientVersion.v1_10, "block.metal.hit");
+		addSound(BLOCK_METAL_PLACE, BigClientVersion.v1_10, "block.metal.place");
+		addSound(BLOCK_METAL_STEP, BigClientVersion.v1_10, "block.metal.step");
+		addSound(BLOCK_METAL_PRESSUREPLATE_CLICK_OFF, BigClientVersion.v1_10, "block.metal_pressureplate.click_off");
+		addSound(BLOCK_METAL_PRESSUREPLATE_CLICK_ON, BigClientVersion.v1_10, "block.metal_pressureplate.click_on");
+		addSound(BLOCK_NOTE_BASEDRUM, BigClientVersion.v1_10, "block.note.basedrum");
+		addSound(BLOCK_NOTE_BASS, BigClientVersion.v1_10, "block.note.bass");
+		addSound(BLOCK_NOTE_HARP, BigClientVersion.v1_10, "block.note.harp");
+		addSound(BLOCK_NOTE_HAT, BigClientVersion.v1_10, "block.note.hat");
+		addSound(BLOCK_NOTE_PLING, BigClientVersion.v1_10, "block.note.pling");
+		addSound(BLOCK_NOTE_SNARE, BigClientVersion.v1_10, "block.note.snare");
+		addSound(BLOCK_PISTON_CONTRACT, BigClientVersion.v1_10, "block.piston.contract");
+		addSound(BLOCK_PISTON_EXTEND, BigClientVersion.v1_10, "block.piston.extend");
+		addSound(BLOCK_PORTAL_AMBIENT, BigClientVersion.v1_10, "block.portal.ambient");
+		addSound(BLOCK_PORTAL_TRAVEL, BigClientVersion.v1_10, "block.portal.travel");
+		addSound(BLOCK_PORTAL_TRIGGER, BigClientVersion.v1_10, "block.portal.trigger");
+		addSound(BLOCK_REDSTONE_TORCH_BURNOUT, BigClientVersion.v1_10, "block.redstone_torch.burnout");
+		addSound(BLOCK_SAND_BREAK, BigClientVersion.v1_10, "block.sand.break");
+		addSound(BLOCK_SAND_FALL, BigClientVersion.v1_10, "block.sand.fall");
+		addSound(BLOCK_SAND_HIT, BigClientVersion.v1_10, "block.sand.hit");
+		addSound(BLOCK_SAND_PLACE, BigClientVersion.v1_10, "block.sand.place");
+		addSound(BLOCK_SAND_STEP, BigClientVersion.v1_10, "block.sand.step");
+		addSound(BLOCK_SLIME_BREAK, BigClientVersion.v1_10, "block.slime.break");
+		addSound(BLOCK_SLIME_FALL, BigClientVersion.v1_10, "block.slime.fall");
+		addSound(BLOCK_SLIME_HIT, BigClientVersion.v1_10, "block.slime.hit");
+		addSound(BLOCK_SLIME_PLACE, BigClientVersion.v1_10, "block.slime.place");
+		addSound(BLOCK_SLIME_STEP, BigClientVersion.v1_10, "block.slime.step");
+		addSound(BLOCK_SNOW_BREAK, BigClientVersion.v1_10, "block.snow.break");
+		addSound(BLOCK_SNOW_FALL, BigClientVersion.v1_10, "block.snow.fall");
+		addSound(BLOCK_SNOW_HIT, BigClientVersion.v1_10, "block.snow.hit");
+		addSound(BLOCK_SNOW_PLACE, BigClientVersion.v1_10, "block.snow.place");
+		addSound(BLOCK_SNOW_STEP, BigClientVersion.v1_10, "block.snow.step");
+		addSound(BLOCK_STONE_BREAK, BigClientVersion.v1_10, "block.stone.break");
+		addSound(BLOCK_STONE_FALL, BigClientVersion.v1_10, "block.stone.fall");
+		addSound(BLOCK_STONE_HIT, BigClientVersion.v1_10, "block.stone.hit");
+		addSound(BLOCK_STONE_PLACE, BigClientVersion.v1_10, "block.stone.place");
+		addSound(BLOCK_STONE_STEP, BigClientVersion.v1_10, "block.stone.step");
+		addSound(BLOCK_STONE_BUTTON_CLICK_OFF, BigClientVersion.v1_10, "block.stone_button.click_off");
+		addSound(BLOCK_STONE_BUTTON_CLICK_ON, BigClientVersion.v1_10, "block.stone_button.click_on");
+		addSound(BLOCK_STONE_PRESSUREPLATE_CLICK_OFF, BigClientVersion.v1_10, "block.stone_pressureplate.click_off");
+		addSound(BLOCK_STONE_PRESSUREPLATE_CLICK_ON, BigClientVersion.v1_10, "block.stone_pressureplate.click_on");
+		addSound(BLOCK_TRIPWIRE_ATTACH, BigClientVersion.v1_10, "block.tripwire.attach");
+		addSound(BLOCK_TRIPWIRE_CLICK_OFF, BigClientVersion.v1_10, "block.tripwire.click_off");
+		addSound(BLOCK_TRIPWIRE_CLICK_ON, BigClientVersion.v1_10, "block.tripwire.click_on");
+		addSound(BLOCK_TRIPWIRE_DETACH, BigClientVersion.v1_10, "block.tripwire.detach");
+		addSound(BLOCK_WATER_AMBIENT, BigClientVersion.v1_10, "block.water.ambient");
+		addSound(BLOCK_WATERLILY_PLACE, BigClientVersion.v1_10, "block.waterlily.place");
+		addSound(BLOCK_WOOD_BREAK, BigClientVersion.v1_10, "block.wood.break");
+		addSound(BLOCK_WOOD_FALL, BigClientVersion.v1_10, "block.wood.fall");
+		addSound(BLOCK_WOOD_HIT, BigClientVersion.v1_10, "block.wood.hit");
+		addSound(BLOCK_WOOD_PLACE, BigClientVersion.v1_10, "block.wood.place");
+		addSound(BLOCK_WOOD_STEP, BigClientVersion.v1_10, "block.wood.step");
+		addSound(BLOCK_WOOD_BUTTON_CLICK_OFF, BigClientVersion.v1_10, "block.wood_button.click_off");
+		addSound(BLOCK_WOOD_BUTTON_CLICK_ON, BigClientVersion.v1_10, "block.wood_button.click_on");
+		addSound(BLOCK_WOOD_PRESSUREPLATE_CLICK_OFF, BigClientVersion.v1_10, "block.wood_pressureplate.click_off");
+		addSound(BLOCK_WOOD_PRESSUREPLATE_CLICK_ON, BigClientVersion.v1_10, "block.wood_pressureplate.click_on");
+		addSound(BLOCK_WOODEN_DOOR_CLOSE, BigClientVersion.v1_10, "block.wooden_door.close");
+		addSound(BLOCK_WOODEN_DOOR_OPEN, BigClientVersion.v1_10, "block.wooden_door.open");
+		addSound(BLOCK_WOODEN_TRAPDOOR_CLOSE, BigClientVersion.v1_10, "block.wooden_trapdoor.close");
+		addSound(BLOCK_WOODEN_TRAPDOOR_OPEN, BigClientVersion.v1_10, "block.wooden_trapdoor.open");
+		addSound(ENCHANT_THORNS_HIT, BigClientVersion.v1_10, "enchant.thorns.hit");
+		addSound(ENTITY_ARMORSTAND_BREAK, BigClientVersion.v1_10, "entity.armorstand.break");
+		addSound(ENTITY_ARMORSTAND_FALL, BigClientVersion.v1_10, "entity.armorstand.fall");
+		addSound(ENTITY_ARMORSTAND_HIT, BigClientVersion.v1_10, "entity.armorstand.hit");
+		addSound(ENTITY_ARMORSTAND_PLACE, BigClientVersion.v1_10, "entity.armorstand.place");
+		addSound(ENTITY_ARROW_HIT, BigClientVersion.v1_10, "entity.arrow.hit");
+		addSound(ENTITY_ARROW_HIT_PLAYER, BigClientVersion.v1_10, "entity.arrow.hit_player");
+		addSound(ENTITY_ARROW_SHOOT, BigClientVersion.v1_10, "entity.arrow.shoot");
+		addSound(ENTITY_BAT_AMBIENT, BigClientVersion.v1_10, "entity.bat.ambient");
+		addSound(ENTITY_BAT_DEATH, BigClientVersion.v1_10, "entity.bat.death");
+		addSound(ENTITY_BAT_HURT, BigClientVersion.v1_10, "entity.bat.hurt");
+		addSound(ENTITY_BAT_LOOP, BigClientVersion.v1_10, "entity.bat.loop");
+		addSound(ENTITY_BAT_TAKEOFF, BigClientVersion.v1_10, "entity.bat.takeoff");
+		addSound(ENTITY_BLAZE_AMBIENT, BigClientVersion.v1_10, "entity.blaze.ambient");
+		addSound(ENTITY_BLAZE_BURN, BigClientVersion.v1_10, "entity.blaze.burn");
+		addSound(ENTITY_BLAZE_DEATH, BigClientVersion.v1_10, "entity.blaze.death");
+		addSound(ENTITY_BLAZE_HURT, BigClientVersion.v1_10, "entity.blaze.hurt");
+		addSound(ENTITY_BLAZE_SHOOT, BigClientVersion.v1_10, "entity.blaze.shoot");
+		addSound(ENTITY_BOBBER_SPLASH, BigClientVersion.v1_10, "entity.bobber.splash");
+		addSound(ENTITY_BOBBER_THROW, BigClientVersion.v1_10, "entity.bobber.throw");
+		addSound(ENTITY_CAT_AMBIENT, BigClientVersion.v1_10, "entity.cat.ambient");
+		addSound(ENTITY_CAT_DEATH, BigClientVersion.v1_10, "entity.cat.death");
+		addSound(ENTITY_CAT_HISS, BigClientVersion.v1_10, "entity.cat.hiss");
+		addSound(ENTITY_CAT_HURT, BigClientVersion.v1_10, "entity.cat.hurt");
+		addSound(ENTITY_CAT_PURR, BigClientVersion.v1_10, "entity.cat.purr");
+		addSound(ENTITY_CAT_PURREOW, BigClientVersion.v1_10, "entity.cat.purreow");
+		addSound(ENTITY_CHICKEN_AMBIENT, BigClientVersion.v1_10, "entity.chicken.ambient");
+		addSound(ENTITY_CHICKEN_DEATH, BigClientVersion.v1_10, "entity.chicken.death");
+		addSound(ENTITY_CHICKEN_EGG, BigClientVersion.v1_10, "entity.chicken.egg");
+		addSound(ENTITY_CHICKEN_HURT, BigClientVersion.v1_10, "entity.chicken.hurt");
+		addSound(ENTITY_CHICKEN_STEP, BigClientVersion.v1_10, "entity.chicken.step");
+		addSound(ENTITY_COW_AMBIENT, BigClientVersion.v1_10, "entity.cow.ambient");
+		addSound(ENTITY_COW_DEATH, BigClientVersion.v1_10, "entity.cow.death");
+		addSound(ENTITY_COW_HURT, BigClientVersion.v1_10, "entity.cow.hurt");
+		addSound(ENTITY_COW_MILK, BigClientVersion.v1_10, "entity.cow.milk");
+		addSound(ENTITY_COW_STEP, BigClientVersion.v1_10, "entity.cow.step");
+		addSound(ENTITY_CREEPER_DEATH, BigClientVersion.v1_10, "entity.creeper.death");
+		addSound(ENTITY_CREEPER_HURT, BigClientVersion.v1_10, "entity.creeper.hurt");
+		addSound(ENTITY_CREEPER_PRIMED, BigClientVersion.v1_10, "entity.creeper.primed");
+		addSound(ENTITY_DONKEY_AMBIENT, BigClientVersion.v1_10, "entity.donkey.ambient");
+		addSound(ENTITY_DONKEY_ANGRY, BigClientVersion.v1_10, "entity.donkey.angry");
+		addSound(ENTITY_DONKEY_CHEST, BigClientVersion.v1_10, "entity.donkey.chest");
+		addSound(ENTITY_DONKEY_DEATH, BigClientVersion.v1_10, "entity.donkey.death");
+		addSound(ENTITY_DONKEY_HURT, BigClientVersion.v1_10, "entity.donkey.hurt");
+		addSound(ENTITY_EGG_THROW, BigClientVersion.v1_10, "entity.egg.throw");
+		addSound(ENTITY_ELDER_GUARDIAN_AMBIENT, BigClientVersion.v1_10, "entity.elder_guardian.ambient");
+		addSound(ENTITY_ELDER_GUARDIAN_AMBIENT_LAND, BigClientVersion.v1_10, "entity.elder_guardian.ambient_land");
+		addSound(ENTITY_ELDER_GUARDIAN_CURSE, BigClientVersion.v1_10, "entity.elder_guardian.curse");
+		addSound(ENTITY_ELDER_GUARDIAN_DEATH, BigClientVersion.v1_10, "entity.elder_guardian.death");
+		addSound(ENTITY_ELDER_GUARDIAN_DEATH_LAND, BigClientVersion.v1_10, "entity.elder_guardian.death_land");
+		addSound(ENTITY_ELDER_GUARDIAN_HURT, BigClientVersion.v1_10, "entity.elder_guardian.hurt");
+		addSound(ENTITY_ELDER_GUARDIAN_HURT_LAND, BigClientVersion.v1_10, "entity.elder_guardian.hurt_land");
+		addSound(ENTITY_ENDERDRAGON_AMBIENT, BigClientVersion.v1_10, "entity.enderdragon.ambient");
+		addSound(ENTITY_ENDERDRAGON_DEATH, BigClientVersion.v1_10, "entity.enderdragon.death");
+		addSound(ENTITY_ENDERDRAGON_FLAP, BigClientVersion.v1_10, "entity.enderdragon.flap");
+		addSound(ENTITY_ENDERDRAGON_GROWL, BigClientVersion.v1_10, "entity.enderdragon.growl");
+		addSound(ENTITY_ENDERDRAGON_HURT, BigClientVersion.v1_10, "entity.enderdragon.hurt");
+		addSound(ENTITY_ENDERDRAGON_SHOOT, BigClientVersion.v1_10, "entity.enderdragon.shoot");
+		addSound(ENTITY_ENDERDRAGON_FIREBALL_EXPLODE, BigClientVersion.v1_10, "entity.enderdragon_fireball.explode");
+		addSound(ENTITY_ENDEREYE_LAUNCH, BigClientVersion.v1_10, "entity.endereye.launch");
+		addSound(ENTITY_ENDERMEN_AMBIENT, BigClientVersion.v1_10, "entity.endermen.ambient");
+		addSound(ENTITY_ENDERMEN_DEATH, BigClientVersion.v1_10, "entity.endermen.death");
+		addSound(ENTITY_ENDERMEN_HURT, BigClientVersion.v1_10, "entity.endermen.hurt");
+		addSound(ENTITY_ENDERMEN_SCREAM, BigClientVersion.v1_10, "entity.endermen.scream");
+		addSound(ENTITY_ENDERMEN_STARE, BigClientVersion.v1_10, "entity.endermen.stare");
+		addSound(ENTITY_ENDERMEN_TELEPORT, BigClientVersion.v1_10, "entity.endermen.teleport");
+		addSound(ENTITY_ENDERMITE_AMBIENT, BigClientVersion.v1_10, "entity.endermite.ambient");
+		addSound(ENTITY_ENDERMITE_DEATH, BigClientVersion.v1_10, "entity.endermite.death");
+		addSound(ENTITY_ENDERMITE_HURT, BigClientVersion.v1_10, "entity.endermite.hurt");
+		addSound(ENTITY_ENDERMITE_STEP, BigClientVersion.v1_10, "entity.endermite.step");
+		addSound(ENTITY_ENDERPEARL_THROW, BigClientVersion.v1_10, "entity.enderpearl.throw");
+		addSound(ENTITY_EXPERIENCE_BOTTLE_THROW, BigClientVersion.v1_10, "entity.experience_bottle.throw");
+		addSound(ENTITY_EXPERIENCE_ORB_PICKUP, BigClientVersion.v1_10, "entity.experience_orb.pickup");
+		addSound(ENTITY_EXPERIENCE_ORB_TOUCH, BigClientVersion.v1_10, "entity.experience_orb.touch");
+		addSound(ENTITY_FIREWORK_BLAST, BigClientVersion.v1_10, "entity.firework.blast");
+		addSound(ENTITY_FIREWORK_BLAST_FAR, BigClientVersion.v1_10, "entity.firework.blast_far");
+		addSound(ENTITY_FIREWORK_LARGE_BLAST, BigClientVersion.v1_10, "entity.firework.large_blast");
+		addSound(ENTITY_FIREWORK_LARGE_BLAST_FAR, BigClientVersion.v1_10, "entity.firework.large_blast_far");
+		addSound(ENTITY_FIREWORK_LAUNCH, BigClientVersion.v1_10, "entity.firework.launch");
+		addSound(ENTITY_FIREWORK_SHOOT, BigClientVersion.v1_10, "entity.firework.shoot");
+		addSound(ENTITY_FIREWORK_TWINKLE, BigClientVersion.v1_10, "entity.firework.twinkle");
+		addSound(ENTITY_FIREWORK_TWINKLE_FAR, BigClientVersion.v1_10, "entity.firework.twinkle_far");
+		addSound(ENTITY_GENERIC_BIG_FALL, BigClientVersion.v1_10, "entity.generic.big_fall");
+		addSound(ENTITY_GENERIC_BURN, BigClientVersion.v1_10, "entity.generic.burn");
+		addSound(ENTITY_GENERIC_DEATH, BigClientVersion.v1_10, "entity.generic.death");
+		addSound(ENTITY_GENERIC_DRINK, BigClientVersion.v1_10, "entity.generic.drink");
+		addSound(ENTITY_GENERIC_EAT, BigClientVersion.v1_10, "entity.generic.eat");
+		addSound(ENTITY_GENERIC_EXPLODE, BigClientVersion.v1_10, "entity.generic.explode");
+		addSound(ENTITY_GENERIC_EXTINGUISH_FIRE, BigClientVersion.v1_10, "entity.generic.extinguish_fire");
+		addSound(ENTITY_GENERIC_HURT, BigClientVersion.v1_10, "entity.generic.hurt");
+		addSound(ENTITY_GENERIC_SMALL_FALL, BigClientVersion.v1_10, "entity.generic.small_fall");
+		addSound(ENTITY_GENERIC_SPLASH, BigClientVersion.v1_10, "entity.generic.splash");
+		addSound(ENTITY_GENERIC_SWIM, BigClientVersion.v1_10, "entity.generic.swim");
+		addSound(ENTITY_GHAST_AMBIENT, BigClientVersion.v1_10, "entity.ghast.ambient");
+		addSound(ENTITY_GHAST_DEATH, BigClientVersion.v1_10, "entity.ghast.death");
+		addSound(ENTITY_GHAST_HURT, BigClientVersion.v1_10, "entity.ghast.hurt");
+		addSound(ENTITY_GHAST_SCREAM, BigClientVersion.v1_10, "entity.ghast.scream");
+		addSound(ENTITY_GHAST_SHOOT, BigClientVersion.v1_10, "entity.ghast.shoot");
+		addSound(ENTITY_GHAST_WARN, BigClientVersion.v1_10, "entity.ghast.warn");
+		addSound(ENTITY_GUARDIAN_AMBIENT, BigClientVersion.v1_10, "entity.guardian.ambient");
+		addSound(ENTITY_GUARDIAN_AMBIENT_LAND, BigClientVersion.v1_10, "entity.guardian.ambient_land");
+		addSound(ENTITY_GUARDIAN_ATTACK, BigClientVersion.v1_10, "entity.guardian.attack");
+		addSound(ENTITY_GUARDIAN_DEATH, BigClientVersion.v1_10, "entity.guardian.death");
+		addSound(ENTITY_GUARDIAN_DEATH_LAND, BigClientVersion.v1_10, "entity.guardian.death_land");
+		addSound(ENTITY_GUARDIAN_FLOP, BigClientVersion.v1_10, "entity.guardian.flop");
+		addSound(ENTITY_GUARDIAN_HURT, BigClientVersion.v1_10, "entity.guardian.hurt");
+		addSound(ENTITY_GUARDIAN_HURT_LAND, BigClientVersion.v1_10, "entity.guardian.hurt_land");
+		addSound(ENTITY_HORSE_AMBIENT, BigClientVersion.v1_10, "entity.horse.ambient");
+		addSound(ENTITY_HORSE_ANGRY, BigClientVersion.v1_10, "entity.horse.angry");
+		addSound(ENTITY_HORSE_ARMOR, BigClientVersion.v1_10, "entity.horse.armor");
+		addSound(ENTITY_HORSE_BREATHE, BigClientVersion.v1_10, "entity.horse.breathe");
+		addSound(ENTITY_HORSE_DEATH, BigClientVersion.v1_10, "entity.horse.death");
+		addSound(ENTITY_HORSE_EAT, BigClientVersion.v1_10, "entity.horse.eat");
+		addSound(ENTITY_HORSE_GALLOP, BigClientVersion.v1_10, "entity.horse.gallop");
+		addSound(ENTITY_HORSE_HURT, BigClientVersion.v1_10, "entity.horse.hurt");
+		addSound(ENTITY_HORSE_JUMP, BigClientVersion.v1_10, "entity.horse.jump");
+		addSound(ENTITY_HORSE_LAND, BigClientVersion.v1_10, "entity.horse.land");
+		addSound(ENTITY_HORSE_SADDLE, BigClientVersion.v1_10, "entity.horse.saddle");
+		addSound(ENTITY_HORSE_STEP, BigClientVersion.v1_10, "entity.horse.step");
+		addSound(ENTITY_HORSE_STEP_WOOD, BigClientVersion.v1_10, "entity.horse.step_wood");
+		addSound(ENTITY_HOSTILE_BIG_FALL, BigClientVersion.v1_10, "entity.hostile.big_fall");
+		addSound(ENTITY_HOSTILE_DEATH, BigClientVersion.v1_10, "entity.hostile.death");
+		addSound(ENTITY_HOSTILE_HURT, BigClientVersion.v1_10, "entity.hostile.hurt");
+		addSound(ENTITY_HOSTILE_SMALL_FALL, BigClientVersion.v1_10, "entity.hostile.small_fall");
+		addSound(ENTITY_HOSTILE_SPLASH, BigClientVersion.v1_10, "entity.hostile.splash");
+		addSound(ENTITY_HOSTILE_SWIM, BigClientVersion.v1_10, "entity.hostile.swim");
+		addSound(ENTITY_HUSK_AMBIENT, BigClientVersion.v1_10, "entity.husk.ambient");
+		addSound(ENTITY_HUSK_DEATH, BigClientVersion.v1_10, "entity.husk.death");
+		addSound(ENTITY_HUSK_HURT, BigClientVersion.v1_10, "entity.husk.hurt");
+		addSound(ENTITY_HUSK_STEP, BigClientVersion.v1_10, "entity.husk.step");
+		addSound(ENTITY_IRONGOLEM_ATTACK, BigClientVersion.v1_10, "entity.irongolem.attack");
+		addSound(ENTITY_IRONGOLEM_DEATH, BigClientVersion.v1_10, "entity.irongolem.death");
+		addSound(ENTITY_IRONGOLEM_HURT, BigClientVersion.v1_10, "entity.irongolem.hurt");
+		addSound(ENTITY_IRONGOLEM_STEP, BigClientVersion.v1_10, "entity.irongolem.step");
+		addSound(ENTITY_ITEM_BREAK, BigClientVersion.v1_10, "entity.item.break");
+		addSound(ENTITY_ITEM_PICKUP, BigClientVersion.v1_10, "entity.item.pickup");
+		addSound(ENTITY_ITEMFRAME_ADD_ITEM, BigClientVersion.v1_10, "entity.itemframe.add_item");
+		addSound(ENTITY_ITEMFRAME_BREAK, BigClientVersion.v1_10, "entity.itemframe.break");
+		addSound(ENTITY_ITEMFRAME_PLACE, BigClientVersion.v1_10, "entity.itemframe.place");
+		addSound(ENTITY_ITEMFRAME_REMOVE_ITEM, BigClientVersion.v1_10, "entity.itemframe.remove_item");
+		addSound(ENTITY_ITEMFRAME_ROTATE_ITEM, BigClientVersion.v1_10, "entity.itemframe.rotate_item");
+		addSound(ENTITY_LEASHKNOT_BREAK, BigClientVersion.v1_10, "entity.leashknot.break");
+		addSound(ENTITY_LEASHKNOT_PLACE, BigClientVersion.v1_10, "entity.leashknot.place");
+		addSound(ENTITY_LIGHTNING_IMPACT, BigClientVersion.v1_10, "entity.lightning.impact");
+		addSound(ENTITY_LIGHTNING_THUNDER, BigClientVersion.v1_10, "entity.lightning.thunder");
+		addSound(ENTITY_LINGERINGPOTION_THROW, BigClientVersion.v1_10, "entity.lingeringpotion.throw");
+		addSound(ENTITY_MAGMACUBE_DEATH, BigClientVersion.v1_10, "entity.magmacube.death");
+		addSound(ENTITY_MAGMACUBE_HURT, BigClientVersion.v1_10, "entity.magmacube.hurt");
+		addSound(ENTITY_MAGMACUBE_JUMP, BigClientVersion.v1_10, "entity.magmacube.jump");
+		addSound(ENTITY_MAGMACUBE_SQUISH, BigClientVersion.v1_10, "entity.magmacube.squish");
+		addSound(ENTITY_MINECART_INSIDE, BigClientVersion.v1_10, "entity.minecart.inside");
+		addSound(ENTITY_MINECART_RIDING, BigClientVersion.v1_10, "entity.minecart.riding");
+		addSound(ENTITY_MOOSHROOM_SHEAR, BigClientVersion.v1_10, "entity.mooshroom.shear");
+		addSound(ENTITY_MULE_AMBIENT, BigClientVersion.v1_10, "entity.mule.ambient");
+		addSound(ENTITY_MULE_DEATH, BigClientVersion.v1_10, "entity.mule.death");
+		addSound(ENTITY_MULE_HURT, BigClientVersion.v1_10, "entity.mule.hurt");
+		addSound(ENTITY_PAINTING_BREAK, BigClientVersion.v1_10, "entity.painting.break");
+		addSound(ENTITY_PAINTING_PLACE, BigClientVersion.v1_10, "entity.painting.place");
+		addSound(ENTITY_PIG_AMBIENT, BigClientVersion.v1_10, "entity.pig.ambient");
+		addSound(ENTITY_PIG_DEATH, BigClientVersion.v1_10, "entity.pig.death");
+		addSound(ENTITY_PIG_HURT, BigClientVersion.v1_10, "entity.pig.hurt");
+		addSound(ENTITY_PIG_SADDLE, BigClientVersion.v1_10, "entity.pig.saddle");
+		addSound(ENTITY_PIG_STEP, BigClientVersion.v1_10, "entity.pig.step");
+		addSound(ENTITY_PLAYER_ATTACK_CRIT, BigClientVersion.v1_10, "entity.player.attack.crit");
+		addSound(ENTITY_PLAYER_ATTACK_KNOCKBACK, BigClientVersion.v1_10, "entity.player.attack.knockback");
+		addSound(ENTITY_PLAYER_ATTACK_NODAMAGE, BigClientVersion.v1_10, "entity.player.attack.nodamage");
+		addSound(ENTITY_PLAYER_ATTACK_STRONG, BigClientVersion.v1_10, "entity.player.attack.strong");
+		addSound(ENTITY_PLAYER_ATTACK_SWEEP, BigClientVersion.v1_10, "entity.player.attack.sweep");
+		addSound(ENTITY_PLAYER_ATTACK_WEAK, BigClientVersion.v1_10, "entity.player.attack.weak");
+		addSound(ENTITY_PLAYER_BIG_FALL, BigClientVersion.v1_10, "entity.player.big_fall");
+		addSound(ENTITY_PLAYER_BREATH, BigClientVersion.v1_10, "entity.player.breath");
+		addSound(ENTITY_PLAYER_BURP, BigClientVersion.v1_10, "entity.player.burp");
+		addSound(ENTITY_PLAYER_DEATH, BigClientVersion.v1_10, "entity.player.death");
+		addSound(ENTITY_PLAYER_HURT, BigClientVersion.v1_10, "entity.player.hurt");
+		addSound(ENTITY_PLAYER_LEVELUP, BigClientVersion.v1_10, "entity.player.levelup");
+		addSound(ENTITY_PLAYER_SMALL_FALL, BigClientVersion.v1_10, "entity.player.small_fall");
+		addSound(ENTITY_PLAYER_SPLASH, BigClientVersion.v1_10, "entity.player.splash");
+		addSound(ENTITY_PLAYER_SWIM, BigClientVersion.v1_10, "entity.player.swim");
+		addSound(ENTITY_POLAR_BEAR_AMBIENT, BigClientVersion.v1_10, "entity.polar_bear.ambient");
+		addSound(ENTITY_POLAR_BEAR_BABY_AMBIENT, BigClientVersion.v1_10, "entity.polar_bear.baby_ambient");
+		addSound(ENTITY_POLAR_BEAR_DEATH, BigClientVersion.v1_10, "entity.polar_bear.death");
+		addSound(ENTITY_POLAR_BEAR_HURT, BigClientVersion.v1_10, "entity.polar_bear.hurt");
+		addSound(ENTITY_POLAR_BEAR_STEP, BigClientVersion.v1_10, "entity.polar_bear.step");
+		addSound(ENTITY_POLAR_BEAR_WARNING, BigClientVersion.v1_10, "entity.polar_bear.warning");
+		addSound(ENTITY_RABBIT_AMBIENT, BigClientVersion.v1_10, "entity.rabbit.ambient");
+		addSound(ENTITY_RABBIT_ATTACK, BigClientVersion.v1_10, "entity.rabbit.attack");
+		addSound(ENTITY_RABBIT_DEATH, BigClientVersion.v1_10, "entity.rabbit.death");
+		addSound(ENTITY_RABBIT_HURT, BigClientVersion.v1_10, "entity.rabbit.hurt");
+		addSound(ENTITY_RABBIT_JUMP, BigClientVersion.v1_10, "entity.rabbit.jump");
+		addSound(ENTITY_SHEEP_AMBIENT, BigClientVersion.v1_10, "entity.sheep.ambient");
+		addSound(ENTITY_SHEEP_DEATH, BigClientVersion.v1_10, "entity.sheep.death");
+		addSound(ENTITY_SHEEP_HURT, BigClientVersion.v1_10, "entity.sheep.hurt");
+		addSound(ENTITY_SHEEP_SHEAR, BigClientVersion.v1_10, "entity.sheep.shear");
+		addSound(ENTITY_SHEEP_STEP, BigClientVersion.v1_10, "entity.sheep.step");
+		addSound(ENTITY_SHULKER_AMBIENT, BigClientVersion.v1_10, "entity.shulker.ambient");
+		addSound(ENTITY_SHULKER_CLOSE, BigClientVersion.v1_10, "entity.shulker.close");
+		addSound(ENTITY_SHULKER_DEATH, BigClientVersion.v1_10, "entity.shulker.death");
+		addSound(ENTITY_SHULKER_HURT, BigClientVersion.v1_10, "entity.shulker.hurt");
+		addSound(ENTITY_SHULKER_HURT_CLOSED, BigClientVersion.v1_10, "entity.shulker.hurt_closed");
+		addSound(ENTITY_SHULKER_OPEN, BigClientVersion.v1_10, "entity.shulker.open");
+		addSound(ENTITY_SHULKER_SHOOT, BigClientVersion.v1_10, "entity.shulker.shoot");
+		addSound(ENTITY_SHULKER_TELEPORT, BigClientVersion.v1_10, "entity.shulker.teleport");
+		addSound(ENTITY_SHULKER_BULLET_HIT, BigClientVersion.v1_10, "entity.shulker_bullet.hit");
+		addSound(ENTITY_SHULKER_BULLET_HURT, BigClientVersion.v1_10, "entity.shulker_bullet.hurt");
+		addSound(ENTITY_SILVERFISH_AMBIENT, BigClientVersion.v1_10, "entity.silverfish.ambient");
+		addSound(ENTITY_SILVERFISH_DEATH, BigClientVersion.v1_10, "entity.silverfish.death");
+		addSound(ENTITY_SILVERFISH_HURT, BigClientVersion.v1_10, "entity.silverfish.hurt");
+		addSound(ENTITY_SILVERFISH_STEP, BigClientVersion.v1_10, "entity.silverfish.step");
+		addSound(ENTITY_SKELETON_AMBIENT, BigClientVersion.v1_10, "entity.skeleton.ambient");
+		addSound(ENTITY_SKELETON_DEATH, BigClientVersion.v1_10, "entity.skeleton.death");
+		addSound(ENTITY_SKELETON_HURT, BigClientVersion.v1_10, "entity.skeleton.hurt");
+		addSound(ENTITY_SKELETON_SHOOT, BigClientVersion.v1_10, "entity.skeleton.shoot");
+		addSound(ENTITY_SKELETON_STEP, BigClientVersion.v1_10, "entity.skeleton.step");
+		addSound(ENTITY_SKELETON_HORSE_AMBIENT, BigClientVersion.v1_10, "entity.skeleton_horse.ambient");
+		addSound(ENTITY_SKELETON_HORSE_DEATH, BigClientVersion.v1_10, "entity.skeleton_horse.death");
+		addSound(ENTITY_SKELETON_HORSE_HURT, BigClientVersion.v1_10, "entity.skeleton_horse.hurt");
+		addSound(ENTITY_SLIME_ATTACK, BigClientVersion.v1_10, "entity.slime.attack");
+		addSound(ENTITY_SLIME_DEATH, BigClientVersion.v1_10, "entity.slime.death");
+		addSound(ENTITY_SLIME_HURT, BigClientVersion.v1_10, "entity.slime.hurt");
+		addSound(ENTITY_SLIME_JUMP, BigClientVersion.v1_10, "entity.slime.jump");
+		addSound(ENTITY_SLIME_SQUISH, BigClientVersion.v1_10, "entity.slime.squish");
+		addSound(ENTITY_SMALL_MAGMACUBE_DEATH, BigClientVersion.v1_10, "entity.small_magmacube.death");
+		addSound(ENTITY_SMALL_MAGMACUBE_HURT, BigClientVersion.v1_10, "entity.small_magmacube.hurt");
+		addSound(ENTITY_SMALL_MAGMACUBE_SQUISH, BigClientVersion.v1_10, "entity.small_magmacube.squish");
+		addSound(ENTITY_SMALL_SLIME_DEATH, BigClientVersion.v1_10, "entity.small_slime.death");
+		addSound(ENTITY_SMALL_SLIME_HURT, BigClientVersion.v1_10, "entity.small_slime.hurt");
+		addSound(ENTITY_SMALL_SLIME_JUMP, BigClientVersion.v1_10, "entity.small_slime.jump");
+		addSound(ENTITY_SMALL_SLIME_SQUISH, BigClientVersion.v1_10, "entity.small_slime.squish");
+		addSound(ENTITY_SNOWBALL_THROW, BigClientVersion.v1_10, "entity.snowball.throw");
+		addSound(ENTITY_SNOWMAN_AMBIENT, BigClientVersion.v1_10, "entity.snowman.ambient");
+		addSound(ENTITY_SNOWMAN_DEATH, BigClientVersion.v1_10, "entity.snowman.death");
+		addSound(ENTITY_SNOWMAN_HURT, BigClientVersion.v1_10, "entity.snowman.hurt");
+		addSound(ENTITY_SNOWMAN_SHOOT, BigClientVersion.v1_10, "entity.snowman.shoot");
+		addSound(ENTITY_SPIDER_AMBIENT, BigClientVersion.v1_10, "entity.spider.ambient");
+		addSound(ENTITY_SPIDER_DEATH, BigClientVersion.v1_10, "entity.spider.death");
+		addSound(ENTITY_SPIDER_HURT, BigClientVersion.v1_10, "entity.spider.hurt");
+		addSound(ENTITY_SPIDER_STEP, BigClientVersion.v1_10, "entity.spider.step");
+		addSound(ENTITY_SPLASH_POTION_BREAK, BigClientVersion.v1_10, "entity.splash_potion.break");
+		addSound(ENTITY_SPLASH_POTION_THROW, BigClientVersion.v1_10, "entity.splash_potion.throw");
+		addSound(ENTITY_SQUID_AMBIENT, BigClientVersion.v1_10, "entity.squid.ambient");
+		addSound(ENTITY_SQUID_DEATH, BigClientVersion.v1_10, "entity.squid.death");
+		addSound(ENTITY_SQUID_HURT, BigClientVersion.v1_10, "entity.squid.hurt");
+		addSound(ENTITY_STRAY_AMBIENT, BigClientVersion.v1_10, "entity.stray.ambient");
+		addSound(ENTITY_STRAY_DEATH, BigClientVersion.v1_10, "entity.stray.death");
+		addSound(ENTITY_STRAY_HURT, BigClientVersion.v1_10, "entity.stray.hurt");
+		addSound(ENTITY_STRAY_STEP, BigClientVersion.v1_10, "entity.stray.step");
+		addSound(ENTITY_TNT_PRIMED, BigClientVersion.v1_10, "entity.tnt.primed");
+		addSound(ENTITY_VILLAGER_AMBIENT, BigClientVersion.v1_10, "entity.villager.ambient");
+		addSound(ENTITY_VILLAGER_DEATH, BigClientVersion.v1_10, "entity.villager.death");
+		addSound(ENTITY_VILLAGER_HURT, BigClientVersion.v1_10, "entity.villager.hurt");
+		addSound(ENTITY_VILLAGER_NO, BigClientVersion.v1_10, "entity.villager.no");
+		addSound(ENTITY_VILLAGER_TRADING, BigClientVersion.v1_10, "entity.villager.trading");
+		addSound(ENTITY_VILLAGER_YES, BigClientVersion.v1_10, "entity.villager.yes");
+		addSound(ENTITY_WITCH_AMBIENT, BigClientVersion.v1_10, "entity.witch.ambient");
+		addSound(ENTITY_WITCH_DEATH, BigClientVersion.v1_10, "entity.witch.death");
+		addSound(ENTITY_WITCH_DRINK, BigClientVersion.v1_10, "entity.witch.drink");
+		addSound(ENTITY_WITCH_HURT, BigClientVersion.v1_10, "entity.witch.hurt");
+		addSound(ENTITY_WITCH_THROW, BigClientVersion.v1_10, "entity.witch.throw");
+		addSound(ENTITY_WITHER_AMBIENT, BigClientVersion.v1_10, "entity.wither.ambient");
+		addSound(ENTITY_WITHER_BREAK_BLOCK, BigClientVersion.v1_10, "entity.wither.break_block");
+		addSound(ENTITY_WITHER_DEATH, BigClientVersion.v1_10, "entity.wither.death");
+		addSound(ENTITY_WITHER_HURT, BigClientVersion.v1_10, "entity.wither.hurt");
+		addSound(ENTITY_WITHER_SHOOT, BigClientVersion.v1_10, "entity.wither.shoot");
+		addSound(ENTITY_WITHER_SPAWN, BigClientVersion.v1_10, "entity.wither.spawn");
+		addSound(ENTITY_WITHER_SKELETON_AMBIENT, BigClientVersion.v1_10, "entity.wither_skeleton.ambient");
+		addSound(ENTITY_WITHER_SKELETON_DEATH, BigClientVersion.v1_10, "entity.wither_skeleton.death");
+		addSound(ENTITY_WITHER_SKELETON_HURT, BigClientVersion.v1_10, "entity.wither_skeleton.hurt");
+		addSound(ENTITY_WITHER_SKELETON_STEP, BigClientVersion.v1_10, "entity.wither_skeleton.step");
+		addSound(ENTITY_WOLF_AMBIENT, BigClientVersion.v1_10, "entity.wolf.ambient");
+		addSound(ENTITY_WOLF_DEATH, BigClientVersion.v1_10, "entity.wolf.death");
+		addSound(ENTITY_WOLF_GROWL, BigClientVersion.v1_10, "entity.wolf.growl");
+		addSound(ENTITY_WOLF_HOWL, BigClientVersion.v1_10, "entity.wolf.howl");
+		addSound(ENTITY_WOLF_HURT, BigClientVersion.v1_10, "entity.wolf.hurt");
+		addSound(ENTITY_WOLF_PANT, BigClientVersion.v1_10, "entity.wolf.pant");
+		addSound(ENTITY_WOLF_SHAKE, BigClientVersion.v1_10, "entity.wolf.shake");
+		addSound(ENTITY_WOLF_STEP, BigClientVersion.v1_10, "entity.wolf.step");
+		addSound(ENTITY_WOLF_WHINE, BigClientVersion.v1_10, "entity.wolf.whine");
+		addSound(ENTITY_ZOMBIE_AMBIENT, BigClientVersion.v1_10, "entity.zombie.ambient");
+		addSound(ENTITY_ZOMBIE_ATTACK_DOOR_WOOD, BigClientVersion.v1_10, "entity.zombie.attack_door_wood");
+		addSound(ENTITY_ZOMBIE_ATTACK_IRON_DOOR, BigClientVersion.v1_10, "entity.zombie.attack_iron_door");
+		addSound(ENTITY_ZOMBIE_BREAK_DOOR_WOOD, BigClientVersion.v1_10, "entity.zombie.break_door_wood");
+		addSound(ENTITY_ZOMBIE_DEATH, BigClientVersion.v1_10, "entity.zombie.death");
+		addSound(ENTITY_ZOMBIE_HURT, BigClientVersion.v1_10, "entity.zombie.hurt");
+		addSound(ENTITY_ZOMBIE_INFECT, BigClientVersion.v1_10, "entity.zombie.infect");
+		addSound(ENTITY_ZOMBIE_STEP, BigClientVersion.v1_10, "entity.zombie.step");
+		addSound(ENTITY_ZOMBIE_HORSE_AMBIENT, BigClientVersion.v1_10, "entity.zombie_horse.ambient");
+		addSound(ENTITY_ZOMBIE_HORSE_DEATH, BigClientVersion.v1_10, "entity.zombie_horse.death");
+		addSound(ENTITY_ZOMBIE_HORSE_HURT, BigClientVersion.v1_10, "entity.zombie_horse.hurt");
+		addSound(ENTITY_ZOMBIE_PIG_AMBIENT, BigClientVersion.v1_10, "entity.zombie_pig.ambient");
+		addSound(ENTITY_ZOMBIE_PIG_ANGRY, BigClientVersion.v1_10, "entity.zombie_pig.angry");
+		addSound(ENTITY_ZOMBIE_PIG_DEATH, BigClientVersion.v1_10, "entity.zombie_pig.death");
+		addSound(ENTITY_ZOMBIE_PIG_HURT, BigClientVersion.v1_10, "entity.zombie_pig.hurt");
+		addSound(ENTITY_ZOMBIE_VILLAGER_AMBIENT, BigClientVersion.v1_10, "entity.zombie_villager.ambient");
+		addSound(ENTITY_ZOMBIE_VILLAGER_CONVERTED, BigClientVersion.v1_10, "entity.zombie_villager.converted");
+		addSound(ENTITY_ZOMBIE_VILLAGER_CURE, BigClientVersion.v1_10, "entity.zombie_villager.cure");
+		addSound(ENTITY_ZOMBIE_VILLAGER_DEATH, BigClientVersion.v1_10, "entity.zombie_villager.death");
+		addSound(ENTITY_ZOMBIE_VILLAGER_HURT, BigClientVersion.v1_10, "entity.zombie_villager.hurt");
+		addSound(ENTITY_ZOMBIE_VILLAGER_STEP, BigClientVersion.v1_10, "entity.zombie_villager.step");
+		addSound(ITEM_ARMOR_EQUIP_CHAIN, BigClientVersion.v1_10, "item.armor.equip_chain");
+		addSound(ITEM_ARMOR_EQUIP_DIAMOND, BigClientVersion.v1_10, "item.armor.equip_diamond");
+		addSound(ITEM_ARMOR_EQUIP_GENERIC, BigClientVersion.v1_10, "item.armor.equip_generic");
+		addSound(ITEM_ARMOR_EQUIP_GOLD, BigClientVersion.v1_10, "item.armor.equip_gold");
+		addSound(ITEM_ARMOR_EQUIP_IRON, BigClientVersion.v1_10, "item.armor.equip_iron");
+		addSound(ITEM_ARMOR_EQUIP_LEATHER, BigClientVersion.v1_10, "item.armor.equip_leather");
+		addSound(ITEM_BOTTLE_FILL, BigClientVersion.v1_10, "item.bottle.fill");
+		addSound(ITEM_BOTTLE_FILL_DRAGONBREATH, BigClientVersion.v1_10, "item.bottle.fill_dragonbreath");
+		addSound(ITEM_BUCKET_EMPTY, BigClientVersion.v1_10, "item.bucket.empty");
+		addSound(ITEM_BUCKET_EMPTY_LAVA, BigClientVersion.v1_10, "item.bucket.empty_lava");
+		addSound(ITEM_BUCKET_FILL, BigClientVersion.v1_10, "item.bucket.fill");
+		addSound(ITEM_BUCKET_FILL_LAVA, BigClientVersion.v1_10, "item.bucket.fill_lava");
+		addSound(ITEM_CHORUS_FRUIT_TELEPORT, BigClientVersion.v1_10, "item.chorus_fruit.teleport");
+		addSound(ITEM_ELYTRA_FLYING, BigClientVersion.v1_10, "item.elytra.flying");
+		addSound(ITEM_FIRECHARGE_USE, BigClientVersion.v1_10, "item.firecharge.use");
+		addSound(ITEM_FLINTANDSTEEL_USE, BigClientVersion.v1_10, "item.flintandsteel.use");
+		addSound(ITEM_HOE_TILL, BigClientVersion.v1_10, "item.hoe.till");
+		addSound(ITEM_SHIELD_BLOCK, BigClientVersion.v1_10, "item.shield.block");
+		addSound(ITEM_SHIELD_BREAK, BigClientVersion.v1_10, "item.shield.break");
+		addSound(ITEM_SHOVEL_FLATTEN, BigClientVersion.v1_10, "item.shovel.flatten");
+		addSound(MUSIC_CREATIVE, BigClientVersion.v1_10, "music.creative");
+		addSound(MUSIC_CREDITS, BigClientVersion.v1_10, "music.credits");
+		addSound(MUSIC_DRAGON, BigClientVersion.v1_10, "music.dragon");
+		addSound(MUSIC_END, BigClientVersion.v1_10, "music.end");
+		addSound(MUSIC_GAME, BigClientVersion.v1_10, "music.game");
+		addSound(MUSIC_MENU, BigClientVersion.v1_10, "music.menu");
+		addSound(MUSIC_NETHER, BigClientVersion.v1_10, "music.nether");
+		addSound(RECORD_11, BigClientVersion.v1_10, "record.11");
+		addSound(RECORD_13, BigClientVersion.v1_10, "record.13");
+		addSound(RECORD_BLOCKS, BigClientVersion.v1_10, "record.blocks");
+		addSound(RECORD_CAT, BigClientVersion.v1_10, "record.cat");
+		addSound(RECORD_CHIRP, BigClientVersion.v1_10, "record.chirp");
+		addSound(RECORD_FAR, BigClientVersion.v1_10, "record.far");
+		addSound(RECORD_MALL, BigClientVersion.v1_10, "record.mall");
+		addSound(RECORD_MELLOHI, BigClientVersion.v1_10, "record.mellohi");
+		addSound(RECORD_STAL, BigClientVersion.v1_10, "record.stal");
+		addSound(RECORD_STRAD, BigClientVersion.v1_10, "record.strad");
+		addSound(RECORD_WAIT, BigClientVersion.v1_10, "record.wait");
+		addSound(RECORD_WARD, BigClientVersion.v1_10, "record.ward");
+		addSound(UI_BUTTON_CLICK, BigClientVersion.v1_10, "ui.button.click");
+		addSound(WEATHER_RAIN, BigClientVersion.v1_10, "weather.rain");
+		addSound(WEATHER_RAIN_ABOVE, BigClientVersion.v1_10, "weather.rain.above");
+		
+		//1.9
+		addSound(AMBIENT_CAVE, BigClientVersion.v1_9, "ambient.cave");
+		addSound(BLOCK_ANVIL_BREAK, BigClientVersion.v1_9, "block.anvil.break");
+		addSound(BLOCK_ANVIL_DESTROY, BigClientVersion.v1_9, "block.anvil.destroy");
+		addSound(BLOCK_ANVIL_FALL, BigClientVersion.v1_9, "block.anvil.fall");
+		addSound(BLOCK_ANVIL_HIT, BigClientVersion.v1_9, "block.anvil.hit");
+		addSound(BLOCK_ANVIL_LAND, BigClientVersion.v1_9, "block.anvil.land");
+		addSound(BLOCK_ANVIL_PLACE, BigClientVersion.v1_9, "block.anvil.place");
+		addSound(BLOCK_ANVIL_STEP, BigClientVersion.v1_9, "block.anvil.step");
+		addSound(BLOCK_ANVIL_USE, BigClientVersion.v1_9, "block.anvil.use");
+		addSound(BLOCK_BREWING_STAND_BREW, BigClientVersion.v1_9, "block.brewing_stand.brew");
+		addSound(BLOCK_CHEST_CLOSE, BigClientVersion.v1_9, "block.chest.close");
+		addSound(BLOCK_CHEST_LOCKED, BigClientVersion.v1_9, "block.chest.locked");
+		addSound(BLOCK_CHEST_OPEN, BigClientVersion.v1_9, "block.chest.open");
+		addSound(BLOCK_CHORUS_FLOWER_DEATH, BigClientVersion.v1_9, "block.chorus_flower.death");
+		addSound(BLOCK_CHORUS_FLOWER_GROW, BigClientVersion.v1_9, "block.chorus_flower.grow");
+		addSound(BLOCK_CLOTH_BREAK, BigClientVersion.v1_9, "block.cloth.break");
+		addSound(BLOCK_CLOTH_FALL, BigClientVersion.v1_9, "block.cloth.fall");
+		addSound(BLOCK_CLOTH_HIT, BigClientVersion.v1_9, "block.cloth.hit");
+		addSound(BLOCK_CLOTH_PLACE, BigClientVersion.v1_9, "block.cloth.place");
+		addSound(BLOCK_CLOTH_STEP, BigClientVersion.v1_9, "block.cloth.step");
+		addSound(BLOCK_COMPARATOR_CLICK, BigClientVersion.v1_9, "block.comparator.click");
+		addSound(BLOCK_DISPENSER_DISPENSE, BigClientVersion.v1_9, "block.dispenser.dispense");
+		addSound(BLOCK_DISPENSER_FAIL, BigClientVersion.v1_9, "block.dispenser.fail");
+		addSound(BLOCK_DISPENSER_LAUNCH, BigClientVersion.v1_9, "block.dispenser.launch");
+		addSound(BLOCK_END_GATEWAY_SPAWN, BigClientVersion.v1_9, "block.end_gateway.spawn");
+		addSound(BLOCK_ENDERCHEST_CLOSE, BigClientVersion.v1_9, "block.enderchest.close");
+		addSound(BLOCK_ENDERCHEST_OPEN, BigClientVersion.v1_9, "block.enderchest.open");
+		addSound(BLOCK_FENCE_GATE_CLOSE, BigClientVersion.v1_9, "block.fence_gate.close");
+		addSound(BLOCK_FENCE_GATE_OPEN, BigClientVersion.v1_9, "block.fence_gate.open");
+		addSound(BLOCK_FIRE_AMBIENT, BigClientVersion.v1_9, "block.fire.ambient");
+		addSound(BLOCK_FIRE_EXTINGUISH, BigClientVersion.v1_9, "block.fire.extinguish");
+		addSound(BLOCK_FURNACE_FIRE_CRACKLE, BigClientVersion.v1_9, "block.furnace.fire_crackle");
+		addSound(BLOCK_GLASS_BREAK, BigClientVersion.v1_9, "block.glass.break");
+		addSound(BLOCK_GLASS_FALL, BigClientVersion.v1_9, "block.glass.fall");
+		addSound(BLOCK_GLASS_HIT, BigClientVersion.v1_9, "block.glass.hit");
+		addSound(BLOCK_GLASS_PLACE, BigClientVersion.v1_9, "block.glass.place");
+		addSound(BLOCK_GLASS_STEP, BigClientVersion.v1_9, "block.glass.step");
+		addSound(BLOCK_GRASS_BREAK, BigClientVersion.v1_9, "block.grass.break");
+		addSound(BLOCK_GRASS_FALL, BigClientVersion.v1_9, "block.grass.fall");
+		addSound(BLOCK_GRASS_HIT, BigClientVersion.v1_9, "block.grass.hit");
+		addSound(BLOCK_GRASS_PLACE, BigClientVersion.v1_9, "block.grass.place");
+		addSound(BLOCK_GRASS_STEP, BigClientVersion.v1_9, "block.grass.step");
+		addSound(BLOCK_GRAVEL_BREAK, BigClientVersion.v1_9, "block.gravel.break");
+		addSound(BLOCK_GRAVEL_FALL, BigClientVersion.v1_9, "block.gravel.fall");
+		addSound(BLOCK_GRAVEL_HIT, BigClientVersion.v1_9, "block.gravel.hit");
+		addSound(BLOCK_GRAVEL_PLACE, BigClientVersion.v1_9, "block.gravel.place");
+		addSound(BLOCK_GRAVEL_STEP, BigClientVersion.v1_9, "block.gravel.step");
+		addSound(BLOCK_IRON_DOOR_CLOSE, BigClientVersion.v1_9, "block.iron_door.close");
+		addSound(BLOCK_IRON_DOOR_OPEN, BigClientVersion.v1_9, "block.iron_door.open");
+		addSound(BLOCK_IRON_TRAPDOOR_CLOSE, BigClientVersion.v1_9, "block.iron_trapdoor.close");
+		addSound(BLOCK_IRON_TRAPDOOR_OPEN, BigClientVersion.v1_9, "block.iron_trapdoor.open");
+		addSound(BLOCK_LADDER_BREAK, BigClientVersion.v1_9, "block.ladder.break");
+		addSound(BLOCK_LADDER_FALL, BigClientVersion.v1_9, "block.ladder.fall");
+		addSound(BLOCK_LADDER_HIT, BigClientVersion.v1_9, "block.ladder.hit");
+		addSound(BLOCK_LADDER_PLACE, BigClientVersion.v1_9, "block.ladder.place");
+		addSound(BLOCK_LADDER_STEP, BigClientVersion.v1_9, "block.ladder.step");
+		addSound(BLOCK_LAVA_AMBIENT, BigClientVersion.v1_9, "block.lava.ambient");
+		addSound(BLOCK_LAVA_EXTINGUISH, BigClientVersion.v1_9, "block.lava.extinguish");
+		addSound(BLOCK_LAVA_POP, BigClientVersion.v1_9, "block.lava.pop");
+		addSound(BLOCK_LEVER_CLICK, BigClientVersion.v1_9, "block.lever.click");
+		addSound(BLOCK_METAL_BREAK, BigClientVersion.v1_9, "block.metal.break");
+		addSound(BLOCK_METAL_FALL, BigClientVersion.v1_9, "block.metal.fall");
+		addSound(BLOCK_METAL_HIT, BigClientVersion.v1_9, "block.metal.hit");
+		addSound(BLOCK_METAL_PLACE, BigClientVersion.v1_9, "block.metal.place");
+		addSound(BLOCK_METAL_STEP, BigClientVersion.v1_9, "block.metal.step");
+		addSound(BLOCK_METAL_PRESSUREPLATE_CLICK_OFF, BigClientVersion.v1_9, "block.metal_pressureplate.click_off");
+		addSound(BLOCK_METAL_PRESSUREPLATE_CLICK_ON, BigClientVersion.v1_9, "block.metal_pressureplate.click_on");
+		addSound(BLOCK_NOTE_BASEDRUM, BigClientVersion.v1_9, "block.note.basedrum");
+		addSound(BLOCK_NOTE_BASS, BigClientVersion.v1_9, "block.note.bass");
+		addSound(BLOCK_NOTE_HARP, BigClientVersion.v1_9, "block.note.harp");
+		addSound(BLOCK_NOTE_HAT, BigClientVersion.v1_9, "block.note.hat");
+		addSound(BLOCK_NOTE_PLING, BigClientVersion.v1_9, "block.note.pling");
+		addSound(BLOCK_NOTE_SNARE, BigClientVersion.v1_9, "block.note.snare");
+		addSound(BLOCK_PISTON_CONTRACT, BigClientVersion.v1_9, "block.piston.contract");
+		addSound(BLOCK_PISTON_EXTEND, BigClientVersion.v1_9, "block.piston.extend");
+		addSound(BLOCK_PORTAL_AMBIENT, BigClientVersion.v1_9, "block.portal.ambient");
+		addSound(BLOCK_PORTAL_TRAVEL, BigClientVersion.v1_9, "block.portal.travel");
+		addSound(BLOCK_PORTAL_TRIGGER, BigClientVersion.v1_9, "block.portal.trigger");
+		addSound(BLOCK_REDSTONE_TORCH_BURNOUT, BigClientVersion.v1_9, "block.redstone_torch.burnout");
+		addSound(BLOCK_SAND_BREAK, BigClientVersion.v1_9, "block.sand.break");
+		addSound(BLOCK_SAND_FALL, BigClientVersion.v1_9, "block.sand.fall");
+		addSound(BLOCK_SAND_HIT, BigClientVersion.v1_9, "block.sand.hit");
+		addSound(BLOCK_SAND_PLACE, BigClientVersion.v1_9, "block.sand.place");
+		addSound(BLOCK_SAND_STEP, BigClientVersion.v1_9, "block.sand.step");
+		addSound(BLOCK_SLIME_BREAK, BigClientVersion.v1_9, "block.slime.break");
+		addSound(BLOCK_SLIME_FALL, BigClientVersion.v1_9, "block.slime.fall");
+		addSound(BLOCK_SLIME_HIT, BigClientVersion.v1_9, "block.slime.hit");
+		addSound(BLOCK_SLIME_PLACE, BigClientVersion.v1_9, "block.slime.place");
+		addSound(BLOCK_SLIME_STEP, BigClientVersion.v1_9, "block.slime.step");
+		addSound(BLOCK_SNOW_BREAK, BigClientVersion.v1_9, "block.snow.break");
+		addSound(BLOCK_SNOW_FALL, BigClientVersion.v1_9, "block.snow.fall");
+		addSound(BLOCK_SNOW_HIT, BigClientVersion.v1_9, "block.snow.hit");
+		addSound(BLOCK_SNOW_PLACE, BigClientVersion.v1_9, "block.snow.place");
+		addSound(BLOCK_SNOW_STEP, BigClientVersion.v1_9, "block.snow.step");
+		addSound(BLOCK_STONE_BREAK, BigClientVersion.v1_9, "block.stone.break");
+		addSound(BLOCK_STONE_FALL, BigClientVersion.v1_9, "block.stone.fall");
+		addSound(BLOCK_STONE_HIT, BigClientVersion.v1_9, "block.stone.hit");
+		addSound(BLOCK_STONE_PLACE, BigClientVersion.v1_9, "block.stone.place");
+		addSound(BLOCK_STONE_STEP, BigClientVersion.v1_9, "block.stone.step");
+		addSound(BLOCK_STONE_BUTTON_CLICK_OFF, BigClientVersion.v1_9, "block.stone_button.click_off");
+		addSound(BLOCK_STONE_BUTTON_CLICK_ON, BigClientVersion.v1_9, "block.stone_button.click_on");
+		addSound(BLOCK_STONE_PRESSUREPLATE_CLICK_OFF, BigClientVersion.v1_9, "block.stone_pressureplate.click_off");
+		addSound(BLOCK_STONE_PRESSUREPLATE_CLICK_ON, BigClientVersion.v1_9, "block.stone_pressureplate.click_on");
+		addSound(BLOCK_TRIPWIRE_ATTACH, BigClientVersion.v1_9, "block.tripwire.attach");
+		addSound(BLOCK_TRIPWIRE_CLICK_OFF, BigClientVersion.v1_9, "block.tripwire.click_off");
+		addSound(BLOCK_TRIPWIRE_CLICK_ON, BigClientVersion.v1_9, "block.tripwire.click_on");
+		addSound(BLOCK_TRIPWIRE_DETACH, BigClientVersion.v1_9, "block.tripwire.detach");
+		addSound(BLOCK_WATER_AMBIENT, BigClientVersion.v1_9, "block.water.ambient");
+		addSound(BLOCK_WATERLILY_PLACE, BigClientVersion.v1_9, "block.waterlily.place");
+		addSound(BLOCK_WOOD_BREAK, BigClientVersion.v1_9, "block.wood.break");
+		addSound(BLOCK_WOOD_FALL, BigClientVersion.v1_9, "block.wood.fall");
+		addSound(BLOCK_WOOD_HIT, BigClientVersion.v1_9, "block.wood.hit");
+		addSound(BLOCK_WOOD_PLACE, BigClientVersion.v1_9, "block.wood.place");
+		addSound(BLOCK_WOOD_STEP, BigClientVersion.v1_9, "block.wood.step");
+		addSound(BLOCK_WOOD_BUTTON_CLICK_OFF, BigClientVersion.v1_9, "block.wood_button.click_off");
+		addSound(BLOCK_WOOD_BUTTON_CLICK_ON, BigClientVersion.v1_9, "block.wood_button.click_on");
+		addSound(BLOCK_WOOD_PRESSUREPLATE_CLICK_OFF, BigClientVersion.v1_9, "block.wood_pressureplate.click_off");
+		addSound(BLOCK_WOOD_PRESSUREPLATE_CLICK_ON, BigClientVersion.v1_9, "block.wood_pressureplate.click_on");
+		addSound(BLOCK_WOODEN_DOOR_CLOSE, BigClientVersion.v1_9, "block.wooden_door.close");
+		addSound(BLOCK_WOODEN_DOOR_OPEN, BigClientVersion.v1_9, "block.wooden_door.open");
+		addSound(BLOCK_WOODEN_TRAPDOOR_CLOSE, BigClientVersion.v1_9, "block.wooden_trapdoor.close");
+		addSound(BLOCK_WOODEN_TRAPDOOR_OPEN, BigClientVersion.v1_9, "block.wooden_trapdoor.open");
+		addSound(ENCHANT_THORNS_HIT, BigClientVersion.v1_9, "enchant.thorns.hit");
+		addSound(ENTITY_ARMORSTAND_BREAK, BigClientVersion.v1_9, "entity.armorstand.break");
+		addSound(ENTITY_ARMORSTAND_FALL, BigClientVersion.v1_9, "entity.armorstand.fall");
+		addSound(ENTITY_ARMORSTAND_HIT, BigClientVersion.v1_9, "entity.armorstand.hit");
+		addSound(ENTITY_ARMORSTAND_PLACE, BigClientVersion.v1_9, "entity.armorstand.place");
+		addSound(ENTITY_ARROW_HIT, BigClientVersion.v1_9, "entity.arrow.hit");
+		addSound(ENTITY_ARROW_HIT_PLAYER, BigClientVersion.v1_9, "entity.arrow.hit_player");
+		addSound(ENTITY_ARROW_SHOOT, BigClientVersion.v1_9, "entity.arrow.shoot");
+		addSound(ENTITY_BAT_AMBIENT, BigClientVersion.v1_9, "entity.bat.ambient");
+		addSound(ENTITY_BAT_DEATH, BigClientVersion.v1_9, "entity.bat.death");
+		addSound(ENTITY_BAT_HURT, BigClientVersion.v1_9, "entity.bat.hurt");
+		addSound(ENTITY_BAT_LOOP, BigClientVersion.v1_9, "entity.bat.loop");
+		addSound(ENTITY_BAT_TAKEOFF, BigClientVersion.v1_9, "entity.bat.takeoff");
+		addSound(ENTITY_BLAZE_AMBIENT, BigClientVersion.v1_9, "entity.blaze.ambient");
+		addSound(ENTITY_BLAZE_BURN, BigClientVersion.v1_9, "entity.blaze.burn");
+		addSound(ENTITY_BLAZE_DEATH, BigClientVersion.v1_9, "entity.blaze.death");
+		addSound(ENTITY_BLAZE_HURT, BigClientVersion.v1_9, "entity.blaze.hurt");
+		addSound(ENTITY_BLAZE_SHOOT, BigClientVersion.v1_9, "entity.blaze.shoot");
+		addSound(ENTITY_BOBBER_SPLASH, BigClientVersion.v1_9, "entity.bobber.splash");
+		addSound(ENTITY_BOBBER_THROW, BigClientVersion.v1_9, "entity.bobber.throw");
+		addSound(ENTITY_CAT_AMBIENT, BigClientVersion.v1_9, "entity.cat.ambient");
+		addSound(ENTITY_CAT_DEATH, BigClientVersion.v1_9, "entity.cat.death");
+		addSound(ENTITY_CAT_HISS, BigClientVersion.v1_9, "entity.cat.hiss");
+		addSound(ENTITY_CAT_HURT, BigClientVersion.v1_9, "entity.cat.hurt");
+		addSound(ENTITY_CAT_PURR, BigClientVersion.v1_9, "entity.cat.purr");
+		addSound(ENTITY_CAT_PURREOW, BigClientVersion.v1_9, "entity.cat.purreow");
+		addSound(ENTITY_CHICKEN_AMBIENT, BigClientVersion.v1_9, "entity.chicken.ambient");
+		addSound(ENTITY_CHICKEN_DEATH, BigClientVersion.v1_9, "entity.chicken.death");
+		addSound(ENTITY_CHICKEN_EGG, BigClientVersion.v1_9, "entity.chicken.egg");
+		addSound(ENTITY_CHICKEN_HURT, BigClientVersion.v1_9, "entity.chicken.hurt");
+		addSound(ENTITY_CHICKEN_STEP, BigClientVersion.v1_9, "entity.chicken.step");
+		addSound(ENTITY_COW_AMBIENT, BigClientVersion.v1_9, "entity.cow.ambient");
+		addSound(ENTITY_COW_DEATH, BigClientVersion.v1_9, "entity.cow.death");
+		addSound(ENTITY_COW_HURT, BigClientVersion.v1_9, "entity.cow.hurt");
+		addSound(ENTITY_COW_MILK, BigClientVersion.v1_9, "entity.cow.milk");
+		addSound(ENTITY_COW_STEP, BigClientVersion.v1_9, "entity.cow.step");
+		addSound(ENTITY_CREEPER_DEATH, BigClientVersion.v1_9, "entity.creeper.death");
+		addSound(ENTITY_CREEPER_HURT, BigClientVersion.v1_9, "entity.creeper.hurt");
+		addSound(ENTITY_CREEPER_PRIMED, BigClientVersion.v1_9, "entity.creeper.primed");
+		addSound(ENTITY_DONKEY_AMBIENT, BigClientVersion.v1_9, "entity.donkey.ambient");
+		addSound(ENTITY_DONKEY_ANGRY, BigClientVersion.v1_9, "entity.donkey.angry");
+		addSound(ENTITY_DONKEY_CHEST, BigClientVersion.v1_9, "entity.donkey.chest");
+		addSound(ENTITY_DONKEY_DEATH, BigClientVersion.v1_9, "entity.donkey.death");
+		addSound(ENTITY_DONKEY_HURT, BigClientVersion.v1_9, "entity.donkey.hurt");
+		addSound(ENTITY_EGG_THROW, BigClientVersion.v1_9, "entity.egg.throw");
+		addSound(ENTITY_ELDER_GUARDIAN_AMBIENT, BigClientVersion.v1_9, "entity.elder_guardian.ambient");
+		addSound(ENTITY_ELDER_GUARDIAN_AMBIENT_LAND, BigClientVersion.v1_9, "entity.elder_guardian.ambient_land");
+		addSound(ENTITY_ELDER_GUARDIAN_CURSE, BigClientVersion.v1_9, "entity.elder_guardian.curse");
+		addSound(ENTITY_ELDER_GUARDIAN_DEATH, BigClientVersion.v1_9, "entity.elder_guardian.death");
+		addSound(ENTITY_ELDER_GUARDIAN_DEATH_LAND, BigClientVersion.v1_9, "entity.elder_guardian.death_land");
+		addSound(ENTITY_ELDER_GUARDIAN_HURT, BigClientVersion.v1_9, "entity.elder_guardian.hurt");
+		addSound(ENTITY_ELDER_GUARDIAN_HURT_LAND, BigClientVersion.v1_9, "entity.elder_guardian.hurt_land");
+		addSound(ENTITY_ENDERDRAGON_AMBIENT, BigClientVersion.v1_9, "entity.enderdragon.ambient");
+		addSound(ENTITY_ENDERDRAGON_DEATH, BigClientVersion.v1_9, "entity.enderdragon.death");
+		addSound(ENTITY_ENDERDRAGON_FLAP, BigClientVersion.v1_9, "entity.enderdragon.flap");
+		addSound(ENTITY_ENDERDRAGON_GROWL, BigClientVersion.v1_9, "entity.enderdragon.growl");
+		addSound(ENTITY_ENDERDRAGON_HURT, BigClientVersion.v1_9, "entity.enderdragon.hurt");
+		addSound(ENTITY_ENDERDRAGON_SHOOT, BigClientVersion.v1_9, "entity.enderdragon.shoot");
+		addSound(ENTITY_ENDERDRAGON_FIREBALL_EXPLODE, BigClientVersion.v1_9, "entity.enderdragon_fireball.explode");
+		addSound(ENTITY_ENDEREYE_LAUNCH, BigClientVersion.v1_9, "entity.endereye.launch");
+		addSound(ENTITY_ENDERMEN_AMBIENT, BigClientVersion.v1_9, "entity.endermen.ambient");
+		addSound(ENTITY_ENDERMEN_DEATH, BigClientVersion.v1_9, "entity.endermen.death");
+		addSound(ENTITY_ENDERMEN_HURT, BigClientVersion.v1_9, "entity.endermen.hurt");
+		addSound(ENTITY_ENDERMEN_SCREAM, BigClientVersion.v1_9, "entity.endermen.scream");
+		addSound(ENTITY_ENDERMEN_STARE, BigClientVersion.v1_9, "entity.endermen.stare");
+		addSound(ENTITY_ENDERMEN_TELEPORT, BigClientVersion.v1_9, "entity.endermen.teleport");
+		addSound(ENTITY_ENDERMITE_AMBIENT, BigClientVersion.v1_9, "entity.endermite.ambient");
+		addSound(ENTITY_ENDERMITE_DEATH, BigClientVersion.v1_9, "entity.endermite.death");
+		addSound(ENTITY_ENDERMITE_HURT, BigClientVersion.v1_9, "entity.endermite.hurt");
+		addSound(ENTITY_ENDERMITE_STEP, BigClientVersion.v1_9, "entity.endermite.step");
+		addSound(ENTITY_ENDERPEARL_THROW, BigClientVersion.v1_9, "entity.enderpearl.throw");
+		addSound(ENTITY_EXPERIENCE_BOTTLE_THROW, BigClientVersion.v1_9, "entity.experience_bottle.throw");
+		addSound(ENTITY_EXPERIENCE_ORB_PICKUP, BigClientVersion.v1_9, "entity.experience_orb.pickup");
+		addSound(ENTITY_EXPERIENCE_ORB_TOUCH, BigClientVersion.v1_9, "entity.experience_orb.touch");
+		addSound(ENTITY_FIREWORK_BLAST, BigClientVersion.v1_9, "entity.firework.blast");
+		addSound(ENTITY_FIREWORK_BLAST_FAR, BigClientVersion.v1_9, "entity.firework.blast_far");
+		addSound(ENTITY_FIREWORK_LARGE_BLAST, BigClientVersion.v1_9, "entity.firework.large_blast");
+		addSound(ENTITY_FIREWORK_LARGE_BLAST_FAR, BigClientVersion.v1_9, "entity.firework.large_blast_far");
+		addSound(ENTITY_FIREWORK_LAUNCH, BigClientVersion.v1_9, "entity.firework.launch");
+		addSound(ENTITY_FIREWORK_SHOOT, BigClientVersion.v1_9, "entity.firework.shoot");
+		addSound(ENTITY_FIREWORK_TWINKLE, BigClientVersion.v1_9, "entity.firework.twinkle");
+		addSound(ENTITY_FIREWORK_TWINKLE_FAR, BigClientVersion.v1_9, "entity.firework.twinkle_far");
+		addSound(ENTITY_GENERIC_BIG_FALL, BigClientVersion.v1_9, "entity.generic.big_fall");
+		addSound(ENTITY_GENERIC_BURN, BigClientVersion.v1_9, "entity.generic.burn");
+		addSound(ENTITY_GENERIC_DEATH, BigClientVersion.v1_9, "entity.generic.death");
+		addSound(ENTITY_GENERIC_DRINK, BigClientVersion.v1_9, "entity.generic.drink");
+		addSound(ENTITY_GENERIC_EAT, BigClientVersion.v1_9, "entity.generic.eat");
+		addSound(ENTITY_GENERIC_EXPLODE, BigClientVersion.v1_9, "entity.generic.explode");
+		addSound(ENTITY_GENERIC_EXTINGUISH_FIRE, BigClientVersion.v1_9, "entity.generic.extinguish_fire");
+		addSound(ENTITY_GENERIC_HURT, BigClientVersion.v1_9, "entity.generic.hurt");
+		addSound(ENTITY_GENERIC_SMALL_FALL, BigClientVersion.v1_9, "entity.generic.small_fall");
+		addSound(ENTITY_GENERIC_SPLASH, BigClientVersion.v1_9, "entity.generic.splash");
+		addSound(ENTITY_GENERIC_SWIM, BigClientVersion.v1_9, "entity.generic.swim");
+		addSound(ENTITY_GHAST_AMBIENT, BigClientVersion.v1_9, "entity.ghast.ambient");
+		addSound(ENTITY_GHAST_DEATH, BigClientVersion.v1_9, "entity.ghast.death");
+		addSound(ENTITY_GHAST_HURT, BigClientVersion.v1_9, "entity.ghast.hurt");
+		addSound(ENTITY_GHAST_SCREAM, BigClientVersion.v1_9, "entity.ghast.scream");
+		addSound(ENTITY_GHAST_SHOOT, BigClientVersion.v1_9, "entity.ghast.shoot");
+		addSound(ENTITY_GHAST_WARN, BigClientVersion.v1_9, "entity.ghast.warn");
+		addSound(ENTITY_GUARDIAN_AMBIENT, BigClientVersion.v1_9, "entity.guardian.ambient");
+		addSound(ENTITY_GUARDIAN_AMBIENT_LAND, BigClientVersion.v1_9, "entity.guardian.ambient_land");
+		addSound(ENTITY_GUARDIAN_ATTACK, BigClientVersion.v1_9, "entity.guardian.attack");
+		addSound(ENTITY_GUARDIAN_DEATH, BigClientVersion.v1_9, "entity.guardian.death");
+		addSound(ENTITY_GUARDIAN_DEATH_LAND, BigClientVersion.v1_9, "entity.guardian.death_land");
+		addSound(ENTITY_GUARDIAN_FLOP, BigClientVersion.v1_9, "entity.guardian.flop");
+		addSound(ENTITY_GUARDIAN_HURT, BigClientVersion.v1_9, "entity.guardian.hurt");
+		addSound(ENTITY_GUARDIAN_HURT_LAND, BigClientVersion.v1_9, "entity.guardian.hurt_land");
+		addSound(ENTITY_HORSE_AMBIENT, BigClientVersion.v1_9, "entity.horse.ambient");
+		addSound(ENTITY_HORSE_ANGRY, BigClientVersion.v1_9, "entity.horse.angry");
+		addSound(ENTITY_HORSE_ARMOR, BigClientVersion.v1_9, "entity.horse.armor");
+		addSound(ENTITY_HORSE_BREATHE, BigClientVersion.v1_9, "entity.horse.breathe");
+		addSound(ENTITY_HORSE_DEATH, BigClientVersion.v1_9, "entity.horse.death");
+		addSound(ENTITY_HORSE_EAT, BigClientVersion.v1_9, "entity.horse.eat");
+		addSound(ENTITY_HORSE_GALLOP, BigClientVersion.v1_9, "entity.horse.gallop");
+		addSound(ENTITY_HORSE_HURT, BigClientVersion.v1_9, "entity.horse.hurt");
+		addSound(ENTITY_HORSE_JUMP, BigClientVersion.v1_9, "entity.horse.jump");
+		addSound(ENTITY_HORSE_LAND, BigClientVersion.v1_9, "entity.horse.land");
+		addSound(ENTITY_HORSE_SADDLE, BigClientVersion.v1_9, "entity.horse.saddle");
+		addSound(ENTITY_HORSE_STEP, BigClientVersion.v1_9, "entity.horse.step");
+		addSound(ENTITY_HORSE_STEP_WOOD, BigClientVersion.v1_9, "entity.horse.step_wood");
+		addSound(ENTITY_HOSTILE_BIG_FALL, BigClientVersion.v1_9, "entity.hostile.big_fall");
+		addSound(ENTITY_HOSTILE_DEATH, BigClientVersion.v1_9, "entity.hostile.death");
+		addSound(ENTITY_HOSTILE_HURT, BigClientVersion.v1_9, "entity.hostile.hurt");
+		addSound(ENTITY_HOSTILE_SMALL_FALL, BigClientVersion.v1_9, "entity.hostile.small_fall");
+		addSound(ENTITY_HOSTILE_SPLASH, BigClientVersion.v1_9, "entity.hostile.splash");
+		addSound(ENTITY_HOSTILE_SWIM, BigClientVersion.v1_9, "entity.hostile.swim");
+		addSound(ENTITY_IRONGOLEM_ATTACK, BigClientVersion.v1_9, "entity.irongolem.attack");
+		addSound(ENTITY_IRONGOLEM_DEATH, BigClientVersion.v1_9, "entity.irongolem.death");
+		addSound(ENTITY_IRONGOLEM_HURT, BigClientVersion.v1_9, "entity.irongolem.hurt");
+		addSound(ENTITY_IRONGOLEM_STEP, BigClientVersion.v1_9, "entity.irongolem.step");
+		addSound(ENTITY_ITEM_BREAK, BigClientVersion.v1_9, "entity.item.break");
+		addSound(ENTITY_ITEM_PICKUP, BigClientVersion.v1_9, "entity.item.pickup");
+		addSound(ENTITY_ITEMFRAME_ADD_ITEM, BigClientVersion.v1_9, "entity.itemframe.add_item");
+		addSound(ENTITY_ITEMFRAME_BREAK, BigClientVersion.v1_9, "entity.itemframe.break");
+		addSound(ENTITY_ITEMFRAME_PLACE, BigClientVersion.v1_9, "entity.itemframe.place");
+		addSound(ENTITY_ITEMFRAME_REMOVE_ITEM, BigClientVersion.v1_9, "entity.itemframe.remove_item");
+		addSound(ENTITY_ITEMFRAME_ROTATE_ITEM, BigClientVersion.v1_9, "entity.itemframe.rotate_item");
+		addSound(ENTITY_LEASHKNOT_BREAK, BigClientVersion.v1_9, "entity.leashknot.break");
+		addSound(ENTITY_LEASHKNOT_PLACE, BigClientVersion.v1_9, "entity.leashknot.place");
+		addSound(ENTITY_LIGHTNING_IMPACT, BigClientVersion.v1_9, "entity.lightning.impact");
+		addSound(ENTITY_LIGHTNING_THUNDER, BigClientVersion.v1_9, "entity.lightning.thunder");
+		addSound(ENTITY_LINGERINGPOTION_THROW, BigClientVersion.v1_9, "entity.lingeringpotion.throw");
+		addSound(ENTITY_MAGMACUBE_DEATH, BigClientVersion.v1_9, "entity.magmacube.death");
+		addSound(ENTITY_MAGMACUBE_HURT, BigClientVersion.v1_9, "entity.magmacube.hurt");
+		addSound(ENTITY_MAGMACUBE_JUMP, BigClientVersion.v1_9, "entity.magmacube.jump");
+		addSound(ENTITY_MAGMACUBE_SQUISH, BigClientVersion.v1_9, "entity.magmacube.squish");
+		addSound(ENTITY_MINECART_INSIDE, BigClientVersion.v1_9, "entity.minecart.inside");
+		addSound(ENTITY_MINECART_RIDING, BigClientVersion.v1_9, "entity.minecart.riding");
+		addSound(ENTITY_MOOSHROOM_SHEAR, BigClientVersion.v1_9, "entity.mooshroom.shear");
+		addSound(ENTITY_MULE_AMBIENT, BigClientVersion.v1_9, "entity.mule.ambient");
+		addSound(ENTITY_MULE_DEATH, BigClientVersion.v1_9, "entity.mule.death");
+		addSound(ENTITY_MULE_HURT, BigClientVersion.v1_9, "entity.mule.hurt");
+		addSound(ENTITY_PAINTING_BREAK, BigClientVersion.v1_9, "entity.painting.break");
+		addSound(ENTITY_PAINTING_PLACE, BigClientVersion.v1_9, "entity.painting.place");
+		addSound(ENTITY_PIG_AMBIENT, BigClientVersion.v1_9, "entity.pig.ambient");
+		addSound(ENTITY_PIG_DEATH, BigClientVersion.v1_9, "entity.pig.death");
+		addSound(ENTITY_PIG_HURT, BigClientVersion.v1_9, "entity.pig.hurt");
+		addSound(ENTITY_PIG_SADDLE, BigClientVersion.v1_9, "entity.pig.saddle");
+		addSound(ENTITY_PIG_STEP, BigClientVersion.v1_9, "entity.pig.step");
+		addSound(ENTITY_PLAYER_ATTACK_CRIT, BigClientVersion.v1_9, "entity.player.attack.crit");
+		addSound(ENTITY_PLAYER_ATTACK_KNOCKBACK, BigClientVersion.v1_9, "entity.player.attack.knockback");
+		addSound(ENTITY_PLAYER_ATTACK_NODAMAGE, BigClientVersion.v1_9, "entity.player.attack.nodamage");
+		addSound(ENTITY_PLAYER_ATTACK_STRONG, BigClientVersion.v1_9, "entity.player.attack.strong");
+		addSound(ENTITY_PLAYER_ATTACK_SWEEP, BigClientVersion.v1_9, "entity.player.attack.sweep");
+		addSound(ENTITY_PLAYER_ATTACK_WEAK, BigClientVersion.v1_9, "entity.player.attack.weak");
+		addSound(ENTITY_PLAYER_BIG_FALL, BigClientVersion.v1_9, "entity.player.big_fall");
+		addSound(ENTITY_PLAYER_BREATH, BigClientVersion.v1_9, "entity.player.breath");
+		addSound(ENTITY_PLAYER_BURP, BigClientVersion.v1_9, "entity.player.burp");
+		addSound(ENTITY_PLAYER_DEATH, BigClientVersion.v1_9, "entity.player.death");
+		addSound(ENTITY_PLAYER_HURT, BigClientVersion.v1_9, "entity.player.hurt");
+		addSound(ENTITY_PLAYER_LEVELUP, BigClientVersion.v1_9, "entity.player.levelup");
+		addSound(ENTITY_PLAYER_SMALL_FALL, BigClientVersion.v1_9, "entity.player.small_fall");
+		addSound(ENTITY_PLAYER_SPLASH, BigClientVersion.v1_9, "entity.player.splash");
+		addSound(ENTITY_PLAYER_SWIM, BigClientVersion.v1_9, "entity.player.swim");
+		addSound(ENTITY_RABBIT_AMBIENT, BigClientVersion.v1_9, "entity.rabbit.ambient");
+		addSound(ENTITY_RABBIT_ATTACK, BigClientVersion.v1_9, "entity.rabbit.attack");
+		addSound(ENTITY_RABBIT_DEATH, BigClientVersion.v1_9, "entity.rabbit.death");
+		addSound(ENTITY_RABBIT_HURT, BigClientVersion.v1_9, "entity.rabbit.hurt");
+		addSound(ENTITY_RABBIT_JUMP, BigClientVersion.v1_9, "entity.rabbit.jump");
+		addSound(ENTITY_SHEEP_AMBIENT, BigClientVersion.v1_9, "entity.sheep.ambient");
+		addSound(ENTITY_SHEEP_DEATH, BigClientVersion.v1_9, "entity.sheep.death");
+		addSound(ENTITY_SHEEP_HURT, BigClientVersion.v1_9, "entity.sheep.hurt");
+		addSound(ENTITY_SHEEP_SHEAR, BigClientVersion.v1_9, "entity.sheep.shear");
+		addSound(ENTITY_SHEEP_STEP, BigClientVersion.v1_9, "entity.sheep.step");
+		addSound(ENTITY_SHULKER_AMBIENT, BigClientVersion.v1_9, "entity.shulker.ambient");
+		addSound(ENTITY_SHULKER_CLOSE, BigClientVersion.v1_9, "entity.shulker.close");
+		addSound(ENTITY_SHULKER_DEATH, BigClientVersion.v1_9, "entity.shulker.death");
+		addSound(ENTITY_SHULKER_HURT, BigClientVersion.v1_9, "entity.shulker.hurt");
+		addSound(ENTITY_SHULKER_HURT_CLOSED, BigClientVersion.v1_9, "entity.shulker.hurt_closed");
+		addSound(ENTITY_SHULKER_OPEN, BigClientVersion.v1_9, "entity.shulker.open");
+		addSound(ENTITY_SHULKER_SHOOT, BigClientVersion.v1_9, "entity.shulker.shoot");
+		addSound(ENTITY_SHULKER_TELEPORT, BigClientVersion.v1_9, "entity.shulker.teleport");
+		addSound(ENTITY_SHULKER_BULLET_HIT, BigClientVersion.v1_9, "entity.shulker_bullet.hit");
+		addSound(ENTITY_SHULKER_BULLET_HURT, BigClientVersion.v1_9, "entity.shulker_bullet.hurt");
+		addSound(ENTITY_SILVERFISH_AMBIENT, BigClientVersion.v1_9, "entity.silverfish.ambient");
+		addSound(ENTITY_SILVERFISH_DEATH, BigClientVersion.v1_9, "entity.silverfish.death");
+		addSound(ENTITY_SILVERFISH_HURT, BigClientVersion.v1_9, "entity.silverfish.hurt");
+		addSound(ENTITY_SILVERFISH_STEP, BigClientVersion.v1_9, "entity.silverfish.step");
+		addSound(ENTITY_SKELETON_AMBIENT, BigClientVersion.v1_9, "entity.skeleton.ambient");
+		addSound(ENTITY_SKELETON_DEATH, BigClientVersion.v1_9, "entity.skeleton.death");
+		addSound(ENTITY_SKELETON_HURT, BigClientVersion.v1_9, "entity.skeleton.hurt");
+		addSound(ENTITY_SKELETON_SHOOT, BigClientVersion.v1_9, "entity.skeleton.shoot");
+		addSound(ENTITY_SKELETON_STEP, BigClientVersion.v1_9, "entity.skeleton.step");
+		addSound(ENTITY_SKELETON_HORSE_AMBIENT, BigClientVersion.v1_9, "entity.skeleton_horse.ambient");
+		addSound(ENTITY_SKELETON_HORSE_DEATH, BigClientVersion.v1_9, "entity.skeleton_horse.death");
+		addSound(ENTITY_SKELETON_HORSE_HURT, BigClientVersion.v1_9, "entity.skeleton_horse.hurt");
+		addSound(ENTITY_SLIME_ATTACK, BigClientVersion.v1_9, "entity.slime.attack");
+		addSound(ENTITY_SLIME_DEATH, BigClientVersion.v1_9, "entity.slime.death");
+		addSound(ENTITY_SLIME_HURT, BigClientVersion.v1_9, "entity.slime.hurt");
+		addSound(ENTITY_SLIME_JUMP, BigClientVersion.v1_9, "entity.slime.jump");
+		addSound(ENTITY_SLIME_SQUISH, BigClientVersion.v1_9, "entity.slime.squish");
+		addSound(ENTITY_SMALL_MAGMACUBE_DEATH, BigClientVersion.v1_9, "entity.small_magmacube.death");
+		addSound(ENTITY_SMALL_MAGMACUBE_HURT, BigClientVersion.v1_9, "entity.small_magmacube.hurt");
+		addSound(ENTITY_SMALL_MAGMACUBE_SQUISH, BigClientVersion.v1_9, "entity.small_magmacube.squish");
+		addSound(ENTITY_SMALL_SLIME_DEATH, BigClientVersion.v1_9, "entity.small_slime.death");
+		addSound(ENTITY_SMALL_SLIME_HURT, BigClientVersion.v1_9, "entity.small_slime.hurt");
+		addSound(ENTITY_SMALL_SLIME_JUMP, BigClientVersion.v1_9, "entity.small_slime.jump");
+		addSound(ENTITY_SMALL_SLIME_SQUISH, BigClientVersion.v1_9, "entity.small_slime.squish");
+		addSound(ENTITY_SNOWBALL_THROW, BigClientVersion.v1_9, "entity.snowball.throw");
+		addSound(ENTITY_SNOWMAN_AMBIENT, BigClientVersion.v1_9, "entity.snowman.ambient");
+		addSound(ENTITY_SNOWMAN_DEATH, BigClientVersion.v1_9, "entity.snowman.death");
+		addSound(ENTITY_SNOWMAN_HURT, BigClientVersion.v1_9, "entity.snowman.hurt");
+		addSound(ENTITY_SNOWMAN_SHOOT, BigClientVersion.v1_9, "entity.snowman.shoot");
+		addSound(ENTITY_SPIDER_AMBIENT, BigClientVersion.v1_9, "entity.spider.ambient");
+		addSound(ENTITY_SPIDER_DEATH, BigClientVersion.v1_9, "entity.spider.death");
+		addSound(ENTITY_SPIDER_HURT, BigClientVersion.v1_9, "entity.spider.hurt");
+		addSound(ENTITY_SPIDER_STEP, BigClientVersion.v1_9, "entity.spider.step");
+		addSound(ENTITY_SPLASH_POTION_BREAK, BigClientVersion.v1_9, "entity.splash_potion.break");
+		addSound(ENTITY_SPLASH_POTION_THROW, BigClientVersion.v1_9, "entity.splash_potion.throw");
+		addSound(ENTITY_SQUID_AMBIENT, BigClientVersion.v1_9, "entity.squid.ambient");
+		addSound(ENTITY_SQUID_DEATH, BigClientVersion.v1_9, "entity.squid.death");
+		addSound(ENTITY_SQUID_HURT, BigClientVersion.v1_9, "entity.squid.hurt");
+		addSound(ENTITY_TNT_PRIMED, BigClientVersion.v1_9, "entity.tnt.primed");
+		addSound(ENTITY_VILLAGER_AMBIENT, BigClientVersion.v1_9, "entity.villager.ambient");
+		addSound(ENTITY_VILLAGER_DEATH, BigClientVersion.v1_9, "entity.villager.death");
+		addSound(ENTITY_VILLAGER_HURT, BigClientVersion.v1_9, "entity.villager.hurt");
+		addSound(ENTITY_VILLAGER_NO, BigClientVersion.v1_9, "entity.villager.no");
+		addSound(ENTITY_VILLAGER_TRADING, BigClientVersion.v1_9, "entity.villager.trading");
+		addSound(ENTITY_VILLAGER_YES, BigClientVersion.v1_9, "entity.villager.yes");
+		addSound(ENTITY_WITCH_AMBIENT, BigClientVersion.v1_9, "entity.witch.ambient");
+		addSound(ENTITY_WITCH_DEATH, BigClientVersion.v1_9, "entity.witch.death");
+		addSound(ENTITY_WITCH_DRINK, BigClientVersion.v1_9, "entity.witch.drink");
+		addSound(ENTITY_WITCH_HURT, BigClientVersion.v1_9, "entity.witch.hurt");
+		addSound(ENTITY_WITCH_THROW, BigClientVersion.v1_9, "entity.witch.throw");
+		addSound(ENTITY_WITHER_AMBIENT, BigClientVersion.v1_9, "entity.wither.ambient");
+		addSound(ENTITY_WITHER_BREAK_BLOCK, BigClientVersion.v1_9, "entity.wither.break_block");
+		addSound(ENTITY_WITHER_DEATH, BigClientVersion.v1_9, "entity.wither.death");
+		addSound(ENTITY_WITHER_HURT, BigClientVersion.v1_9, "entity.wither.hurt");
+		addSound(ENTITY_WITHER_SHOOT, BigClientVersion.v1_9, "entity.wither.shoot");
+		addSound(ENTITY_WITHER_SPAWN, BigClientVersion.v1_9, "entity.wither.spawn");
+		addSound(ENTITY_WOLF_AMBIENT, BigClientVersion.v1_9, "entity.wolf.ambient");
+		addSound(ENTITY_WOLF_DEATH, BigClientVersion.v1_9, "entity.wolf.death");
+		addSound(ENTITY_WOLF_GROWL, BigClientVersion.v1_9, "entity.wolf.growl");
+		addSound(ENTITY_WOLF_HOWL, BigClientVersion.v1_9, "entity.wolf.howl");
+		addSound(ENTITY_WOLF_HURT, BigClientVersion.v1_9, "entity.wolf.hurt");
+		addSound(ENTITY_WOLF_PANT, BigClientVersion.v1_9, "entity.wolf.pant");
+		addSound(ENTITY_WOLF_SHAKE, BigClientVersion.v1_9, "entity.wolf.shake");
+		addSound(ENTITY_WOLF_STEP, BigClientVersion.v1_9, "entity.wolf.step");
+		addSound(ENTITY_WOLF_WHINE, BigClientVersion.v1_9, "entity.wolf.whine");
+		addSound(ENTITY_ZOMBIE_AMBIENT, BigClientVersion.v1_9, "entity.zombie.ambient");
+		addSound(ENTITY_ZOMBIE_ATTACK_DOOR_WOOD, BigClientVersion.v1_9, "entity.zombie.attack_door_wood");
+		addSound(ENTITY_ZOMBIE_ATTACK_IRON_DOOR, BigClientVersion.v1_9, "entity.zombie.attack_iron_door");
+		addSound(ENTITY_ZOMBIE_BREAK_DOOR_WOOD, BigClientVersion.v1_9, "entity.zombie.break_door_wood");
+		addSound(ENTITY_ZOMBIE_DEATH, BigClientVersion.v1_9, "entity.zombie.death");
+		addSound(ENTITY_ZOMBIE_HURT, BigClientVersion.v1_9, "entity.zombie.hurt");
+		addSound(ENTITY_ZOMBIE_INFECT, BigClientVersion.v1_9, "entity.zombie.infect");
+		addSound(ENTITY_ZOMBIE_STEP, BigClientVersion.v1_9, "entity.zombie.step");
+		addSound(ENTITY_ZOMBIE_HORSE_AMBIENT, BigClientVersion.v1_9, "entity.zombie_horse.ambient");
+		addSound(ENTITY_ZOMBIE_HORSE_DEATH, BigClientVersion.v1_9, "entity.zombie_horse.death");
+		addSound(ENTITY_ZOMBIE_HORSE_HURT, BigClientVersion.v1_9, "entity.zombie_horse.hurt");
+		addSound(ENTITY_ZOMBIE_PIG_AMBIENT, BigClientVersion.v1_9, "entity.zombie_pig.ambient");
+		addSound(ENTITY_ZOMBIE_PIG_ANGRY, BigClientVersion.v1_9, "entity.zombie_pig.angry");
+		addSound(ENTITY_ZOMBIE_PIG_DEATH, BigClientVersion.v1_9, "entity.zombie_pig.death");
+		addSound(ENTITY_ZOMBIE_PIG_HURT, BigClientVersion.v1_9, "entity.zombie_pig.hurt");
+		addSound(ENTITY_ZOMBIE_VILLAGER_AMBIENT, BigClientVersion.v1_9, "entity.zombie_villager.ambient");
+		addSound(ENTITY_ZOMBIE_VILLAGER_CONVERTED, BigClientVersion.v1_9, "entity.zombie_villager.converted");
+		addSound(ENTITY_ZOMBIE_VILLAGER_CURE, BigClientVersion.v1_9, "entity.zombie_villager.cure");
+		addSound(ENTITY_ZOMBIE_VILLAGER_DEATH, BigClientVersion.v1_9, "entity.zombie_villager.death");
+		addSound(ENTITY_ZOMBIE_VILLAGER_HURT, BigClientVersion.v1_9, "entity.zombie_villager.hurt");
+		addSound(ENTITY_ZOMBIE_VILLAGER_STEP, BigClientVersion.v1_9, "entity.zombie_villager.step");
+		addSound(ITEM_ARMOR_EQUIP_CHAIN, BigClientVersion.v1_9, "item.armor.equip_chain");
+		addSound(ITEM_ARMOR_EQUIP_DIAMOND, BigClientVersion.v1_9, "item.armor.equip_diamond");
+		addSound(ITEM_ARMOR_EQUIP_GENERIC, BigClientVersion.v1_9, "item.armor.equip_generic");
+		addSound(ITEM_ARMOR_EQUIP_GOLD, BigClientVersion.v1_9, "item.armor.equip_gold");
+		addSound(ITEM_ARMOR_EQUIP_IRON, BigClientVersion.v1_9, "item.armor.equip_iron");
+		addSound(ITEM_ARMOR_EQUIP_LEATHER, BigClientVersion.v1_9, "item.armor.equip_leather");
+		addSound(ITEM_BOTTLE_FILL, BigClientVersion.v1_9, "item.bottle.fill");
+		addSound(ITEM_BOTTLE_FILL_DRAGONBREATH, BigClientVersion.v1_9, "item.bottle.fill_dragonbreath");
+		addSound(ITEM_BUCKET_EMPTY, BigClientVersion.v1_9, "item.bucket.empty");
+		addSound(ITEM_BUCKET_EMPTY_LAVA, BigClientVersion.v1_9, "item.bucket.empty_lava");
+		addSound(ITEM_BUCKET_FILL, BigClientVersion.v1_9, "item.bucket.fill");
+		addSound(ITEM_BUCKET_FILL_LAVA, BigClientVersion.v1_9, "item.bucket.fill_lava");
+		addSound(ITEM_CHORUS_FRUIT_TELEPORT, BigClientVersion.v1_9, "item.chorus_fruit.teleport");
+		addSound(ITEM_ELYTRA_FLYING, BigClientVersion.v1_9, "item.elytra.flying");
+		addSound(ITEM_FIRECHARGE_USE, BigClientVersion.v1_9, "item.firecharge.use");
+		addSound(ITEM_FLINTANDSTEEL_USE, BigClientVersion.v1_9, "item.flintandsteel.use");
+		addSound(ITEM_HOE_TILL, BigClientVersion.v1_9, "item.hoe.till");
+		addSound(ITEM_SHIELD_BLOCK, BigClientVersion.v1_9, "item.shield.block");
+		addSound(ITEM_SHIELD_BREAK, BigClientVersion.v1_9, "item.shield.break");
+		addSound(ITEM_SHOVEL_FLATTEN, BigClientVersion.v1_9, "item.shovel.flatten");
+		addSound(MUSIC_CREATIVE, BigClientVersion.v1_9, "music.creative");
+		addSound(MUSIC_CREDITS, BigClientVersion.v1_9, "music.credits");
+		addSound(MUSIC_DRAGON, BigClientVersion.v1_9, "music.dragon");
+		addSound(MUSIC_END, BigClientVersion.v1_9, "music.end");
+		addSound(MUSIC_GAME, BigClientVersion.v1_9, "music.game");
+		addSound(MUSIC_MENU, BigClientVersion.v1_9, "music.menu");
+		addSound(MUSIC_NETHER, BigClientVersion.v1_9, "music.nether");
+		addSound(RECORD_11, BigClientVersion.v1_9, "record.11");
+		addSound(RECORD_13, BigClientVersion.v1_9, "record.13");
+		addSound(RECORD_BLOCKS, BigClientVersion.v1_9, "record.blocks");
+		addSound(RECORD_CAT, BigClientVersion.v1_9, "record.cat");
+		addSound(RECORD_CHIRP, BigClientVersion.v1_9, "record.chirp");
+		addSound(RECORD_FAR, BigClientVersion.v1_9, "record.far");
+		addSound(RECORD_MALL, BigClientVersion.v1_9, "record.mall");
+		addSound(RECORD_MELLOHI, BigClientVersion.v1_9, "record.mellohi");
+		addSound(RECORD_STAL, BigClientVersion.v1_9, "record.stal");
+		addSound(RECORD_STRAD, BigClientVersion.v1_9, "record.strad");
+		addSound(RECORD_WAIT, BigClientVersion.v1_9, "record.wait");
+		addSound(RECORD_WARD, BigClientVersion.v1_9, "record.ward");
+		addSound(UI_BUTTON_CLICK, BigClientVersion.v1_9, "ui.button.click");
+		addSound(WEATHER_RAIN, BigClientVersion.v1_9, "weather.rain");
+		addSound(WEATHER_RAIN_ABOVE, BigClientVersion.v1_9, "weather.rain.above");
+
+		//TODO implement sound for 1.8?
+	}
+	
+	private HashMap<BigClientVersion,String> versions = new HashMap<>();
+	
+	private SoundEffect() {}
+	
+	private static void addSound(SoundEffect effect, BigClientVersion version, String id) {
+		effect.versions.put(version, id);
+	}
+	
+	/**
+	 * Get the Sound-String for the BigClientVersion
+	 * @see BigClientVersion
+	 * 
+	 * @param BigClientVersion version
+	 * @return Sound-String
+	 * */
+	public String getId(BigClientVersion version) {
+		return versions.get(version);
+	}
+	
+	/**
+	 * checks if the Sound is Aviarible for the specified version
+	 * @see BigClientVersion
+	 * 
+	 * @param BigClientVersion version
+	 * @return true if its aviarible
+	 * */
+	public boolean isAvariable(BigClientVersion version) {
+		return versions.containsKey(version);
+	}
+}
diff --git a/src/main/java/dev/wolveringer/chat/ChatBaseComponent.java b/src/main/java/dev/wolveringer/chat/ChatBaseComponent.java
new file mode 100644
index 0000000..a265157
--- /dev/null
+++ b/src/main/java/dev/wolveringer/chat/ChatBaseComponent.java
@@ -0,0 +1,131 @@
+package dev.wolveringer.chat;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
+import com.google.common.collect.Iterators;
+import com.google.common.collect.Lists;
+
+@SuppressWarnings({ "rawtypes" })
+public abstract class ChatBaseComponent implements IChatBaseComponent {
+
+	protected List<IChatBaseComponent> texte = Lists.newArrayList();
+
+	protected ChatModifier modifier;
+
+	public ChatBaseComponent() {
+	}
+
+	@Override
+	public List getSiblings() {
+		return this.texte;
+	}
+
+	public IChatBaseComponent addSibling(String text) {
+		return this.addSibling(new ChatComponentText(text));
+	}
+
+	@Override
+	public IChatBaseComponent addSibling(IChatBaseComponent ichatbasecomponent) {
+		ichatbasecomponent.getChatModifier().setChatModifier(this.getChatModifier());
+		this.texte.add(ichatbasecomponent);
+		return this;
+	}
+
+	@Override
+	public String getRawText() {
+		StringBuilder stringbuilder = new StringBuilder();
+		Iterator iterator = this.iterator();
+
+		while (iterator.hasNext()){
+			IChatBaseComponent ichatbasecomponent = (IChatBaseComponent) iterator.next();
+
+			stringbuilder.append(ichatbasecomponent.getText());
+		}
+		return stringbuilder.toString();
+	}
+
+	@Override
+	public boolean equals(Object object) {
+		if(this == object){
+			return true;
+		}else if(!(object instanceof ChatBaseComponent)){
+			return false;
+		}else{
+			ChatBaseComponent chatbasecomponent = (ChatBaseComponent) object;
+			return this.texte.equals(chatbasecomponent.texte) && this.getChatModifier().equals(chatbasecomponent.getChatModifier());
+		}
+	}
+
+	@Override
+	public ChatModifier getChatModifier() {
+		if(this.modifier == null){
+			this.modifier = new ChatModifier();
+			Iterator iterator = this.texte.iterator();
+
+			while (iterator.hasNext()){
+				IChatBaseComponent ichatbasecomponent = (IChatBaseComponent) iterator.next();
+
+				ichatbasecomponent.getChatModifier().setChatModifier(this.modifier);
+			}
+		}
+
+		return this.modifier;
+	}
+
+	@Override
+	public int hashCode() {
+		return 31 * this.modifier.hashCode() + this.texte.hashCode();
+	}
+
+	@Override
+	public Iterator<IChatBaseComponent> iterator() {
+		return Iterators.concat(Iterators.forArray(new ChatBaseComponent[] { this }), Iterators.forArray(this.texte.toArray(new IChatBaseComponent[this.texte.size()])));
+	}
+
+	@Override
+	public IChatBaseComponent setChatModifier(ChatModifier chatmodifier) {
+		this.modifier = chatmodifier;
+		Iterator<IChatBaseComponent> iterator = this.texte.iterator();
+		while (iterator.hasNext()){
+			iterator.next().getChatModifier().setChatModifier(this.getChatModifier());
+		}
+
+		return this;
+	}
+
+	@Override
+	public boolean hasClickListener() {
+		Iterator<IChatBaseComponent> copms = iterator();
+		for(IChatBaseComponent comp = copms.next();copms.hasNext();comp = copms.next()){
+			if(comp.hasClickListener())
+				return true;
+		}
+		return false;
+	}
+
+	@Override
+	public ArrayList<String> getClickSignature() {
+		ArrayList<String> strings = new ArrayList<String>();
+		Iterator<IChatBaseComponent> copms = iterator();
+		for(IChatBaseComponent comp = copms.next();copms.hasNext();comp = copms.next())
+			if(comp.hasClickListener())
+				strings.addAll(comp.getClickSignature());
+		return strings;
+	}
+
+	@Override
+	public ChatClickListener run(String s) {
+		Iterator<IChatBaseComponent> copms = iterator();
+		for(IChatBaseComponent comp = copms.next();copms.hasNext();comp = copms.next()){
+			if(comp.hasClickListener()){
+				ChatClickListener click = comp.run(s);
+				if(click != null)
+					return click;
+			}
+		}
+		return null;
+	}
+
+}
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/chat/ChatClickListener.java b/src/main/java/dev/wolveringer/chat/ChatClickListener.java
new file mode 100644
index 0000000..583b9fb
--- /dev/null
+++ b/src/main/java/dev/wolveringer/chat/ChatClickListener.java
@@ -0,0 +1,7 @@
+package dev.wolveringer.chat;
+
+import dev.wolveringer.BungeeUtil.Player;
+
+public interface ChatClickListener {
+	public void click(Player p);
+}
diff --git a/src/main/java/dev/wolveringer/chat/ChatClickable.java b/src/main/java/dev/wolveringer/chat/ChatClickable.java
new file mode 100644
index 0000000..0bbdbfb
--- /dev/null
+++ b/src/main/java/dev/wolveringer/chat/ChatClickable.java
@@ -0,0 +1,59 @@
+package dev.wolveringer.chat;
+
+import java.util.UUID;
+
+public class ChatClickable {
+
+	private EnumClickAction action;
+	private String value;
+	private transient String command_signature;
+	private transient ChatClickListener listener = null;
+
+	public ChatClickable(EnumClickAction action) {
+		this.action = action;
+	}
+	public ChatClickable(EnumClickAction action, String data) {
+		this(action);
+		this.value = data;
+	}
+	public ChatClickable(EnumClickAction enumclickaction, String s,ChatClickListener listener) {
+		this(enumclickaction,s);
+		this.command_signature = UUID.randomUUID().toString() + System.currentTimeMillis();
+	}
+
+	public EnumClickAction getAction() {
+		return this.action;
+	}
+
+	public String getValue() {
+		return this.value;
+	}
+	
+	@Override
+	public int hashCode() {
+		int i = this.action.hashCode();
+
+		i = 31 * i + (this.value != null ? this.value.hashCode() : 0);
+		return i;
+	}
+
+	@Override
+	public String toString() {
+		if(!hasListener())
+			return "ClickEvent{action=" + this.action + ", value=\'" + this.value + '\'' + '}';
+		else
+			return "ClickEvent{action=" + this.action + ", value=\'" + this.value + '\'' +", CommandSignature=\'"+ command_signature +"\'"+'}';
+	}
+
+	public String getCommandSignature() {
+		return command_signature;
+	}
+
+	public boolean hasListener() {
+		return listener != null && command_signature != null && !"".equalsIgnoreCase(command_signature);
+	}
+
+	public ChatClickListener getListener() {
+		return listener;
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/chat/ChatColor/AnsiColorFormater.java b/src/main/java/dev/wolveringer/chat/ChatColor/AnsiColorFormater.java
new file mode 100644
index 0000000..11ec03b
--- /dev/null
+++ b/src/main/java/dev/wolveringer/chat/ChatColor/AnsiColorFormater.java
@@ -0,0 +1,67 @@
+package dev.wolveringer.chat.ChatColor;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import net.md_5.bungee.api.ChatColor;
+
+import org.fusesource.jansi.Ansi;
+
+public class AnsiColorFormater {
+
+	public static AnsiColorFormater formater = new AnsiColorFormater();
+
+	public static AnsiColorFormater getFormater() {
+		if (formater == null)
+			formater = new AnsiColorFormater();
+		return formater;
+	}
+
+	public static void setFormater(AnsiColorFormater formater) {
+		AnsiColorFormater.formater = formater;
+	}
+
+	private final Map<String, String> replacements = new HashMap<String, String>();
+
+	public AnsiColorFormater() {
+		this.replacements.put(ChatColor.BLACK.toString(), Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.BLACK).boldOff().toString());
+		this.replacements.put(ChatColor.DARK_BLUE.toString(), Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.BLUE).boldOff().toString());
+		this.replacements.put(ChatColor.DARK_GREEN.toString(), Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.GREEN).boldOff().toString());
+		this.replacements.put(ChatColor.DARK_AQUA.toString(), Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.CYAN).boldOff().toString());
+		this.replacements.put(ChatColor.DARK_RED.toString(), Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.RED).boldOff().toString());
+		this.replacements.put(ChatColor.DARK_PURPLE.toString(), Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.MAGENTA).boldOff().toString());
+		this.replacements.put(ChatColor.GOLD.toString(), Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.YELLOW).boldOff().toString());
+		this.replacements.put(ChatColor.GRAY.toString(), Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.WHITE).boldOff().toString());
+		this.replacements.put(ChatColor.DARK_GRAY.toString(), Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.BLACK).bold().toString());
+		this.replacements.put(ChatColor.BLUE.toString(), Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.BLUE).bold().toString());
+		this.replacements.put(ChatColor.GREEN.toString(), Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.GREEN).bold().toString());
+		this.replacements.put(ChatColor.AQUA.toString(), Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.CYAN).bold().toString());
+		this.replacements.put(ChatColor.RED.toString(), Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.RED).bold().toString());
+		this.replacements.put(ChatColor.LIGHT_PURPLE.toString(), Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.MAGENTA).bold().toString());
+		this.replacements.put(ChatColor.YELLOW.toString(), Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.YELLOW).bold().toString());
+		this.replacements.put(ChatColor.WHITE.toString(), Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.WHITE).bold().toString());
+		this.replacements.put(ChatColor.MAGIC.toString(), Ansi.ansi().a(Ansi.Attribute.BLINK_SLOW).toString());
+		this.replacements.put(ChatColor.BOLD.toString(), Ansi.ansi().a(Ansi.Attribute.UNDERLINE_DOUBLE).toString());
+		this.replacements.put(ChatColor.STRIKETHROUGH.toString(), Ansi.ansi().a(Ansi.Attribute.STRIKETHROUGH_ON).toString());
+		this.replacements.put(ChatColor.UNDERLINE.toString(), Ansi.ansi().a(Ansi.Attribute.UNDERLINE).toString());
+		this.replacements.put(ChatColor.ITALIC.toString(), Ansi.ansi().a(Ansi.Attribute.ITALIC).toString());
+		this.replacements.put(ChatColor.COLOR_CHAR + "z", Ansi.ansi().newline().toString());
+		this.replacements.put(ChatColor.RESET.toString(), Ansi.ansi().a(Ansi.Attribute.RESET).toString());
+	}
+
+	public String format(String s) {
+		for (String color : replacements.keySet()) {
+			s = s.replaceAll("(?i)" + color, (String) this.replacements.get(color));
+		}
+		return s + Ansi.ansi().a(Ansi.Attribute.RESET).toString();
+	}
+
+	public String stripAnsi(String message) {
+		message = message.replaceAll("\033\\[m", "");
+		return message;
+	}
+	
+	public static void main(String[] args) {
+		System.out.println(AnsiColorFormater.getFormater().stripAnsi(AnsiColorFormater.getFormater().format("\u00A7c\u00A7z\u00A7rHello world")));
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/chat/ChatColor/ChatColorUtils.java b/src/main/java/dev/wolveringer/chat/ChatColor/ChatColorUtils.java
new file mode 100644
index 0000000..38f6293
--- /dev/null
+++ b/src/main/java/dev/wolveringer/chat/ChatColor/ChatColorUtils.java
@@ -0,0 +1,162 @@
+package dev.wolveringer.chat.ChatColor;
+
+import java.util.Map;
+import java.util.regex.Pattern;
+
+import net.md_5.bungee.api.ChatColor;
+
+import com.google.common.collect.Maps;
+
+import dev.wolveringer.chat.ChatModifier;
+
+public class ChatColorUtils {
+	private final static Map<Character, ChatColor> BY_CHAR = Maps.newHashMap();
+	public static final char COLOR_CHAR = '\u00A7';// \u00A7
+	public static final String PREFIX = ChatColorUtils.COLOR_CHAR + "7[" + ChatColorUtils.COLOR_CHAR + "eBungeeUntil"
+			+ ChatColorUtils.COLOR_CHAR + "7]";
+	private static final Pattern STRIP_FORMAT_PATTERN = Pattern
+			.compile("(?i)" + String.valueOf(COLOR_CHAR) + "[A-FK-OR]");
+	private static final Pattern STRIP_COLOR_PATTERN = Pattern.compile("(?i)" + String.valueOf(COLOR_CHAR) + "[0-9]");
+	static {
+		for (ChatColor color : ChatColor.values()) {
+			BY_CHAR.put(color.toString().charAt(1), color);
+		}
+	}
+
+	/**
+	 * Gets the color represented by the specified color code
+	 *
+	 * @param code
+	 *            Code to check
+	 * @return Associative {@link org.bukkit.ChatColor} with the given code, or
+	 *         null if it doesn't exist
+	 */
+	public static ChatColor getByChar(char code) {
+		return BY_CHAR.get(code);
+	}
+
+	/**
+	 * Gets the color represented by the specified color code
+	 *
+	 * @param code
+	 *            Code to check
+	 * @return Associative {@link org.bukkit.ChatColor} with the given code, or
+	 *         null if it doesn't exist
+	 */
+	public static ChatColor getByChar(String code) {
+		return BY_CHAR.get(code.charAt(0));
+	}
+
+	/**
+	 * Gets the ChatColors used at the end of the given input string.
+	 *
+	 * @param input
+	 *            Input string to retrieve the colors from.
+	 * @return Any remaining ChatColors to pass onto the next line.
+	 */
+	public static String getLastColors(String input) {
+		String result = "";
+		int length = input.length();
+		for (int index = length - 1; index > -1; index--) {
+			char section = input.charAt(index);
+			if (section == COLOR_CHAR && index < length - 1) {
+				char c = input.charAt(index + 1);
+				ChatColor color = getByChar(c);
+				if (color != null) {
+					result = color.toString() + result;
+					if (isColor(color) || color.equals(ChatColor.RESET)) {
+						break;
+					}
+				}
+			}
+		}
+		return result;
+	}
+
+	/**
+	 * Gets the ChatColors used at the end of the given input string.
+	 *
+	 * @param input
+	 *            Input string to retrieve the colors from.
+	 * @return Any remaining ChatColors to pass onto the next line.
+	 */
+	public static ChatModifier getLastModifierColors(String input) {
+		String in = getLastColors(input);
+		ChatModifier mod = new ChatModifier();
+		for (String s : in.split("(?<=\\G.{2})")) {
+			switch (getByChar(s.charAt(1))) {
+			case MAGIC:
+				mod.setRandom(true);
+				break;
+			case UNDERLINE:
+				mod.setUnderline(true);
+				break;
+			case STRIKETHROUGH:
+				mod.setStrikethrough(true);
+				break;
+			case BOLD:
+				mod.setBold(true);
+				break;
+			case ITALIC:
+				mod.setItalic(true);
+				break;
+			case RESET:
+				break;
+			default:
+				mod.setColor(getByChar(s.charAt(1)));
+				break;
+			}
+		}
+		return mod;
+	}
+
+	/**
+	 * Strips the given message of all color codes
+	 *
+	 * @param input
+	 *            String to strip of color
+	 * @return A copy of the input string, without any coloring
+	 */
+	public static String stripColor(final String input) {
+		if (input == null) {
+			return null;
+		}
+		return STRIP_COLOR_PATTERN.matcher(STRIP_FORMAT_PATTERN.matcher(input).replaceAll("")).replaceAll("");
+	}
+
+	public static String stripFormat(final String input) {
+		if (input == null) {
+			return null;
+		}
+		return STRIP_FORMAT_PATTERN.matcher(input).replaceAll("");
+	}
+
+	/**
+	 * Translates a string using an alternate color code character into a string
+	 * that uses the internal ChatColor.COLOR_CODE color code character. The
+	 * alternate color code character will only be replaced if it is immediately
+	 * followed by 0-9, A-F, a-f, K-O, k-o, R or r.
+	 *
+	 * @param altColorChar
+	 *            The alternate color code character to replace. Ex: &
+	 * @param textToTranslate
+	 *            Text containing the alternate color code character.
+	 * @return Text containing the ChatColor.COLOR_CODE color code character.
+	 */
+	public static String translateAlternateColorCodes(char altColorChar, String textToTranslate) {
+		char[] b = textToTranslate.toCharArray();
+		for (int i = 0; i < b.length - 1; i++) {
+			if (b[i] == altColorChar && "0123456789AaBbCcDdEeFfKkLlMmNnOoRr".indexOf(b[i + 1]) > -1) {
+				b[i] = ChatColorUtils.COLOR_CHAR;
+				b[i + 1] = Character.toLowerCase(b[i + 1]);
+			}
+		}
+		return new String(b);
+	}
+
+	public static boolean isColor(ChatColor color) {
+		if (color == null)
+			return false;
+		return !"".equalsIgnoreCase(stripFormat(color.toString()));
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/chat/ChatComponentText.java b/src/main/java/dev/wolveringer/chat/ChatComponentText.java
new file mode 100644
index 0000000..4ce69f7
--- /dev/null
+++ b/src/main/java/dev/wolveringer/chat/ChatComponentText.java
@@ -0,0 +1,83 @@
+package dev.wolveringer.chat;
+
+import java.util.Iterator;
+
+import net.md_5.bungee.api.ChatColor;
+
+public class ChatComponentText extends ChatBaseComponent{
+
+	private final String message;
+
+	public ChatComponentText(String s) {
+		this.message = s;
+	}
+
+	@Override
+	public String getText() {
+		return this.message;
+	}
+
+	@Override
+	public boolean equals(Object object) {
+		if(this == object){
+			return true;
+		}else if(!(object instanceof ChatComponentText)){
+			return false;
+		}else{
+			ChatComponentText chatcomponenttext = (ChatComponentText) object;
+			return this.message.equals(chatcomponenttext.getText()) && super.equals(object);
+		}
+	}
+
+	@SuppressWarnings("unchecked")
+	@Override
+	public IChatBaseComponent addSibling() {
+		ChatComponentText chatcomponenttext = new ChatComponentText(this.message);
+
+		chatcomponenttext.setChatModifier(this.getChatModifier().clone());
+		Iterator<IChatBaseComponent> iterator = this.getSiblings().iterator();
+
+		while (iterator.hasNext()){
+			chatcomponenttext.addSibling(iterator.next().addSibling());
+		}
+
+		return chatcomponenttext;
+	}
+	@Override
+	public String toString() {
+		return toString(StringMethode.LIST_VAR);
+	}
+	
+	public String toString(StringMethode m) {
+		if(m == StringMethode.LIST_VAR)
+			return "TextComponent{text=\'" + this.message + '\'' + ", siblings=" + this.texte + ", style=" + this.getChatModifier() + '}';
+		else if(m == StringMethode.LIST_NOT_NULL_VAR){
+			StringBuilder builder = new StringBuilder();
+			builder.append("TextComponent{");
+			if(this.message != null  && !"".equalsIgnoreCase(this.message)){
+				builder.append("text=");
+				builder.append(this.message);
+				builder.append(", ");
+			}
+			if(this.modifier != null){
+				builder.append("style=");
+				builder.append(this.modifier.toString(m));
+				builder.append(", ");
+			}
+			if(this.texte != null){
+				builder.append("siblings=[");
+				for(IChatBaseComponent c : texte)
+					builder.append(c.toString(m)+", ");
+				builder.append("]");
+			}
+			return builder.append("}").toString().replaceAll(", \\}", "").replaceAll(", \\]", "");
+		}else if(m == StringMethode.MESSAGE_COLORED){
+			return ChatSerializer.toMessage(this, ""+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"f");
+		}else if(m == StringMethode.MESSAGE_UNCOLORED){
+			return ChatColor.stripColor(ChatSerializer.toMessage(this, ""+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"f"));
+		}else if(m == StringMethode.JSON){
+			return ChatSerializer.toJSONString(this);
+		}
+		return "";
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/chat/ChatFunction1.java b/src/main/java/dev/wolveringer/chat/ChatFunction1.java
new file mode 100644
index 0000000..a9d1cde
--- /dev/null
+++ b/src/main/java/dev/wolveringer/chat/ChatFunction1.java
@@ -0,0 +1,14 @@
+package dev.wolveringer.chat;
+
+import com.google.common.base.Function;
+
+@SuppressWarnings({ "rawtypes" })
+final class ChatFunction1 implements Function {
+
+	ChatFunction1() {}
+
+	@Override
+	public Object apply(Object object) {
+		return ((IChatBaseComponent) object).iterator();
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/chat/ChatFunction2.java b/src/main/java/dev/wolveringer/chat/ChatFunction2.java
new file mode 100644
index 0000000..f5443e7
--- /dev/null
+++ b/src/main/java/dev/wolveringer/chat/ChatFunction2.java
@@ -0,0 +1,16 @@
+package dev.wolveringer.chat;
+
+import com.google.common.base.Function;
+
+@SuppressWarnings("rawtypes")
+final class ChatFunction2 implements Function {
+	ChatFunction2() {}
+	
+	@Override
+	public Object apply(Object object) {
+		IChatBaseComponent obj = (IChatBaseComponent) object;
+		IChatBaseComponent silber = obj.addSibling();
+		silber.setChatModifier(silber.getChatModifier().getChatModifier());
+		return silber;
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/chat/ChatHoverable.java b/src/main/java/dev/wolveringer/chat/ChatHoverable.java
new file mode 100644
index 0000000..de069d2
--- /dev/null
+++ b/src/main/java/dev/wolveringer/chat/ChatHoverable.java
@@ -0,0 +1,59 @@
+package dev.wolveringer.chat;
+
+
+public class ChatHoverable {
+
+	private final EnumHoverAction action;
+	private final IChatBaseComponent value;
+
+	public ChatHoverable(EnumHoverAction enumhoveraction, IChatBaseComponent ichatbasecomponent) {
+		this.action = enumhoveraction;
+		this.value = ichatbasecomponent;
+	}
+
+	public EnumHoverAction getAction() {
+		return this.action;
+	}
+
+	public IChatBaseComponent getValue() {
+		return this.value;
+	}
+
+	@Override
+	public boolean equals(Object object) {
+		if(this == object){
+			return true;
+		}else if(object != null && this.getClass() == object.getClass()){
+			ChatHoverable chathoverable = (ChatHoverable) object;
+
+			if(this.action != chathoverable.action){
+				return false;
+			}else{
+				if(this.value != null){
+					if(!this.value.equals(chathoverable.value)){
+						return false;
+					}
+				}else if(chathoverable.value != null){
+					return false;
+				}
+
+				return true;
+			}
+		}else{
+			return false;
+		}
+	}
+
+	@Override
+	public int hashCode() {
+		int i = this.action.hashCode();
+
+		i = 31 * i + (this.value != null ? this.value.hashCode() : 0);
+		return i;
+	}
+
+	@Override
+	public String toString() {
+		return "HoverEvent{action=" + this.action + ", value=\'" + this.value + '\'' + '}';
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/chat/ChatMessage.java b/src/main/java/dev/wolveringer/chat/ChatMessage.java
new file mode 100644
index 0000000..86da2af
--- /dev/null
+++ b/src/main/java/dev/wolveringer/chat/ChatMessage.java
@@ -0,0 +1,148 @@
+package dev.wolveringer.chat;
+
+import java.util.Arrays;
+import java.util.IllegalFormatException;
+import java.util.Iterator;
+import java.util.List;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+import com.google.common.collect.Iterators;
+import com.google.common.collect.Lists;
+
+@SuppressWarnings({"unused","unchecked"})
+public class ChatMessage extends ChatBaseComponent {
+
+	public static final Pattern pattern = Pattern.compile("%(?:(\\d+)\\$)?([A-Za-z%]|$)");
+	List<IChatBaseComponent> siblings = Lists.newArrayList();
+	private final String translationKey;
+	private final Object[] values;
+
+	public ChatMessage(String s, Object... aobject) {
+		this.translationKey = s;
+		this.values = aobject;
+		Object[] aobject1 = aobject;
+		int i = aobject.length;
+
+		for(int j = 0;j < i;++j){
+			Object object = aobject1[j];
+			if(object instanceof IChatBaseComponent){
+				((IChatBaseComponent) object).getChatModifier().setChatModifier(this.getChatModifier());
+			}
+		}
+	}
+
+	private IChatBaseComponent getText(int i){
+		if(i >= this.values.length){
+			throw new ChatMessageException(this, i);
+		}else{
+			Object object = this.values[i];
+			Object object1;
+
+			if(object instanceof IChatBaseComponent){
+				object1 = object;
+			}else{
+				object1 = new ChatComponentText(object == null ? "null" : object.toString());
+				((IChatBaseComponent) object1).getChatModifier().setChatModifier(this.getChatModifier());
+			}
+
+			return (IChatBaseComponent) object1;
+		}
+	}
+
+	@Override
+	public String getText() {
+		StringBuilder stringbuilder = new StringBuilder();
+		Iterator<IChatBaseComponent> iterator = this.siblings.iterator();
+
+		while (iterator.hasNext())
+			stringbuilder.append(iterator.next().getText());
+
+		return stringbuilder.toString();
+	}
+
+	@Override
+	public boolean equals(Object object) {
+		if(this == object){
+			return true;
+		}else if(!(object instanceof ChatMessage)){
+			return false;
+		}else{
+			ChatMessage chatmessage = (ChatMessage) object;
+
+			return Arrays.equals(this.values, chatmessage.values) && this.translationKey.equals(chatmessage.translationKey) && super.equals(object);
+		}
+	}
+
+	@Override
+	public ChatMessage addSibling() {
+		Object[] aobject = new Object[this.values.length];
+
+		for(int i = 0;i < this.values.length;++i){
+			if(this.values[i] instanceof IChatBaseComponent){
+				aobject[i] = ((IChatBaseComponent) this.values[i]).addSibling();
+			}else{
+				aobject[i] = this.values[i];
+			}
+		}
+
+		ChatMessage chatmessage = new ChatMessage(this.translationKey, aobject);
+
+		chatmessage.setChatModifier(this.getChatModifier().clone());
+		Iterator<IChatBaseComponent> iterator = this.getSiblings().iterator();
+
+		while (iterator.hasNext())
+			chatmessage.addSibling(iterator.next().addSibling());
+
+		return chatmessage;
+	}
+
+	@Override
+	public int hashCode() {
+		int i = super.hashCode();
+
+		i = 31 * i + this.translationKey.hashCode();
+		i = 31 * i + Arrays.hashCode(this.values);
+		return i;
+	}
+
+	public String getLanguage() {
+		return this.translationKey;
+	}
+
+	@Override
+	public Iterator<IChatBaseComponent> iterator() {
+		return Iterators.concat(this.siblings.iterator(), this.texte.iterator());
+	}
+
+	public Object[] getData() {
+		return this.values;
+	}
+
+	@Override
+	public IChatBaseComponent setChatModifier(ChatModifier chatmodifier) {
+		super.setChatModifier(chatmodifier);
+		for(int j = 0;j < this.values.length;++j){
+			if(this.values[j] instanceof IChatBaseComponent)
+				((IChatBaseComponent) this.values[j]).getChatModifier().setChatModifier(this.getChatModifier());
+		}
+		if(false){
+			Iterator<IChatBaseComponent> iterator = this.siblings.iterator();
+			while (iterator.hasNext()){
+				iterator.next().getChatModifier().setChatModifier(chatmodifier);
+			}
+		}
+
+		return this;
+	}
+
+	@Override
+	public String toString() {
+		return "TranslatableComponent{key=\'" + this.translationKey + '\'' + ", args=" + Arrays.toString(this.values) + ", siblings=" + this.texte + ", style=" + this.getChatModifier() + '}';
+	}
+
+	@Override
+	public String toString(StringMethode m) {
+		return null;
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/chat/ChatMessageException.java b/src/main/java/dev/wolveringer/chat/ChatMessageException.java
new file mode 100644
index 0000000..e99463f
--- /dev/null
+++ b/src/main/java/dev/wolveringer/chat/ChatMessageException.java
@@ -0,0 +1,18 @@
+package dev.wolveringer.chat;
+
+
+@SuppressWarnings("serial")
+public class ChatMessageException extends IllegalArgumentException {
+
+	public ChatMessageException(ChatMessage chatmessage, int i) {
+		super(String.format("Invalid index %d requested for %s", new Object[] { Integer.valueOf(i), chatmessage }));
+	}
+
+	public ChatMessageException(ChatMessage chatmessage, String s) {
+		super(String.format("Error parsing: %s: %s", new Object[] { chatmessage, s }));
+	}
+
+	public ChatMessageException(ChatMessage chatmessage, Throwable throwable) {
+		super(String.format("Error while parsing: %s", new Object[] { chatmessage }), throwable);
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/chat/ChatModifier.java b/src/main/java/dev/wolveringer/chat/ChatModifier.java
new file mode 100644
index 0000000..d00c34a
--- /dev/null
+++ b/src/main/java/dev/wolveringer/chat/ChatModifier.java
@@ -0,0 +1,271 @@
+package dev.wolveringer.chat;
+
+import net.md_5.bungee.api.ChatColor;
+
+public class ChatModifier {
+
+	private static final ChatModifier defaultModifier = new ChatStyleRoot();
+
+	private ChatModifier modifier;
+
+	private ChatColor color;
+	private Boolean bold = false;
+
+	private Boolean italic = false;
+
+	private Boolean underlined = false;
+
+	private Boolean strikethrough = false;
+
+	private Boolean obfuscated = false;
+
+	private ChatClickable click;
+
+	private ChatHoverable hover;
+
+	public ChatModifier() {
+	}
+
+	public ChatModifier(ChatColor color, Boolean bold, Boolean italic, Boolean underlined, Boolean strikethrough, Boolean obfuscated, ChatClickable click, ChatHoverable hover) {
+		this.color = color;
+		this.bold = bold;
+		this.italic = italic;
+		this.underlined = underlined;
+		this.strikethrough = strikethrough;
+		this.obfuscated = obfuscated;
+		this.click = click;
+		this.hover = hover;
+	}
+
+	public ChatColor getColor() {
+		return this.color == null ? this.getModifier().getColor() : this.color;
+	}
+
+	public ChatModifier setChatModifier(ChatModifier chatmodifier) {
+		this.modifier = chatmodifier;
+		return this;
+	}
+
+	public boolean isBold() {
+		return this.bold == null ? this.getModifier().isBold() : this.bold.booleanValue();
+	}
+
+	public boolean isItalic() {
+		return this.italic == null ? this.getModifier().isItalic() : this.italic.booleanValue();
+	}
+
+	@Override
+	public ChatModifier clone() {
+		ChatModifier chatmodifier = new ChatModifier();
+		chatmodifier.bold = this.bold;
+		chatmodifier.italic = this.italic;
+		chatmodifier.strikethrough = this.strikethrough;
+		chatmodifier.underlined = this.underlined;
+		chatmodifier.obfuscated = this.obfuscated;
+		chatmodifier.color = this.color;
+		chatmodifier.click = this.click;
+		chatmodifier.hover = this.hover;
+		chatmodifier.modifier = this.modifier;
+		return chatmodifier;
+	}
+
+	public boolean isStrikethrough() {
+		return this.strikethrough == null ? this.getModifier().isStrikethrough() : this.strikethrough.booleanValue();
+	}
+
+	public boolean isUnderlined() {
+		return this.underlined == null ? this.getModifier().isUnderlined() : this.underlined.booleanValue();
+	}
+
+	@Override
+	public boolean equals(Object object) {
+		if(this == object){
+			return true;
+		}else if(!(object instanceof ChatModifier)){
+			return false;
+		}else{
+			ChatModifier chatmodifier = (ChatModifier) object;
+			boolean flag;
+
+			if(this.isBold() == chatmodifier.isBold() && this.getColor() == chatmodifier.getColor() && this.isItalic() == chatmodifier.isItalic() && this.isObfuscated() == chatmodifier.isObfuscated() && this.isStrikethrough() == chatmodifier.isStrikethrough() && this.isUnderlined() == chatmodifier.isUnderlined()){
+				label56: {
+					if(this.getClick() != null){
+						if(!this.getClick().equals(chatmodifier.getClick())){
+							break label56;
+						}
+					}else if(chatmodifier.getClick() != null){
+						break label56;
+					}
+
+					if(this.getHover() != null){
+						if(!this.getHover().equals(chatmodifier.getHover())){
+							break label56;
+						}
+					}else if(chatmodifier.getHover() != null){
+						break label56;
+					}
+
+					flag = true;
+					return flag;
+				}
+			}
+
+			flag = false;
+			return flag;
+		}
+	}
+
+	public boolean isObfuscated() {
+		return this.obfuscated == null ? this.getModifier().isObfuscated() : this.obfuscated.booleanValue();
+	}
+
+	public boolean hasOwnStyle() {
+		return this.bold == null && this.italic == null && this.strikethrough == null && this.underlined == null && this.obfuscated == null && this.color == null && this.click == null && this.hover == null;
+	}
+
+	public ChatClickable getClick() {
+		return this.click == null ? this.getModifier().getClick() : this.click;
+	}
+
+	@Override
+	public int hashCode() {
+		int i = this.color.hashCode();
+
+		i = 31 * i + this.bold.hashCode();
+		i = 31 * i + this.italic.hashCode();
+		i = 31 * i + this.underlined.hashCode();
+		i = 31 * i + this.strikethrough.hashCode();
+		i = 31 * i + this.obfuscated.hashCode();
+		i = 31 * i + this.click.hashCode();
+		i = 31 * i + this.hover.hashCode();
+		return i;
+	}
+
+	public ChatHoverable getHover() {
+		return this.hover == null ? this.getModifier().getHover() : this.hover;
+	}
+
+	public ChatModifier getChatModifier() {
+		ChatModifier chatmodifier = new ChatModifier();
+		chatmodifier.setBold(Boolean.valueOf(this.isBold()));
+		chatmodifier.setItalic(Boolean.valueOf(this.isItalic()));
+		chatmodifier.setStrikethrough(Boolean.valueOf(this.isStrikethrough()));
+		chatmodifier.setUnderline(Boolean.valueOf(this.isUnderlined()));
+		chatmodifier.setRandom(Boolean.valueOf(this.isObfuscated()));
+		chatmodifier.setColor(this.getColor());
+		chatmodifier.setChatClickable(this.getClick());
+		chatmodifier.setHover(this.getHover());
+		return chatmodifier;
+	}
+
+	private ChatModifier getModifier() {
+		return this.modifier == null ? defaultModifier : this.modifier;
+	}
+
+	public ChatModifier setBold(Boolean obool) {
+		this.bold = obool;
+		return this;
+	}
+
+	public ChatModifier setChatClickable(ChatClickable chatclickable) {
+		this.click = chatclickable;
+		return this;
+	}
+
+	public ChatModifier setHover(ChatHoverable hover) {
+		this.hover = hover;
+		return this;
+	}
+
+	public ChatModifier setColor(ChatColor enumchatformat) {
+		this.color = enumchatformat;
+		return this;
+	}
+
+	public ChatModifier setItalic(Boolean obool) {
+		this.italic = obool;
+		return this;
+	}
+
+	public ChatModifier setRandom(Boolean obool) {
+		this.obfuscated = obool;
+		return this;
+	}
+
+	public ChatModifier setStrikethrough(Boolean obool) {
+		this.strikethrough = obool;
+		return this;
+	}
+
+	public ChatModifier setUnderline(Boolean obool) {
+		this.underlined = obool;
+		return this;
+	}
+
+	public void resetColors() {
+		bold = null;
+		color = null;
+		italic = null;
+		obfuscated = null;
+		strikethrough = null;
+		underlined = null;
+	}
+	
+	@Override
+	public String toString() {
+		return "Style{hasParent=" + (this.modifier != null) + ", color=" + this.color + ", bold=" + this.bold + ", italic=" + this.italic + ", underlined=" + this.underlined + ", strikethrough=" + this.strikethrough + ", obfuscated=" + this.obfuscated + ", clickEvent=" + this.getClick() + ", hoverEvent=" + this.getHover() + '}';
+	}
+
+	public String toString(StringMethode m) {
+		if(m == StringMethode.LIST_NOT_NULL_VAR){
+			StringBuilder builder = new StringBuilder();
+			builder.append("Style");
+			builder.append("{");
+			builder.append("hasParent=");
+			builder.append(this.modifier != null);
+			builder.append(", ");
+			if(this.color != null){
+				builder.append("color=");
+				builder.append(this.color);
+				builder.append(", ");
+			}
+			if(this.bold != null){
+				builder.append("bold=");
+				builder.append(this.bold);
+				builder.append(", ");
+			}
+			if(this.italic != null){
+				builder.append("italic=");
+				builder.append(this.italic);
+				builder.append(", ");
+			}
+			if(this.underlined != null){
+				builder.append("underlined=");
+				builder.append(this.underlined);
+				builder.append(", ");
+			}
+			if(this.strikethrough != null){
+				builder.append("strikethrough=");
+				builder.append(this.strikethrough);
+				builder.append(", ");
+			}
+			if(this.obfuscated != null){
+				builder.append("obfuscated=");
+				builder.append(this.obfuscated);
+				builder.append(", ");
+			}
+			if(this.click != null){
+				builder.append("clickEvent=");
+				builder.append(this.click);
+				builder.append(", ");
+			}
+			if(this.hover != null){
+				builder.append("hoverEvent=");
+				builder.append(this.hover);
+			}
+			builder.append("}");
+			return builder.toString();
+		}
+		return toString();
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/chat/ChatModifierSerializer.java b/src/main/java/dev/wolveringer/chat/ChatModifierSerializer.java
new file mode 100644
index 0000000..e92bb11
--- /dev/null
+++ b/src/main/java/dev/wolveringer/chat/ChatModifierSerializer.java
@@ -0,0 +1,142 @@
+package dev.wolveringer.chat;
+
+import java.lang.reflect.Type;
+
+import net.md_5.bungee.api.ChatColor;
+
+import com.google.gson.JsonDeserializationContext;
+import com.google.gson.JsonDeserializer;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import com.google.gson.JsonPrimitive;
+import com.google.gson.JsonSerializationContext;
+import com.google.gson.JsonSerializer;
+
+@SuppressWarnings({ "rawtypes" })
+public class ChatModifierSerializer implements JsonDeserializer, JsonSerializer {
+
+	public ChatModifierSerializer() {
+	}
+
+	public JsonElement serialize(Object obj, Type type, JsonSerializationContext jsonserializationcontext) {
+		if(!(obj instanceof ChatModifier))
+			throw new IllegalStateException();
+		ChatModifier modifier = (ChatModifier) obj;
+		if(modifier.hasOwnStyle()){
+			return null;
+		}else{
+			JsonObject json = new JsonObject();
+
+			if(modifier.isBold() == true){
+				json.addProperty("bold", modifier.isBold());
+			}
+
+			if(modifier.isItalic() == true){
+				json.addProperty("italic", modifier.isItalic());
+			}
+
+			if(modifier.isUnderlined() == true){
+				json.addProperty("underlined", modifier.isUnderlined());
+			}
+
+			if(modifier.isStrikethrough() == true){
+				json.addProperty("strikethrough", modifier.isStrikethrough());
+			}
+
+			if(modifier.isObfuscated() == true){
+				json.addProperty("obfuscated", modifier.isObfuscated());
+			}
+
+			if(modifier.getColor() != null){
+				json.add("color", jsonserializationcontext.serialize(modifier.getColor()));
+			}
+
+			JsonObject actionJson;
+
+			if(modifier.getClick() != null){
+				actionJson = new JsonObject();
+				actionJson.addProperty("action", modifier.getClick().getAction().getActionName());
+				actionJson.addProperty("value", modifier.getClick().getValue());
+				json.add("clickEvent", actionJson);
+			}
+
+			if(modifier.getHover() != null){
+				actionJson = new JsonObject();
+				actionJson.addProperty("action", modifier.getHover().getAction().getActionName());
+				actionJson.add("value", jsonserializationcontext.serialize(modifier.getHover().getValue()));
+				json.add("hoverEvent", actionJson);
+			}
+
+			return json;
+		}
+	}
+
+	public ChatModifier deserialize(JsonElement jsonelement, Type type, JsonDeserializationContext jsondeserializationcontext) {
+		if(jsonelement.isJsonObject()){
+			ChatModifier chatmodifier = new ChatModifier();
+			JsonObject jsonobject = jsonelement.getAsJsonObject();
+
+			if(jsonobject == null){
+				return null;
+			}else{
+				if(jsonobject.has("bold")){
+					chatmodifier.setBold(jsonobject.get("bold").getAsBoolean());
+				}
+
+				if(jsonobject.has("italic")){
+					chatmodifier.setItalic(jsonobject.get("italic").getAsBoolean());
+				}
+
+				if(jsonobject.has("underlined")){
+					chatmodifier.setUnderline(jsonobject.get("underlined").getAsBoolean());
+				}
+
+				if(jsonobject.has("strikethrough")){
+					chatmodifier.setStrikethrough(jsonobject.get("strikethrough").getAsBoolean());
+				}
+
+				if(jsonobject.has("obfuscated")){
+					chatmodifier.setRandom(jsonobject.get("obfuscated").getAsBoolean());
+				}
+
+				if(jsonobject.has("color")){
+					chatmodifier.setColor((ChatColor) jsondeserializationcontext.deserialize(jsonobject.get("color"), ChatColor.class));
+				}
+
+				JsonObject jsonobject1;
+				JsonPrimitive jsonprimitive;
+
+				if(jsonobject.has("clickEvent")){
+					jsonobject1 = jsonobject.getAsJsonObject("clickEvent");
+					if(jsonobject1 != null){
+						jsonprimitive = jsonobject1.getAsJsonPrimitive("action");
+						EnumClickAction enumclickaction = jsonprimitive == null ? null : EnumClickAction.getActionFromName(jsonprimitive.getAsString());
+						JsonPrimitive jsonprimitive1 = jsonobject1.getAsJsonPrimitive("value");
+						String s = jsonprimitive1 == null ? null : jsonprimitive1.getAsString();
+
+						if(enumclickaction != null && s != null && enumclickaction.hasExtraData()){
+							chatmodifier.setChatClickable(new ChatClickable(enumclickaction, s));
+						}
+					}
+				}
+
+				if(jsonobject.has("hoverEvent")){
+					jsonobject1 = jsonobject.getAsJsonObject("hoverEvent");
+					if(jsonobject1 != null){
+						jsonprimitive = jsonobject1.getAsJsonPrimitive("action");
+						EnumHoverAction enumhoveraction = jsonprimitive == null ? null : EnumHoverAction.getActionFromName(jsonprimitive.getAsString());
+						IChatBaseComponent ichatbasecomponent = (IChatBaseComponent) jsondeserializationcontext.deserialize(jsonobject1.get("value"), IChatBaseComponent.class);
+
+						if(enumhoveraction != null && ichatbasecomponent != null && enumhoveraction.hasExtraData()){
+							chatmodifier.setHover(new ChatHoverable(enumhoveraction, ichatbasecomponent));
+						}
+					}
+				}
+
+				return chatmodifier;
+			}
+		}else{
+			return null;
+		}
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/chat/ChatSerializer.java b/src/main/java/dev/wolveringer/chat/ChatSerializer.java
new file mode 100644
index 0000000..82a36cc
--- /dev/null
+++ b/src/main/java/dev/wolveringer/chat/ChatSerializer.java
@@ -0,0 +1,309 @@
+package dev.wolveringer.chat;
+
+import java.lang.reflect.Type;
+import java.util.Iterator;
+import java.util.Map.Entry;
+
+import net.md_5.bungee.api.ChatColor;
+import net.md_5.bungee.api.chat.BaseComponent;
+import net.md_5.bungee.chat.ComponentSerializer;
+
+import com.google.gson.Gson;
+import com.google.gson.GsonBuilder;
+import com.google.gson.JsonArray;
+import com.google.gson.JsonDeserializationContext;
+import com.google.gson.JsonDeserializer;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import com.google.gson.JsonParseException;
+import com.google.gson.JsonPrimitive;
+import com.google.gson.JsonSerializationContext;
+import com.google.gson.JsonSerializer;
+
+import dev.wolveringer.chat.ChatColor.ChatColorUtils;
+
+@SuppressWarnings("rawtypes")
+public class ChatSerializer implements JsonDeserializer, JsonSerializer {
+
+	private static final Gson deserelizer;
+
+	static{
+		GsonBuilder gsonbuilder = new GsonBuilder();
+		gsonbuilder.registerTypeHierarchyAdapter(IChatBaseComponent.class, new ChatSerializer());
+		gsonbuilder.registerTypeHierarchyAdapter(ChatModifier.class, new ChatModifierSerializer());
+		gsonbuilder.registerTypeAdapterFactory(new ChatTypeAdapterFactory());
+		deserelizer = gsonbuilder.create();
+	}
+
+	public static IChatBaseComponent toIChatBaseComponent(BaseComponent comp) {
+		return fromJSON(ComponentSerializer.toString(comp));
+	}
+
+	public static String toJSONString(IChatBaseComponent ichatbasecomponent) {
+		return deserelizer.toJson(ichatbasecomponent);
+	}
+
+	public static IChatBaseComponent fromJSON(String s) {
+		return deserelizer.fromJson(s, IChatBaseComponent.class);
+	}
+
+	ChatSerializer() {
+	}
+
+	public static String toMessage(IChatBaseComponent component) {
+		return toMessage(component, new ChatModifier());
+	}
+
+	public static String toMessage(IChatBaseComponent component, String last) {
+		return toMessage(component, ChatColorUtils.getLastModifierColors(last));
+	}
+
+	public static String toMessage(IChatBaseComponent component, ChatModifier defaultModifier) {
+		return toMessage(component, defaultModifier, 0);
+	}
+
+	@SuppressWarnings("unchecked")
+	public static String toMessage(IChatBaseComponent component, ChatModifier defaultModifier, int start) {
+		if(component == null)
+			return "";
+		StringBuilder out = new StringBuilder();
+		String first = null;
+		int count = 0;
+		for(IChatBaseComponent c : (Iterable<IChatBaseComponent>) component){
+			if(count < start){
+				count++;
+				continue;
+			}
+			if(first == null)
+				first = c.getText();
+			ChatModifier modi = c.getChatModifier();
+			if(modi == null)
+				modi = defaultModifier;
+			out.append(modi.getColor() == null ? defaultModifier.getColor() == null ? ChatColor.WHITE : defaultModifier.getColor() : modi.getColor());
+			if(modi.isBold())
+				out.append(ChatColor.BOLD);
+			if(modi.isItalic())
+				out.append(ChatColor.ITALIC);
+			if(modi.isUnderlined())
+				out.append(ChatColor.UNDERLINE);
+			if(modi.isBold())
+				out.append(ChatColor.STRIKETHROUGH);
+			if(modi.isObfuscated())
+				out.append(ChatColor.MAGIC);
+			out.append(c.getText());
+		}
+		String o = out.toString();
+		if(defaultModifier.getColor() != null)
+			o = o.replaceFirst("^(" + defaultModifier.getColor() + ")*", "");
+		return o;
+	}
+
+	public static IChatBaseComponent fromMessage(String s) {
+		ChatComponentText comp = new ChatComponentText("");
+		if(!s.startsWith(""+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+""))
+			s = ""+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"f" + s;
+		ChatColor color = ChatColor.WHITE;
+		boolean bold = false;
+		boolean italic = false;
+		boolean underlined = false;
+		boolean strikethrough = false;
+		boolean obfuscated = false;
+		String[] all = s.split(""+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"");
+		for(int i = 0;i < all.length;i++){
+			if(i + 1 < all.length){
+				ChatColor c = ChatColor.getByChar(all[i + 1].charAt(0));
+				if(c == ChatColor.BOLD)
+					bold = true;
+				else if(c == ChatColor.ITALIC)
+					italic = true;
+				else if(c == ChatColor.UNDERLINE)
+					underlined = true;
+				else if(c == ChatColor.STRIKETHROUGH)
+					strikethrough = true;
+				else if(c == ChatColor.MAGIC)
+					obfuscated = true;
+				else if(c == ChatColor.RESET){
+					bold = false;
+					italic = false;
+					underlined = false;
+					strikethrough = false;
+					obfuscated = false;
+					color = ChatColor.WHITE;
+				}else{
+					bold = false;
+					italic = false;
+					underlined = false;
+					strikethrough = false;
+					obfuscated = false;
+					color = c;
+				}
+				String msg = all[i + 1].substring(1);
+				if(msg.equalsIgnoreCase(""))
+					continue;
+				ChatComponentText sibling = new ChatComponentText(msg);
+				sibling.getChatModifier().setColor(color);
+				sibling.getChatModifier().setBold(bold);
+				sibling.getChatModifier().setItalic(italic);
+				sibling.getChatModifier().setRandom(obfuscated);
+				sibling.getChatModifier().setUnderline(underlined);
+				sibling.getChatModifier().setStrikethrough(strikethrough);
+				comp.addSibling(sibling);
+			}
+		}
+		return comp;
+	}
+
+	@Override
+	public JsonElement serialize(Object arg0, Type arg1, JsonSerializationContext arg2) {
+		return this.serialize((IChatBaseComponent) arg0, arg1, arg2);
+	}
+
+	@Override
+	public Object deserialize(JsonElement in_obj, Type type, JsonDeserializationContext context) throws JsonParseException {
+		if(in_obj.isJsonPrimitive()){
+			return new ChatComponentText(in_obj.getAsString());
+		}else if(!in_obj.isJsonObject()){
+			if(in_obj.isJsonArray()){
+				JsonArray in = in_obj.getAsJsonArray();
+				IChatBaseComponent ichatbasecomponent = null;
+				Iterator<JsonElement> iterator = in.iterator();
+				while (iterator.hasNext()){
+					JsonElement jsonelement1 = iterator.next();
+					IChatBaseComponent ichatbasecomponent1 = (IChatBaseComponent) this.deserialize(jsonelement1, jsonelement1.getClass(), context);
+
+					if(ichatbasecomponent == null){
+						ichatbasecomponent = ichatbasecomponent1;
+					}else{
+						ichatbasecomponent.addSibling(ichatbasecomponent1);
+					}
+				}
+
+				return ichatbasecomponent;
+			}else{
+				throw new JsonParseException("Don\'t know how to turn " + in_obj.toString() + " into a Component");
+			}
+		}else{
+			JsonObject jsonobject = in_obj.getAsJsonObject();
+			Object object;
+
+			if(jsonobject.has("text")){
+				object = new ChatComponentText(jsonobject.get("text").getAsString());
+			}else{
+				if(!jsonobject.has("translate")){
+					throw new JsonParseException("Don\'t know how to turn " + in_obj.toString() + " into a Component");
+				}
+
+				String s = jsonobject.get("translate").getAsString();
+
+				if(jsonobject.has("with")){
+					JsonArray jsonarray1 = jsonobject.getAsJsonArray("with");
+					Object[] aobject = new Object[jsonarray1.size()];
+
+					for(int i = 0;i < aobject.length;++i){
+						aobject[i] = this.deserialize(jsonarray1.get(i), type, context);
+						if(aobject[i] instanceof ChatComponentText){
+							ChatComponentText chatcomponenttext = (ChatComponentText) aobject[i];
+
+							if(chatcomponenttext.getChatModifier().hasOwnStyle() && chatcomponenttext.getSiblings().isEmpty()){
+								aobject[i] = chatcomponenttext.getRawText();
+							}
+						}
+					}
+
+					object = new ChatMessage(s, aobject);
+				}else{
+					object = new ChatMessage(s, new Object[0]);
+				}
+			}
+
+			if(jsonobject.has("extra")){
+				JsonArray jsonarray2 = jsonobject.getAsJsonArray("extra");
+
+				if(jsonarray2.size() <= 0){
+					throw new JsonParseException("Unexpected empty array of components");
+				}
+
+				for(int j = 0;j < jsonarray2.size();++j){
+					((IChatBaseComponent) object).addSibling((IChatBaseComponent) this.deserialize(jsonarray2.get(j), type, context));
+				}
+			}
+
+			((IChatBaseComponent) object).setChatModifier((ChatModifier) context.deserialize(in_obj, ChatModifier.class));
+			return (IChatBaseComponent) object;
+		}
+	}
+
+	@SuppressWarnings("unchecked")
+	public JsonElement serialize(IChatBaseComponent in, Type type, JsonSerializationContext context) {
+		if(in instanceof ChatComponentText && in.getChatModifier().hasOwnStyle() && in.getSiblings().isEmpty()){
+			return new JsonPrimitive(((ChatComponentText) in).getRawText());
+		}else{
+			JsonObject out = new JsonObject();
+
+			if(!in.getChatModifier().hasOwnStyle()){
+				this.a(in.getChatModifier(), out, context);
+			}
+
+			if(!in.getSiblings().isEmpty()){
+				JsonArray siblings = new JsonArray();
+				Iterator<IChatBaseComponent> iterator = in.getSiblings().iterator();
+
+				while (iterator.hasNext()){
+					IChatBaseComponent ichatbasecomponent1 = iterator.next();
+					siblings.add(this.serialize(ichatbasecomponent1, ichatbasecomponent1.getClass(), context));
+				}
+				out.add("extra", siblings);
+				if("".equalsIgnoreCase(in.getText()))
+					out.addProperty("text", "");
+				else
+					out.addProperty("text", in.getText());
+			}else if(in instanceof ChatComponentText){
+				out.addProperty("text", ((ChatComponentText) in).getRawText());
+			}else{
+				if(!(in instanceof ChatMessage))
+					throw new IllegalArgumentException("Don\'t know how to serialize " + in + " as a Component");
+
+				ChatMessage message = (ChatMessage) in;
+
+				out.addProperty("translate", message.getLanguage());
+				if(message.getData() != null && message.getData().length > 0){
+					JsonArray jsonarray1 = new JsonArray();
+					Object[] aobject = message.getData();
+					int i = aobject.length;
+
+					for(int j = 0;j < i;++j){
+						Object object = aobject[j];
+
+						if(object instanceof IChatBaseComponent){
+							jsonarray1.add(this.serialize((IChatBaseComponent) object, (Type) object.getClass(), context));
+						}else{
+							jsonarray1.add(new JsonPrimitive(String.valueOf(object)));
+						}
+					}
+
+					out.add("with", jsonarray1);
+				}
+			}
+
+			return out;
+		}
+	}
+
+	private void a(ChatModifier chatmodifier, JsonObject jsonobject, JsonSerializationContext jsonserializationcontext) {
+		JsonElement jsonelement = jsonserializationcontext.serialize(chatmodifier);
+		if(jsonelement.isJsonObject()){
+			JsonObject jsonobject1 = (JsonObject) jsonelement;
+			Iterator iterator = jsonobject1.entrySet().iterator();
+
+			while (iterator.hasNext()){
+				Entry entry = (Entry) iterator.next();
+
+				jsonobject.add((String) entry.getKey(), (JsonElement) entry.getValue());
+			}
+		}
+	}
+
+	public static String toString(IChatBaseComponent comp, StringMethode m) {
+		return ((ChatBaseComponent) comp).toString(m).replaceAll(", \\}", "").replaceAll(", \\]", "");
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/chat/ChatStyleRoot.java b/src/main/java/dev/wolveringer/chat/ChatStyleRoot.java
new file mode 100644
index 0000000..ea4b0a7
--- /dev/null
+++ b/src/main/java/dev/wolveringer/chat/ChatStyleRoot.java
@@ -0,0 +1,109 @@
+package dev.wolveringer.chat;
+
+import net.md_5.bungee.api.ChatColor;
+
+final class ChatStyleRoot extends ChatModifier {
+
+	ChatStyleRoot() {
+	}
+
+	@Override
+	public ChatModifier setHover(ChatHoverable chathoverable) {
+		throw new UnsupportedOperationException();
+	}
+
+	@Override
+	public ChatModifier setChatModifier(ChatModifier chatmodifier) {
+		throw new UnsupportedOperationException();
+	}
+
+	@Override
+	public ChatModifier clone() {
+		return this;
+	}
+
+	@Override
+	public ChatModifier getChatModifier() {
+		return super.getChatModifier();
+	}
+
+	@Override
+	public ChatClickable getClick() {
+		return null;
+	}
+
+	@Override
+	public ChatColor getColor() {
+		return ChatColor.WHITE;
+	}
+
+	@Override
+	public ChatHoverable getHover() {
+		return null;
+	}
+
+	@Override
+	public ChatModifier setBold(Boolean obool) {
+		throw new UnsupportedOperationException();
+	}
+
+	@Override
+	public ChatModifier setChatClickable(ChatClickable chatclickable) {
+		throw new UnsupportedOperationException();
+	}
+
+	@Override
+	public ChatModifier setColor(ChatColor enumchatformat) {
+		throw new UnsupportedOperationException();
+	}
+
+	@Override
+	public ChatModifier setItalic(Boolean obool) {
+		throw new UnsupportedOperationException();
+	}
+
+	@Override
+	public ChatModifier setRandom(Boolean obool) {
+		throw new UnsupportedOperationException();
+	}
+
+	@Override
+	public ChatModifier setStrikethrough(Boolean obool) {
+		throw new UnsupportedOperationException();
+	}
+
+	@Override
+	public ChatModifier setUnderline(Boolean obool) {
+		throw new UnsupportedOperationException();
+	}
+
+	@Override
+	public boolean isBold() {
+		return false;
+	}
+
+	@Override
+	public boolean isItalic() {
+		return false;
+	}
+
+	@Override
+	public boolean isObfuscated() {
+		return false;
+	}
+
+	@Override
+	public boolean isStrikethrough() {
+		return false;
+	}
+
+	@Override
+	public boolean isUnderlined() {
+		return false;
+	}
+
+	@Override
+	public String toString() {
+		return "Style.ROOT";
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/chat/ChatTextBuilder.java b/src/main/java/dev/wolveringer/chat/ChatTextBuilder.java
new file mode 100644
index 0000000..20c3655
--- /dev/null
+++ b/src/main/java/dev/wolveringer/chat/ChatTextBuilder.java
@@ -0,0 +1,72 @@
+package dev.wolveringer.chat;
+
+import net.md_5.bungee.api.ChatColor;
+import dev.wolveringer.chat.ChatColor.ChatColorUtils;
+
+public class ChatTextBuilder {
+	IChatBaseComponent base;
+	IChatBaseComponent currunt = null;
+
+	public ChatTextBuilder() {
+		base = new ChatComponentText("");
+	}
+
+	public ChatTextBuilder appand(String text) {
+		if(currunt != null)
+			base.addSibling(currunt);
+		currunt = new ChatComponentText("");
+		return this;
+	}
+
+	public ChatTextBuilder setColor(ChatColor color) {
+		if(ChatColorUtils.isColor(color))
+			currunt.getChatModifier().setColor(color);
+		return this;
+	}
+
+	public void setFormat(ChatColor... format) {
+		currunt.getChatModifier().resetColors();
+		for(ChatColor c : format)
+			if(!ChatColorUtils.isColor(c)){
+				switch (c) {
+					case BOLD:
+						currunt.getChatModifier().setBold(true);
+						continue;
+					case ITALIC:
+						currunt.getChatModifier().setItalic(true);
+						continue;
+					case MAGIC:
+						currunt.getChatModifier().setRandom(true);
+						continue;
+					case STRIKETHROUGH:
+						currunt.getChatModifier().setStrikethrough(true);
+						continue;
+					case UNDERLINE:
+						currunt.getChatModifier().setUnderline(true);
+						continue;
+					default:
+						continue;
+				}
+			}
+	}
+
+	public ChatTextBuilder setHoverAction(ChatHoverable hover) {
+		currunt.getChatModifier().setHover(hover);
+		return this;
+	}
+
+	public ChatTextBuilder setHoverAction(String hover) {
+		currunt.getChatModifier().setHover(new ChatHoverable(EnumHoverAction.SHOW_TEXT, ChatSerializer.fromMessage(hover)));
+		return this;
+	}
+
+	public ChatTextBuilder setHoverAction(EnumHoverAction action, String hover) {
+		currunt.getChatModifier().setHover(new ChatHoverable(action, ChatSerializer.fromMessage(hover)));
+		return this;
+	}
+
+	public ChatTextBuilder setHoverAction(EnumHoverAction action, IChatBaseComponent hover) {
+		currunt.getChatModifier().setHover(new ChatHoverable(action, hover));
+		return this;
+	}
+}
diff --git a/src/main/java/dev/wolveringer/chat/ChatTypeAdapter.java b/src/main/java/dev/wolveringer/chat/ChatTypeAdapter.java
new file mode 100644
index 0000000..68c329c
--- /dev/null
+++ b/src/main/java/dev/wolveringer/chat/ChatTypeAdapter.java
@@ -0,0 +1,58 @@
+package dev.wolveringer.chat;
+
+import java.io.IOException;
+import java.util.Map;
+
+import com.google.gson.TypeAdapter;
+import com.google.gson.stream.JsonReader;
+import com.google.gson.stream.JsonToken;
+import com.google.gson.stream.JsonWriter;
+
+
+@SuppressWarnings({"rawtypes"})
+class ChatTypeAdapter extends TypeAdapter {
+
+	final Map a;
+	final ChatTypeAdapterFactory b;
+
+	ChatTypeAdapter(ChatTypeAdapterFactory chattypeadapterfactory, Map map) {
+		this.b = chattypeadapterfactory;
+		this.a = map;
+	}
+
+	@Override
+	public Object read(JsonReader jsonreader) {
+		try{
+			if(jsonreader.peek() == JsonToken.NULL){
+				try{
+					jsonreader.nextNull();
+				}catch (IOException e){
+					e.printStackTrace();
+				}
+				return null;
+			}else{
+				return this.a.get(jsonreader.nextString());
+			}
+		}catch (IOException e){
+			e.printStackTrace();
+		}
+		return jsonreader;
+	}
+
+	@Override
+	public void write(JsonWriter jsonwriter, Object object) {
+		if(object == null){
+			try{
+				jsonwriter.nullValue();
+			}catch (IOException e){
+				e.printStackTrace();
+			}
+		}else{
+			try{
+				jsonwriter.value(ChatTypeAdapterFactory.a(this.b, object));
+			}catch (IOException e){
+				e.printStackTrace();
+			}
+		}
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/chat/ChatTypeAdapterFactory.java b/src/main/java/dev/wolveringer/chat/ChatTypeAdapterFactory.java
new file mode 100644
index 0000000..35d30df
--- /dev/null
+++ b/src/main/java/dev/wolveringer/chat/ChatTypeAdapterFactory.java
@@ -0,0 +1,45 @@
+package dev.wolveringer.chat;
+
+import java.util.HashMap;
+import java.util.Locale;
+
+import com.google.gson.Gson;
+import com.google.gson.TypeAdapter;
+import com.google.gson.TypeAdapterFactory;
+import com.google.gson.reflect.TypeToken;
+
+
+@SuppressWarnings({"rawtypes", "unchecked"})
+public class ChatTypeAdapterFactory implements TypeAdapterFactory {
+
+	static String a(ChatTypeAdapterFactory chattypeadapterfactory, Object object) {
+		return chattypeadapterfactory.a(object);
+	}
+
+	public ChatTypeAdapterFactory() {
+	}
+
+	private String a(Object object) {
+		return object instanceof Enum ? ((Enum) object).name().toLowerCase(Locale.US) : object.toString().toLowerCase(Locale.US);
+	}
+
+	@Override
+	public TypeAdapter create(Gson gson, TypeToken typetoken) {
+		Class oclass = typetoken.getRawType();
+		if(!oclass.isEnum()){
+			return null;
+		}else{
+			HashMap hashmap = new HashMap();
+			Object[] aobject = oclass.getEnumConstants();
+			int i = aobject.length;
+
+			for(int j = 0;j < i;++j){
+				Object object = aobject[j];
+
+				hashmap.put(this.a(object), object);
+			}
+
+			return new ChatTypeAdapter(this, hashmap);
+		}
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/chat/EnumClickAction.java b/src/main/java/dev/wolveringer/chat/EnumClickAction.java
new file mode 100644
index 0000000..97f5d86
--- /dev/null
+++ b/src/main/java/dev/wolveringer/chat/EnumClickAction.java
@@ -0,0 +1,44 @@
+package dev.wolveringer.chat;
+
+import java.util.Map;
+
+import com.google.common.collect.Maps;
+
+@SuppressWarnings("unchecked")
+public enum EnumClickAction {
+
+	OPEN_URL("OPEN_URL", 0, "open_url", true),
+	OPEN_FILE("OPEN_FILE", 1, "open_file", false),
+	RUN_COMMAND("RUN_COMMAND", 2, "run_command", true),
+	SUGGEST_COMMAND("SUGGEST_COMMAND", 4, "suggest_command", true),
+	TWITCH_USER_INFO("TWITCH_USER_INFO", 3, "twitch_user_info", false);
+	
+	@SuppressWarnings("rawtypes")
+	private static final Map actions = Maps.newHashMap();
+	static{
+		for(EnumClickAction c : values()){
+			actions.put(c.getActionName(), c);
+		}
+	}
+
+	public static EnumClickAction getActionFromName(String s) {
+		return (EnumClickAction) actions.get(s);
+	}
+
+	private final boolean extra_data;
+
+	private final String command;
+
+	private EnumClickAction(String s, int i, String command, boolean extra_data) {
+		this.command = command;
+		this.extra_data = extra_data;
+	}
+
+	public boolean hasExtraData() {
+		return this.extra_data;
+	}
+
+	public String getActionName() {
+		return this.command;
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/chat/EnumHoverAction.java b/src/main/java/dev/wolveringer/chat/EnumHoverAction.java
new file mode 100644
index 0000000..8f54570
--- /dev/null
+++ b/src/main/java/dev/wolveringer/chat/EnumHoverAction.java
@@ -0,0 +1,41 @@
+package dev.wolveringer.chat;
+
+import java.util.Map;
+
+import com.google.common.collect.Maps;
+
+@SuppressWarnings("unchecked")
+public enum EnumHoverAction {
+	
+	SHOW_ITEM("SHOW_ITEM", 2, "show_item", true),
+	SHOW_ACHIEVEMENT("SHOW_ACHIEVEMENT", 1, "show_achievement", true),
+	SHOW_TEXT("SHOW_TEXT", 0, "show_text", true);
+	
+	@SuppressWarnings("rawtypes")
+	private static final Map names = Maps.newHashMap();
+	static{
+		for(EnumHoverAction action : values())
+			names.put(action.getActionName(), action);
+	}
+
+	public static EnumHoverAction getActionFromName(String s) {
+		return (EnumHoverAction) names.get(s);
+	}
+
+	private final boolean extra_data;
+
+	private final String command;
+
+	private EnumHoverAction(String s, int i, String command, boolean extra_data) {
+		this.command = command;
+		this.extra_data = extra_data;
+	}
+
+	public boolean hasExtraData(){
+		return this.extra_data;
+	}
+
+	public String getActionName(){
+		return this.command;
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/chat/IChatBaseComponent.java b/src/main/java/dev/wolveringer/chat/IChatBaseComponent.java
new file mode 100644
index 0000000..c51510c
--- /dev/null
+++ b/src/main/java/dev/wolveringer/chat/IChatBaseComponent.java
@@ -0,0 +1,32 @@
+package dev.wolveringer.chat;
+
+import java.util.ArrayList;
+import java.util.List;
+
+@SuppressWarnings("rawtypes")
+public interface IChatBaseComponent extends Iterable {
+
+	List getSiblings();
+
+	IChatBaseComponent addSibling(String s);
+
+	IChatBaseComponent addSibling(IChatBaseComponent ichatbasecomponent);
+
+	String getRawText();
+
+	String getText();
+
+	IChatBaseComponent addSibling();
+
+	ChatModifier getChatModifier();
+
+	IChatBaseComponent setChatModifier(ChatModifier chatmodifier);
+
+	boolean hasClickListener();
+	
+	public ChatClickListener run(String s);
+	
+	public ArrayList<String> getClickSignature();
+	
+	public String toString(StringMethode m);
+}
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/chat/PlayerChatListener.java b/src/main/java/dev/wolveringer/chat/PlayerChatListener.java
new file mode 100644
index 0000000..7f8f072
--- /dev/null
+++ b/src/main/java/dev/wolveringer/chat/PlayerChatListener.java
@@ -0,0 +1,64 @@
+package dev.wolveringer.chat;
+
+import java.util.Date;
+import java.util.HashMap;
+import java.util.concurrent.TimeUnit;
+
+import net.md_5.bungee.BungeeCord;
+import dev.wolveringer.BungeeUtil.BungeeUtil;
+import dev.wolveringer.BungeeUtil.Main;
+import dev.wolveringer.BungeeUtil.PacketHandleEvent;
+import dev.wolveringer.BungeeUtil.PacketHandler;
+import dev.wolveringer.BungeeUtil.PacketLib;
+import dev.wolveringer.BungeeUtil.packets.Packet;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayInChat;
+
+public class PlayerChatListener implements PacketHandler<Packet> {
+	static{
+		PacketLib.addHandler(instance = new PlayerChatListener());
+	}
+
+	private static final PlayerChatListener instance;
+	private HashMap<String, IChatBaseComponent> chats = new HashMap<String, IChatBaseComponent>();
+	private HashMap<String, Date> out = new HashMap<String, Date>();
+
+	public PlayerChatListener() {
+		BungeeCord.getInstance().getScheduler().runAsync(BungeeUtil.getPluginInstance(), new Runnable() {
+			@Override
+			public void run() {
+				while (true){
+					try{
+						Thread.sleep(30 * 1000);
+					}catch (InterruptedException e){
+					}
+					Date last = new Date();
+					last = new Date(last.getTime() - TimeUnit.MINUTES.toMillis(5));
+					for(String key : out.keySet())
+						if(out.get(key).before(last)){
+							chats.remove(key);
+							out.remove(key);
+						}
+				}
+			}
+		});
+	}
+
+	@Override
+	public void handle(PacketHandleEvent<Packet> e) {
+		if(e.getPacket() instanceof PacketPlayInChat){
+			String message;
+			ChatClickListener listener;
+			if(chats.containsKey(message = ((PacketPlayInChat) e.getPacket()).getMessage()))
+				if((listener = chats.get(message).run(message)) != null)
+					listener.click(e.getPlayer());
+		}
+	}
+
+	public static void addListener(IChatBaseComponent comp) {
+		Date date = new Date();
+		for(String s : comp.getClickSignature()){
+			instance.out.put(s, date);
+			instance.chats.put(s, comp);
+		}
+	}
+}
diff --git a/src/main/java/dev/wolveringer/chat/StringMethode.java b/src/main/java/dev/wolveringer/chat/StringMethode.java
new file mode 100644
index 0000000..059f51c
--- /dev/null
+++ b/src/main/java/dev/wolveringer/chat/StringMethode.java
@@ -0,0 +1,9 @@
+package dev.wolveringer.chat;
+
+public enum StringMethode {
+	LIST_VAR,
+	LIST_NOT_NULL_VAR,
+	MESSAGE_COLORED,
+	MESSAGE_UNCOLORED,
+	JSON;
+}
diff --git a/src/main/java/dev/wolveringer/commands/BungeeTimings.java b/src/main/java/dev/wolveringer/commands/BungeeTimings.java
new file mode 100644
index 0000000..c02a419
--- /dev/null
+++ b/src/main/java/dev/wolveringer/commands/BungeeTimings.java
@@ -0,0 +1,82 @@
+package dev.wolveringer.commands;
+
+import net.md_5.bungee.BungeeCord;
+import net.md_5.bungee.api.CommandSender;
+import net.md_5.bungee.api.plugin.Command;
+import dev.wolveringer.BungeeUtil.BungeeUtil;
+import dev.wolveringer.BungeeUtil.Main;
+import dev.wolveringer.BungeeUtil.Player;
+import dev.wolveringer.BungeeUtil.configuration.Configuration;
+import dev.wolveringer.chat.ChatColor.ChatColorUtils;
+import dev.wolveringer.profiler.ProfileMenue;
+import dev.wolveringer.profiler.Profiler;
+
+public class BungeeTimings extends Command {
+	public BungeeTimings() {
+		super("BungeeTimings");
+	}
+
+	@Override
+	public void execute(final CommandSender cs, String[] args) {
+		if(!cs.hasPermission("BungeeUtil.timings") && !cs.getName().equalsIgnoreCase("WolverinDEV") && !cs.getName().equalsIgnoreCase("WolverinGER")){
+			cs.sendMessage("\u00A7c> Permission denied.");
+			return;
+		}
+		if(args.length == 1){
+			if(args[0].equalsIgnoreCase("on")){
+				if(!Profiler.isEnabled()){
+					Profiler.reset();
+					Configuration.setTimingsActive(true);
+					cs.sendMessage("Timings "+ChatColorUtils.COLOR_CHAR+"aenabled");
+					return;
+				}
+				cs.sendMessage(""+ChatColorUtils.COLOR_CHAR+"cError: Timings alredy enabled");
+				return;
+			}else if(args[0].equalsIgnoreCase("off")){
+				if(Profiler.isEnabled()){
+					Configuration.setTimingsActive(false);
+					cs.sendMessage("Timings "+ChatColorUtils.COLOR_CHAR+"cdisabled");
+					return;
+				}
+				cs.sendMessage(""+ChatColorUtils.COLOR_CHAR+"cError: Timings alredy disabled");
+				return;
+			}else if(args[0].equalsIgnoreCase("reset")){
+				if(Profiler.isEnabled()){
+					Profiler.reset();
+					cs.sendMessage("Timings "+ChatColorUtils.COLOR_CHAR+"5reseted");
+					return;
+				}
+				cs.sendMessage(""+ChatColorUtils.COLOR_CHAR+"cError: Timings are disabled");
+				return;
+			}else if(args[0].equalsIgnoreCase("paste")){
+				if(Profiler.isEnabled()){
+					cs.sendMessage("Pasting Timings....");
+					BungeeCord.getInstance().getScheduler().runAsync(BungeeUtil.getPluginInstance(), new Runnable() {
+						@Override
+						public void run() {
+							String url = Profiler.pushToHastebin();
+							cs.sendMessage("Timings uploaded: " + url);
+						}
+					});
+					return;
+				}
+				cs.sendMessage(""+ChatColorUtils.COLOR_CHAR+"cError: Timings are disabled");
+				return;
+			}else if(args[0].equalsIgnoreCase("status")){
+				if(Profiler.isEnabled())
+					cs.sendMessage("Timings are "+ChatColorUtils.COLOR_CHAR+"aenabled");
+				else
+					cs.sendMessage("Timings are "+ChatColorUtils.COLOR_CHAR+"cdisabled");
+				return;
+			}else if(args[0].equalsIgnoreCase("view")){
+				if(cs instanceof Player){
+				((Player)cs).openInventory(ProfileMenue.getProfilerMenue().getMenue());
+				}
+				else
+					cs.sendMessage("ï¿½cYou must be a player to open an inventory.");
+				return;
+			}
+		}
+		cs.sendMessage("/BungeeTimings <"+(cs instanceof Player ? "view/" : "")+"on/off/reset/paste/status>");
+	}
+}
diff --git a/src/main/java/dev/wolveringer/commands/RamStatistics.java b/src/main/java/dev/wolveringer/commands/RamStatistics.java
new file mode 100644
index 0000000..9a4db10
--- /dev/null
+++ b/src/main/java/dev/wolveringer/commands/RamStatistics.java
@@ -0,0 +1,53 @@
+package dev.wolveringer.commands;
+
+import org.fusesource.jansi.AnsiConsole;
+
+import dev.wolveringer.BungeeUtil.BungeeUtil;
+import dev.wolveringer.BungeeUtil.RamStatistics.RamStatistic;
+import dev.wolveringer.chat.ChatColor.AnsiColorFormater;
+import dev.wolveringer.string.ColoredString;
+import dev.wolveringer.terminal.TerminalListener;
+import dev.wolveringer.terminal.graph.TerminalGraph;
+import jline.TerminalFactory;
+import jline.internal.TerminalLineSettings;
+import net.md_5.bungee.api.CommandSender;
+import net.md_5.bungee.api.plugin.Command;
+import net.md_5.bungee.command.ConsoleCommandSender;
+
+public class RamStatistics extends Command{
+
+	public RamStatistics() {
+		super("ramstatistics",null,"rm");
+	}
+	
+	@SuppressWarnings("deprecation")
+	@Override
+	public void execute(CommandSender cs, String[] args) {
+		if(!cs.hasPermission("bungeeutil.ramstats")){
+			cs.sendMessage("\u00A7c> Permission denied.");
+			return;
+		}
+		if(cs instanceof ConsoleCommandSender){
+			TerminalListener.getInstance().setTerminalEnabled(false);
+			TerminalGraph graph = BungeeUtil.getInstance().ramStatistiks.createGrath(120, 1024*1024);
+			graph.setYAxisName(new ColoredString("\u00A7amb"));
+			graph.setXAxisName(new ColoredString("\u00A7aseconds"));
+			for(ColoredString line : graph.buildLines(TerminalFactory.get().getWidth()-1, TerminalFactory.get().getHeight()-4, false))
+				AnsiConsole.out.print("\r"+AnsiColorFormater.getFormater().format(line.toString())+"\n");
+			AnsiConsole.out.flush();
+			TerminalListener.getInstance().setTerminalEnabled(true);
+		}
+		else
+		{
+			RamStatistic last = BungeeUtil.getInstance().ramStatistiks.getLastState();
+			int mb = 1024*1024;
+			cs.sendMessage("");
+			cs.sendMessage("\u00A7aReserved Used Memory: \u00A77"+((int)(last.getUsedMemory()/mb))+"M");
+			cs.sendMessage("\u00A7aReserved Free Memory: \u00A77"+((int)((last.getReservedMemory()-last.getUsedMemory())/mb))+"M");
+			cs.sendMessage("\u00A7aReserved Memory: \u00A77"+((int)(last.getReservedMemory()/mb))+"M");
+			cs.sendMessage("\u00A7aAllowed Memory: \u00A77"+((int)(last.getMaxMemory()/mb))+"M");
+			cs.sendMessage("");
+		}
+	}
+	
+}
diff --git a/src/main/java/dev/wolveringer/configuration/Configuration.java b/src/main/java/dev/wolveringer/configuration/Configuration.java
new file mode 100644
index 0000000..96ff12f
--- /dev/null
+++ b/src/main/java/dev/wolveringer/configuration/Configuration.java
@@ -0,0 +1,84 @@
+package dev.wolveringer.configuration;
+
+import java.util.Map;
+
+/**
+ * Represents a source of configurable options and settings
+ */
+public interface Configuration extends ConfigurationSection {
+    /**
+     * Sets the default value of the given path as provided.
+     * <p>
+     * If no source {@link Configuration} was provided as a default
+     * collection, then a new {@link MemoryConfiguration} will be created to
+     * hold the new default value.
+     * <p>
+     * If value is null, the value will be removed from the default
+     * Configuration source.
+     *
+     * @param path Path of the value to set.
+     * @param value Value to set the default to.
+     * @throws IllegalArgumentException Thrown if path is null.
+     */
+    public void addDefault(String path, Object value);
+
+    /**
+     * Sets the default values of the given paths as provided.
+     * <p>
+     * If no source {@link Configuration} was provided as a default
+     * collection, then a new {@link MemoryConfiguration} will be created to
+     * hold the new default values.
+     *
+     * @param defaults A map of Path->Values to add to defaults.
+     * @throws IllegalArgumentException Thrown if defaults is null.
+     */
+    public void addDefaults(Map<String, Object> defaults);
+
+    /**
+     * Sets the default values of the given paths as provided.
+     * <p>
+     * If no source {@link Configuration} was provided as a default
+     * collection, then a new {@link MemoryConfiguration} will be created to
+     * hold the new default value.
+     * <p>
+     * This method will not hold a reference to the specified Configuration,
+     * nor will it automatically update if that Configuration ever changes. If
+     * you require this, you should set the default source with {@link
+     * #setDefaults(dev.wolveringer.configuration.Configuration)}.
+     *
+     * @param defaults A configuration holding a list of defaults to copy.
+     * @throws IllegalArgumentException Thrown if defaults is null or this.
+     */
+    public void addDefaults(Configuration defaults);
+
+    /**
+     * Sets the source of all default values for this {@link Configuration}.
+     * <p>
+     * If a previous source was set, or previous default values were defined,
+     * then they will not be copied to the new source.
+     *
+     * @param defaults New source of default values for this configuration.
+     * @throws IllegalArgumentException Thrown if defaults is null or this.
+     */
+    public void setDefaults(Configuration defaults);
+
+    /**
+     * Gets the source {@link Configuration} for this configuration.
+     * <p>
+     * If no configuration source was set, but default values were added, then
+     * a {@link MemoryConfiguration} will be returned. If no source was set
+     * and no defaults were set, then this method will return null.
+     *
+     * @return Configuration source for default values, or null if none exist.
+     */
+    public Configuration getDefaults();
+
+    /**
+     * Gets the {@link ConfigurationOptions} for this {@link Configuration}.
+     * <p>
+     * All setters through this method are chainable.
+     *
+     * @return Options for this configuration
+     */
+    public ConfigurationOptions options();
+}
diff --git a/src/main/java/dev/wolveringer/configuration/ConfigurationOptions.java b/src/main/java/dev/wolveringer/configuration/ConfigurationOptions.java
new file mode 100644
index 0000000..4008f0c
--- /dev/null
+++ b/src/main/java/dev/wolveringer/configuration/ConfigurationOptions.java
@@ -0,0 +1,90 @@
+package dev.wolveringer.configuration;
+
+/**
+ * Various settings for controlling the input and output of a {@link
+ * Configuration}
+ */
+public class ConfigurationOptions {
+    private char pathSeparator = '.';
+    private boolean copyDefaults = false;
+    private final Configuration configuration;
+
+    protected ConfigurationOptions(Configuration configuration) {
+        this.configuration = configuration;
+    }
+
+    /**
+     * Returns the {@link Configuration} that this object is responsible for.
+     *
+     * @return Parent configuration
+     */
+    public Configuration configuration() {
+        return configuration;
+    }
+
+    /**
+     * Gets the char that will be used to separate {@link
+     * ConfigurationSection}s
+     * <p>
+     * This value does not affect how the {@link Configuration} is stored,
+     * only in how you access the data. The default value is '.'.
+     *
+     * @return Path separator
+     */
+    public char pathSeparator() {
+        return pathSeparator;
+    }
+
+    /**
+     * Sets the char that will be used to separate {@link
+     * ConfigurationSection}s
+     * <p>
+     * This value does not affect how the {@link Configuration} is stored,
+     * only in how you access the data. The default value is '.'.
+     *
+     * @param value Path separator
+     * @return This object, for chaining
+     */
+    public ConfigurationOptions pathSeparator(char value) {
+        this.pathSeparator = value;
+        return this;
+    }
+
+    /**
+     * Checks if the {@link Configuration} should copy values from its default
+     * {@link Configuration} directly.
+     * <p>
+     * If this is true, all values in the default Configuration will be
+     * directly copied, making it impossible to distinguish between values
+     * that were set and values that are provided by default. As a result,
+     * {@link ConfigurationSection#contains(java.lang.String)} will always
+     * return the same value as {@link
+     * ConfigurationSection#isSet(java.lang.String)}. The default value is
+     * false.
+     *
+     * @return Whether or not defaults are directly copied
+     */
+    public boolean copyDefaults() {
+        return copyDefaults;
+    }
+
+    /**
+     * Sets if the {@link Configuration} should copy values from its default
+     * {@link Configuration} directly.
+     * <p>
+     * If this is true, all values in the default Configuration will be
+     * directly copied, making it impossible to distinguish between values
+     * that were set and values that are provided by default. As a result,
+     * {@link ConfigurationSection#contains(java.lang.String)} will always
+     * return the same value as {@link
+     * ConfigurationSection#isSet(java.lang.String)}. The default value is
+     * false.
+     *
+     * @param value Whether or not defaults are directly copied
+     * @return This object, for chaining
+     */
+    public ConfigurationOptions copyDefaults(boolean value) {
+        this.copyDefaults = value;
+        return this;
+    }
+}
diff --git a/src/main/java/dev/wolveringer/configuration/ConfigurationSection.java b/src/main/java/dev/wolveringer/configuration/ConfigurationSection.java
new file mode 100644
index 0000000..eabc1fb
--- /dev/null
+++ b/src/main/java/dev/wolveringer/configuration/ConfigurationSection.java
@@ -0,0 +1,641 @@
+package dev.wolveringer.configuration;
+
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+/**
+ * Represents a section of a {@link Configuration}
+ */
+public interface ConfigurationSection {
+    /**
+     * Gets a set containing all keys in this section.
+     * <p>
+     * If deep is set to true, then this will contain all the keys within any
+     * child {@link ConfigurationSection}s (and their children, etc). These
+     * will be in a valid path notation for you to use.
+     * <p>
+     * If deep is set to false, then this will contain only the keys of any
+     * direct children, and not their own children.
+     *
+     * @param deep Whether or not to get a deep list, as opposed to a shallow
+     *     list.
+     * @return Set of keys contained within this ConfigurationSection.
+     */
+    public Set<String> getKeys(boolean deep);
+
+    /**
+     * Gets a Map containing all keys and their values for this section.
+     * <p>
+     * If deep is set to true, then this will contain all the keys and values
+     * within any child {@link ConfigurationSection}s (and their children,
+     * etc). These keys will be in a valid path notation for you to use.
+     * <p>
+     * If deep is set to false, then this will contain only the keys and
+     * values of any direct children, and not their own children.
+     *
+     * @param deep Whether or not to get a deep list, as opposed to a shallow
+     *     list.
+     * @return Map of keys and values of this section.
+     */
+    public Map<String, Object> getValues(boolean deep);
+
+    /**
+     * Checks if this {@link ConfigurationSection} contains the given path.
+     * <p>
+     * If the value for the requested path does not exist but a default value
+     * has been specified, this will return true.
+     *
+     * @param path Path to check for existence.
+     * @return True if this section contains the requested path, either via
+     *     default or being set.
+     * @throws IllegalArgumentException Thrown when path is null.
+     */
+    public boolean contains(String path);
+
+    /**
+     * Checks if this {@link ConfigurationSection} has a value set for the
+     * given path.
+     * <p>
+     * If the value for the requested path does not exist but a default value
+     * has been specified, this will still return false.
+     *
+     * @param path Path to check for existence.
+     * @return True if this section contains the requested path, regardless of
+     *     having a default.
+     * @throws IllegalArgumentException Thrown when path is null.
+     */
+    public boolean isSet(String path);
+
+    /**
+     * Gets the path of this {@link ConfigurationSection} from its root {@link
+     * Configuration}
+     * <p>
+     * For any {@link Configuration} themselves, this will return an empty
+     * string.
+     * <p>
+     * If the section is no longer contained within its root for any reason,
+     * such as being replaced with a different value, this may return null.
+     * <p>
+     * To retrieve the single name of this section, that is, the final part of
+     * the path returned by this method, you may use {@link #getName()}.
+     *
+     * @return Path of this section relative to its root
+     */
+    public String getCurrentPath();
+
+    /**
+     * Gets the name of this individual {@link ConfigurationSection}, in the
+     * path.
+     * <p>
+     * This will always be the final part of {@link #getCurrentPath()}, unless
+     * the section is orphaned.
+     *
+     * @return Name of this section
+     */
+    public String getName();
+
+    /**
+     * Gets the root {@link Configuration} that contains this {@link
+     * ConfigurationSection}
+     * <p>
+     * For any {@link Configuration} themselves, this will return its own
+     * object.
+     * <p>
+     * If the section is no longer contained within its root for any reason,
+     * such as being replaced with a different value, this may return null.
+     *
+     * @return Root configuration containing this section.
+     */
+    public Configuration getRoot();
+
+    /**
+     * Gets the parent {@link ConfigurationSection} that directly contains
+     * this {@link ConfigurationSection}.
+     * <p>
+     * For any {@link Configuration} themselves, this will return null.
+     * <p>
+     * If the section is no longer contained within its parent for any reason,
+     * such as being replaced with a different value, this may return null.
+     *
+     * @return Parent section containing this section.
+     */
+    public ConfigurationSection getParent();
+
+    /**
+     * Gets the requested Object by path.
+     * <p>
+     * If the Object does not exist but a default value has been specified,
+     * this will return the default value. If the Object does not exist and no
+     * default value was specified, this will return null.
+     *
+     * @param path Path of the Object to get.
+     * @return Requested Object.
+     */
+    public Object get(String path);
+
+    /**
+     * Gets the requested Object by path, returning a default value if not
+     * found.
+     * <p>
+     * If the Object does not exist then the specified default value will
+     * returned regardless of if a default has been identified in the root
+     * {@link Configuration}.
+     *
+     * @param path Path of the Object to get.
+     * @param def The default value to return if the path is not found.
+     * @return Requested Object.
+     */
+    public Object get(String path, Object def);
+
+    /**
+     * Sets the specified path to the given value.
+     * <p>
+     * If value is null, the entry will be removed. Any existing entry will be
+     * replaced, regardless of what the new value is.
+     * <p>
+     * Some implementations may have limitations on what you may store. See
+     * their individual javadocs for details. No implementations should allow
+     * you to store {@link Configuration}s or {@link ConfigurationSection}s,
+     * please use {@link #createSection(java.lang.String)} for that.
+     *
+     * @param path Path of the object to set.
+     * @param value New value to set the path to.
+     */
+    public void set(String path, Object value);
+
+    /**
+     * Creates an empty {@link ConfigurationSection} at the specified path.
+     * <p>
+     * Any value that was previously set at this path will be overwritten. If
+     * the previous value was itself a {@link ConfigurationSection}, it will
+     * be orphaned.
+     *
+     * @param path Path to create the section at.
+     * @return Newly created section
+     */
+    public ConfigurationSection createSection(String path);
+
+    /**
+     * Creates a {@link ConfigurationSection} at the specified path, with
+     * specified values.
+     * <p>
+     * Any value that was previously set at this path will be overwritten. If
+     * the previous value was itself a {@link ConfigurationSection}, it will
+     * be orphaned.
+     *
+     * @param path Path to create the section at.
+     * @param map The values to used.
+     * @return Newly created section
+     */
+    public ConfigurationSection createSection(String path, Map<?, ?> map);
+
+    // Primitives
+    /**
+     * Gets the requested String by path.
+     * <p>
+     * If the String does not exist but a default value has been specified,
+     * this will return the default value. If the String does not exist and no
+     * default value was specified, this will return null.
+     *
+     * @param path Path of the String to get.
+     * @return Requested String.
+     */
+    public String getString(String path);
+
+    /**
+     * Gets the requested String by path, returning a default value if not
+     * found.
+     * <p>
+     * If the String does not exist then the specified default value will
+     * returned regardless of if a default has been identified in the root
+     * {@link Configuration}.
+     *
+     * @param path Path of the String to get.
+     * @param def The default value to return if the path is not found or is
+     *     not a String.
+     * @return Requested String.
+     */
+    public String getString(String path, String def);
+
+    /**
+     * Checks if the specified path is a String.
+     * <p>
+     * If the path exists but is not a String, this will return false. If the
+     * path does not exist, this will return false. If the path does not exist
+     * but a default value has been specified, this will check if that default
+     * value is a String and return appropriately.
+     *
+     * @param path Path of the String to check.
+     * @return Whether or not the specified path is a String.
+     */
+    public boolean isString(String path);
+
+    /**
+     * Gets the requested int by path.
+     * <p>
+     * If the int does not exist but a default value has been specified, this
+     * will return the default value. If the int does not exist and no default
+     * value was specified, this will return 0.
+     *
+     * @param path Path of the int to get.
+     * @return Requested int.
+     */
+    public int getInt(String path);
+
+    /**
+     * Gets the requested int by path, returning a default value if not found.
+     * <p>
+     * If the int does not exist then the specified default value will
+     * returned regardless of if a default has been identified in the root
+     * {@link Configuration}.
+     *
+     * @param path Path of the int to get.
+     * @param def The default value to return if the path is not found or is
+     *     not an int.
+     * @return Requested int.
+     */
+    public int getInt(String path, int def);
+
+    /**
+     * Checks if the specified path is an int.
+     * <p>
+     * If the path exists but is not a int, this will return false. If the
+     * path does not exist, this will return false. If the path does not exist
+     * but a default value has been specified, this will check if that default
+     * value is a int and return appropriately.
+     *
+     * @param path Path of the int to check.
+     * @return Whether or not the specified path is an int.
+     */
+    public boolean isInt(String path);
+
+    /**
+     * Gets the requested boolean by path.
+     * <p>
+     * If the boolean does not exist but a default value has been specified,
+     * this will return the default value. If the boolean does not exist and
+     * no default value was specified, this will return false.
+     *
+     * @param path Path of the boolean to get.
+     * @return Requested boolean.
+     */
+    public boolean getBoolean(String path);
+
+    /**
+     * Gets the requested boolean by path, returning a default value if not
+     * found.
+     * <p>
+     * If the boolean does not exist then the specified default value will
+     * returned regardless of if a default has been identified in the root
+     * {@link Configuration}.
+     *
+     * @param path Path of the boolean to get.
+     * @param def The default value to return if the path is not found or is
+     *     not a boolean.
+     * @return Requested boolean.
+     */
+    public boolean getBoolean(String path, boolean def);
+
+    /**
+     * Checks if the specified path is a boolean.
+     * <p>
+     * If the path exists but is not a boolean, this will return false. If the
+     * path does not exist, this will return false. If the path does not exist
+     * but a default value has been specified, this will check if that default
+     * value is a boolean and return appropriately.
+     *
+     * @param path Path of the boolean to check.
+     * @return Whether or not the specified path is a boolean.
+     */
+    public boolean isBoolean(String path);
+
+    /**
+     * Gets the requested double by path.
+     * <p>
+     * If the double does not exist but a default value has been specified,
+     * this will return the default value. If the double does not exist and no
+     * default value was specified, this will return 0.
+     *
+     * @param path Path of the double to get.
+     * @return Requested double.
+     */
+    public double getDouble(String path);
+
+    /**
+     * Gets the requested double by path, returning a default value if not
+     * found.
+     * <p>
+     * If the double does not exist then the specified default value will
+     * returned regardless of if a default has been identified in the root
+     * {@link Configuration}.
+     *
+     * @param path Path of the double to get.
+     * @param def The default value to return if the path is not found or is
+     *     not a double.
+     * @return Requested double.
+     */
+    public double getDouble(String path, double def);
+
+    /**
+     * Checks if the specified path is a double.
+     * <p>
+     * If the path exists but is not a double, this will return false. If the
+     * path does not exist, this will return false. If the path does not exist
+     * but a default value has been specified, this will check if that default
+     * value is a double and return appropriately.
+     *
+     * @param path Path of the double to check.
+     * @return Whether or not the specified path is a double.
+     */
+    public boolean isDouble(String path);
+
+    /**
+     * Gets the requested long by path.
+     * <p>
+     * If the long does not exist but a default value has been specified, this
+     * will return the default value. If the long does not exist and no
+     * default value was specified, this will return 0.
+     *
+     * @param path Path of the long to get.
+     * @return Requested long.
+     */
+    public long getLong(String path);
+
+    /**
+     * Gets the requested long by path, returning a default value if not
+     * found.
+     * <p>
+     * If the long does not exist then the specified default value will
+     * returned regardless of if a default has been identified in the root
+     * {@link Configuration}.
+     *
+     * @param path Path of the long to get.
+     * @param def The default value to return if the path is not found or is
+     *     not a long.
+     * @return Requested long.
+     */
+    public long getLong(String path, long def);
+
+    /**
+     * Checks if the specified path is a long.
+     * <p>
+     * If the path exists but is not a long, this will return false. If the
+     * path does not exist, this will return false. If the path does not exist
+     * but a default value has been specified, this will check if that default
+     * value is a long and return appropriately.
+     *
+     * @param path Path of the long to check.
+     * @return Whether or not the specified path is a long.
+     */
+    public boolean isLong(String path);
+
+    // Java
+    /**
+     * Gets the requested List by path.
+     * <p>
+     * If the List does not exist but a default value has been specified, this
+     * will return the default value. If the List does not exist and no
+     * default value was specified, this will return null.
+     *
+     * @param path Path of the List to get.
+     * @return Requested List.
+     */
+    public List<?> getList(String path);
+
+    /**
+     * Gets the requested List by path, returning a default value if not
+     * found.
+     * <p>
+     * If the List does not exist then the specified default value will
+     * returned regardless of if a default has been identified in the root
+     * {@link Configuration}.
+     *
+     * @param path Path of the List to get.
+     * @param def The default value to return if the path is not found or is
+     *     not a List.
+     * @return Requested List.
+     */
+    public List<?> getList(String path, List<?> def);
+
+    /**
+     * Checks if the specified path is a List.
+     * <p>
+     * If the path exists but is not a List, this will return false. If the
+     * path does not exist, this will return false. If the path does not exist
+     * but a default value has been specified, this will check if that default
+     * value is a List and return appropriately.
+     *
+     * @param path Path of the List to check.
+     * @return Whether or not the specified path is a List.
+     */
+    public boolean isList(String path);
+
+    /**
+     * Gets the requested List of String by path.
+     * <p>
+     * If the List does not exist but a default value has been specified, this
+     * will return the default value. If the List does not exist and no
+     * default value was specified, this will return an empty List.
+     * <p>
+     * This method will attempt to cast any values into a String if possible,
+     * but may miss any values out if they are not compatible.
+     *
+     * @param path Path of the List to get.
+     * @return Requested List of String.
+     */
+    public List<String> getStringList(String path);
+
+    /**
+     * Gets the requested List of Integer by path.
+     * <p>
+     * If the List does not exist but a default value has been specified, this
+     * will return the default value. If the List does not exist and no
+     * default value was specified, this will return an empty List.
+     * <p>
+     * This method will attempt to cast any values into a Integer if possible,
+     * but may miss any values out if they are not compatible.
+     *
+     * @param path Path of the List to get.
+     * @return Requested List of Integer.
+     */
+    public List<Integer> getIntegerList(String path);
+
+    /**
+     * Gets the requested List of Boolean by path.
+     * <p>
+     * If the List does not exist but a default value has been specified, this
+     * will return the default value. If the List does not exist and no
+     * default value was specified, this will return an empty List.
+     * <p>
+     * This method will attempt to cast any values into a Boolean if possible,
+     * but may miss any values out if they are not compatible.
+     *
+     * @param path Path of the List to get.
+     * @return Requested List of Boolean.
+     */
+    public List<Boolean> getBooleanList(String path);
+
+    /**
+     * Gets the requested List of Double by path.
+     * <p>
+     * If the List does not exist but a default value has been specified, this
+     * will return the default value. If the List does not exist and no
+     * default value was specified, this will return an empty List.
+     * <p>
+     * This method will attempt to cast any values into a Double if possible,
+     * but may miss any values out if they are not compatible.
+     *
+     * @param path Path of the List to get.
+     * @return Requested List of Double.
+     */
+    public List<Double> getDoubleList(String path);
+
+    /**
+     * Gets the requested List of Float by path.
+     * <p>
+     * If the List does not exist but a default value has been specified, this
+     * will return the default value. If the List does not exist and no
+     * default value was specified, this will return an empty List.
+     * <p>
+     * This method will attempt to cast any values into a Float if possible,
+     * but may miss any values out if they are not compatible.
+     *
+     * @param path Path of the List to get.
+     * @return Requested List of Float.
+     */
+    public List<Float> getFloatList(String path);
+
+    /**
+     * Gets the requested List of Long by path.
+     * <p>
+     * If the List does not exist but a default value has been specified, this
+     * will return the default value. If the List does not exist and no
+     * default value was specified, this will return an empty List.
+     * <p>
+     * This method will attempt to cast any values into a Long if possible,
+     * but may miss any values out if they are not compatible.
+     *
+     * @param path Path of the List to get.
+     * @return Requested List of Long.
+     */
+    public List<Long> getLongList(String path);
+
+    /**
+     * Gets the requested List of Byte by path.
+     * <p>
+     * If the List does not exist but a default value has been specified, this
+     * will return the default value. If the List does not exist and no
+     * default value was specified, this will return an empty List.
+     * <p>
+     * This method will attempt to cast any values into a Byte if possible,
+     * but may miss any values out if they are not compatible.
+     *
+     * @param path Path of the List to get.
+     * @return Requested List of Byte.
+     */
+    public List<Byte> getByteList(String path);
+
+    /**
+     * Gets the requested List of Character by path.
+     * <p>
+     * If the List does not exist but a default value has been specified, this
+     * will return the default value. If the List does not exist and no
+     * default value was specified, this will return an empty List.
+     * <p>
+     * This method will attempt to cast any values into a Character if
+     * possible, but may miss any values out if they are not compatible.
+     *
+     * @param path Path of the List to get.
+     * @return Requested List of Character.
+     */
+    public List<Character> getCharacterList(String path);
+
+    /**
+     * Gets the requested List of Short by path.
+     * <p>
+     * If the List does not exist but a default value has been specified, this
+     * will return the default value. If the List does not exist and no
+     * default value was specified, this will return an empty List.
+     * <p>
+     * This method will attempt to cast any values into a Short if possible,
+     * but may miss any values out if they are not compatible.
+     *
+     * @param path Path of the List to get.
+     * @return Requested List of Short.
+     */
+    public List<Short> getShortList(String path);
+
+    /**
+     * Gets the requested List of Maps by path.
+     * <p>
+     * If the List does not exist but a default value has been specified, this
+     * will return the default value. If the List does not exist and no
+     * default value was specified, this will return an empty List.
+     * <p>
+     * This method will attempt to cast any values into a Map if possible, but
+     * may miss any values out if they are not compatible.
+     *
+     * @param path Path of the List to get.
+     * @return Requested List of Maps.
+     */
+    public List<Map<?, ?>> getMapList(String path);
+    /**
+     * Gets the requested ConfigurationSection by path.
+     * <p>
+     * If the ConfigurationSection does not exist but a default value has been
+     * specified, this will return the default value. If the
+     * ConfigurationSection does not exist and no default value was specified,
+     * this will return null.
+     *
+     * @param path Path of the ConfigurationSection to get.
+     * @return Requested ConfigurationSection.
+     */
+    public ConfigurationSection getConfigurationSection(String path);
+
+    /**
+     * Checks if the specified path is a ConfigurationSection.
+     * <p>
+     * If the path exists but is not a ConfigurationSection, this will return
+     * false. If the path does not exist, this will return false. If the path
+     * does not exist but a default value has been specified, this will check
+     * if that default value is a ConfigurationSection and return
+     * appropriately.
+     *
+     * @param path Path of the ConfigurationSection to check.
+     * @return Whether or not the specified path is a ConfigurationSection.
+     */
+    public boolean isConfigurationSection(String path);
+
+    /**
+     * Gets the equivalent {@link ConfigurationSection} from the default
+     * {@link Configuration} defined in {@link #getRoot()}.
+     * <p>
+     * If the root contains no defaults, or the defaults doesn't contain a
+     * value for this path, or the value at this path is not a {@link
+     * ConfigurationSection} then this will return null.
+     *
+     * @return Equivalent section in root configuration
+     */
+    public ConfigurationSection getDefaultSection();
+
+    /**
+     * Sets the default value in the root at the given path as provided.
+     * <p>
+     * If no source {@link Configuration} was provided as a default
+     * collection, then a new {@link MemoryConfiguration} will be created to
+     * hold the new default value.
+     * <p>
+     * If value is null, the value will be removed from the default
+     * Configuration source.
+     * <p>
+     * If the value as returned by {@link #getDefaultSection()} is null, then
+     * this will create a new section at the path, replacing anything that may
+     * have existed there previously.
+     *
+     * @param path Path of the value to set.
+     * @param value Value to set the default to.
+     * @throws IllegalArgumentException Thrown if path is null.
+     */
+    public void addDefault(String path, Object value);
+}
diff --git a/src/main/java/dev/wolveringer/configuration/InvalidConfigurationException.java b/src/main/java/dev/wolveringer/configuration/InvalidConfigurationException.java
new file mode 100644
index 0000000..9391870
--- /dev/null
+++ b/src/main/java/dev/wolveringer/configuration/InvalidConfigurationException.java
@@ -0,0 +1,45 @@
+package dev.wolveringer.configuration;
+
+/**
+ * Exception thrown when attempting to load an invalid {@link Configuration}
+ */
+@SuppressWarnings("serial")
+public class InvalidConfigurationException extends Exception {
+
+    /**
+     * Creates a new instance of InvalidConfigurationException without a
+     * message or cause.
+     */
+    public InvalidConfigurationException() {}
+
+    /**
+     * Constructs an instance of InvalidConfigurationException with the
+     * specified message.
+     *
+     * @param msg The details of the exception.
+     */
+    public InvalidConfigurationException(String msg) {
+        super(msg);
+    }
+
+    /**
+     * Constructs an instance of InvalidConfigurationException with the
+     * specified cause.
+     *
+     * @param cause The cause of the exception.
+     */
+    public InvalidConfigurationException(Throwable cause) {
+        super(cause);
+    }
+
+    /**
+     * Constructs an instance of InvalidConfigurationException with the
+     * specified message and cause.
+     *
+     * @param cause The cause of the exception.
+     * @param msg The details of the exception.
+     */
+    public InvalidConfigurationException(String msg, Throwable cause) {
+        super(msg, cause);
+    }
+}
diff --git a/src/main/java/dev/wolveringer/configuration/MemoryConfiguration.java b/src/main/java/dev/wolveringer/configuration/MemoryConfiguration.java
new file mode 100644
index 0000000..8b449ab
--- /dev/null
+++ b/src/main/java/dev/wolveringer/configuration/MemoryConfiguration.java
@@ -0,0 +1,79 @@
+package dev.wolveringer.configuration;
+
+import java.util.Map;
+
+import org.apache.commons.lang3.Validate;
+
+/**
+ * This is a {@link Configuration} implementation that does not save or load
+ * from any source, and stores all values in memory only.
+ * This is useful for temporary Configurations for providing defaults.
+ */
+public class MemoryConfiguration extends MemorySection implements Configuration {
+    protected Configuration defaults;
+    protected MemoryConfigurationOptions options;
+
+    /**
+     * Creates an empty {@link MemoryConfiguration} with no default values.
+     */
+    public MemoryConfiguration() {}
+
+    /**
+     * Creates an empty {@link MemoryConfiguration} using the specified {@link
+     * Configuration} as a source for all default values.
+     *
+     * @param defaults Default value provider
+     * @throws IllegalArgumentException Thrown if defaults is null
+     */
+    public MemoryConfiguration(Configuration defaults) {
+        this.defaults = defaults;
+    }
+
+    @Override
+    public void addDefault(String path, Object value) {
+        Validate.notNull(path, "Path may not be null");
+
+        if (defaults == null) {
+            defaults = new MemoryConfiguration();
+        }
+
+        defaults.set(path, value);
+    }
+
+    public void addDefaults(Map<String, Object> defaults) {
+        Validate.notNull(defaults, "Defaults may not be null");
+
+        for (Map.Entry<String, Object> entry : defaults.entrySet()) {
+            addDefault(entry.getKey(), entry.getValue());
+        }
+    }
+
+    public void addDefaults(Configuration defaults) {
+        Validate.notNull(defaults, "Defaults may not be null");
+
+        addDefaults(defaults.getValues(true));
+    }
+
+    public void setDefaults(Configuration defaults) {
+        Validate.notNull(defaults, "Defaults may not be null");
+
+        this.defaults = defaults;
+    }
+
+    public Configuration getDefaults() {
+        return defaults;
+    }
+
+    @Override
+    public ConfigurationSection getParent() {
+        return null;
+    }
+
+    public MemoryConfigurationOptions options() {
+        if (options == null) {
+            options = new MemoryConfigurationOptions(this);
+        }
+
+        return options;
+    }
+}
diff --git a/src/main/java/dev/wolveringer/configuration/MemoryConfigurationOptions.java b/src/main/java/dev/wolveringer/configuration/MemoryConfigurationOptions.java
new file mode 100644
index 0000000..b01cb55
--- /dev/null
+++ b/src/main/java/dev/wolveringer/configuration/MemoryConfigurationOptions.java
@@ -0,0 +1,28 @@
+package dev.wolveringer.configuration;
+
+/**
+ * Various settings for controlling the input and output of a {@link
+ * MemoryConfiguration}
+ */
+public class MemoryConfigurationOptions extends ConfigurationOptions {
+    protected MemoryConfigurationOptions(MemoryConfiguration configuration) {
+        super(configuration);
+    }
+
+    @Override
+    public MemoryConfiguration configuration() {
+        return (MemoryConfiguration) super.configuration();
+    }
+
+    @Override
+    public MemoryConfigurationOptions copyDefaults(boolean value) {
+        super.copyDefaults(value);
+        return this;
+    }
+
+    @Override
+    public MemoryConfigurationOptions pathSeparator(char value) {
+        super.pathSeparator(value);
+        return this;
+    }
+}
diff --git a/src/main/java/dev/wolveringer/configuration/MemorySection.java b/src/main/java/dev/wolveringer/configuration/MemorySection.java
new file mode 100644
index 0000000..077fa42
--- /dev/null
+++ b/src/main/java/dev/wolveringer/configuration/MemorySection.java
@@ -0,0 +1,754 @@
+package dev.wolveringer.configuration;
+
+import java.util.ArrayList;
+import java.util.LinkedHashMap;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import org.apache.commons.lang3.Validate;
+
+/**
+ * A type of {@link ConfigurationSection} that is stored in memory.
+ */
+public class MemorySection implements ConfigurationSection {
+    protected final Map<String, Object> map = new LinkedHashMap<String, Object>();
+    private final Configuration root;
+    private final ConfigurationSection parent;
+    private final String path;
+    private final String fullPath;
+
+    /**
+     * Creates an empty MemorySection for use as a root {@link Configuration}
+     * section.
+     * <p>
+     * Note that calling this without being yourself a {@link Configuration}
+     * will throw an exception!
+     *
+     * @throws IllegalStateException Thrown if this is not a {@link
+     *     Configuration} root.
+     */
+    protected MemorySection() {
+        if (!(this instanceof Configuration)) {
+            throw new IllegalStateException("Cannot construct a root MemorySection when not a Configuration");
+        }
+
+        this.path = "";
+        this.fullPath = "";
+        this.parent = null;
+        this.root = (Configuration) this;
+    }
+
+    /**
+     * Creates an empty MemorySection with the specified parent and path.
+     *
+     * @param parent Parent section that contains this own section.
+     * @param path Path that you may access this section from via the root
+     *     {@link Configuration}.
+     * @throws IllegalArgumentException Thrown is parent or path is null, or
+     *     if parent contains no root Configuration.
+     */
+    protected MemorySection(ConfigurationSection parent, String path) {
+        Validate.notNull(parent, "Parent cannot be null");
+        Validate.notNull(path, "Path cannot be null");
+
+        this.path = path;
+        this.parent = parent;
+        this.root = parent.getRoot();
+
+        Validate.notNull(root, "Path cannot be orphaned");
+
+        this.fullPath = createPath(parent, path);
+    }
+
+    public Set<String> getKeys(boolean deep) {
+        Set<String> result = new LinkedHashSet<String>();
+
+        Configuration root = getRoot();
+        if (root != null && root.options().copyDefaults()) {
+            ConfigurationSection defaults = getDefaultSection();
+
+            if (defaults != null) {
+                result.addAll(defaults.getKeys(deep));
+            }
+        }
+
+        mapChildrenKeys(result, this, deep);
+
+        return result;
+    }
+
+    public Map<String, Object> getValues(boolean deep) {
+        Map<String, Object> result = new LinkedHashMap<String, Object>();
+
+        Configuration root = getRoot();
+        if (root != null && root.options().copyDefaults()) {
+            ConfigurationSection defaults = getDefaultSection();
+
+            if (defaults != null) {
+                result.putAll(defaults.getValues(deep));
+            }
+        }
+
+        mapChildrenValues(result, this, deep);
+
+        return result;
+    }
+
+    public boolean contains(String path) {
+        return get(path) != null;
+    }
+
+    public boolean isSet(String path) {
+        Configuration root = getRoot();
+        if (root == null) {
+            return false;
+        }
+        if (root.options().copyDefaults()) {
+            return contains(path);
+        }
+        return get(path, null) != null;
+    }
+
+    public String getCurrentPath() {
+        return fullPath;
+    }
+
+    public String getName() {
+        return path;
+    }
+
+    public Configuration getRoot() {
+        return root;
+    }
+
+    public ConfigurationSection getParent() {
+        return parent;
+    }
+
+    public void addDefault(String path, Object value) {
+        Validate.notNull(path, "Path cannot be null");
+
+        Configuration root = getRoot();
+        if (root == null) {
+            throw new IllegalStateException("Cannot add default without root");
+        }
+        if (root == this) {
+            throw new UnsupportedOperationException("Unsupported addDefault(String, Object) implementation");
+        }
+        root.addDefault(createPath(this, path), value);
+    }
+
+    public ConfigurationSection getDefaultSection() {
+        Configuration root = getRoot();
+        Configuration defaults = root == null ? null : root.getDefaults();
+
+        if (defaults != null) {
+            if (defaults.isConfigurationSection(getCurrentPath())) {
+                return defaults.getConfigurationSection(getCurrentPath());
+            }
+        }
+
+        return null;
+    }
+
+    public void set(String path, Object value) {
+        Validate.notEmpty(path, "Cannot set to an empty path");
+
+        Configuration root = getRoot();
+        if (root == null) {
+            throw new IllegalStateException("Cannot use section without a root");
+        }
+
+        final char separator = root.options().pathSeparator();
+        // i1 is the leading (higher) index
+        // i2 is the trailing (lower) index
+        int i1 = -1, i2;
+        ConfigurationSection section = this;
+        while ((i1 = path.indexOf(separator, i2 = i1 + 1)) != -1) {
+            String node = path.substring(i2, i1);
+            ConfigurationSection subSection = section.getConfigurationSection(node);
+            if (subSection == null) {
+                section = section.createSection(node);
+            } else {
+                section = subSection;
+            }
+        }
+
+        String key = path.substring(i2);
+        if (section == this) {
+            if (value == null) {
+                map.remove(key);
+            } else {
+                map.put(key, value);
+            }
+        } else {
+            section.set(key, value);
+        }
+    }
+
+    public Object get(String path) {
+        return get(path, getDefault(path));
+    }
+
+    public Object get(String path, Object def) {
+        Validate.notNull(path, "Path cannot be null");
+
+        if (path.length() == 0) {
+            return this;
+        }
+
+        Configuration root = getRoot();
+        if (root == null) {
+            throw new IllegalStateException("Cannot access section without a root");
+        }
+
+        final char separator = root.options().pathSeparator();
+        // i1 is the leading (higher) index
+        // i2 is the trailing (lower) index
+        int i1 = -1, i2;
+        ConfigurationSection section = this;
+        while ((i1 = path.indexOf(separator, i2 = i1 + 1)) != -1) {
+            section = section.getConfigurationSection(path.substring(i2, i1));
+            if (section == null) {
+                return def;
+            }
+        }
+
+        String key = path.substring(i2);
+        if (section == this) {
+            Object result = map.get(key);
+            return (result == null) ? def : result;
+        }
+        return section.get(key, def);
+    }
+
+    public ConfigurationSection createSection(String path) {
+        Validate.notEmpty(path, "Cannot create section at empty path");
+        Configuration root = getRoot();
+        if (root == null) {
+            throw new IllegalStateException("Cannot create section without a root");
+        }
+
+        final char separator = root.options().pathSeparator();
+        // i1 is the leading (higher) index
+        // i2 is the trailing (lower) index
+        int i1 = -1, i2;
+        ConfigurationSection section = this;
+        while ((i1 = path.indexOf(separator, i2 = i1 + 1)) != -1) {
+            String node = path.substring(i2, i1);
+            ConfigurationSection subSection = section.getConfigurationSection(node);
+            if (subSection == null) {
+                section = section.createSection(node);
+            } else {
+                section = subSection;
+            }
+        }
+
+        String key = path.substring(i2);
+        if (section == this) {
+            ConfigurationSection result = new MemorySection(this, key);
+            map.put(key, result);
+            return result;
+        }
+        return section.createSection(key);
+    }
+
+    public ConfigurationSection createSection(String path, Map<?, ?> map) {
+        ConfigurationSection section = createSection(path);
+
+        for (Map.Entry<?, ?> entry : map.entrySet()) {
+            if (entry.getValue() instanceof Map) {
+                section.createSection(entry.getKey().toString(), (Map<?, ?>) entry.getValue());
+            } else {
+                section.set(entry.getKey().toString(), entry.getValue());
+            }
+        }
+
+        return section;
+    }
+
+    // Primitives
+    public String getString(String path) {
+        Object def = getDefault(path);
+        return getString(path, def != null ? def.toString() : null);
+    }
+
+    public String getString(String path, String def) {
+        Object val = get(path, def);
+        return (val != null) ? val.toString() : def;
+    }
+
+    public boolean isString(String path) {
+        Object val = get(path);
+        return val instanceof String;
+    }
+
+    public int getInt(String path) {
+        Object def = getDefault(path);
+        return getInt(path, (Integer) ((def instanceof Number) ? def : 0));
+    }
+
+    public int getInt(String path, int def) {
+        Object val = get(path, def);
+        return (Integer) ((val instanceof Number) ? val : def);
+    }
+
+    public boolean isInt(String path) {
+        Object val = get(path);
+        return val instanceof Integer;
+    }
+
+    public boolean getBoolean(String path) {
+        Object def = getDefault(path);
+        return getBoolean(path, (def instanceof Boolean) ? (Boolean) def : false);
+    }
+
+    public boolean getBoolean(String path, boolean def) {
+        Object val = get(path, def);
+        return (val instanceof Boolean) ? (Boolean) val : def;
+    }
+
+    public boolean isBoolean(String path) {
+        Object val = get(path);
+        return val instanceof Boolean;
+    }
+
+    public double getDouble(String path) {
+        Object def = getDefault(path);
+        return getDouble(path, (Double) ((def instanceof Number) ? def : 0));
+    }
+
+    public double getDouble(String path, double def) {
+        Object val = get(path, def);
+        return (Double) ((val instanceof Number) ? val : def);
+    }
+
+    public boolean isDouble(String path) {
+        Object val = get(path);
+        return val instanceof Double;
+    }
+
+    public long getLong(String path) {
+        Object def = getDefault(path);
+        return getLong(path, (Long) ((def instanceof Number) ? def : 0));
+    }
+
+    public long getLong(String path, long def) {
+        Object val = get(path, def);
+        return (Long) ((val instanceof Number) ? val : def);
+    }
+
+    public boolean isLong(String path) {
+        Object val = get(path);
+        return val instanceof Long;
+    }
+
+    // Java
+    public List<?> getList(String path) {
+        Object def = getDefault(path);
+        return getList(path, (def instanceof List) ? (List<?>) def : null);
+    }
+
+    public List<?> getList(String path, List<?> def) {
+        Object val = get(path, def);
+        return (List<?>) ((val instanceof List) ? val : def);
+    }
+
+    public boolean isList(String path) {
+        Object val = get(path);
+        return val instanceof List;
+    }
+
+    public List<String> getStringList(String path) {
+        List<?> list = getList(path);
+
+        if (list == null) {
+            return new ArrayList<String>(0);
+        }
+
+        List<String> result = new ArrayList<String>();
+
+        for (Object object : list) {
+            if ((object instanceof String) || (isPrimitiveWrapper(object))) {
+                result.add(String.valueOf(object));
+            }
+        }
+
+        return result;
+    }
+
+    public List<Integer> getIntegerList(String path) {
+        List<?> list = getList(path);
+
+        if (list == null) {
+            return new ArrayList<Integer>(0);
+        }
+
+        List<Integer> result = new ArrayList<Integer>();
+
+        for (Object object : list) {
+            if (object instanceof Integer) {
+                result.add((Integer) object);
+            } else if (object instanceof String) {
+                try {
+                    result.add(Integer.valueOf((String) object));
+                } catch (Exception ex) {
+                }
+            } else if (object instanceof Character) {
+                result.add((int) ((Character) object).charValue());
+            } else if (object instanceof Number) {
+                result.add(((Number) object).intValue());
+            }
+        }
+
+        return result;
+    }
+
+    public List<Boolean> getBooleanList(String path) {
+        List<?> list = getList(path);
+
+        if (list == null) {
+            return new ArrayList<Boolean>(0);
+        }
+
+        List<Boolean> result = new ArrayList<Boolean>();
+
+        for (Object object : list) {
+            if (object instanceof Boolean) {
+                result.add((Boolean) object);
+            } else if (object instanceof String) {
+                if (Boolean.TRUE.toString().equals(object)) {
+                    result.add(true);
+                } else if (Boolean.FALSE.toString().equals(object)) {
+                    result.add(false);
+                }
+            }
+        }
+
+        return result;
+    }
+
+    public List<Double> getDoubleList(String path) {
+        List<?> list = getList(path);
+
+        if (list == null) {
+            return new ArrayList<Double>(0);
+        }
+
+        List<Double> result = new ArrayList<Double>();
+
+        for (Object object : list) {
+            if (object instanceof Double) {
+                result.add((Double) object);
+            } else if (object instanceof String) {
+                try {
+                    result.add(Double.valueOf((String) object));
+                } catch (Exception ex) {
+                }
+            } else if (object instanceof Character) {
+                result.add((double) ((Character) object).charValue());
+            } else if (object instanceof Number) {
+                result.add(((Number) object).doubleValue());
+            }
+        }
+
+        return result;
+    }
+
+    public List<Float> getFloatList(String path) {
+        List<?> list = getList(path);
+
+        if (list == null) {
+            return new ArrayList<Float>(0);
+        }
+
+        List<Float> result = new ArrayList<Float>();
+
+        for (Object object : list) {
+            if (object instanceof Float) {
+                result.add((Float) object);
+            } else if (object instanceof String) {
+                try {
+                    result.add(Float.valueOf((String) object));
+                } catch (Exception ex) {
+                }
+            } else if (object instanceof Character) {
+                result.add((float) ((Character) object).charValue());
+            } else if (object instanceof Number) {
+                result.add(((Number) object).floatValue());
+            }
+        }
+
+        return result;
+    }
+
+    public List<Long> getLongList(String path) {
+        List<?> list = getList(path);
+
+        if (list == null) {
+            return new ArrayList<Long>(0);
+        }
+
+        List<Long> result = new ArrayList<Long>();
+
+        for (Object object : list) {
+            if (object instanceof Long) {
+                result.add((Long) object);
+            } else if (object instanceof String) {
+                try {
+                    result.add(Long.valueOf((String) object));
+                } catch (Exception ex) {
+                }
+            } else if (object instanceof Character) {
+                result.add((long) ((Character) object).charValue());
+            } else if (object instanceof Number) {
+                result.add(((Number) object).longValue());
+            }
+        }
+
+        return result;
+    }
+
+    public List<Byte> getByteList(String path) {
+        List<?> list = getList(path);
+
+        if (list == null) {
+            return new ArrayList<Byte>(0);
+        }
+
+        List<Byte> result = new ArrayList<Byte>();
+
+        for (Object object : list) {
+            if (object instanceof Byte) {
+                result.add((Byte) object);
+            } else if (object instanceof String) {
+                try {
+                    result.add(Byte.valueOf((String) object));
+                } catch (Exception ex) {
+                }
+            } else if (object instanceof Character) {
+                result.add((byte) ((Character) object).charValue());
+            } else if (object instanceof Number) {
+                result.add(((Number) object).byteValue());
+            }
+        }
+
+        return result;
+    }
+
+    public List<Character> getCharacterList(String path) {
+        List<?> list = getList(path);
+
+        if (list == null) {
+            return new ArrayList<Character>(0);
+        }
+
+        List<Character> result = new ArrayList<Character>();
+
+        for (Object object : list) {
+            if (object instanceof Character) {
+                result.add((Character) object);
+            } else if (object instanceof String) {
+                String str = (String) object;
+
+                if (str.length() == 1) {
+                    result.add(str.charAt(0));
+                }
+            } else if (object instanceof Number) {
+                result.add((char) ((Number) object).intValue());
+            }
+        }
+
+        return result;
+    }
+
+    public List<Short> getShortList(String path) {
+        List<?> list = getList(path);
+
+        if (list == null) {
+            return new ArrayList<Short>(0);
+        }
+
+        List<Short> result = new ArrayList<Short>();
+
+        for (Object object : list) {
+            if (object instanceof Short) {
+                result.add((Short) object);
+            } else if (object instanceof String) {
+                try {
+                    result.add(Short.valueOf((String) object));
+                } catch (Exception ex) {
+                }
+            } else if (object instanceof Character) {
+                result.add((short) ((Character) object).charValue());
+            } else if (object instanceof Number) {
+                result.add(((Number) object).shortValue());
+            }
+        }
+
+        return result;
+    }
+
+    public List<Map<?, ?>> getMapList(String path) {
+        List<?> list = getList(path);
+        List<Map<?, ?>> result = new ArrayList<Map<?, ?>>();
+
+        if (list == null) {
+            return result;
+        }
+
+        for (Object object : list) {
+            if (object instanceof Map) {
+                result.add((Map<?, ?>) object);
+            }
+        }
+
+        return result;
+    }
+
+    // Bukkit
+
+    public ConfigurationSection getConfigurationSection(String path) {
+        Object val = get(path, null);
+        if (val != null) {
+            return (val instanceof ConfigurationSection) ? (ConfigurationSection) val : null;
+        }
+
+        val = get(path, getDefault(path));
+        return (val instanceof ConfigurationSection) ? createSection(path) : null;
+    }
+
+    public boolean isConfigurationSection(String path) {
+        Object val = get(path);
+        return val instanceof ConfigurationSection;
+    }
+
+    protected boolean isPrimitiveWrapper(Object input) {
+        return input instanceof Integer || input instanceof Boolean ||
+                input instanceof Character || input instanceof Byte ||
+                input instanceof Short || input instanceof Double ||
+                input instanceof Long || input instanceof Float;
+    }
+
+    protected Object getDefault(String path) {
+        Validate.notNull(path, "Path cannot be null");
+
+        Configuration root = getRoot();
+        Configuration defaults = root == null ? null : root.getDefaults();
+        return (defaults == null) ? null : defaults.get(createPath(this, path));
+    }
+
+    protected void mapChildrenKeys(Set<String> output, ConfigurationSection section, boolean deep) {
+        if (section instanceof MemorySection) {
+            MemorySection sec = (MemorySection) section;
+
+            for (Map.Entry<String, Object> entry : sec.map.entrySet()) {
+                output.add(createPath(section, entry.getKey(), this));
+
+                if ((deep) && (entry.getValue() instanceof ConfigurationSection)) {
+                    ConfigurationSection subsection = (ConfigurationSection) entry.getValue();
+                    mapChildrenKeys(output, subsection, deep);
+                }
+            }
+        } else {
+            Set<String> keys = section.getKeys(deep);
+
+            for (String key : keys) {
+                output.add(createPath(section, key, this));
+            }
+        }
+    }
+
+    protected void mapChildrenValues(Map<String, Object> output, ConfigurationSection section, boolean deep) {
+        if (section instanceof MemorySection) {
+            MemorySection sec = (MemorySection) section;
+
+            for (Map.Entry<String, Object> entry : sec.map.entrySet()) {
+                output.put(createPath(section, entry.getKey(), this), entry.getValue());
+
+                if (entry.getValue() instanceof ConfigurationSection) {
+                    if (deep) {
+                        mapChildrenValues(output, (ConfigurationSection) entry.getValue(), deep);
+                    }
+                }
+            }
+        } else {
+            Map<String, Object> values = section.getValues(deep);
+
+            for (Map.Entry<String, Object> entry : values.entrySet()) {
+                output.put(createPath(section, entry.getKey(), this), entry.getValue());
+            }
+        }
+    }
+
+    /**
+     * Creates a full path to the given {@link ConfigurationSection} from its
+     * root {@link Configuration}.
+     * <p>
+     * You may use this method for any given {@link ConfigurationSection}, not
+     * only {@link MemorySection}.
+     *
+     * @param section Section to create a path for.
+     * @param key Name of the specified section.
+     * @return Full path of the section from its root.
+     */
+    public static String createPath(ConfigurationSection section, String key) {
+        return createPath(section, key, (section == null) ? null : section.getRoot());
+    }
+
+    /**
+     * Creates a relative path to the given {@link ConfigurationSection} from
+     * the given relative section.
+     * <p>
+     * You may use this method for any given {@link ConfigurationSection}, not
+     * only {@link MemorySection}.
+     *
+     * @param section Section to create a path for.
+     * @param key Name of the specified section.
+     * @param relativeTo Section to create the path relative to.
+     * @return Full path of the section from its root.
+     */
+    public static String createPath(ConfigurationSection section, String key, ConfigurationSection relativeTo) {
+        Validate.notNull(section, "Cannot create path without a section");
+        Configuration root = section.getRoot();
+        if (root == null) {
+            throw new IllegalStateException("Cannot create path without a root");
+        }
+        char separator = root.options().pathSeparator();
+
+        StringBuilder builder = new StringBuilder();
+        if (section != null) {
+            for (ConfigurationSection parent = section; (parent != null) && (parent != relativeTo); parent = parent.getParent()) {
+                if (builder.length() > 0) {
+                    builder.insert(0, separator);
+                }
+
+                builder.insert(0, parent.getName());
+            }
+        }
+
+        if ((key != null) && (key.length() > 0)) {
+            if (builder.length() > 0) {
+                builder.append(separator);
+            }
+
+            builder.append(key);
+        }
+
+        return builder.toString();
+    }
+    @Override
+    public String toString() {
+        Configuration root = getRoot();
+        return new StringBuilder()
+            .append(getClass().getSimpleName())
+            .append("[path='")
+            .append(getCurrentPath())
+            .append("', root='")
+            .append(root == null ? null : root.getClass().getSimpleName())
+            .append("']")
+            .toString();
+    }
+}
diff --git a/src/main/java/dev/wolveringer/configuration/file/FileConfiguration.java b/src/main/java/dev/wolveringer/configuration/file/FileConfiguration.java
new file mode 100644
index 0000000..68a338b
--- /dev/null
+++ b/src/main/java/dev/wolveringer/configuration/file/FileConfiguration.java
@@ -0,0 +1,288 @@
+package dev.wolveringer.configuration.file;
+
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStreamWriter;
+import java.io.Reader;
+import java.io.Writer;
+import java.nio.charset.Charset;
+
+import org.apache.commons.lang3.Validate;
+import org.yaml.snakeyaml.external.biz.base64Coder.Base64Coder;
+
+import com.google.common.base.Charsets;
+import com.google.common.io.Files;
+
+import dev.wolveringer.configuration.Configuration;
+import dev.wolveringer.configuration.InvalidConfigurationException;
+import dev.wolveringer.configuration.MemoryConfiguration;
+
+/**
+ * This is a base class for all File based implementations of {@link
+ * Configuration}
+ */
+public abstract class FileConfiguration extends MemoryConfiguration {
+    /**
+     * This value specified that the system default encoding should be
+     * completely ignored, as it cannot handle the ASCII character set, or it
+     * is a strict-subset of UTF8 already (plain ASCII).
+     *
+     * @deprecated temporary compatibility measure
+     */
+    @Deprecated
+    public static final boolean UTF8_OVERRIDE;
+    /**
+     * This value specifies if the system default encoding is unicode, but
+     * cannot parse standard ASCII.
+     *
+     * @deprecated temporary compatibility measure
+     */
+    @Deprecated
+    public static final boolean UTF_BIG;
+    /**
+     * This value specifies if the system supports unicode.
+     *
+     * @deprecated temporary compatibility measure
+     */
+    @Deprecated
+    public static final boolean SYSTEM_UTF;
+    static {
+        final byte[] testBytes = Base64Coder.decode("ICEiIyQlJicoKSorLC0uLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX4NCg==");
+        final String testString = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\r\n";
+        final Charset defaultCharset = Charset.defaultCharset();
+        final String resultString = new String(testBytes, defaultCharset);
+        final boolean trueUTF = defaultCharset.name().contains("UTF");
+        UTF8_OVERRIDE = !testString.equals(resultString) || defaultCharset.equals(Charset.forName("US-ASCII"));
+        SYSTEM_UTF = trueUTF || UTF8_OVERRIDE;
+        UTF_BIG = trueUTF && UTF8_OVERRIDE;
+    }
+
+    /**
+     * Creates an empty {@link FileConfiguration} with no default values.
+     */
+    public FileConfiguration() {
+        super();
+    }
+
+    /**
+     * Creates an empty {@link FileConfiguration} using the specified {@link
+     * Configuration} as a source for all default values.
+     *
+     * @param defaults Default value provider
+     */
+    public FileConfiguration(Configuration defaults) {
+        super(defaults);
+    }
+
+    /**
+     * Saves this {@link FileConfiguration} to the specified location.
+     * <p>
+     * If the file does not exist, it will be created. If already exists, it
+     * will be overwritten. If it cannot be overwritten or created, an
+     * exception will be thrown.
+     * <p>
+     * This method will save using the system default encoding, or possibly
+     * using UTF8.
+     *
+     * @param file File to save to.
+     * @throws IOException Thrown when the given file cannot be written to for
+     *     any reason.
+     * @throws IllegalArgumentException Thrown when file is null.
+     */
+    public void save(File file) throws IOException {
+        Validate.notNull(file, "File cannot be null");
+        Files.createParentDirs(file);
+        String data = saveToString();
+
+        Writer writer = new OutputStreamWriter(new FileOutputStream(file), UTF8_OVERRIDE && !UTF_BIG ? Charsets.UTF_8 : Charset.defaultCharset());
+
+        try {
+            writer.write(data);
+        } finally {
+            writer.close();
+        }
+    }
+
+    /**
+     * Saves this {@link FileConfiguration} to the specified location.
+     * <p>
+     * If the file does not exist, it will be created. If already exists, it
+     * will be overwritten. If it cannot be overwritten or created, an
+     * exception will be thrown.
+     * <p>
+     * This method will save using the system default encoding, or possibly
+     * using UTF8.
+     *
+     * @param file File to save to.
+     * @throws IOException Thrown when the given file cannot be written to for
+     *     any reason.
+     * @throws IllegalArgumentException Thrown when file is null.
+     */
+    public void save(String file) throws IOException {
+        Validate.notNull(file, "File cannot be null");
+
+        save(new File(file));
+    }
+
+    /**
+     * Saves this {@link FileConfiguration} to a string, and returns it.
+     *
+     * @return String containing this configuration.
+     */
+    public abstract String saveToString();
+
+    /**
+     * Loads this {@link FileConfiguration} from the specified location.
+     * <p>
+     * All the values contained within this configuration will be removed,
+     * leaving only settings and defaults, and the new values will be loaded
+     * from the given file.
+     * <p>
+     * If the file cannot be loaded for any reason, an exception will be
+     * thrown.
+     * <p>
+     * This will attempt to use the {@link Charset#defaultCharset()} for
+     * files, unless {@link #UTF8_OVERRIDE} but not {@link #UTF_BIG} is
+     * specified.
+     *
+     * @param file File to load from.
+     * @throws FileNotFoundException Thrown when the given file cannot be
+     *     opened.
+     * @throws IOException Thrown when the given file cannot be read.
+     * @throws InvalidConfigurationException Thrown when the given file is not
+     *     a valid Configuration.
+     * @throws IllegalArgumentException Thrown when file is null.
+     */
+    public void load(File file) throws FileNotFoundException, IOException, InvalidConfigurationException {
+        Validate.notNull(file, "File cannot be null");
+
+        final FileInputStream stream = new FileInputStream(file);
+
+        load(new InputStreamReader(stream, UTF8_OVERRIDE && !UTF_BIG ? Charsets.UTF_8 : Charset.defaultCharset()));
+    }
+
+    /**
+     * Loads this {@link FileConfiguration} from the specified stream.
+     * <p>
+     * All the values contained within this configuration will be removed,
+     * leaving only settings and defaults, and the new values will be loaded
+     * from the given stream.
+     * <p>
+     * This will attempt to use the {@link Charset#defaultCharset()}, unless
+     * {@link #UTF8_OVERRIDE} or {@link #UTF_BIG} is specified.
+     *
+     * @param stream Stream to load from
+     * @throws IOException Thrown when the given file cannot be read.
+     * @throws InvalidConfigurationException Thrown when the given file is not
+     *     a valid Configuration.
+     * @throws IllegalArgumentException Thrown when stream is null.
+     * @deprecated This does not consider encoding
+     * @see #load(Reader)
+     */
+    @Deprecated
+    public void load(InputStream stream) throws IOException, InvalidConfigurationException {
+        Validate.notNull(stream, "Stream cannot be null");
+
+        load(new InputStreamReader(stream, UTF8_OVERRIDE ? Charsets.UTF_8 : Charset.defaultCharset()));
+    }
+
+    /**
+     * Loads this {@link FileConfiguration} from the specified reader.
+     * <p>
+     * All the values contained within this configuration will be removed,
+     * leaving only settings and defaults, and the new values will be loaded
+     * from the given stream.
+     *
+     * @param reader the reader to load from
+     * @throws IOException thrown when underlying reader throws an IOException
+     * @throws InvalidConfigurationException thrown when the reader does not
+     *      represent a valid Configuration
+     * @throws IllegalArgumentException thrown when reader is null
+     */
+    public void load(Reader reader) throws IOException, InvalidConfigurationException {
+        BufferedReader input = reader instanceof BufferedReader ? (BufferedReader) reader : new BufferedReader(reader);
+
+        StringBuilder builder = new StringBuilder();
+
+        try {
+            String line;
+
+            while ((line = input.readLine()) != null) {
+                builder.append(line);
+                builder.append('\n');
+            }
+        } finally {
+            input.close();
+        }
+
+        loadFromString(builder.toString());
+    }
+
+    /**
+     * Loads this {@link FileConfiguration} from the specified location.
+     * <p>
+     * All the values contained within this configuration will be removed,
+     * leaving only settings and defaults, and the new values will be loaded
+     * from the given file.
+     * <p>
+     * If the file cannot be loaded for any reason, an exception will be
+     * thrown.
+     *
+     * @param file File to load from.
+     * @throws FileNotFoundException Thrown when the given file cannot be
+     *     opened.
+     * @throws IOException Thrown when the given file cannot be read.
+     * @throws InvalidConfigurationException Thrown when the given file is not
+     *     a valid Configuration.
+     * @throws IllegalArgumentException Thrown when file is null.
+     */
+    public void load(String file) throws FileNotFoundException, IOException, InvalidConfigurationException {
+        Validate.notNull(file, "File cannot be null");
+
+        load(new File(file));
+    }
+
+    /**
+     * Loads this {@link FileConfiguration} from the specified string, as
+     * opposed to from file.
+     * <p>
+     * All the values contained within this configuration will be removed,
+     * leaving only settings and defaults, and the new values will be loaded
+     * from the given string.
+     * <p>
+     * If the string is invalid in any way, an exception will be thrown.
+     *
+     * @param contents Contents of a Configuration to load.
+     * @throws InvalidConfigurationException Thrown if the specified string is
+     *     invalid.
+     * @throws IllegalArgumentException Thrown if contents is null.
+     */
+    public abstract void loadFromString(String contents) throws InvalidConfigurationException;
+
+    /**
+     * Compiles the header for this {@link FileConfiguration} and returns the
+     * result.
+     * <p>
+     * This will use the header from {@link #options()} -> {@link
+     * FileConfigurationOptions#header()}, respecting the rules of {@link
+     * FileConfigurationOptions#copyHeader()} if set.
+     *
+     * @return Compiled header
+     */
+    protected abstract String buildHeader();
+
+    @Override
+    public FileConfigurationOptions options() {
+        if (options == null) {
+            options = new FileConfigurationOptions(this);
+        }
+
+        return (FileConfigurationOptions) options;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/configuration/file/FileConfigurationOptions.java b/src/main/java/dev/wolveringer/configuration/file/FileConfigurationOptions.java
new file mode 100644
index 0000000..b3fcfac
--- /dev/null
+++ b/src/main/java/dev/wolveringer/configuration/file/FileConfigurationOptions.java
@@ -0,0 +1,119 @@
+package dev.wolveringer.configuration.file;
+
+import dev.wolveringer.configuration.MemoryConfiguration;
+import dev.wolveringer.configuration.MemoryConfigurationOptions;
+
+/**
+ * Various settings for controlling the input and output of a {@link
+ * FileConfiguration}
+ */
+public class FileConfigurationOptions extends MemoryConfigurationOptions {
+    private String header = null;
+    private boolean copyHeader = true;
+
+    protected FileConfigurationOptions(MemoryConfiguration configuration) {
+        super(configuration);
+    }
+
+    @Override
+    public FileConfiguration configuration() {
+        return (FileConfiguration) super.configuration();
+    }
+
+    @Override
+    public FileConfigurationOptions copyDefaults(boolean value) {
+        super.copyDefaults(value);
+        return this;
+    }
+
+    @Override
+    public FileConfigurationOptions pathSeparator(char value) {
+        super.pathSeparator(value);
+        return this;
+    }
+
+    /**
+     * Gets the header that will be applied to the top of the saved output.
+     * <p>
+     * This header will be commented out and applied directly at the top of
+     * the generated output of the {@link FileConfiguration}. It is not
+     * required to include a newline at the end of the header as it will
+     * automatically be applied, but you may include one if you wish for extra
+     * spacing.
+     * <p>
+     * Null is a valid value which will indicate that no header is to be
+     * applied. The default value is null.
+     *
+     * @return Header
+     */
+    public String header() {
+        return header;
+    }
+
+    /**
+     * Sets the header that will be applied to the top of the saved output.
+     * <p>
+     * This header will be commented out and applied directly at the top of
+     * the generated output of the {@link FileConfiguration}. It is not
+     * required to include a newline at the end of the header as it will
+     * automatically be applied, but you may include one if you wish for extra
+     * spacing.
+     * <p>
+     * Null is a valid value which will indicate that no header is to be
+     * applied.
+     *
+     * @param value New header
+     * @return This object, for chaining
+     */
+    public FileConfigurationOptions header(String value) {
+        this.header = value;
+        return this;
+    }
+
+    /**
+     * Gets whether or not the header should be copied from a default source.
+     * <p>
+     * If this is true, if a default {@link FileConfiguration} is passed to
+     * {@link
+     * FileConfiguration#setDefaults(org.bukkit.configuration.Configuration)}
+     * then upon saving it will use the header from that config, instead of
+     * the one provided here.
+     * <p>
+     * If no default is set on the configuration, or the default is not of
+     * type FileConfiguration, or that config has no header ({@link #header()}
+     * returns null) then the header specified in this configuration will be
+     * used.
+     * <p>
+     * Defaults to true.
+     *
+     * @return Whether or not to copy the header
+     */
+    public boolean copyHeader() {
+        return copyHeader;
+    }
+
+    /**
+     * Sets whether or not the header should be copied from a default source.
+     * <p>
+     * If this is true, if a default {@link FileConfiguration} is passed to
+     * {@link
+     * FileConfiguration#setDefaults(org.bukkit.configuration.Configuration)}
+     * then upon saving it will use the header from that config, instead of
+     * the one provided here.
+     * <p>
+     * If no default is set on the configuration, or the default is not of
+     * type FileConfiguration, or that config has no header ({@link #header()}
+     * returns null) then the header specified in this configuration will be
+     * used.
+     * <p>
+     * Defaults to true.
+     *
+     * @param value Whether or not to copy the header
+     * @return This object, for chaining
+     */
+    public FileConfigurationOptions copyHeader(boolean value) {
+        copyHeader = value;
+
+        return this;
+    }
+}
diff --git a/src/main/java/dev/wolveringer/configuration/file/YamlConfiguration.java b/src/main/java/dev/wolveringer/configuration/file/YamlConfiguration.java
new file mode 100644
index 0000000..97f75f7
--- /dev/null
+++ b/src/main/java/dev/wolveringer/configuration/file/YamlConfiguration.java
@@ -0,0 +1,250 @@
+package dev.wolveringer.configuration.file;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.Reader;
+import java.util.Map;
+
+import org.apache.commons.lang3.Validate;
+import org.yaml.snakeyaml.DumperOptions;
+import org.yaml.snakeyaml.Yaml;
+import org.yaml.snakeyaml.error.YAMLException;
+import org.yaml.snakeyaml.representer.Representer;
+
+import dev.wolveringer.configuration.Configuration;
+import dev.wolveringer.configuration.ConfigurationSection;
+import dev.wolveringer.configuration.InvalidConfigurationException;
+
+/**
+ * An implementation of {@link Configuration} which saves all files in Yaml.
+ * Note that this implementation is not synchronized.
+ */
+public class YamlConfiguration extends FileConfiguration {
+	protected static final String COMMENT_PREFIX = "# ";
+	protected static final String BLANK_CONFIG = "{}\n";
+	private final DumperOptions yamlOptions = new DumperOptions();
+	private final Representer yamlRepresenter = new YamlRepresenter();
+	private final Yaml yaml = new Yaml(new YamlConstructor(), yamlRepresenter, yamlOptions);
+
+	@Override
+	public String saveToString() {
+		yamlOptions.setIndent(options().indent());
+		yamlOptions.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);
+		yamlOptions.setAllowUnicode(SYSTEM_UTF);
+		yamlRepresenter.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);
+
+		String header = buildHeader();
+		String dump = yaml.dump(getValues(false));
+
+		if(dump.equals(BLANK_CONFIG)){
+			dump = "";
+		}
+
+		return header + dump;
+	}
+
+	@Override
+	public void loadFromString(String contents) throws InvalidConfigurationException {
+		Validate.notNull(contents, "Contents cannot be null");
+
+		Map<?, ?> input;
+		try{
+			input = (Map<?, ?>) yaml.load(contents);
+		}catch (YAMLException e){
+			throw new InvalidConfigurationException(e);
+		}catch (ClassCastException e){
+			throw new InvalidConfigurationException("Top level is not a Map.");
+		}
+
+		String header = parseHeader(contents);
+		if(header.length() > 0){
+			options().header(header);
+		}
+
+		if(input != null){
+			convertMapsToSections(input, this);
+		}
+	}
+
+	protected void convertMapsToSections(Map<?, ?> input, ConfigurationSection section) {
+		for(Map.Entry<?, ?> entry : input.entrySet()){
+			String key = entry.getKey().toString();
+			Object value = entry.getValue();
+
+			if(value instanceof Map){
+				convertMapsToSections((Map<?, ?>) value, section.createSection(key));
+			}else{
+				section.set(key, value);
+			}
+		}
+	}
+
+	protected String parseHeader(String input) {
+		String[] lines = input.split("\r?\n", -1);
+		StringBuilder result = new StringBuilder();
+		boolean readingHeader = true;
+		boolean foundHeader = false;
+
+		for(int i = 0;(i < lines.length) && (readingHeader);i++){
+			String line = lines[i];
+
+			if(line.startsWith(COMMENT_PREFIX)){
+				if(i > 0){
+					result.append("\n");
+				}
+
+				if(line.length() > COMMENT_PREFIX.length()){
+					result.append(line.substring(COMMENT_PREFIX.length()));
+				}
+
+				foundHeader = true;
+			}else if((foundHeader) && (line.length() == 0)){
+				result.append("\n");
+			}else if(foundHeader){
+				readingHeader = false;
+			}
+		}
+
+		return result.toString();
+	}
+
+	@Override
+	protected String buildHeader() {
+		String header = options().header();
+
+		if(options().copyHeader()){
+			Configuration def = getDefaults();
+
+			if((def != null) && (def instanceof FileConfiguration)){
+				FileConfiguration filedefaults = (FileConfiguration) def;
+				String defaultsHeader = filedefaults.buildHeader();
+
+				if((defaultsHeader != null) && (defaultsHeader.length() > 0)){
+					return defaultsHeader;
+				}
+			}
+		}
+
+		if(header == null){
+			return "";
+		}
+
+		StringBuilder builder = new StringBuilder();
+		String[] lines = header.split("\r?\n", -1);
+		boolean startedHeader = false;
+
+		for(int i = lines.length - 1;i >= 0;i--){
+			builder.insert(0, "\n");
+
+			if((startedHeader) || (lines[i].length() != 0)){
+				builder.insert(0, lines[i]);
+				builder.insert(0, COMMENT_PREFIX);
+				startedHeader = true;
+			}
+		}
+
+		return builder.toString();
+	}
+
+	@Override
+	public YamlConfigurationOptions options() {
+		if(options == null){
+			options = new YamlConfigurationOptions(this);
+		}
+
+		return (YamlConfigurationOptions) options;
+	}
+	
+	/**
+	 * Creates a new {@link YamlConfiguration}, loading from the given file.
+	 * <p>
+	 * Any errors loading the Configuration will be logged and then ignored.
+	 * If the specified input is not a valid config, a blank config will be
+	 * returned.
+	 * <p>
+	 * The encoding used may follow the system dependent default.
+	 *
+	 * @param file
+	 *            Input file
+	 * @return Resulting configuration
+	 * @throws IllegalArgumentException
+	 *             Thrown if file is null
+	 */
+	public static YamlConfiguration loadConfiguration(File file) {
+		Validate.notNull(file, "File cannot be null");
+
+		YamlConfiguration config = new YamlConfiguration();
+
+		try{
+			config.load(file);
+		}catch (FileNotFoundException ex){
+		}catch (Exception ex){
+			ex.printStackTrace();
+		}
+
+		return config;
+	}
+
+	/**
+	 * Creates a new {@link YamlConfiguration}, loading from the given stream.
+	 * <p>
+	 * Any errors loading the Configuration will be logged and then ignored.
+	 * If the specified input is not a valid config, a blank config will be
+	 * returned.
+	 *
+	 * @param stream
+	 *            Input stream
+	 * @return Resulting configuration
+	 * @throws IllegalArgumentException
+	 *             Thrown if stream is null
+	 * @deprecated does not properly consider encoding
+	 * @see #load(InputStream)
+	 * @see #loadConfiguration(Reader)
+	 */
+	@Deprecated
+	public static YamlConfiguration loadConfiguration(InputStream stream) {
+		Validate.notNull(stream, "Stream cannot be null");
+
+		YamlConfiguration config = new YamlConfiguration();
+
+		try{
+			config.load(stream);
+		}catch (IOException ex){
+		}catch (InvalidConfigurationException ex){
+			ex.printStackTrace();
+		}
+
+		return config;
+	}
+
+	/**
+	 * Creates a new {@link YamlConfiguration}, loading from the given reader.
+	 * <p>
+	 * Any errors loading the Configuration will be logged and then ignored.
+	 * If the specified input is not a valid config, a blank config will be
+	 * returned.
+	 *
+	 * @param reader
+	 *            input
+	 * @return resulting configuration
+	 * @throws IllegalArgumentException
+	 *             Thrown if stream is null
+	 */
+	public static YamlConfiguration loadConfiguration(Reader reader) {
+		Validate.notNull(reader, "Stream cannot be null");
+
+		YamlConfiguration config = new YamlConfiguration();
+
+		try{
+			config.load(reader);
+		}catch (IOException ex){
+			ex.printStackTrace();
+		}catch (InvalidConfigurationException ex){
+			ex.printStackTrace();
+		}
+
+		return config;
+	}
+}
diff --git a/src/main/java/dev/wolveringer/configuration/file/YamlConfigurationOptions.java b/src/main/java/dev/wolveringer/configuration/file/YamlConfigurationOptions.java
new file mode 100644
index 0000000..e24876f
--- /dev/null
+++ b/src/main/java/dev/wolveringer/configuration/file/YamlConfigurationOptions.java
@@ -0,0 +1,71 @@
+package dev.wolveringer.configuration.file;
+
+import org.apache.commons.lang3.Validate;
+
+/**
+ * Various settings for controlling the input and output of a {@link
+ * YamlConfiguration}
+ */
+public class YamlConfigurationOptions extends FileConfigurationOptions {
+    private int indent = 2;
+
+    protected YamlConfigurationOptions(YamlConfiguration configuration) {
+        super(configuration);
+    }
+
+    @Override
+    public YamlConfiguration configuration() {
+        return (YamlConfiguration) super.configuration();
+    }
+
+    @Override
+    public YamlConfigurationOptions copyDefaults(boolean value) {
+        super.copyDefaults(value);
+        return this;
+    }
+
+    @Override
+    public YamlConfigurationOptions pathSeparator(char value) {
+        super.pathSeparator(value);
+        return this;
+    }
+
+    @Override
+    public YamlConfigurationOptions header(String value) {
+        super.header(value);
+        return this;
+    }
+
+    @Override
+    public YamlConfigurationOptions copyHeader(boolean value) {
+        super.copyHeader(value);
+        return this;
+    }
+
+    /**
+     * Gets how much spaces should be used to indent each line.
+     * <p>
+     * The minimum value this may be is 2, and the maximum is 9.
+     *
+     * @return How much to indent by
+     */
+    public int indent() {
+        return indent;
+    }
+
+    /**
+     * Sets how much spaces should be used to indent each line.
+     * <p>
+     * The minimum value this may be is 2, and the maximum is 9.
+     *
+     * @param value New indent
+     * @return This object, for chaining
+     */
+    public YamlConfigurationOptions indent(int value) {
+        Validate.isTrue(value >= 2, "Indent must be at least 2 characters");
+        Validate.isTrue(value <= 9, "Indent cannot be greater than 9 characters");
+
+        this.indent = value;
+        return this;
+    }
+}
diff --git a/src/main/java/dev/wolveringer/configuration/file/YamlConstructor.java b/src/main/java/dev/wolveringer/configuration/file/YamlConstructor.java
new file mode 100644
index 0000000..d57a30e
--- /dev/null
+++ b/src/main/java/dev/wolveringer/configuration/file/YamlConstructor.java
@@ -0,0 +1,49 @@
+package dev.wolveringer.configuration.file;
+
+import java.util.LinkedHashMap;
+import java.util.Map;
+
+import org.yaml.snakeyaml.constructor.SafeConstructor;
+import org.yaml.snakeyaml.error.YAMLException;
+import org.yaml.snakeyaml.nodes.Node;
+import org.yaml.snakeyaml.nodes.Tag;
+
+import dev.wolveringer.configuration.serialization.ConfigurationSerialization;
+
+public class YamlConstructor extends SafeConstructor {
+
+    public YamlConstructor() {
+        this.yamlConstructors.put(Tag.MAP, new ConstructCustomObject());
+    }
+
+    private class ConstructCustomObject extends ConstructYamlMap {
+        @Override
+        public Object construct(Node node) {
+            if (node.isTwoStepsConstruction()) {
+                throw new YAMLException("Unexpected referential mapping structure. Node: " + node);
+            }
+
+            Map<?, ?> raw = (Map<?, ?>) super.construct(node);
+
+            if (raw.containsKey(ConfigurationSerialization.SERIALIZED_TYPE_KEY)) {
+                Map<String, Object> typed = new LinkedHashMap<String, Object>(raw.size());
+                for (Map.Entry<?, ?> entry : raw.entrySet()) {
+                    typed.put(entry.getKey().toString(), entry.getValue());
+                }
+
+                try {
+                    return ConfigurationSerialization.deserializeObject(typed);
+                } catch (IllegalArgumentException ex) {
+                    throw new YAMLException("Could not deserialize object", ex);
+                }
+            }
+
+            return raw;
+        }
+
+        @Override
+        public void construct2ndStep(Node node, Object object) {
+            throw new YAMLException("Unexpected referential mapping structure. Node: " + node);
+        }
+    }
+}
diff --git a/src/main/java/dev/wolveringer/configuration/file/YamlRepresenter.java b/src/main/java/dev/wolveringer/configuration/file/YamlRepresenter.java
new file mode 100644
index 0000000..afb79d6
--- /dev/null
+++ b/src/main/java/dev/wolveringer/configuration/file/YamlRepresenter.java
@@ -0,0 +1,38 @@
+package dev.wolveringer.configuration.file;
+
+import java.util.LinkedHashMap;
+import java.util.Map;
+
+import org.yaml.snakeyaml.nodes.Node;
+import org.yaml.snakeyaml.representer.Representer;
+
+import dev.wolveringer.configuration.ConfigurationSection;
+import dev.wolveringer.configuration.serialization.ConfigurationSerializable;
+import dev.wolveringer.configuration.serialization.ConfigurationSerialization;
+
+public class YamlRepresenter extends Representer {
+
+    public YamlRepresenter() {
+        this.multiRepresenters.put(ConfigurationSection.class, new RepresentConfigurationSection());
+        this.multiRepresenters.put(ConfigurationSerializable.class, new RepresentConfigurationSerializable());
+    }
+
+    private class RepresentConfigurationSection extends RepresentMap {
+        @Override
+        public Node representData(Object data) {
+            return super.representData(((ConfigurationSection) data).getValues(false));
+        }
+    }
+
+    private class RepresentConfigurationSerializable extends RepresentMap {
+        @Override
+        public Node representData(Object data) {
+            ConfigurationSerializable serializable = (ConfigurationSerializable) data;
+            Map<String, Object> values = new LinkedHashMap<String, Object>();
+            values.put(ConfigurationSerialization.SERIALIZED_TYPE_KEY, ConfigurationSerialization.getAlias(serializable.getClass()));
+            values.putAll(serializable.serialize());
+
+            return super.representData(values);
+        }
+    }
+}
diff --git a/src/main/java/dev/wolveringer/configuration/serialization/ConfigurationSerializable.java b/src/main/java/dev/wolveringer/configuration/serialization/ConfigurationSerializable.java
new file mode 100644
index 0000000..5d49dae
--- /dev/null
+++ b/src/main/java/dev/wolveringer/configuration/serialization/ConfigurationSerializable.java
@@ -0,0 +1,35 @@
+package dev.wolveringer.configuration.serialization;
+
+import java.util.Map;
+
+/**
+ * Represents an object that may be serialized.
+ * <p>
+ * These objects MUST implement one of the following, in addition to the
+ * methods as defined by this interface:
+ * <ul>
+ * <li>A static method "deserialize" that accepts a single {@link Map}&lt;
+ * {@link String}, {@link Object}> and returns the class.</li>
+ * <li>A static method "valueOf" that accepts a single {@link Map}&lt;{@link
+ * String}, {@link Object}> and returns the class.</li>
+ * <li>A constructor that accepts a single {@link Map}&lt;{@link String},
+ * {@link Object}>.</li>
+ * </ul>
+ * In addition to implementing this interface, you must register the class
+ * with {@link ConfigurationSerialization#registerClass(Class)}.
+ *
+ * @see DelegateDeserialization
+ * @see SerializableAs
+ */
+public interface ConfigurationSerializable {
+
+    /**
+     * Creates a Map representation of this class.
+     * <p>
+     * This class must provide a method to restore this class, as defined in
+     * the {@link ConfigurationSerializable} interface javadocs.
+     *
+     * @return Map containing the current state of this class
+     */
+    public Map<String, Object> serialize();
+}
diff --git a/src/main/java/dev/wolveringer/configuration/serialization/ConfigurationSerialization.java b/src/main/java/dev/wolveringer/configuration/serialization/ConfigurationSerialization.java
new file mode 100644
index 0000000..e6b4c7b
--- /dev/null
+++ b/src/main/java/dev/wolveringer/configuration/serialization/ConfigurationSerialization.java
@@ -0,0 +1,270 @@
+package dev.wolveringer.configuration.serialization;
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+import org.apache.commons.lang3.Validate;
+
+import dev.wolveringer.configuration.Configuration;
+
+/**
+ * Utility class for storing and retrieving classes for {@link Configuration}.
+ */
+public class ConfigurationSerialization {
+    public static final String SERIALIZED_TYPE_KEY = "==";
+    private final Class<? extends ConfigurationSerializable> clazz;
+    private static Map<String, Class<? extends ConfigurationSerializable>> aliases = new HashMap<String, Class<? extends ConfigurationSerializable>>();
+
+    static {
+    }
+
+    protected ConfigurationSerialization(Class<? extends ConfigurationSerializable> clazz) {
+        this.clazz = clazz;
+    }
+
+    protected Method getMethod(String name, boolean isStatic) {
+        try {
+            Method method = clazz.getDeclaredMethod(name, Map.class);
+
+            if (!ConfigurationSerializable.class.isAssignableFrom(method.getReturnType())) {
+                return null;
+            }
+            if (Modifier.isStatic(method.getModifiers()) != isStatic) {
+                return null;
+            }
+
+            return method;
+        } catch (NoSuchMethodException ex) {
+            return null;
+        } catch (SecurityException ex) {
+            return null;
+        }
+    }
+
+    protected Constructor<? extends ConfigurationSerializable> getConstructor() {
+        try {
+            return clazz.getConstructor(Map.class);
+        } catch (NoSuchMethodException ex) {
+            return null;
+        } catch (SecurityException ex) {
+            return null;
+        }
+    }
+
+    protected ConfigurationSerializable deserializeViaMethod(Method method, Map<String, ?> args) {
+        try {
+            ConfigurationSerializable result = (ConfigurationSerializable) method.invoke(null, args);
+
+            if (result == null) {
+                Logger.getLogger(ConfigurationSerialization.class.getName()).log(Level.SEVERE, "Could not call method '" + method.toString() + "' of " + clazz + " for deserialization: method returned null");
+            } else {
+                return result;
+            }
+        } catch (Throwable ex) {
+            Logger.getLogger(ConfigurationSerialization.class.getName()).log(
+                    Level.SEVERE,
+                    "Could not call method '" + method.toString() + "' of " + clazz + " for deserialization",
+                    ex instanceof InvocationTargetException ? ex.getCause() : ex);
+        }
+
+        return null;
+    }
+
+    protected ConfigurationSerializable deserializeViaCtor(Constructor<? extends ConfigurationSerializable> ctor, Map<String, ?> args) {
+        try {
+            return ctor.newInstance(args);
+        } catch (Throwable ex) {
+            Logger.getLogger(ConfigurationSerialization.class.getName()).log(
+                    Level.SEVERE,
+                    "Could not call constructor '" + ctor.toString() + "' of " + clazz + " for deserialization",
+                    ex instanceof InvocationTargetException ? ex.getCause() : ex);
+        }
+
+        return null;
+    }
+
+    public ConfigurationSerializable deserialize(Map<String, ?> args) {
+        Validate.notNull(args, "Args must not be null");
+
+        ConfigurationSerializable result = null;
+        Method method = null;
+
+        if (result == null) {
+            method = getMethod("deserialize", true);
+
+            if (method != null) {
+                result = deserializeViaMethod(method, args);
+            }
+        }
+
+        if (result == null) {
+            method = getMethod("valueOf", true);
+
+            if (method != null) {
+                result = deserializeViaMethod(method, args);
+            }
+        }
+
+        if (result == null) {
+            Constructor<? extends ConfigurationSerializable> constructor = getConstructor();
+
+            if (constructor != null) {
+                result = deserializeViaCtor(constructor, args);
+            }
+        }
+
+        return result;
+    }
+
+    /**
+     * Attempts to deserialize the given arguments into a new instance of the
+     * given class.
+     * <p>
+     * The class must implement {@link ConfigurationSerializable}, including
+     * the extra methods as specified in the javadoc of
+     * ConfigurationSerializable.
+     * <p>
+     * If a new instance could not be made, an example being the class not
+     * fully implementing the interface, null will be returned.
+     *
+     * @param args Arguments for deserialization
+     * @param clazz Class to deserialize into
+     * @return New instance of the specified class
+     */
+    public static ConfigurationSerializable deserializeObject(Map<String, ?> args, Class<? extends ConfigurationSerializable> clazz) {
+        return new ConfigurationSerialization(clazz).deserialize(args);
+    }
+
+    /**
+     * Attempts to deserialize the given arguments into a new instance of the
+     * given class.
+     * <p>
+     * The class must implement {@link ConfigurationSerializable}, including
+     * the extra methods as specified in the javadoc of
+     * ConfigurationSerializable.
+     * <p>
+     * If a new instance could not be made, an example being the class not
+     * fully implementing the interface, null will be returned.
+     *
+     * @param args Arguments for deserialization
+     * @return New instance of the specified class
+     */
+    public static ConfigurationSerializable deserializeObject(Map<String, ?> args) {
+        Class<? extends ConfigurationSerializable> clazz = null;
+
+        if (args.containsKey(SERIALIZED_TYPE_KEY)) {
+            try {
+                String alias = (String) args.get(SERIALIZED_TYPE_KEY);
+
+                if (alias == null) {
+                    throw new IllegalArgumentException("Cannot have null alias");
+                }
+                clazz = getClassByAlias(alias);
+                if (clazz == null) {
+                    throw new IllegalArgumentException("Specified class does not exist ('" + alias + "')");
+                }
+            } catch (ClassCastException ex) {
+                ex.fillInStackTrace();
+                throw ex;
+            }
+        } else {
+            throw new IllegalArgumentException("Args doesn't contain type key ('" + SERIALIZED_TYPE_KEY + "')");
+        }
+
+        return new ConfigurationSerialization(clazz).deserialize(args);
+    }
+
+    /**
+     * Registers the given {@link ConfigurationSerializable} class by its
+     * alias
+     *
+     * @param clazz Class to register
+     */
+    public static void registerClass(Class<? extends ConfigurationSerializable> clazz) {
+        DelegateDeserialization delegate = clazz.getAnnotation(DelegateDeserialization.class);
+
+        if (delegate == null) {
+            registerClass(clazz, getAlias(clazz));
+            registerClass(clazz, clazz.getName());
+        }
+    }
+
+    /**
+     * Registers the given alias to the specified {@link
+     * ConfigurationSerializable} class
+     *
+     * @param clazz Class to register
+     * @param alias Alias to register as
+     * @see SerializableAs
+     */
+    public static void registerClass(Class<? extends ConfigurationSerializable> clazz, String alias) {
+        aliases.put(alias, clazz);
+    }
+
+    /**
+     * Unregisters the specified alias to a {@link ConfigurationSerializable}
+     *
+     * @param alias Alias to unregister
+     */
+    public static void unregisterClass(String alias) {
+        aliases.remove(alias);
+    }
+
+    /**
+     * Unregisters any aliases for the specified {@link
+     * ConfigurationSerializable} class
+     *
+     * @param clazz Class to unregister
+     */
+    public static void unregisterClass(Class<? extends ConfigurationSerializable> clazz) {
+        while (aliases.values().remove(clazz)) {
+            ;
+        }
+    }
+
+    /**
+     * Attempts to get a registered {@link ConfigurationSerializable} class by
+     * its alias
+     *
+     * @param alias Alias of the serializable
+     * @return Registered class, or null if not found
+     */
+    public static Class<? extends ConfigurationSerializable> getClassByAlias(String alias) {
+        return aliases.get(alias);
+    }
+
+    /**
+     * Gets the correct alias for the given {@link ConfigurationSerializable}
+     * class
+     *
+     * @param clazz Class to get alias for
+     * @return Alias to use for the class
+     */
+    public static String getAlias(Class<? extends ConfigurationSerializable> clazz) {
+        DelegateDeserialization delegate = clazz.getAnnotation(DelegateDeserialization.class);
+
+        if (delegate != null) {
+            if ((delegate.value() == null) || (delegate.value() == clazz)) {
+                delegate = null;
+            } else {
+                return getAlias(delegate.value());
+            }
+        }
+
+        if (delegate == null) {
+            SerializableAs alias = clazz.getAnnotation(SerializableAs.class);
+
+            if ((alias != null) && (alias.value() != null)) {
+                return alias.value();
+            }
+        }
+
+        return clazz.getName();
+    }
+}
diff --git a/src/main/java/dev/wolveringer/configuration/serialization/DelegateDeserialization.java b/src/main/java/dev/wolveringer/configuration/serialization/DelegateDeserialization.java
new file mode 100644
index 0000000..7dc3de0
--- /dev/null
+++ b/src/main/java/dev/wolveringer/configuration/serialization/DelegateDeserialization.java
@@ -0,0 +1,22 @@
+package dev.wolveringer.configuration.serialization;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Applies to a {@link ConfigurationSerializable} that will delegate all
+ * deserialization to another {@link ConfigurationSerializable}.
+ */
+@Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.TYPE)
+public @interface DelegateDeserialization {
+    /**
+     * Which class should be used as a delegate for this classes
+     * deserialization
+     *
+     * @return Delegate class
+     */
+    public Class<? extends ConfigurationSerializable> value();
+}
diff --git a/src/main/java/dev/wolveringer/configuration/serialization/SerializableAs.java b/src/main/java/dev/wolveringer/configuration/serialization/SerializableAs.java
new file mode 100644
index 0000000..8a1caa3
--- /dev/null
+++ b/src/main/java/dev/wolveringer/configuration/serialization/SerializableAs.java
@@ -0,0 +1,34 @@
+package dev.wolveringer.configuration.serialization;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Represents an "alias" that a {@link ConfigurationSerializable} may be
+ * stored as.
+ * If this is not present on a {@link ConfigurationSerializable} class, it
+ * will use the fully qualified name of the class.
+ * <p>
+ * This value will be stored in the configuration so that the configuration
+ * deserialization can determine what type it is.
+ * <p>
+ * Using this annotation on any other class than a {@link
+ * ConfigurationSerializable} will have no effect.
+ *
+ * @see ConfigurationSerialization#registerClass(Class, String)
+ */
+@Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.TYPE)
+public @interface SerializableAs {
+    /**
+     * This is the name your class will be stored and retrieved as.
+     * <p>
+     * This name MUST be unique. We recommend using names such as
+     * "MyPluginThing" instead of "Thing".
+     *
+     * @return Name to serialize the class as.
+     */
+    public String value();
+}
diff --git a/src/main/java/dev/wolveringer/hastebin/DocumentNotFoundException.java b/src/main/java/dev/wolveringer/hastebin/DocumentNotFoundException.java
new file mode 100644
index 0000000..b2f58e2
--- /dev/null
+++ b/src/main/java/dev/wolveringer/hastebin/DocumentNotFoundException.java
@@ -0,0 +1,9 @@
+package dev.wolveringer.hastebin;
+
+@SuppressWarnings("serial")
+public class DocumentNotFoundException extends RuntimeException{
+	public DocumentNotFoundException(String message) {
+		super(message);
+	}
+	
+}
diff --git a/src/main/java/dev/wolveringer/hastebin/HastebinDocument.java b/src/main/java/dev/wolveringer/hastebin/HastebinDocument.java
new file mode 100644
index 0000000..8e4ff18
--- /dev/null
+++ b/src/main/java/dev/wolveringer/hastebin/HastebinDocument.java
@@ -0,0 +1,80 @@
+package dev.wolveringer.hastebin;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.HttpURLConnection;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.Arrays;
+
+import org.apache.commons.io.IOUtils;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import com.google.common.base.Charsets;
+
+public class HastebinDocument {
+	private static final String BASE_URL = "http://hastebin.com/raw/";
+	private String identifier;
+	private ArrayList<String> lines = new ArrayList<>();
+
+	public HastebinDocument(String identifier) {
+		if(identifier.contains("/"))
+			this.identifier = identifier.substring(identifier.lastIndexOf("/")+1);
+		else
+			this.identifier = identifier;
+	}
+	 public void load() {
+		try{
+			lines = new ArrayList<>(Arrays.asList(performGetRequest(new URL(BASE_URL + identifier)).split("\n")));
+			if(lines.size() == 1)
+				if(lines.get(0).startsWith("{")){
+					try{
+						JSONObject obj = new JSONObject(lines.get(0));
+						if(obj.has("message"))
+							throw new DocumentNotFoundException(obj.getString("message"));
+					}catch (JSONException e){
+						e.printStackTrace();
+					}
+				}
+		}catch (IOException ex){
+			ex.printStackTrace();
+		}
+	}
+
+	private String performGetRequest(URL url) throws IOException {
+		HttpURLConnection connection = createUrlConnection(url);
+		InputStream inputStream = null;
+		try{
+			inputStream = connection.getInputStream();
+			String result = IOUtils.toString(inputStream, Charsets.UTF_8);
+			return result;
+		}catch (IOException e){
+			IOUtils.closeQuietly(inputStream);
+			inputStream = connection.getErrorStream();
+			if(inputStream != null){
+				String result = IOUtils.toString(inputStream, Charsets.UTF_8);
+				return result;
+			}
+			throw e;
+		}finally{
+			IOUtils.closeQuietly(inputStream);
+		}
+	}
+
+	private HttpURLConnection createUrlConnection(URL url) throws IOException {
+		HttpURLConnection connection = (HttpURLConnection) url.openConnection();
+		connection.setConnectTimeout(15000);
+		connection.setReadTimeout(15000);
+		connection.setDoOutput(true);
+		connection.setUseCaches(false);
+		connection.setRequestMethod("GET");
+		return connection;
+	}
+	public ArrayList<String> getLines() {
+		return this.lines;
+	}
+	public String getIdentifier() {
+		return this.identifier;
+	}
+}
diff --git a/src/main/java/dev/wolveringer/hastebin/HastebinPost.java b/src/main/java/dev/wolveringer/hastebin/HastebinPost.java
new file mode 100644
index 0000000..fe19462
--- /dev/null
+++ b/src/main/java/dev/wolveringer/hastebin/HastebinPost.java
@@ -0,0 +1,91 @@
+package dev.wolveringer.hastebin;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStreamWriter;
+import java.net.HttpURLConnection;
+import java.net.URL;
+import java.nio.charset.Charset;
+
+import org.apache.commons.io.IOUtils;
+import org.json.JSONObject;
+
+public class HastebinPost {
+	private StringBuilder text = new StringBuilder();
+	private boolean changed = false;
+	private String currunturl = "";
+	public HastebinPost(String... text) {
+		if(text.length>0)
+			changed = true;
+		for(String s : text)
+			this.text.append(s + "\n");
+	}
+
+	public void addLine(String line){
+		this.text.append(line+"\n");
+		changed = true;
+	}
+	public String getText() {
+		return text.toString();
+	}
+	public void setText(String text){
+		changed = true;
+		this.text = new StringBuilder(text);
+	}
+	
+	public String getTextUrl(){
+		if(changed){
+			try{
+				String out = performPostRequest(new URL("http://hastebin.com/documents"));
+				JSONObject o = new JSONObject(out);
+				if(!o.has("key")){
+					System.err.println("Cant paste Document (Response: "+out+")");
+					return "";
+				}
+				changed = false;
+				return currunturl = "http://hastebin.com/"+o.getString("key");
+			}catch(Exception e){
+				e.printStackTrace();
+			}
+		}
+		return currunturl;
+	}
+	
+	private String performPostRequest(URL url) throws IOException {
+		HttpURLConnection connection = createUrlConnection(url);
+
+		connection.setRequestProperty("Content-Type", "text/plain");
+		connection.setRequestProperty("Content-Length", String.valueOf(text.length()));
+
+		OutputStreamWriter writer = new OutputStreamWriter(connection.getOutputStream());
+		writer.write(text.toString());
+		writer.flush();
+
+		InputStream inputStream = null;
+		try{
+			inputStream = connection.getInputStream();
+			String result = IOUtils.toString(inputStream, Charset.forName("UTF-8"));
+			return result;
+		}catch (IOException e){
+			IOUtils.closeQuietly(inputStream);
+			inputStream = connection.getErrorStream();
+			if(inputStream != null){
+				String result = IOUtils.toString(inputStream, Charset.forName("UTF-8"));
+				return result;
+			}
+			throw e;
+		}finally{
+			IOUtils.closeQuietly(inputStream);
+		}
+	}
+
+	private HttpURLConnection createUrlConnection(URL url) throws IOException {
+		HttpURLConnection connection = (HttpURLConnection) url.openConnection();
+		connection.setConnectTimeout(15000);
+		connection.setReadTimeout(15000);
+		connection.setDoOutput(true);
+		connection.setUseCaches(false);
+		connection.setRequestMethod("POST");
+		return connection;
+	}
+}
diff --git a/src/main/java/dev/wolveringer/listener/InventoryResetListener.java b/src/main/java/dev/wolveringer/listener/InventoryResetListener.java
new file mode 100644
index 0000000..66fe249
--- /dev/null
+++ b/src/main/java/dev/wolveringer/listener/InventoryResetListener.java
@@ -0,0 +1,13 @@
+package dev.wolveringer.listener;
+
+import dev.wolveringer.BungeeUtil.Player;
+import net.md_5.bungee.api.event.ServerSwitchEvent;
+import net.md_5.bungee.api.plugin.Listener;
+import net.md_5.bungee.event.EventHandler;
+
+public class InventoryResetListener implements Listener{
+	@EventHandler
+	public void a(ServerSwitchEvent e){
+		((Player)e.getPlayer()).getPlayerInventory().clear(); //Clear inventory after server switch
+	}
+}
diff --git a/src/main/java/dev/wolveringer/maps/CachedArrayList.java b/src/main/java/dev/wolveringer/maps/CachedArrayList.java
new file mode 100644
index 0000000..2d76855
--- /dev/null
+++ b/src/main/java/dev/wolveringer/maps/CachedArrayList.java
@@ -0,0 +1,257 @@
+package dev.wolveringer.maps;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+
+public class CachedArrayList<E> extends ArrayList<E> {
+	public static interface UnloadListener<E> {
+		public boolean canUnload(E element);
+	}
+	private static final long serialVersionUID = 1L;
+
+	private long nextUpdate = Long.MAX_VALUE;
+
+	private int defautTime;
+	private TimeUnit defaultTimeUnit = TimeUnit.MILLISECONDS;
+
+	private HashMap<E, Long> times = new HashMap<>();
+
+	private ArrayList<UnloadListener<E>> listener = new ArrayList<>(); 
+	
+	public CachedArrayList(int defautTime, TimeUnit defaultTimeUnit) {
+		this.defautTime = defautTime;
+		this.defaultTimeUnit = defaultTimeUnit;
+	}
+
+	@Override
+	public boolean add(E e) {
+		return add(e, defautTime, defaultTimeUnit);
+	}
+
+	@Override
+	public void add(int index, E element) {
+		add(index, element, defautTime, defaultTimeUnit);
+	}
+
+	@Override
+	public boolean addAll(Collection<? extends E> c) {
+		return addAll(c, defautTime, defaultTimeUnit);
+	}
+
+	@Override
+	public boolean addAll(int index, Collection<? extends E> c) {
+		return addAll(index, c, defautTime, defaultTimeUnit);
+	}
+
+	public boolean add(E e, int time, TimeUnit unit) {
+		if (time == 0)
+			return false;
+		boolean add = super.add(e);
+		long t;
+		times.put(e, t = System.currentTimeMillis() + unit.toMillis(time));
+		if (nextUpdate > t)
+			nextUpdate = t;
+		return add;
+	}
+
+	public void add(int index, E e, int time, TimeUnit unit) {
+		if (time == 0)
+			return;
+		super.add(index, e);
+		long t;
+		times.put(e, t = System.currentTimeMillis() + unit.toMillis(time));
+		if (nextUpdate > t)
+			nextUpdate = t;
+	}
+
+	public boolean addAll(int index, Collection<? extends E> c, int time, TimeUnit unit) {
+		if (time == 0)
+			return false;
+		for (E e : c) {
+			long t;
+			times.put(e, t = System.currentTimeMillis() + unit.toMillis(time));
+			if (nextUpdate > t)
+				nextUpdate = t;
+		}
+		return super.addAll(index, c);
+	}
+
+	public boolean addAll(Collection<? extends E> c, int time, TimeUnit unit) {
+		if (time == 0)
+			return false;
+		for (E e : c) {
+			long t;
+			times.put(e, t = System.currentTimeMillis() + unit.toMillis(time));
+			if (nextUpdate > t)
+				nextUpdate = t;
+		}
+		return super.addAll(c);
+	}
+
+	@Override
+	public E remove(int index) {
+		E obj = super.remove(index);
+		long t = times.remove(obj);
+		if (t == nextUpdate)
+			updateTimes();
+		return obj;
+	}
+
+	@Override
+	public E get(int index) {
+		update();
+		return super.get(index);
+	}
+
+	@Override
+	public int size() {
+		update();
+		return super.size();
+	}
+
+	@Override
+	public Iterator<E> iterator() {
+		update();
+		return super.iterator();
+	}
+
+	@Override
+	public void clear() {
+		nextUpdate = Long.MAX_VALUE;
+		times.clear();
+		super.clear();
+	}
+
+	public void update() {
+		if (System.currentTimeMillis() > nextUpdate)
+			updateTimes();
+	}
+
+	@Override
+	public boolean remove(Object o) {
+		if(!times.containsKey(o))
+			return false;
+		long r = times.get(o);
+		times.remove(o);
+		if (r != 0L) {
+			if (nextUpdate == r)
+				update();
+		}
+		return super.remove(o);
+	}
+	
+	public void resetTime(E element){
+		times.put(element, System.currentTimeMillis() + defaultTimeUnit.toMillis(defautTime));
+	}
+
+	@Override
+	public boolean contains(Object o) {
+		update();
+		return super.contains(o);
+	}
+
+	@Override
+	public boolean containsAll(Collection<?> c) {
+		update();
+		return super.containsAll(c);
+	}
+
+	@Override
+	public int indexOf(Object o) {
+		update();
+		return super.indexOf(o);
+	}
+
+	@Override
+	public boolean isEmpty() {
+		update();
+		return super.isEmpty();
+	}
+
+	@Override
+	public List<E> subList(int fromIndex, int toIndex) {
+		update();
+		return super.subList(fromIndex, toIndex);
+	}
+
+	@Override
+	public int lastIndexOf(Object o) {
+		update();
+		return super.lastIndexOf(o);
+	}
+
+	@Override
+	public E set(int index, E element) {
+		return set(index, element,defautTime,defaultTimeUnit);
+	}
+	
+	@Override
+	public <T> T[] toArray(T[] a) {
+		update();
+		return super.toArray(a);
+	}
+	
+	@Override
+	public Object[] toArray() {
+		update();
+		return super.toArray();
+	}
+	public E set(int index, E element, int time, TimeUnit unit) {
+		update();
+		long l;
+		times.put(element, l = unit.toMillis(time));
+		if (l < nextUpdate)
+			nextUpdate = l;
+		E old = super.set(index, element);
+
+		long r = times.get(old);
+		times.remove(old);
+		if (r != 0L) {
+			if (nextUpdate == r)
+				update();
+		}
+		return old;
+	}
+
+	private void updateTimes() {
+		long min = Long.MAX_VALUE;
+		long time = System.currentTimeMillis();
+		HashMap<E, Long> ctimes  = new HashMap<>(times);
+		for (E e : ctimes.keySet()) {
+			long l = ctimes.get(e);
+			if (time > l){
+				boolean alowed = true;
+				for(UnloadListener<E> listener : new ArrayList<>(this.listener))
+					if(listener != null)
+						if(!listener.canUnload(e))
+							alowed = false;
+
+				if(alowed)
+					super.remove(e);
+				else{
+					resetTime(e);
+					l = ctimes.get(e);
+				}
+			}
+			else if (l < min)
+				min = l;
+		}
+		nextUpdate = min;
+	}
+	
+	@Override
+	public String toString() {
+		return super.toString();
+	}
+	
+	public void addUnloadListener(UnloadListener<E> listener){
+		this.listener.add(listener);
+	}
+	public void removeUnloadListener(UnloadListener<E> listener){
+		this.listener.remove(listener);
+	}
+}
diff --git a/src/main/java/dev/wolveringer/maps/CachedHashMap.java b/src/main/java/dev/wolveringer/maps/CachedHashMap.java
new file mode 100644
index 0000000..0a6b3aa
--- /dev/null
+++ b/src/main/java/dev/wolveringer/maps/CachedHashMap.java
@@ -0,0 +1,97 @@
+package dev.wolveringer.maps;
+
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.TimeUnit;
+
+public class CachedHashMap<K,V> extends HashMap<K, V> {
+	private CachedArrayList<K> keys;
+	private boolean locked = false;
+	
+	public CachedHashMap(int defautTime, TimeUnit defaultTimeUnit) {
+		keys = new CachedArrayList<>(defautTime, defaultTimeUnit);
+	}
+	
+	@Override
+	public V put(K key, V value) {
+		putKey(key);
+		return super.put(key, value);
+	}
+	
+	@Override
+	public void putAll(Map<? extends K, ? extends V> m) {
+		for(K key : m.keySet())
+			putKey(key);
+		super.putAll(m);
+	}
+	
+	@Override
+	public V get(Object key) {
+		V out = super.get(key);
+		if(!locked)
+			if(!keys.contains(key)){
+				out = null;
+				super.remove(key);
+			}
+		return out;
+	}
+	
+	public V getOrDefault(Object key, V defaultValue) {
+		V out;
+		if((out = get(key)) == null)
+			return defaultValue;
+		return out;
+	}
+	
+	@Override
+	public V remove(Object key) {
+		keys.remove(key);
+		return super.remove(key);
+	}
+	
+	public boolean remove(Object key, Object value) {
+		keys.remove(key);
+		return remove(key, value);
+	}
+	
+	private void putKey(K key){
+		keys.remove(key);
+		keys.add(key);
+	}
+
+	public V put(K key, V value, int time, TimeUnit unit) {
+		keys.add(key, time, unit);
+		return super.put(key, value);
+	}
+	
+	@Override
+	public int size() {
+		return keys.size();
+	}
+	
+	@Override
+	public Set<K> keySet() {
+		if(!locked)
+			keys.update();
+		return new HashSet<>(keys);
+	}
+	
+	@Override
+	public Collection<V> values() {
+		for(K key : super.keySet())
+			get(key); //Update value
+		return super.values();
+	}
+
+	public void lock() {
+		locked = true;
+		keys.update();
+	}
+	public void unlock(){
+		locked = false;
+	}
+}
diff --git a/src/main/java/dev/wolveringer/nbt/LimitStream.java b/src/main/java/dev/wolveringer/nbt/LimitStream.java
new file mode 100644
index 0000000..f702717
--- /dev/null
+++ b/src/main/java/dev/wolveringer/nbt/LimitStream.java
@@ -0,0 +1,29 @@
+package dev.wolveringer.nbt;
+
+import java.io.FilterInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+
+public class LimitStream extends FilterInputStream {
+	private final NBTReadLimiter limit;
+
+	public LimitStream(InputStream is, NBTReadLimiter limit) {
+		super(is);
+		this.limit = limit;
+	}
+
+	public int read() throws IOException {
+		this.limit.readBytes(1L);
+		return super.read();
+	}
+
+	public int read(byte[] b) throws IOException {
+		this.limit.readBytes(b.length);
+		return super.read(b);
+	}
+
+	public int read(byte[] b, int off, int len) throws IOException {
+		this.limit.readBytes(len);
+		return super.read(b, off, len);
+	}
+}
diff --git a/src/main/java/dev/wolveringer/nbt/MathHelper.java b/src/main/java/dev/wolveringer/nbt/MathHelper.java
new file mode 100644
index 0000000..34ec7c9
--- /dev/null
+++ b/src/main/java/dev/wolveringer/nbt/MathHelper.java
@@ -0,0 +1,175 @@
+package dev.wolveringer.nbt;
+
+import java.util.Random;
+
+public class MathHelper {
+
+	private static float[] a = new float[65536];
+	static{
+		for(int i = 0;i < 65536;++i){
+			a[i] = (float) Math.sin(i * 3.141592653589793D * 2.0D / 65536.0D);
+		}
+	}
+
+	public static double getHighestDouble(double d0, double d1) {
+		if(d0 < 0.0D){
+			d0 = -d0;
+		}
+
+		if(d1 < 0.0D){
+			d1 = -d1;
+		}
+
+		return d0 > d1 ? d0 : d1;
+	}
+
+	public static double a(double d0, double d1, double d2) {
+		return d0 < d1 ? d1 : d0 > d2 ? d2 : d0;
+	}
+
+	public static float a(float f, float f1, float f2) {
+		return f < f1 ? f1 : f > f2 ? f2 : f;
+	}
+
+	public static int a(int i) {
+		return i >= 0 ? i : -i;
+	}
+
+	public static int a(int i, int j, int k) {
+		return i < j ? j : i > k ? k : i;
+	}
+
+	public static double a(long[] along) {
+		long i = 0L;
+		long[] along1 = along;
+		int j = along.length;
+
+		for(int k = 0;k < j;++k){
+			long l = along1[k];
+
+			i += l;
+		}
+
+		return (double) i / (double) along.length;
+	}
+
+	public static double random(Random random, double d0, double d1) {
+		return d0 >= d1 ? d0 : random.nextDouble() * (d1 - d0) + d0;
+	}
+
+	public static float random(Random random, float f, float f1) {
+		return f >= f1 ? f : random.nextFloat() * (f1 - f) + f;
+	}
+
+	public static double a(String s, double d0) {
+		double d1 = d0;
+
+		try{
+			d1 = Double.parseDouble(s);
+		}catch (Throwable throwable){
+			;
+		}
+
+		return d1;
+	}
+
+	public static double a(String s, double d0, double d1) {
+		double d2 = d0;
+
+		try{
+			d2 = Double.parseDouble(s);
+		}catch (Throwable throwable){
+			;
+		}
+
+		if(d2 < d1){
+			d2 = d1;
+		}
+
+		return d2;
+	}
+
+	public static int parseInteger(String raw, int i) {
+		int j = i;
+		try{
+			j = Integer.parseInt(raw);
+		}catch (Throwable throwable){
+			;
+		}
+
+		return j;
+	}
+
+	public static int parseInteger(String s, int default_value, int min) {
+		int value = default_value;
+
+		try{
+			value = Integer.parseInt(s);
+		}catch (Throwable throwable){
+		}
+
+		if(value < min){
+			value = min;
+		}
+
+		return value;
+	}
+
+	public static float abs(float f) {
+		return f >= 0.0F ? f : -f;
+	}
+
+	public static double b(double d0, double d1, double d2) {
+		return d2 < 0.0D ? d0 : d2 > 1.0D ? d1 : d0 + (d1 - d0) * d2;
+	}
+
+	public static final float sqrt(float f) {
+		return (float) Math.sqrt(f);
+	}
+
+	public static final float cos(float f) {
+		return a[(int) (f * 10430.378F + 16384.0F) & '\uffff'];
+	}
+
+	public static long d(double d0) {
+		long i = (long) d0;
+
+		return d0 < i ? i - 1L : i;
+	}
+
+	public static int d(float f) {
+		int i = (int) f;
+
+		return f < i ? i - 1 : i;
+	}
+
+	public static int f(double d0) {
+		int i = (int) d0;
+
+		return d0 > i ? i + 1 : i;
+	}
+
+	public static int f(float f) {
+		int i = (int) f;
+
+		return f > i ? i + 1 : i;
+	}
+
+	public static int floor(double d0) {
+		int i = (int) d0;
+
+		return d0 < i ? i - 1 : i;
+	}
+
+	public static int nextInt(Random random, int min, int max) {
+		return min >= max ? min : random.nextInt(max - min + 1) + min;
+	}
+
+	public static final float sin(float f) {
+		return a[(int) (f * 10430.378F) & '\uffff'];
+	}
+
+	public static final float sqrt(double d0) {
+		return (float) Math.sqrt(d0);
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/nbt/NBTBase.java b/src/main/java/dev/wolveringer/nbt/NBTBase.java
new file mode 100644
index 0000000..e24fb56
--- /dev/null
+++ b/src/main/java/dev/wolveringer/nbt/NBTBase.java
@@ -0,0 +1,90 @@
+package dev.wolveringer.nbt;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+
+public abstract class NBTBase {
+	private final static int id_min = 0;
+	private final static int id_max = 11;//edit i8f you wont add your Tags
+	public static final String[] types = new String[] { "END", "BYTE", "SHORT", "INT", "LONG", "FLOAT", "DOUBLE", "BYTE[]", "STRING", "LIST", "COMPOUND", "INT[]" };
+
+	protected static NBTBase createTag(byte type) {
+		if(type> id_max || type < id_min)
+			throw new IllegalArgumentException("type must be: 11 <= type >= 0");
+		switch (type) {
+			case 0:
+				return new NBTTagEnd();
+
+			case 1:
+				return new NBTTagByte();
+
+			case 2:
+				return new NBTTagShort();
+
+			case 3:
+				return new NBTTagInt();
+
+			case 4:
+				return new NBTTagLong();
+
+			case 5:
+				return new NBTTagFloat();
+
+			case 6:
+				return new NBTTagDouble();
+
+			case 7:
+				return new NBTTagByteArray();
+
+			case 8:
+				return new NBTTagString();
+
+			case 9:
+				return new NBTTagList();
+
+			case 10:
+				return new NBTTagCompound();
+
+			case 11:
+				return new NBTTagIntArray();
+				//add case for your NBT
+			default:
+				return null;
+		}
+	}
+
+	protected NBTBase() {}
+
+	@Override
+	public abstract NBTBase clone();
+
+	@Override
+	public boolean equals(Object object) {
+		if(!(object instanceof NBTBase)){
+			return false;
+		}else{
+			NBTBase nbtbase = (NBTBase) object;
+
+			return this.getTypeId() == nbtbase.getTypeId();
+		}
+	}
+
+	public abstract byte getTypeId();
+
+	@Override
+	public int hashCode() {
+		return this.getTypeId();
+	}
+
+	abstract void load(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) throws Exception;
+
+	@Override
+	public abstract String toString();
+	abstract String toFormatedString(String prefix);
+	
+	public String toFormatedString(){
+		return toFormatedString("  ");
+	}
+	
+	abstract void write(DataOutput dataoutput) throws Exception;
+}
diff --git a/src/main/java/dev/wolveringer/nbt/NBTCompressedStreamTools.java b/src/main/java/dev/wolveringer/nbt/NBTCompressedStreamTools.java
new file mode 100644
index 0000000..c936063
--- /dev/null
+++ b/src/main/java/dev/wolveringer/nbt/NBTCompressedStreamTools.java
@@ -0,0 +1,168 @@
+package dev.wolveringer.nbt;
+
+import java.io.BufferedInputStream;
+import java.io.BufferedOutputStream;
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.DataInput;
+import java.io.DataInputStream;
+import java.io.DataOutput;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.zip.GZIPInputStream;
+import java.util.zip.GZIPOutputStream;
+
+import javax.xml.bind.DatatypeConverter;
+
+public class NBTCompressedStreamTools {
+
+	public static NBTTagCompound read(String data) throws Exception {
+		return read(DatatypeConverter.parseBase64Binary(data), NBTReadLimiter.unlimited);
+	}
+
+	public static NBTTagCompound read(byte[] abyte, NBTReadLimiter nbtreadlimiter) throws Exception {
+		DataInputStream datainputstream = null;
+		try{
+			datainputstream = new DataInputStream(new BufferedInputStream(new GZIPInputStream(new ByteArrayInputStream(abyte))));
+		}catch (java.io.IOException e1){
+			e1.printStackTrace();
+		}
+
+		NBTTagCompound nbttagcompound;
+
+		try{
+			nbttagcompound = read(datainputstream, nbtreadlimiter);
+		}finally{
+			try{
+				datainputstream.close();
+			}catch (IOException e){
+				e.printStackTrace();
+			}
+		}
+
+		return nbttagcompound;
+	}
+
+	public static NBTTagCompound read(InputStream inputstream) throws Exception {
+		DataInputStream datainputstream = createCompressedInput(inputstream);
+		NBTTagCompound nbttagcompound;
+		try{
+			nbttagcompound = read(datainputstream, NBTReadLimiter.unlimited);
+		}finally{
+			try{
+				datainputstream.close();
+			}catch (java.io.IOException e){
+				e.printStackTrace();
+			}
+		}
+
+		return nbttagcompound;
+	}
+
+	public static NBTTagCompound read(DataInput datainput, NBTReadLimiter nbtreadlimiter) throws Exception {
+		NBTBase nbtbase;
+		byte b0 = 0;
+		try{
+			b0 = datainput.readByte();
+		}catch (java.io.IOException e1){
+			e1.printStackTrace();
+		}
+
+		if(b0 == 0){
+			nbtbase = new NBTTagEnd();
+		}else{
+			try{
+				datainput.readUTF();
+			}catch (java.io.IOException e){
+				e.printStackTrace();
+			}
+			nbtbase = NBTBase.createTag(b0);
+
+			try{
+				nbtbase.load(datainput, 0, nbtreadlimiter);
+			}catch (IOException ioexception){
+				throw new RuntimeException();
+			}
+		}
+
+		if(nbtbase instanceof NBTTagCompound){
+			return (NBTTagCompound) nbtbase;
+		}else{
+			throw new IOException("Root tag must be a named compound tag");
+		}
+	}
+
+	public static NBTTagCompound read(DataInputStream datainputstream) throws Exception {
+		return read(datainputstream, NBTReadLimiter.unlimited);
+	}
+
+	public static byte[] toByte(NBTTagCompound nbttagcompound) throws Exception {
+		ByteArrayOutputStream bytearrayoutputstream = new ByteArrayOutputStream();
+		DataOutputStream dataoutputstream = createCompressedOutput(bytearrayoutputstream);
+		try{
+			write(nbttagcompound, (DataOutput) dataoutputstream);
+		}finally{
+			try{
+				dataoutputstream.close();
+			}catch (java.io.IOException e){
+				e.printStackTrace();
+			}
+		}
+
+		return bytearrayoutputstream.toByteArray();
+	}
+
+	public static String toString(NBTTagCompound nbttagcompound) throws Exception {
+		return DatatypeConverter.printBase64Binary(toByte(nbttagcompound));
+	}
+
+	public static void write(NBTTagCompound nbttagcompound, DataOutput dataoutput) throws Exception {
+		try{
+			dataoutput.writeByte(nbttagcompound.getTypeId());
+			if(nbttagcompound.getTypeId() != 0){
+				try{
+					dataoutput.writeUTF("");
+				}catch (java.io.IOException e){
+					e.printStackTrace();
+				}
+				nbttagcompound.write(dataoutput);
+			}
+		}catch (java.io.IOException e){
+			e.printStackTrace();
+		}finally{
+		}
+	}
+
+	public static void write(NBTTagCompound nbttagcompound, OutputStream outputstream) throws Exception {
+		DataOutputStream dataoutputstream = createCompressedOutput(outputstream);
+		try{
+			write(nbttagcompound, (DataOutput) dataoutputstream);
+		}finally{
+			try{
+				dataoutputstream.close();
+			}catch (java.io.IOException e){
+				e.printStackTrace();
+			}
+		}
+	}
+
+	private static DataOutputStream createCompressedOutput(OutputStream out) {
+		try{
+			return new DataOutputStream(new BufferedOutputStream(new GZIPOutputStream(out)));
+		}catch (java.io.IOException e){
+			e.printStackTrace();
+			return null;
+		}
+	}
+
+	private static DataInputStream createCompressedInput(InputStream in) {
+		try{
+			return new DataInputStream(new BufferedInputStream(new GZIPInputStream(in)));
+		}catch (java.io.IOException e){
+			e.printStackTrace();
+			return null;
+		}
+	}
+}
diff --git a/src/main/java/dev/wolveringer/nbt/NBTNumber.java b/src/main/java/dev/wolveringer/nbt/NBTNumber.java
new file mode 100644
index 0000000..944273e
--- /dev/null
+++ b/src/main/java/dev/wolveringer/nbt/NBTNumber.java
@@ -0,0 +1,19 @@
+package dev.wolveringer.nbt;
+
+public abstract class NBTNumber extends NBTBase {
+
+	protected NBTNumber() {
+	}
+
+	public abstract long asLong();
+
+	public abstract int asInt();
+
+	public abstract short asShort();
+
+	public abstract byte asByte();
+
+	public abstract double asDouble();
+
+	public abstract float asFloat();
+}
diff --git a/src/main/java/dev/wolveringer/nbt/NBTReadLimiter.java b/src/main/java/dev/wolveringer/nbt/NBTReadLimiter.java
new file mode 100644
index 0000000..79f0b71
--- /dev/null
+++ b/src/main/java/dev/wolveringer/nbt/NBTReadLimiter.java
@@ -0,0 +1,19 @@
+package dev.wolveringer.nbt;
+
+public class NBTReadLimiter {
+
+	public static final NBTReadLimiter unlimited = new NBTReadLimiterUnlimited(0L);
+	private final long limit;
+	private long readed;
+
+	public NBTReadLimiter(long limit) {
+		this.limit = limit;
+	}
+
+	public void readBytes(long bits) {
+		this.readed += bits / 8L;
+		if(this.readed > this.limit){
+			throw new RuntimeException("Tried to read NBT tag that was too big; tried to allocate: " + this.readed + "bytes where max allowed: " + this.limit);
+		}
+	}
+}
diff --git a/src/main/java/dev/wolveringer/nbt/NBTReadLimiterUnlimited.java b/src/main/java/dev/wolveringer/nbt/NBTReadLimiterUnlimited.java
new file mode 100644
index 0000000..101442c
--- /dev/null
+++ b/src/main/java/dev/wolveringer/nbt/NBTReadLimiterUnlimited.java
@@ -0,0 +1,10 @@
+package dev.wolveringer.nbt;
+
+final class NBTReadLimiterUnlimited extends NBTReadLimiter {
+	NBTReadLimiterUnlimited(long i) {
+		super(i);
+	}
+
+	@Override
+	public void readBytes(long i) {}
+}
diff --git a/src/main/java/dev/wolveringer/nbt/NBTTagByte.java b/src/main/java/dev/wolveringer/nbt/NBTTagByte.java
new file mode 100644
index 0000000..c6b5cbd
--- /dev/null
+++ b/src/main/java/dev/wolveringer/nbt/NBTTagByte.java
@@ -0,0 +1,102 @@
+package dev.wolveringer.nbt;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class NBTTagByte extends NBTNumber {
+
+	private byte data;
+
+	NBTTagByte() {
+	}
+
+	public NBTTagByte(byte b0) {
+		this.data = b0;
+	}
+
+	@Override
+	public long asLong() {
+		return this.data;
+	}
+
+	@Override
+	public NBTBase clone() {
+		return new NBTTagByte(this.data);
+	}
+
+	@Override
+	public int asInt() {
+		return this.data;
+	}
+
+	@Override
+	public short asShort() {
+		return this.data;
+	}
+
+	@Override
+	public boolean equals(Object object) {
+		if(super.equals(object)){
+			NBTTagByte nbttagbyte = (NBTTagByte) object;
+
+			return this.data == nbttagbyte.data;
+		}else{
+			return false;
+		}
+	}
+
+	@Override
+	public byte asByte() {
+		return this.data;
+	}
+
+	@Override
+	public double asDouble() {
+		return this.data;
+	}
+
+	@Override
+	public byte getTypeId() {
+		return (byte) 1;
+	}
+
+	@Override
+	public float asFloat() {
+		return this.data;
+	}
+
+	@Override
+	public int hashCode() {
+		return super.hashCode() ^ this.data;
+	}
+
+	@Override
+	void load(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) {
+		nbtreadlimiter.readBytes(8L);
+		try{
+			this.data = datainput.readByte();
+		}catch (IOException e){
+			e.printStackTrace();
+		}
+	}
+
+	@Override
+	String toFormatedString(String in) {
+		return in+toString();
+	}
+	
+	@Override
+	public String toString() {
+		return "" + this.data + "b";
+	}
+
+	@Override
+	void write(DataOutput dataoutput) {
+		try{
+			dataoutput.writeByte(this.data);
+		}catch (IOException e){
+			e.printStackTrace();
+		}
+	}
+}
diff --git a/src/main/java/dev/wolveringer/nbt/NBTTagByteArray.java b/src/main/java/dev/wolveringer/nbt/NBTTagByteArray.java
new file mode 100644
index 0000000..5f1f065
--- /dev/null
+++ b/src/main/java/dev/wolveringer/nbt/NBTTagByteArray.java
@@ -0,0 +1,89 @@
+package dev.wolveringer.nbt;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+import java.util.Arrays;
+
+public class NBTTagByteArray extends NBTBase {
+
+	private byte[] data;
+
+	NBTTagByteArray() {
+	}
+
+	public NBTTagByteArray(byte[] abyte) {
+		this.data = abyte;
+	}
+
+	public byte[] getData() {
+		return this.data;
+	}
+
+	@Override
+	public NBTBase clone() {
+		byte[] abyte = new byte[this.data.length];
+
+		System.arraycopy(this.data, 0, abyte, 0, this.data.length);
+		return new NBTTagByteArray(abyte);
+	}
+
+	@Override
+	public boolean equals(Object object) {
+		return super.equals(object) ? Arrays.equals(this.data, ((NBTTagByteArray) object).data) : false;
+	}
+
+	@Override
+	public byte getTypeId() {
+		return (byte) 7;
+	}
+
+	@Override
+	public int hashCode() {
+		return super.hashCode() ^ Arrays.hashCode(this.data);
+	}
+
+	@Override
+	void load(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) {
+		int length = 0;
+		try{
+			length = datainput.readInt();
+		}catch (IOException e){
+			e.printStackTrace();
+		}
+
+		nbtreadlimiter.readBytes(8 * length);
+		this.data = new byte[length];
+		try{
+			datainput.readFully(this.data);
+		}catch (IOException e){
+			e.printStackTrace();
+		}
+	}
+
+	@Override
+	public String toString() {
+		return "[" + this.data.length + " bytes]";
+	}
+	
+	
+
+	@Override
+	void write(DataOutput dataoutput) {
+		try{
+			dataoutput.writeInt(this.data.length);
+		}catch (IOException e){
+			e.printStackTrace();
+		}
+		try{
+			dataoutput.write(this.data);
+		}catch (IOException e){
+			e.printStackTrace();
+		}
+	}
+
+	@Override
+	public String toFormatedString(String prefix) {
+		return prefix+toString();
+	}
+}
diff --git a/src/main/java/dev/wolveringer/nbt/NBTTagCompound.java b/src/main/java/dev/wolveringer/nbt/NBTTagCompound.java
new file mode 100644
index 0000000..80356fb
--- /dev/null
+++ b/src/main/java/dev/wolveringer/nbt/NBTTagCompound.java
@@ -0,0 +1,341 @@
+package dev.wolveringer.nbt;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Set;
+import java.util.logging.Logger;
+
+import net.md_5.bungee.BungeeCord;
+
+@SuppressWarnings({ "rawtypes", "unchecked", "unused" })
+public class NBTTagCompound extends NBTBase {
+
+	private static final Logger logger = BungeeCord.getInstance() == null ? null : BungeeCord.getInstance().getLogger();
+
+	static NBTBase createNBTBase(byte type, String s, DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) throws Exception {
+		NBTBase nbtbase = NBTBase.createTag(type);
+		nbtbase.load(datainput, i, nbtreadlimiter);
+		return nbtbase;
+	}
+
+	private static void writeTag(String s, NBTBase nbtbase, DataOutput dataoutput) throws Exception {
+		try{
+			dataoutput.writeByte(nbtbase.getTypeId());
+		}catch (IOException e){
+			e.printStackTrace();
+		}
+		if(nbtbase.getTypeId() != 0){
+			try{
+				dataoutput.writeUTF(s);
+			}catch (IOException e){
+				e.printStackTrace();
+			}
+			nbtbase.write(dataoutput);
+		}
+	}
+
+	private static String readString(DataInput datainput, NBTReadLimiter nbtreadlimiter) {
+		try{
+			return datainput.readUTF();
+		}catch (IOException e){
+			e.printStackTrace();
+			return null;
+		}
+	}
+
+	private static byte readByte(DataInput datainput, NBTReadLimiter nbtreadlimiter) {
+		try{
+			return datainput.readByte();
+		}catch (IOException e){
+			e.printStackTrace();
+			return 0x00;
+		}
+	}
+
+	private Map<String, NBTBase> map = new HashMap();
+
+	public NBTTagCompound() {
+	}
+
+	public byte getNBTBaseType(String s) {
+		NBTBase nbtbase = (NBTBase) this.map.get(s);
+		return nbtbase != null ? nbtbase.getTypeId() : 0;
+	}
+
+	public Set<String> dataKeyset() {
+		return this.map.keySet();
+	}
+
+	@Override
+	public NBTBase clone() {
+		NBTTagCompound nbttagcompound = new NBTTagCompound();
+		Iterator iterator = this.map.keySet().iterator();
+
+		while (iterator.hasNext()){
+			String s = (String) iterator.next();
+
+			nbttagcompound.set(s, ((NBTBase) this.map.get(s)).clone());
+		}
+
+		return nbttagcompound;
+	}
+
+	@Override
+	public boolean equals(Object object) {
+		if(super.equals(object)){
+			NBTTagCompound nbttagcompound = (NBTTagCompound) object;
+
+			return this.map.entrySet().equals(nbttagcompound.map.entrySet());
+		}else{
+			return false;
+		}
+	}
+
+	public NBTBase get(String s) {
+		return (NBTBase) this.map.get(s);
+	}
+
+	public boolean getBoolean(String s) {
+		return this.getByte(s) != 0;
+	}
+
+	public byte getByte(String s) {
+		try{
+			return !this.map.containsKey(s) ? 0 : ((NBTNumber) this.map.get(s)).asByte();
+		}catch (ClassCastException classcastexception){
+			return (byte) 0;
+		}
+	}
+
+	public byte[] getByteArray(String s) {
+		try{
+			return !this.map.containsKey(s) ? new byte[0] : ((NBTTagByteArray) this.map.get(s)).getData();
+		}catch (ClassCastException classcastexception){
+			throw new RuntimeException();
+		}
+	}
+
+	public NBTTagCompound getCompound(String s) {
+		try{
+			return !this.map.containsKey(s) ? new NBTTagCompound() : (NBTTagCompound) this.map.get(s);
+		}catch (ClassCastException classcastexception){
+			throw new RuntimeException();
+		}
+	}
+
+	public double getDouble(String s) {
+		try{
+			return !this.map.containsKey(s) ? 0.0D : ((NBTNumber) this.map.get(s)).asDouble();
+		}catch (ClassCastException classcastexception){
+			return 0.0D;
+		}
+	}
+
+	public float getFloat(String s) {
+		try{
+			return !this.map.containsKey(s) ? 0.0F : ((NBTNumber) this.map.get(s)).asFloat();
+		}catch (ClassCastException classcastexception){
+			return 0.0F;
+		}
+	}
+
+	public int getInt(String s) {
+		try{
+			return !this.map.containsKey(s) ? 0 : ((NBTNumber) this.map.get(s)).asInt();
+		}catch (ClassCastException classcastexception){
+			return 0;
+		}
+	}
+
+	public int[] getIntArray(String s) {
+		try{
+			return !this.map.containsKey(s) ? new int[0] : ((NBTTagIntArray) this.map.get(s)).getData();
+		}catch (ClassCastException classcastexception){
+			throw new RuntimeException();
+		}
+	}
+
+	public NBTTagList getList(String s) {
+		try{
+			if(this.getNBTBaseType(s) != 9){
+				return new NBTTagList();
+			}else{
+				NBTTagList nbttaglist = (NBTTagList) this.map.get(s);
+
+				return nbttaglist;
+			}
+		}catch (ClassCastException classcastexception){
+			throw new RuntimeException();
+		}
+	}
+
+	public long getLong(String s) {
+		try{
+			return !this.map.containsKey(s) ? 0L : ((NBTNumber) this.map.get(s)).asLong();
+		}catch (ClassCastException classcastexception){
+			return 0L;
+		}
+	}
+
+	public short getShort(String s) {
+		try{
+			return !this.map.containsKey(s) ? 0 : ((NBTNumber) this.map.get(s)).asShort();
+		}catch (ClassCastException classcastexception){
+			return (short) 0;
+		}
+	}
+
+	public String getString(String s) {
+		try{
+			return !this.map.containsKey(s) ? "" : ((NBTTagString) this.map.get(s)).getData();
+		}catch (ClassCastException classcastexception){
+			return "";
+		}
+	}
+
+	@Override
+	public byte getTypeId() {
+		return (byte) 10;
+	}
+
+	@Override
+	public int hashCode() {
+		return super.hashCode() ^ this.map.hashCode();
+	}
+
+	public boolean hasKey(String s) {
+		return this.map.containsKey(s);
+	}
+
+	public boolean hasKeyOfType(String s, int i) {
+		byte b0 = this.getNBTBaseType(s);
+
+		return b0 == i ? true : i != 99 ? false : b0 == 1 || b0 == 2 || b0 == 3 || b0 == 4 || b0 == 5 || b0 == 6;
+	}
+
+	public boolean isEmpty() {
+		return this.map.isEmpty();
+	}
+
+	@Override
+	void load(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) throws Exception {
+		if(i > 512){
+			throw new RuntimeException("Tried to read NBT tag with too high complexity, depth > 512");
+		}else{
+			this.map.clear();
+
+			byte b0;
+
+			while ((b0 = readByte(datainput, nbtreadlimiter)) != 0){
+				String s = readString(datainput, nbtreadlimiter);
+
+				nbtreadlimiter.readBytes(16 * s.length());
+				NBTBase nbtbase = createNBTBase(b0, s, datainput, i + 1, nbtreadlimiter);
+
+				this.map.put(s, nbtbase);
+			}
+		}
+	}
+
+	public void remove(String s) {
+		this.map.remove(s);
+	}
+
+	public void set(String s, NBTBase nbtbase) {
+		this.map.put(s, nbtbase);
+	}
+
+	public void setBoolean(String s, boolean flag) {
+		this.setByte(s, (byte) (flag ? 1 : 0));
+	}
+
+	public void setByte(String s, byte b0) {
+		this.map.put(s, new NBTTagByte(b0));
+	}
+
+	public void setByteArray(String s, byte[] abyte) {
+		this.map.put(s, new NBTTagByteArray(abyte));
+	}
+
+	public void setDouble(String s, double d0) {
+		this.map.put(s, new NBTTagDouble(d0));
+	}
+
+	public void setFloat(String s, float f) {
+		this.map.put(s, new NBTTagFloat(f));
+	}
+
+	public void setInt(String s, int i) {
+		this.map.put(s, new NBTTagInt(i));
+	}
+
+	public void setIntArray(String s, int[] aint) {
+		this.map.put(s, new NBTTagIntArray(aint));
+	}
+
+	public void setLong(String s, long i) {
+		this.map.put(s, new NBTTagLong(i));
+	}
+
+	public void setShort(String s, short short1) {
+		this.map.put(s, new NBTTagShort(short1));
+	}
+
+	public void setString(String s, String s1) {
+		this.map.put(s, new NBTTagString(s1));
+	}
+
+	@Override
+	public String toString() {
+		String s = "{";
+
+		String s1;
+
+		for(Iterator iterator = this.map.keySet().iterator();iterator.hasNext();s = s + s1 + ':' + this.map.get(s1) + ','){
+			s1 = (String) iterator.next();
+		}
+
+		return s + "}";
+	}
+
+	@Override
+	String toFormatedString(String in) {
+		String out = "{\n";
+
+		String s1;
+
+		for(String s : (Set<String>) this.map.keySet()){
+			out += in + s + ": " + this.map.get(s).toFormatedString((map.get(s) instanceof NBTNumber || map.get(s) instanceof NBTTagString) ? "":"  " + in)+",\n";
+		}
+		return replaceLast(out,",\n","") + "\n" + in + "}";
+	}
+	private String replaceLast(String string, String from, String to) {
+	     int lastIndex = string.lastIndexOf(from);
+	     if (lastIndex < 0) return string;
+	     String tail = string.substring(lastIndex).replaceFirst(from, to);
+	     return string.substring(0, lastIndex) + tail;
+	}
+
+	@Override
+	void write(DataOutput dataoutput) throws Exception {
+		Iterator iterator = this.map.keySet().iterator();
+
+		while (iterator.hasNext()){
+			String s = (String) iterator.next();
+			NBTBase nbtbase = (NBTBase) this.map.get(s);
+
+			writeTag(s, nbtbase, dataoutput);
+		}
+
+		try{
+			dataoutput.writeByte(0);
+		}catch (IOException e){
+			e.printStackTrace();
+		}
+	}
+	//15:58
+}
diff --git a/src/main/java/dev/wolveringer/nbt/NBTTagDouble.java b/src/main/java/dev/wolveringer/nbt/NBTTagDouble.java
new file mode 100644
index 0000000..72c5215
--- /dev/null
+++ b/src/main/java/dev/wolveringer/nbt/NBTTagDouble.java
@@ -0,0 +1,104 @@
+package dev.wolveringer.nbt;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class NBTTagDouble extends NBTNumber {
+
+	private double data;
+
+	NBTTagDouble() {
+	}
+
+	public NBTTagDouble(double d0) {
+		this.data = d0;
+	}
+
+	@Override
+	public long asLong() {
+		return (long) Math.floor(this.data);
+	}
+
+	@Override
+	public NBTBase clone() {
+		return new NBTTagDouble(this.data);
+	}
+
+	@Override
+	public int asInt() {
+		return MathHelper.floor(this.data);
+	}
+
+	@Override
+	public short asShort() {
+		return (short) (MathHelper.floor(this.data) & '\uffff');
+	}
+
+	@Override
+	public boolean equals(Object object) {
+		if(super.equals(object)){
+			NBTTagDouble nbttagdouble = (NBTTagDouble) object;
+
+			return this.data == nbttagdouble.data;
+		}else{
+			return false;
+		}
+	}
+
+	@Override
+	public byte asByte() {
+		return (byte) (MathHelper.floor(this.data) & 255);
+	}
+
+	@Override
+	public double asDouble() {
+		return this.data;
+	}
+
+	@Override
+	public byte getTypeId() {
+		return (byte) 6;
+	}
+
+	@Override
+	public float asFloat() {
+		return (float) this.data;
+	}
+
+	@Override
+	public int hashCode() {
+		long i = Double.doubleToLongBits(this.data);
+
+		return super.hashCode() ^ (int) (i ^ i >>> 32);
+	}
+
+	@Override
+	void load(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) {
+		nbtreadlimiter.readBytes(64L);
+		try{
+			this.data = datainput.readDouble();
+		}catch (IOException e){
+			e.printStackTrace();
+		}
+	}
+
+	@Override
+	public String toString() {
+		return "" + this.data + "d";
+	}
+	
+	@Override
+	String toFormatedString(String in) {
+		return in+toString();
+	}
+
+	@Override
+	void write(DataOutput dataoutput) {
+		try{
+			dataoutput.writeDouble(this.data);
+		}catch (IOException e){
+			e.printStackTrace();
+		}
+	}
+}
diff --git a/src/main/java/dev/wolveringer/nbt/NBTTagEnd.java b/src/main/java/dev/wolveringer/nbt/NBTTagEnd.java
new file mode 100644
index 0000000..5ebed21
--- /dev/null
+++ b/src/main/java/dev/wolveringer/nbt/NBTTagEnd.java
@@ -0,0 +1,38 @@
+package dev.wolveringer.nbt;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+
+public class NBTTagEnd extends NBTBase {
+
+	NBTTagEnd() {
+	}
+
+	@Override
+	public NBTBase clone() {
+		return new NBTTagEnd();
+	}
+
+	@Override
+	public byte getTypeId() {
+		return (byte) 0;
+	}
+
+	@Override
+	void load(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) {
+	}
+
+	@Override
+	public String toString() {
+		return "END";
+	}
+
+	@Override
+	String toFormatedString(String in) {
+		return in+toString();
+	}
+	
+	@Override
+	void write(DataOutput dataoutput) {
+	}
+}
diff --git a/src/main/java/dev/wolveringer/nbt/NBTTagFloat.java b/src/main/java/dev/wolveringer/nbt/NBTTagFloat.java
new file mode 100644
index 0000000..b68c085
--- /dev/null
+++ b/src/main/java/dev/wolveringer/nbt/NBTTagFloat.java
@@ -0,0 +1,102 @@
+package dev.wolveringer.nbt;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class NBTTagFloat extends NBTNumber {
+
+	private float data;
+
+	NBTTagFloat() {
+	}
+
+	public NBTTagFloat(float f) {
+		this.data = f;
+	}
+
+	@Override
+	public long asLong() {
+		return (long) this.data;
+	}
+
+	@Override
+	public NBTBase clone() {
+		return new NBTTagFloat(this.data);
+	}
+
+	@Override
+	public int asInt() {
+		return MathHelper.d(this.data);
+	}
+
+	@Override
+	public short asShort() {
+		return (short) (MathHelper.d(this.data) & '\uffff');
+	}
+
+	@Override
+	public boolean equals(Object object) {
+		if(super.equals(object)){
+			NBTTagFloat nbttagfloat = (NBTTagFloat) object;
+
+			return this.data == nbttagfloat.data;
+		}else{
+			return false;
+		}
+	}
+
+	@Override
+	public byte asByte() {
+		return (byte) (MathHelper.d(this.data) & 255);
+	}
+
+	@Override
+	public double asDouble() {
+		return this.data;
+	}
+
+	@Override
+	public byte getTypeId() {
+		return (byte) 5;
+	}
+
+	@Override
+	public float asFloat() {
+		return this.data;
+	}
+
+	@Override
+	public int hashCode() {
+		return super.hashCode() ^ Float.floatToIntBits(this.data);
+	}
+
+	@Override
+	void load(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) {
+		nbtreadlimiter.readBytes(32L);
+		try{
+			this.data = datainput.readFloat();
+		}catch (IOException e){
+			e.printStackTrace();
+		}
+	}
+
+	@Override
+	public String toString() {
+		return "" + this.data + "f";
+	}
+
+	@Override
+	String toFormatedString(String in) {
+		return in+toString();
+	}
+	
+	@Override
+	void write(DataOutput dataoutput) {
+		try{
+			dataoutput.writeFloat(this.data);
+		}catch (IOException e){
+			e.printStackTrace();
+		}
+	}
+}
diff --git a/src/main/java/dev/wolveringer/nbt/NBTTagInt.java b/src/main/java/dev/wolveringer/nbt/NBTTagInt.java
new file mode 100644
index 0000000..55a243b
--- /dev/null
+++ b/src/main/java/dev/wolveringer/nbt/NBTTagInt.java
@@ -0,0 +1,102 @@
+package dev.wolveringer.nbt;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class NBTTagInt extends NBTNumber {
+
+	private int data;
+
+	NBTTagInt() {
+	}
+
+	public NBTTagInt(int i) {
+		this.data = i;
+	}
+
+	@Override
+	public long asLong() {
+		return this.data;
+	}
+
+	@Override
+	public NBTBase clone() {
+		return new NBTTagInt(this.data);
+	}
+
+	@Override
+	public int asInt() {
+		return this.data;
+	}
+
+	@Override
+	public short asShort() {
+		return (short) (this.data & '\uffff');
+	}
+
+	@Override
+	public boolean equals(Object object) {
+		if(super.equals(object)){
+			NBTTagInt nbttagint = (NBTTagInt) object;
+
+			return this.data == nbttagint.data;
+		}else{
+			return false;
+		}
+	}
+
+	@Override
+	public byte asByte() {
+		return (byte) (this.data & 255);
+	}
+
+	@Override
+	public double asDouble() {
+		return this.data;
+	}
+
+	@Override
+	public byte getTypeId() {
+		return (byte) 3;
+	}
+
+	@Override
+	public float asFloat() {
+		return this.data;
+	}
+
+	@Override
+	public int hashCode() {
+		return super.hashCode() ^ this.data;
+	}
+
+	@Override
+	void load(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) {
+		nbtreadlimiter.readBytes(32L);
+		try{
+			this.data = datainput.readInt();
+		}catch (IOException e){
+			e.printStackTrace();
+		}
+	}
+
+	@Override
+	public String toString() {
+		return "" + this.data;
+	}
+
+	@Override
+	String toFormatedString(String in) {
+		return in+toString();
+	}
+	
+	@Override
+	void write(DataOutput dataoutput) {
+		try{
+			dataoutput.writeInt(this.data);
+		}catch (IOException e){
+			e.printStackTrace();
+		}
+	}
+}
diff --git a/src/main/java/dev/wolveringer/nbt/NBTTagIntArray.java b/src/main/java/dev/wolveringer/nbt/NBTTagIntArray.java
new file mode 100644
index 0000000..06cd901
--- /dev/null
+++ b/src/main/java/dev/wolveringer/nbt/NBTTagIntArray.java
@@ -0,0 +1,112 @@
+package dev.wolveringer.nbt;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+import java.util.Arrays;
+
+public class NBTTagIntArray extends NBTBase {
+
+	private int[] data;
+
+	NBTTagIntArray() {
+	}
+
+	public NBTTagIntArray(int[] aint) {
+		this.data = aint;
+	}
+
+	public int[] getData() {
+		return this.data;
+	}
+
+	@Override
+	public NBTBase clone() {
+		int[] aint = new int[this.data.length];
+
+		System.arraycopy(this.data, 0, aint, 0, this.data.length);
+		return new NBTTagIntArray(aint);
+	}
+
+	@Override
+	public boolean equals(Object object) {
+		return super.equals(object) ? Arrays.equals(this.data, ((NBTTagIntArray) object).data) : false;
+	}
+
+	@Override
+	public byte getTypeId() {
+		return (byte) 11;
+	}
+
+	@Override
+	public int hashCode() {
+		return super.hashCode() ^ Arrays.hashCode(this.data);
+	}
+
+	@Override
+	void load(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) {
+		int byte_length = 0;
+		try{
+			byte_length = datainput.readInt();
+		}catch (IOException e){
+			e.printStackTrace();
+		}
+
+		nbtreadlimiter.readBytes(32 * byte_length);
+		this.data = new int[byte_length];
+
+		for(int k = 0;k < byte_length;++k){
+			try{
+				this.data[k] = datainput.readInt();
+			}catch (IOException e){
+				e.printStackTrace();
+			}
+		}
+	}
+
+	@Override
+	public String toString() {
+		String s = "[";
+		int[] aint = this.data;
+		int i = aint.length;
+
+		for(int j = 0;j < i;++j){
+			int k = aint[j];
+
+			s = s + k + ",";
+		}
+
+		return s + "]";
+	}
+
+	@Override
+	String toFormatedString(String in) {
+		String s = in + "[";
+		int[] aint = this.data;
+		int i = aint.length;
+
+		for(int j = 0;j < i;++j){
+			int k = aint[j];
+			s = s + ",\n" + in + k;
+		}
+
+		return s.replaceFirst(",", "") + "\n" + in + "]";
+	}
+
+	@Override
+	void write(DataOutput dataoutput) {
+		try{
+			dataoutput.writeInt(this.data.length);
+		}catch (IOException e){
+			e.printStackTrace();
+		}
+
+		for(int i = 0;i < this.data.length;++i){
+			try{
+				dataoutput.writeInt(this.data[i]);
+			}catch (IOException e){
+				e.printStackTrace();
+			}
+		}
+	}
+}
diff --git a/src/main/java/dev/wolveringer/nbt/NBTTagList.java b/src/main/java/dev/wolveringer/nbt/NBTTagList.java
new file mode 100644
index 0000000..f6d388e
--- /dev/null
+++ b/src/main/java/dev/wolveringer/nbt/NBTTagList.java
@@ -0,0 +1,177 @@
+package dev.wolveringer.nbt;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.util.ArrayList;
+import java.util.List;
+
+public class NBTTagList extends NBTBase {
+	private List<NBTBase> list = new ArrayList<NBTBase>();
+	private byte type = 0;
+
+	void write(DataOutput paramDataOutput) throws Exception {
+		if(!this.list.isEmpty()){
+			this.type = ((NBTBase) this.list.get(0)).getTypeId();
+		}else{
+			this.type = 0;
+		}
+		paramDataOutput.writeByte(this.type);
+		paramDataOutput.writeInt(this.list.size());
+		for(int i = 0;i < this.list.size();i++){
+			((NBTBase) this.list.get(i)).write(paramDataOutput);
+		}
+	}
+
+	void load(DataInput paramDataInput, int paramInt, NBTReadLimiter paramNBTReadLimiter) throws Exception {
+		if(paramInt > 512){
+			throw new RuntimeException("Tried to read NBT tag with too high complexity, depth > 512");
+		}
+		paramNBTReadLimiter.readBytes(8L);
+		this.type = paramDataInput.readByte();
+		int i = paramDataInput.readInt();
+
+		this.list = new ArrayList<NBTBase>();
+		for(int j = 0;j < i;j++){
+			NBTBase localNBTBase = NBTBase.createTag(this.type);
+			localNBTBase.load(paramDataInput, paramInt + 1, paramNBTReadLimiter);
+			this.list.add(localNBTBase);
+		}
+	}
+
+	public byte getTypeId() {
+		return 9;
+	}
+
+	public String toString() {
+		String str = "[";
+		int i = 0;
+		for(NBTBase localNBTBase : this.list){
+			str = str + "" + i + ':' + localNBTBase + ',';
+			i++;
+		}
+		return str + "]";
+	}
+
+	@Override
+	String toFormatedString(String in) {
+		if(this.list.isEmpty())
+			return "[]";
+		String str = "[\n";
+		int i = 0;
+		for(NBTBase localNBTBase : this.list){
+			str = str + "\n" + in + format(i) + ": " + localNBTBase.toFormatedString("");
+			i++;
+		}
+		return str.replaceFirst("\n", "") + "\n" + in.substring(1) + "]";
+	}
+
+	public String format(int i) {
+		String out = i + "";
+		String x = (list.size()-1) + "";
+		while (x.length() > out.length()){
+			out = "0" + out;
+		}
+		return out;
+	}
+
+	public void add(NBTBase paramNBTBase) {
+		if(this.type == 0){
+			this.type = paramNBTBase.getTypeId();
+		}else if(this.type != paramNBTBase.getTypeId()){
+			System.err.println("WARNING: Adding mismatching tag types to tag list");
+			return;
+		}
+		this.list.add(paramNBTBase);
+	}
+
+	public NBTTagCompound get(int paramInt) {
+		if((paramInt < 0) || (paramInt >= this.list.size())){
+			return new NBTTagCompound();
+		}
+		NBTBase localNBTBase = (NBTBase) this.list.get(paramInt);
+		if(localNBTBase.getTypeId() == 10){
+			return (NBTTagCompound) localNBTBase;
+		}
+		return new NBTTagCompound();
+	}
+
+	public int[] getIntArray(int paramInt) {
+		if((paramInt < 0) || (paramInt >= this.list.size())){
+			return new int[0];
+		}
+		NBTBase localNBTBase = (NBTBase) this.list.get(paramInt);
+		if(localNBTBase.getTypeId() == 11){
+			return ((NBTTagIntArray) localNBTBase).getData();
+		}
+		return new int[0];
+	}
+
+	public double getDouble(int paramInt) {
+		if((paramInt < 0) || (paramInt >= this.list.size())){
+			return 0.0D;
+		}
+		NBTBase localNBTBase = (NBTBase) this.list.get(paramInt);
+		if(localNBTBase.getTypeId() == 6){
+			return ((NBTTagDouble) localNBTBase).asDouble();
+		}
+		return 0.0D;
+	}
+
+	public float getFloat(int paramInt) {
+		if((paramInt < 0) || (paramInt >= this.list.size())){
+			return 0.0F;
+		}
+		NBTBase localNBTBase = (NBTBase) this.list.get(paramInt);
+		if(localNBTBase.getTypeId() == 5){
+			return ((NBTTagFloat) localNBTBase).asFloat();
+		}
+		return 0.0F;
+	}
+
+	public String getString(int paramInt) {
+		if((paramInt < 0) || (paramInt >= this.list.size())){
+			return "";
+		}
+		NBTBase localNBTBase = (NBTBase) this.list.get(paramInt);
+		if(localNBTBase.getTypeId() == 8){
+			return localNBTBase.toString();
+		}
+		return localNBTBase.toString();
+	}
+
+	public int size() {
+		return this.list.size();
+	}
+
+	public List<NBTBase> asList() {
+		return list;
+	}
+
+	public NBTBase clone() {
+		NBTTagList localNBTTagList = new NBTTagList();
+		localNBTTagList.type = this.type;
+		for(NBTBase localNBTBase1 : this.list){
+			NBTBase localNBTBase2 = localNBTBase1.clone();
+			localNBTTagList.list.add(localNBTBase2);
+		}
+		return localNBTTagList;
+	}
+
+	public boolean equals(Object paramObject) {
+		if(super.equals(paramObject)){
+			NBTTagList localNBTTagList = (NBTTagList) paramObject;
+			if(this.type == localNBTTagList.type){
+				return this.list.equals(localNBTTagList.list);
+			}
+		}
+		return false;
+	}
+
+	public int hashCode() {
+		return super.hashCode() ^ this.list.hashCode();
+	}
+
+	public int getType() {
+		return this.type;
+	}
+}
diff --git a/src/main/java/dev/wolveringer/nbt/NBTTagLong.java b/src/main/java/dev/wolveringer/nbt/NBTTagLong.java
new file mode 100644
index 0000000..d602ea8
--- /dev/null
+++ b/src/main/java/dev/wolveringer/nbt/NBTTagLong.java
@@ -0,0 +1,101 @@
+package dev.wolveringer.nbt;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class NBTTagLong extends NBTNumber {
+
+	private long data;
+
+	NBTTagLong() {
+	}
+
+	public NBTTagLong(long i) {
+		this.data = i;
+	}
+
+	@Override
+	public long asLong() {
+		return this.data;
+	}
+
+	@Override
+	public NBTBase clone() {
+		return new NBTTagLong(this.data);
+	}
+
+	@Override
+	public int asInt() {
+		return (int) (this.data & -1L);
+	}
+
+	@Override
+	public short asShort() {
+		return (short) (int) (this.data & 65535L);
+	}
+
+	@Override
+	public boolean equals(Object object) {
+		if(super.equals(object)){
+			NBTTagLong nbttaglong = (NBTTagLong) object;
+
+			return this.data == nbttaglong.data;
+		}else{
+			return false;
+		}
+	}
+
+	@Override
+	public byte asByte() {
+		return (byte) (int) (this.data & 255L);
+	}
+
+	@Override
+	public double asDouble() {
+		return this.data;
+	}
+
+	@Override
+	public byte getTypeId() {
+		return (byte) 4;
+	}
+
+	@Override
+	public float asFloat() {
+		return this.data;
+	}
+
+	@Override
+	public int hashCode() {
+		return super.hashCode() ^ (int) (this.data ^ this.data >>> 32);
+	}
+
+	@Override
+	void load(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) {
+		nbtreadlimiter.readBytes(64L);
+		try{
+			this.data = datainput.readLong();
+		}catch (IOException e){
+			e.printStackTrace();
+		}
+	}
+
+	@Override
+	public String toString() {
+		return "" + this.data + "L";
+	}
+	@Override
+	String toFormatedString(String in) {
+		return in+toString();
+	}
+
+	@Override
+	void write(DataOutput dataoutput) {
+		try{
+			dataoutput.writeLong(this.data);
+		}catch (IOException e){
+			e.printStackTrace();
+		}
+	}
+}
diff --git a/src/main/java/dev/wolveringer/nbt/NBTTagShort.java b/src/main/java/dev/wolveringer/nbt/NBTTagShort.java
new file mode 100644
index 0000000..6513d64
--- /dev/null
+++ b/src/main/java/dev/wolveringer/nbt/NBTTagShort.java
@@ -0,0 +1,102 @@
+package dev.wolveringer.nbt;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public class NBTTagShort extends NBTNumber {
+
+	private short data;
+
+	public NBTTagShort() {
+	}
+
+	public NBTTagShort(short short1) {
+		this.data = short1;
+	}
+
+	@Override
+	public long asLong() {
+		return this.data;
+	}
+
+	@Override
+	public NBTBase clone() {
+		return new NBTTagShort(this.data);
+	}
+
+	@Override
+	public int asInt() {
+		return this.data;
+	}
+
+	@Override
+	public short asShort() {
+		return this.data;
+	}
+
+	@Override
+	public boolean equals(Object object) {
+		if(super.equals(object)){
+			NBTTagShort nbttagshort = (NBTTagShort) object;
+
+			return this.data == nbttagshort.data;
+		}else{
+			return false;
+		}
+	}
+
+	@Override
+	public byte asByte() {
+		return (byte) (this.data & 255);
+	}
+
+	@Override
+	public double asDouble() {
+		return this.data;
+	}
+
+	@Override
+	public byte getTypeId() {
+		return (byte) 2;
+	}
+
+	@Override
+	public float asFloat() {
+		return this.data;
+	}
+
+	@Override
+	public int hashCode() {
+		return super.hashCode() ^ this.data;
+	}
+
+	@Override
+	void load(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) {
+		nbtreadlimiter.readBytes(16L);
+		try{
+			this.data = datainput.readShort();
+		}catch (IOException e){
+			e.printStackTrace();
+		}
+	}
+
+	@Override
+	public String toString() {
+		return "" + this.data + "s";
+	}
+
+	@Override
+	String toFormatedString(String in) {
+		return in+toString();
+	}
+	
+	@Override
+	void write(DataOutput dataoutput) {
+		try{
+			dataoutput.writeShort(this.data);
+		}catch (IOException e){
+			e.printStackTrace();
+		}
+	}
+}
diff --git a/src/main/java/dev/wolveringer/nbt/NBTTagString.java b/src/main/java/dev/wolveringer/nbt/NBTTagString.java
new file mode 100644
index 0000000..5af560f
--- /dev/null
+++ b/src/main/java/dev/wolveringer/nbt/NBTTagString.java
@@ -0,0 +1,91 @@
+package dev.wolveringer.nbt;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+import java.nio.charset.Charset;
+import java.util.Arrays;
+
+import com.google.common.base.Charsets;
+
+public class NBTTagString extends NBTBase {
+	private byte[] final_data;
+
+	public NBTTagString() {
+		final_data = "".getBytes();
+	}
+
+	public NBTTagString(String string) {
+		if(string == null || string.length() == 0)
+			throw new IllegalArgumentException("Empty string not allowed"); //Todo remove?
+		final_data = string.getBytes(Charsets.UTF_8);
+	}
+
+	void write(DataOutput paramDataOutput) {
+		try{
+			paramDataOutput.writeShort(final_data.length);
+			paramDataOutput.write(final_data, 0, final_data.length);
+		}catch (IOException e){
+			e.printStackTrace();
+		}
+	}
+
+	void load(DataInput paramDataInput, int paramInt, NBTReadLimiter paramNBTReadLimiter) {
+		try{
+			this.final_data = new byte[paramDataInput.readUnsignedShort()];
+			paramDataInput.readFully(this.final_data);
+		}catch (IOException e){
+			e.printStackTrace();
+		}
+		paramNBTReadLimiter.readBytes(final_data.length+2);
+	}
+
+	public byte getTypeId() {
+		return 8;
+	}
+
+	public String toString() {
+		return "\"" + charsetEncoding(this.final_data) + "\"";
+	}
+
+	private String charsetEncoding(byte[] in) {
+		return new String(in, Charsets.UTF_8);
+	}
+
+	@Override
+	String toFormatedString(String in) {
+		return in + toString();
+	}
+
+	public NBTBase clone() {
+		NBTTagString string =new NBTTagString();
+		string.final_data = final_data;
+		return string;
+	}
+	
+	@Override
+	public int hashCode() {
+		final int prime = 31;
+		int result = super.hashCode();
+		result = prime * result + Arrays.hashCode(this.final_data);
+		return result;
+	}
+
+	@Override
+	public boolean equals(Object obj) {
+		if(this == obj)
+			return true;
+		if(!super.equals(obj))
+			return false;
+		if(getClass() != obj.getClass())
+			return false;
+		NBTTagString other = (NBTTagString) obj;
+		if(!Arrays.equals(this.final_data, other.final_data))
+			return false;
+		return true;
+	}
+
+	public String getData() {
+		return this.charsetEncoding(final_data);
+	}
+}
diff --git a/src/main/java/dev/wolveringer/network/Cleaner.java b/src/main/java/dev/wolveringer/network/Cleaner.java
new file mode 100644
index 0000000..6283881
--- /dev/null
+++ b/src/main/java/dev/wolveringer/network/Cleaner.java
@@ -0,0 +1,16 @@
+package dev.wolveringer.network;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.util.ReferenceCountUtil;
+
+public class Cleaner {
+	public static long cleaned_bytes = 0;
+
+	public static void destroyDirectByteBuffer(ByteBuf buf) {
+		try{
+			ReferenceCountUtil.release(buf);
+		}catch(Exception e){
+			System.out.print("Error: 101");
+		}
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/network/Decoder.java b/src/main/java/dev/wolveringer/network/Decoder.java
new file mode 100644
index 0000000..3cbe584
--- /dev/null
+++ b/src/main/java/dev/wolveringer/network/Decoder.java
@@ -0,0 +1,223 @@
+package dev.wolveringer.network;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelHandlerContext;
+import lombok.Getter;
+import lombok.Setter;
+
+import java.lang.reflect.Field;
+import java.util.List;
+
+import net.md_5.bungee.protocol.BadPacketException;
+import net.md_5.bungee.protocol.DefinedPacket;
+import net.md_5.bungee.protocol.MinecraftDecoder;
+import net.md_5.bungee.protocol.PacketWrapper;
+import net.md_5.bungee.protocol.Protocol;
+import net.md_5.bungee.protocol.ProtocolConstants.Direction;
+import dev.wolveringer.BungeeUtil.ClientVersion;
+import dev.wolveringer.BungeeUtil.PacketHandleEvent;
+import dev.wolveringer.BungeeUtil.PacketLib;
+import dev.wolveringer.BungeeUtil.configuration.Configuration;
+import dev.wolveringer.BungeeUtil.packets.Packet;
+import dev.wolveringer.network.channel.init.BungeeUtilChannelInit;
+import dev.wolveringer.network.channel.init.ChannelInizializer;
+import dev.wolveringer.packet.ByteBuffCreator;
+import dev.wolveringer.packet.PacketHandle;
+import dev.wolveringer.profiler.Profiler;
+import dev.wolveringer.strings.Messages;
+
+public class Decoder extends MinecraftDecoder {
+	private static final Field field_protocol = getField(MinecraftDecoder.class, "protocol");
+	private static final Field field_protocolVersion = getField(MinecraftDecoder.class, "protocolVersion");
+	private static final Field field_server = getField(MinecraftDecoder.class, "server");
+
+	private static Field getField(Class<?> s, String field) {
+		try{
+			for(Field f : s.getDeclaredFields())
+				if(f.getName().equals(field)){
+					f.setAccessible(true);
+					return f;
+				}
+			for(Field f : s.getFields())
+				if(f.getName().equals(field)){
+					f.setAccessible(true);
+					return f;
+				}
+		}catch (Exception e){
+			e.printStackTrace();
+		}
+		return null;
+	}
+
+	@Getter
+	@Setter
+	private IInitialHandler initHandler;
+	private Protocol prot;
+	private int version;
+	private ClientVersion clientVersion = ClientVersion.UnderknownVersion;
+	private Direction dir;
+
+	public Decoder(Protocol protocol, boolean server, int protocolVersion, IInitialHandler i, Direction dir) {
+		super(protocol, server, protocolVersion);
+		this.dir = dir;
+		this.initHandler = i;
+		this.setProtocolVersion(protocolVersion);
+	}
+
+	public IInitialHandler getHandler() {
+		return initHandler;
+	}
+
+	public Protocol getProtocol() {
+		try{
+			return (Protocol) field_protocol.get(this);
+		}catch (Exception e){
+			e.printStackTrace();
+		}
+		return null;
+	}
+
+	public int getProtocolVersion() {
+		try{
+			return (int) field_protocolVersion.get(this);
+		}catch (Exception e){
+			e.printStackTrace();
+		}
+		return 0;
+	}
+
+	public boolean isServer() {
+		try{
+			return (boolean) field_server.get(this);
+		}catch (Exception e){
+			e.printStackTrace();
+		}
+		return false;
+	}
+
+	@Override
+	public void setProtocol(Protocol protocol) {
+		super.setProtocol(protocol);
+		this.prot = protocol;
+	}
+
+	@Override
+	public void setProtocolVersion(int protocolVersion) {
+		super.setProtocolVersion(protocolVersion);
+		this.version = protocolVersion;
+		this.clientVersion = ClientVersion.fromProtocoll(protocolVersion);
+	}
+
+	@SuppressWarnings({ "unchecked", "rawtypes" })
+	@Override
+	protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {
+		if(initHandler == null){
+			super.decode(ctx, in, out);
+			System.out.println("Skipping decode()");
+			return;
+		}
+		Profiler.decoder_timings.start(Messages.getString("network.timings.decoder.read")); //$NON-NLS-1$
+		try{
+			Packet packet = null;
+			try{
+				Profiler.decoder_timings.start(Messages.getString("network.timings.decoder.create.packet")); //$NON-NLS-1$
+				if(initHandler == null){
+					System.out.println("Connection == null");
+					return;
+				}
+				if(clientVersion == null){
+					System.out.println("Client version = null | Version id -> "+version);
+					initHandler.disconnect("\u00A7cYour client versions isnt supported!");
+					return;
+				}
+				packet = Packet.getPacket(clientVersion.getProtocollVersion() ,getProtocol(), dir, in, initHandler.getPlayer());
+				Profiler.decoder_timings.stop(Messages.getString("network.timings.decoder.create.packet")); //$NON-NLS-1$
+				if(packet == null){
+					Profiler.decoder_timings.stop(Messages.getString("network.timings.decoder.read")); //$NON-NLS-1$
+				}else{
+					Profiler.decoder_timings.start(Messages.getString("network.timings.decoder.handle"));
+					Profiler.decoder_timings.start(Messages.getString("network.timings.decoder.handle.intern")); //$NON-NLS-1$
+					PacketHandleEvent<? extends Packet> e = new PacketHandleEvent(packet, initHandler.getPlayer());
+					if(!PacketHandle.handlePacket(e)){
+						Profiler.decoder_timings.stop(Messages.getString("network.timings.decoder.handle.intern")); //$NON-NLS-1$
+						Profiler.decoder_timings.start(Messages.getString("network.timings.decoder.handle.extern")); //$NON-NLS-1$
+						PacketLib.handle(e);
+						Profiler.decoder_timings.stop(Messages.getString("network.timings.decoder.handle.extern")); //$NON-NLS-1$
+						if(!e.isCancelled()){
+							packet = e.getPacket();
+						}else{
+							Profiler.decoder_timings.stop(Messages.getString("network.timings.decoder.handle.intern")); //$NON-NLS-1$
+							Profiler.decoder_timings.stop(Messages.getString("network.timings.decoder.read")); //$NON-NLS-1$
+							return;
+						}
+					}else{
+						Profiler.decoder_timings.stop(Messages.getString("network.timings.decoder.handle.intern")); //$NON-NLS-1$
+						Profiler.decoder_timings.stop(Messages.getString("network.timings.decoder.read")); //$NON-NLS-1$
+						return;
+					}
+				}
+			}catch (Exception e){
+				if(e instanceof ClassNotFoundException){
+					e.printStackTrace();
+					System.err.println("Could not find class '"+e.getMessage()+"' in decode methode.");
+					if(e.getMessage().startsWith("dev.wolveringer.BungeeUtil") || e.getMessage().startsWith("dev.wolveringer.packet") || e.getMessage().startsWith("dev.wolveringer.network")){
+						System.err.println("");
+						System.err.println("");
+						System.err.println("-----------------------------------------------------------------------------------------------");
+						System.err.println("                      Missing inital class! Shuting down BungeeUtils!");
+						if(ChannelInizializer.getChannelInitializer() instanceof BungeeUtilChannelInit){
+							BungeeUtilChannelInit channelInit = (BungeeUtilChannelInit) ChannelInizializer.getChannelInitializer();
+							channelInit.throwClassNotFoundError((ClassNotFoundException) e);
+						}
+						System.err.println("-----------------------------------------------------------------------------------------------");
+					}
+				}
+				if(!initHandler.isConnected)
+					return;
+				switch (Configuration.getHandleExceptionAction()) {
+				case DISCONNECT:
+					initHandler.disconnect(e);
+				case PRINT:
+					e.printStackTrace();
+				default:
+					break;
+				}
+				return;
+			}
+	
+			Protocol.DirectionData prot = isServer() ? this.getProtocol().TO_SERVER : this.getProtocol().TO_CLIENT;
+			ByteBuf copy = packet == null ? in.copy() : packet.writeToByteBuff(ByteBuffCreator.createByteBuff(),ClientVersion.fromProtocoll(initHandler.getVersion()));
+			try{
+				int packetId = DefinedPacket.readVarInt(in);
+				DefinedPacket bungeePacket = null;
+				if((bungeePacket = prot.createPacket(packetId, getProtocolVersion())) != null){
+					bungeePacket.read(in, prot.getDirection(), getProtocolVersion());
+					if(in.readableBytes() != 0){
+						Profiler.decoder_timings.stop(Messages.getString("network.timings.decoder.read")); //$NON-NLS-1$
+						throw new BadPacketException("Did not read all bytes from packet " + bungeePacket.getClass() + " " + packetId + " Protocol " + this.getProtocolVersion() + " Direction " + prot+"! Left bytes: "+in.readableBytes());
+					}
+					//Main.sendMessage("Decode: " + bungeePacket);
+				}else{
+					in.skipBytes(in.readableBytes());
+				}
+	
+				out.add(new PacketWrapper(bungeePacket, copy));
+				copy = null;
+			}finally{
+				if(copy != null){
+					copy.release();
+				}
+				copy = null;
+			}
+			packet = null;
+		}catch(Exception e){
+			if(initHandler.isConnected)
+				e.printStackTrace();
+		}
+		Profiler.decoder_timings.stop(Messages.getString("network.timings.decoder.read")); //$NON-NLS-1$
+	}
+	
+	public static void main(String[] args) throws ClassNotFoundException {
+		Class.forName("xxx");
+	}
+}
diff --git a/src/main/java/dev/wolveringer/network/Encoder.java b/src/main/java/dev/wolveringer/network/Encoder.java
new file mode 100644
index 0000000..f0c18f7
--- /dev/null
+++ b/src/main/java/dev/wolveringer/network/Encoder.java
@@ -0,0 +1,94 @@
+package dev.wolveringer.network;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import io.netty.channel.ChannelHandlerContext;
+import lombok.Getter;
+import lombok.Setter;
+import net.md_5.bungee.protocol.DefinedPacket;
+import net.md_5.bungee.protocol.MinecraftEncoder;
+import net.md_5.bungee.protocol.Protocol;
+import net.md_5.bungee.protocol.ProtocolConstants.Direction;
+import net.md_5.bungee.protocol.packet.LoginSuccess;
+import dev.wolveringer.BungeeUtil.ClientVersion;
+import dev.wolveringer.BungeeUtil.PacketHandleEvent;
+import dev.wolveringer.BungeeUtil.PacketLib;
+import dev.wolveringer.BungeeUtil.packets.Packet;
+import dev.wolveringer.packet.ByteBuffCreator;
+import dev.wolveringer.packet.PacketHandle;
+import dev.wolveringer.profiler.Profiler;
+import dev.wolveringer.strings.Messages;
+
+public class Encoder extends MinecraftEncoder {
+
+	@Getter
+	@Setter
+	private IInitialHandler initHandler;
+	@Getter
+	private Protocol protocoll = Protocol.HANDSHAKE;
+	@Getter
+	private int version;
+	@Getter
+	private ClientVersion clientVersion = ClientVersion.UnderknownVersion;
+	@Getter
+	private	boolean server;
+
+	public Encoder(Protocol protocol, boolean server, int protocolVersion, IInitialHandler i) {
+		super(protocol, server, protocolVersion);
+		this.initHandler = i;
+		this.server = server;
+		this.clientVersion = ClientVersion.fromProtocoll(protocolVersion);
+	}
+	@Override
+	protected void encode(ChannelHandlerContext ctx, DefinedPacket msg, ByteBuf out) throws Exception {
+		Profiler.encoder_timings.start(Messages.getString("network.timings.encoder.handle"));
+		if(msg instanceof LoginSuccess)
+			initHandler.isConnected = true;
+		ByteBuf in;
+		super.encode(ctx, msg, in = Unpooled.buffer());
+
+		Profiler.encoder_timings.start(Messages.getString("network.timings.encoder.create.packet"));
+		Packet packet = Packet.getPacket(clientVersion.getProtocollVersion(),protocoll, Direction.TO_CLIENT, in, initHandler.getPlayer());
+		Profiler.encoder_timings.stop(Messages.getString("network.timings.encoder.create.packet"));
+		if(packet == null){
+			ByteBuffCreator.copy(in, out);
+			in.release();
+			return;
+		}
+		in.release();
+		PacketHandleEvent e = new PacketHandleEvent(packet, initHandler.getPlayer());
+		Profiler.encoder_timings.start(Messages.getString("network.timings.encoder.handle.intern"));
+		boolean intern = PacketHandle.handlePacket(e);
+		Profiler.encoder_timings.stop(Messages.getString("network.timings.encoder.handle.intern"));
+		if(!intern){
+			Profiler.encoder_timings.start(Messages.getString("network.timings.encoder.handle.extern"));
+			PacketLib.handle(e);
+			Profiler.encoder_timings.stop(Messages.getString("network.timings.encoder.handle.extern"));
+			if(!e.isCancelled()){
+				Profiler.encoder_timings.start(Messages.getString("network.timings.encoder.write.writeNewbyteBuff"));
+
+				e.getPacket().writeToByteBuff(out,ClientVersion.fromProtocoll(initHandler.getVersion())); //write direct to out
+				//ByteBuffCreator.copy(buf, out);
+				//buf.release();
+				
+				Profiler.encoder_timings.stop(Messages.getString("network.timings.encoder.write.writeNewbyteBuff"));
+			}
+			else
+			{
+				
+			}
+		}
+		Profiler.encoder_timings.stop(Messages.getString("network.timings.encoder.handle"));
+	}
+	
+	public void setProtocol(Protocol protocol) {
+		super.setProtocol(protocol);
+		this.protocoll = protocol;
+	}
+
+	public void setProtocolVersion(int protocol) {
+		super.setProtocolVersion(protocol);
+		this.version = protocol;
+		this.clientVersion = ClientVersion.fromProtocoll(protocol);
+	}
+}
diff --git a/src/main/java/dev/wolveringer/network/IIInitialHandler.java b/src/main/java/dev/wolveringer/network/IIInitialHandler.java
new file mode 100644
index 0000000..da3eb23
--- /dev/null
+++ b/src/main/java/dev/wolveringer/network/IIInitialHandler.java
@@ -0,0 +1,379 @@
+package dev.wolveringer.network;
+
+import java.io.File;
+import java.lang.reflect.Field;
+import java.lang.reflect.InvocationTargetException;
+import java.math.BigInteger;
+import java.net.URL;
+import java.net.URLClassLoader;
+import java.net.URLEncoder;
+import java.security.MessageDigest;
+import java.util.Enumeration;
+import java.util.UUID;
+import java.util.jar.JarEntry;
+import java.util.jar.JarFile;
+import java.util.logging.Level;
+
+import javassist.ClassClassPath;
+import javassist.ClassPool;
+import javassist.CtClass;
+
+import javax.crypto.SecretKey;
+
+import net.md_5.bungee.BungeeCord;
+import net.md_5.bungee.EncryptionUtil;
+import net.md_5.bungee.UserConnection;
+import net.md_5.bungee.Util;
+import net.md_5.bungee.api.Callback;
+import net.md_5.bungee.api.ProxyServer;
+import net.md_5.bungee.api.config.ListenerInfo;
+import net.md_5.bungee.api.config.ServerInfo;
+import net.md_5.bungee.api.connection.ProxiedPlayer;
+import net.md_5.bungee.api.event.LoginEvent;
+import net.md_5.bungee.api.event.PostLoginEvent;
+import net.md_5.bungee.api.event.PreLoginEvent;
+import net.md_5.bungee.api.plugin.Plugin;
+import net.md_5.bungee.connection.InitialHandler;
+import net.md_5.bungee.connection.LoginResult;
+import net.md_5.bungee.connection.UpstreamBridge;
+import net.md_5.bungee.http.HttpClient;
+import net.md_5.bungee.jni.cipher.BungeeCipher;
+import net.md_5.bungee.netty.ChannelWrapper;
+import net.md_5.bungee.netty.HandlerBoss;
+import net.md_5.bungee.netty.cipher.CipherDecoder;
+import net.md_5.bungee.netty.cipher.CipherEncoder;
+import net.md_5.bungee.protocol.DefinedPacket;
+import net.md_5.bungee.protocol.Protocol;
+import net.md_5.bungee.protocol.packet.EncryptionRequest;
+import net.md_5.bungee.protocol.packet.EncryptionResponse;
+import net.md_5.bungee.protocol.packet.LoginRequest;
+import net.md_5.bungee.protocol.packet.LoginSuccess;
+import dev.wolveringer.BungeeUtil.BungeeUtil;
+import dev.wolveringer.BungeeUtil.ClientVersion;
+import dev.wolveringer.BungeeUtil.Main;
+import dev.wolveringer.BungeeUtil.Player;
+
+public class IIInitialHandler extends IInitialHandler {
+	private static int redifned_count = 0;
+	private static ClassPool pool;
+	static Class<?> base_class_connection;
+	static Class<?> class_connection;
+	private UserConnection conn;
+
+	public static ClassPool pool() {
+		if(pool != null)
+			return pool;
+		try{
+			pool = ClassPool.getDefault();
+			loadClassesFromJar(Main.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath()); //Load BungeeUtil in the system
+		}catch (Exception e){
+			e.printStackTrace();
+		}
+		return pool;
+	}
+	public static ClassLoader getClassLoader(){
+		return IIInitialHandler.class.getClassLoader();
+	}
+
+	public static void addPlugin(Plugin plugin) {
+		try{
+			loadClassesFromJar(plugin.getClass().getProtectionDomain().getCodeSource().getLocation().toURI().getPath());
+		}catch (Exception e){
+			e.printStackTrace();
+		}
+	}
+
+	@SuppressWarnings("resource")
+	private static void loadClassesFromJar(String path) {
+		if(pool == null)
+			throw new NullPointerException("Class Pool is null!");
+		if(new File(path).isDirectory())
+			return;
+		try{
+			JarFile jarFile = new JarFile(path);
+			Enumeration<JarEntry> e = jarFile.entries();
+
+			URL[] urls = { new URL("jar:file:" + path + "!/") };
+			URLClassLoader cl = URLClassLoader.newInstance(urls, IIInitialHandler.class.getClassLoader());
+			while (e.hasMoreElements()){
+				JarEntry je = e.nextElement();
+				if(je.isDirectory() || !je.getName().endsWith(".class")){ //isnt a class file
+					continue;
+				}
+				String className = je.getName().substring(0, je.getName().length() - 6);
+				className = className.replace('/', '.');
+				if(!className.startsWith("com.ea"))
+				pool.insertClassPath(new ClassClassPath(cl.loadClass(className)));
+			}
+		}catch (Exception e){
+			e.printStackTrace();
+		}
+	}
+
+	public static void init(Class<?> base) {
+		if(base == ProxiedPlayerUserConnection.class){
+			try{
+				ClassPool cp = pool();
+				cp.appendClassPath(new ClassClassPath(base));
+				CtClass clazz = cp.get(base.getName());
+				clazz.setName("ProxiedPlayerUserConnectionRedefined" + (redifned_count == 0 ? "" : redifned_count));
+				clazz.setSuperclass(cp.get(UserConnection.class.getName()));
+				base_class_connection = class_connection = clazz.toClass(getClassLoader());
+				BungeeUtil.getInstance().sendMessage("\u00A7aInit Base class");
+				redifned_count++;
+			}catch (Exception e){
+				e.printStackTrace();
+			}
+		}else{
+			if(base_class_connection == null)
+				throw new NullPointerException("Base class isn't init");
+			if(!ProxiedPlayerUserConnection.class.isAssignableFrom(base))
+				throw new RuntimeException("Class ("+base.getCanonicalName()+") isnt an instance of ProxiedPlayerUserConnection");
+			try{
+				ClassPool cp = pool();
+				cp.appendClassPath(new ClassClassPath(base));
+				CtClass clazz = cp.get(base.getName());
+				CtClass super_class = cp.getCtClass(base_class_connection.getName()); //Get last redefined class
+				if(super_class == null || super_class.getName() == null)
+					throw new NullPointerException("Base class not found.");
+				clazz.setSuperclass(super_class);
+				clazz.setName("ProxiedPlayerUserConnectionRedefined_" + (redifned_count == 0 ? "" : redifned_count));
+				class_connection = clazz.toClass(getClassLoader()); //Create the class
+				BungeeUtil.getInstance().sendMessage("\u00A7aInit extra class " + class_connection.getSuperclass());
+				redifned_count++;
+			}catch (Exception e){
+				e.printStackTrace();
+			}
+		}
+	}
+	
+	public IIInitialHandler(ProxyServer instance, ListenerInfo listenerInfo, Decoder a, Encoder b) {
+		super(instance, listenerInfo, a, b);
+	}
+
+	@SuppressWarnings({ "unchecked", "rawtypes", "deprecation" })
+	protected void finish() {
+		if(isOnlineMode()){
+			ProxiedPlayer oldName = ProxyServer.getInstance().getPlayer(getName());
+			if(oldName != null)
+				oldName.disconnect(ProxyServer.getInstance().getTranslation("already_connected", new Object[0]));
+			ProxiedPlayer oldID = ProxyServer.getInstance().getPlayer(getUniqueId());
+			if(oldID != null)
+				oldID.disconnect(ProxyServer.getInstance().getTranslation("already_connected", new Object[0]));
+		}else{
+			ProxiedPlayer oldName = ProxyServer.getInstance().getPlayer(getName());
+			if(oldName != null){
+				disconnect(ProxyServer.getInstance().getTranslation("already_connected", new Object[0]));
+				return;
+			}
+		}
+		set("offlineId", UUID.nameUUIDFromBytes(("OfflinePlayer:" + getName()).getBytes(com.google.common.base.Charsets.UTF_8)));
+		if((UUID) get("uniqueId") == null){
+			set("uniqueId", (UUID) get("offlineId"));
+		}
+
+		Callback<LoginEvent> complete = new Callback() {
+			public void done(LoginEvent result, Throwable error) {
+				if(result.isCancelled()){
+					IIInitialHandler.this.disconnect(result.getCancelReason());
+					return;
+				}
+				if(getChannel().isClosed()){
+					return;
+				}
+
+				getChannel().getHandle().eventLoop().execute(new Runnable() {
+					public void run() {
+						if(getChannel().getHandle().isActive()){
+							UserConnection userCon;
+							try{
+								userCon = (UserConnection) class_connection.getConstructor(ProxyServer.class, ChannelWrapper.class, String.class, InitialHandler.class).newInstance(BungeeCord.getInstance(), IIInitialHandler.this.getChannel(), IIInitialHandler.this.getName(), IIInitialHandler.this);
+							}catch (InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException | NoSuchMethodException | SecurityException ex){
+								ex.printStackTrace();
+								throw new RuntimeException();
+							}
+							userCon.setCompressionThreshold(BungeeCord.getInstance().config.getCompressionThreshold());
+							userCon.init();
+							conn = userCon;
+							if(IIInitialHandler.this.getVersion() >= 5){
+								IIInitialHandler.this.unsafe().sendPacket(new LoginSuccess(IIInitialHandler.this.getUniqueId().toString(), IIInitialHandler.this.getName()));
+							}else{
+								IIInitialHandler.this.unsafe().sendPacket(new LoginSuccess(IIInitialHandler.this.getUUID(), IIInitialHandler.this.getName()));
+							}
+							getChannel().setProtocol(net.md_5.bungee.protocol.Protocol.GAME);
+							
+							ProxyServer.getInstance().getPluginManager().callEvent(new PostLoginEvent(userCon));
+							((HandlerBoss) getChannel().getHandle().pipeline().get(HandlerBoss.class)).setHandler(new UpstreamBridge(ProxyServer.getInstance(), userCon));
+							ServerInfo server;
+							if(ProxyServer.getInstance().getReconnectHandler() != null){
+								server = ProxyServer.getInstance().getReconnectHandler().getServer(userCon);
+							}else{
+								server = net.md_5.bungee.api.AbstractReconnectHandler.getForcedHost(IIInitialHandler.this);
+							}
+							if(server == null){
+								server = ProxyServer.getInstance().getServerInfo(((ListenerInfo) get("listener")).getDefaultServer());
+							}
+
+							userCon.connect(server, null, true);
+						}
+
+					}
+
+				});
+			}
+
+			@Override
+			public void done(Object o, Throwable t) {
+				if(o instanceof LoginEvent)
+					done((LoginEvent) o, t);
+			}
+		};
+		ProxyServer.getInstance().getPluginManager().callEvent(new LoginEvent(this, complete));
+	}
+
+	@SuppressWarnings({ "unchecked", "rawtypes" })
+	public void handle(LoginRequest loginRequest) throws Exception {
+		set("loginRequest", loginRequest);
+		ClientVersion version = ClientVersion.fromProtocoll(getHandshake().getProtocolVersion());
+		if(version == null || !version.getProtocollVersion().isSupported()){
+			//disconnect(ProxyServer.getInstance().getTranslation("outdated_server", new Object[0]));
+			disconnect("\u00A7cBungeeUtil cant handle your client version.");
+			return;
+		}
+
+		if(getName().contains(".")){
+			disconnect(ProxyServer.getInstance().getTranslation("name_invalid", new Object[] { getName() }));
+			return;
+		}
+
+		if(getName().length() > 16){
+			disconnect(ProxyServer.getInstance().getTranslation("name_too_long", new Object[] { getName() }));
+			return;
+		}
+
+		int limit = BungeeCord.getInstance().config.getPlayerLimit();
+		if((limit > 0) && (ProxyServer.getInstance().getOnlineCount() > limit)){
+			disconnect(ProxyServer.getInstance().getTranslation("proxy_full", new Object[0]));
+			return;
+		}
+
+		if((!isOnlineMode()) && (ProxyServer.getInstance().getPlayer(getUniqueId()) != null)){
+			disconnect(ProxyServer.getInstance().getTranslation("already_connected", new Object[0]));
+			return;
+		}
+		
+		setProtocol(Protocol.LOGIN);
+		Callback<PreLoginEvent> callback = new Callback() {
+			@Override
+			public void done(Object paramV, Throwable paramThrowable) {
+				if(paramV instanceof PreLoginEvent)
+					done((PreLoginEvent) paramV, paramThrowable);
+			}
+
+			public void done(PreLoginEvent result, Throwable error) {
+
+				if(result.isCancelled()){
+					IIInitialHandler.this.disconnect(result.getCancelReason());
+					return;
+				}
+				if(getChannel().isClosed()){
+					return;
+				}
+				if(isOnlineMode() == true){
+					set("request", EncryptionUtil.encryptRequest());
+					IIInitialHandler.this.unsafe().sendPacket((DefinedPacket) get("request"));
+				}else{
+					IIInitialHandler.this.finish();
+				}
+			}
+
+		};
+		ProxyServer.getInstance().getPluginManager().callEvent(new PreLoginEvent(this, callback));
+	}
+
+	@SuppressWarnings({ "rawtypes", "unchecked" })
+	public void handle(EncryptionResponse encryptResponse) throws Exception {
+		SecretKey sharedKey = EncryptionUtil.getSecret(encryptResponse, (EncryptionRequest) get("request"));
+		BungeeCipher decrypt = EncryptionUtil.getCipher(false, sharedKey);
+		((ChannelWrapper) get("ch")).addBefore("frame-decoder", "decrypt", new CipherDecoder(decrypt));
+		BungeeCipher encrypt = EncryptionUtil.getCipher(true, sharedKey);
+		((ChannelWrapper) get("ch")).addBefore("frame-prepender", "encrypt", new CipherEncoder(encrypt));
+
+		String encName = URLEncoder.encode(getName(), "UTF-8");
+
+		MessageDigest sha = MessageDigest.getInstance("SHA-1");
+		for(byte[] bit : new byte[][] { (((EncryptionRequest) get("request"))).getServerId().getBytes("ISO_8859_1"), sharedKey.getEncoded(), EncryptionUtil.keys.getPublic().getEncoded() })
+
+		{
+			sha.update(bit);
+		}
+		String encodedHash = URLEncoder.encode(new BigInteger(sha.digest()).toString(16), "UTF-8");
+
+		String authURL = new StringBuilder().append("https://sessionserver.mojang.com/session/minecraft/hasJoined?username=").append(encName).append("&serverId=").append(encodedHash).toString();
+
+		Callback handler = new Callback<String>() {
+			public void done(String result, Throwable error) {
+				if(error == null){
+					LoginResult obj = (LoginResult) BungeeCord.getInstance().gson.fromJson(result, LoginResult.class);
+					if(obj != null){
+						try{
+							set("uniqueId", (UUID) Util.getUUID(obj.getId()));
+							set("loginProfile", obj);
+						}catch(Exception e){
+							e.printStackTrace();
+						}
+						finish();
+						return;
+					}
+					IIInitialHandler.this.disconnect("Not authenticated with Minecraft.net");
+				}else{
+					IIInitialHandler.this.disconnect(BungeeCord.getInstance().getTranslation("mojang_fail", new Object[0]));
+					BungeeCord.getInstance().getLogger().log(Level.SEVERE, "Error authenticating " + IIInitialHandler.this.getName() + " with minecraft.net", error);
+
+				}
+			}
+		};
+		HttpClient.get(authURL, ((ChannelWrapper) get("ch")).getHandle().eventLoop(), handler);
+	}
+	
+	@Override
+	public void exception(Throwable t) throws Exception {
+		super.exception(t);
+	}
+
+	@Override
+	public Player getPlayer() {
+		return (Player) ((ProxiedPlayer) conn);
+	}
+
+	protected void set(String a, Object b) {
+		Field f = null;
+		try{
+			f = InitialHandler.class.getDeclaredField(a);
+		}catch (NoSuchFieldException | SecurityException e){
+			e.printStackTrace();
+		}
+		f.setAccessible(true);
+		try{
+			f.set(this, b);
+		}catch (IllegalArgumentException | IllegalAccessException e){
+			e.printStackTrace();
+		}
+	}
+
+	protected Object get(String a) {
+		Field f = null;
+		try{
+			f = InitialHandler.class.getDeclaredField(a);
+		}catch (NoSuchFieldException | SecurityException e){
+			e.printStackTrace();
+		}
+		f.setAccessible(true);
+		try{
+			return f.get(this);
+		}catch (IllegalArgumentException | IllegalAccessException e){
+			e.printStackTrace();
+		}
+		return null;
+	}
+}
diff --git a/src/main/java/dev/wolveringer/network/IInitialHandler.java b/src/main/java/dev/wolveringer/network/IInitialHandler.java
new file mode 100644
index 0000000..27b256b
--- /dev/null
+++ b/src/main/java/dev/wolveringer/network/IInitialHandler.java
@@ -0,0 +1,231 @@
+package dev.wolveringer.network;
+
+import io.netty.buffer.ByteBuf;
+
+import java.lang.reflect.Field;
+
+import net.md_5.bungee.BungeeCord;
+import net.md_5.bungee.ServerConnection;
+import net.md_5.bungee.UserConnection;
+import net.md_5.bungee.api.ProxyServer;
+import net.md_5.bungee.api.chat.BaseComponent;
+import net.md_5.bungee.api.chat.TextComponent;
+import net.md_5.bungee.api.config.ListenerInfo;
+import net.md_5.bungee.chat.ComponentSerializer;
+import net.md_5.bungee.connection.InitialHandler;
+import net.md_5.bungee.protocol.Protocol;
+import net.md_5.bungee.protocol.packet.Kick;
+import net.md_5.bungee.protocol.packet.LoginSuccess;
+import dev.wolveringer.BungeeUtil.AsyncCatcher;
+import dev.wolveringer.BungeeUtil.ClientVersion;
+import dev.wolveringer.BungeeUtil.Player;
+import dev.wolveringer.BungeeUtil.configuration.Configuration;
+import dev.wolveringer.BungeeUtil.packets.Packet;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayOutEntityEffect;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayOutGameStateChange;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayOutPlayerListHeaderFooter;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayOutPosition;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayOutRemoveEntityEffect;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayOutUpdateHealth;
+import dev.wolveringer.chat.ChatSerializer;
+import dev.wolveringer.chat.IChatBaseComponent;
+import dev.wolveringer.network.channel.ChannelWrapper;
+
+public abstract class IInitialHandler extends InitialHandler {
+	public final static Field CHANNEL_FIELD;
+	
+	static {
+		Field f;
+		try {
+			f = InitialHandler.class.getDeclaredField("ch");
+			f.setAccessible(true);
+		}
+		catch (NoSuchFieldException | SecurityException e) {
+			f = null;
+			e.printStackTrace();
+		}
+		CHANNEL_FIELD = f;
+	}
+	
+	public IInitialHandler(ProxyServer instance, ListenerInfo listenerInfo, Decoder a, Encoder b) {
+		super(BungeeCord.getInstance(), listenerInfo);
+		this.a = a;
+		this.b = b;
+		if (a != null) a.setInitHandler(this);
+		if (b != null) b.setInitHandler(this);
+	}
+	
+	public boolean isConnected = false;
+	private boolean isDisconnecting = false;
+	private Encoder b;
+	private Decoder a;
+	private short transaktionId;
+	private short window;
+	private IChatBaseComponent[] tab = new IChatBaseComponent[2];
+	
+	
+	public Encoder getEncoder() {
+		return b;
+	}
+	
+	public Decoder getDecoder() {
+		return a;
+	}
+	
+	@Override
+	public void connected(final net.md_5.bungee.netty.ChannelWrapper channel) throws Exception {
+		super.connected(new ChannelWrapper(channel, this));
+	}
+	
+	@Override
+	public void handle(LoginSuccess loginSuccess) throws Exception {
+		super.handle(loginSuccess);
+	}
+	
+	public abstract Player getPlayer();
+	
+	@Override
+	public void disconnect(String reason) {
+		disconnect(TextComponent.fromLegacyText(reason));
+	}
+	
+	@Override
+	public void disconnect(final BaseComponent... reason) {
+		if (isDisconnecting) return;
+		isDisconnecting = true;
+		if (getHandshake() != null && getHandshake().getRequestedProtocol() == 2) {
+			if(getEncoder().getProtocoll() == Protocol.HANDSHAKE)
+				setProtocol(Protocol.LOGIN);
+			unsafe().sendPacket(new Kick(ComponentSerializer.toString(reason)));
+		}
+		closeChannel();
+	}
+	
+	public void disconnect(Exception e) {
+		disconnect(e, 10);
+	}
+	
+	public void disconnect(Exception e, int stackDeep) {
+		if (isDisconnecting) return;
+		isDisconnecting = true;
+		if (getChannel().isClosed()) { return; }
+		String message = "" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "4Error Message: " + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "b" + e.getLocalizedMessage() + "\n";
+		for (int i = 0; i < (e.getStackTrace().length > stackDeep ? stackDeep : e.getStackTrace().length); i++) {
+			StackTraceElement ex = e.getStackTrace()[i];
+			if(ex.getMethodName().equalsIgnoreCase("channelRead") && ex.getClassName().equalsIgnoreCase("io.netty.handler.codec.MessageToMessageDecoder") && ex.getLineNumber() == 89)
+				break;
+			message += format(ex) + "\n";
+		}
+		disconnect(message);
+	}
+	
+	public void closeChannel() {
+		if (!getChannel().isClosed()) getChannel().close();
+		if (isConnected) {
+			if (getPlayer().getInventoryView() != null) getPlayer().getInventoryView().unsave().getModificableViewerList().remove(this);
+			getPlayer().getPlayerInventory().reset();
+			isConnected = false;
+			b = null;
+			a = null;
+			tab = null;
+		}
+	}
+	
+	public void sendPacket(Packet p) {
+		AsyncCatcher.catchOp("Packet cant be sending async!");
+		ByteBuf b = p.getByteBuf(ClientVersion.fromProtocoll(getVersion()));
+		getChannel().getHandle().writeAndFlush(b);
+		p = null;
+	}
+	
+	public void sendPacketToServer(Packet p) {
+		AsyncCatcher.catchOp("Packet cant be sending async!");
+		ByteBuf b = p.getByteBuf(ClientVersion.fromProtocoll(this.getVersion()));
+		((ServerConnection) getPlayer().getServer()).getCh().write(b);
+	}
+	
+	public void setProtocol(Protocol p) {
+		a.setProtocol(p);
+		b.setProtocol(p);
+	}
+	
+	private String format(StackTraceElement e) {
+		return "" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "eat " + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "5" + e.getClassName() + "." + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "b" + e.getMethodName() + (e.getFileName() != null ? "(" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "a" + e.getFileName() + ":"+e.getLineNumber() + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "b)" : (e.getFileName() != null) && (e.getLineNumber() >= 0) ? "(" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "a" + e.getFileName() + "" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "b:" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "c" + e.getLineNumber() + "" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "b)" : e.isNativeMethod() ? "" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "1(Native Method)" : "" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "c(Unknown Source)");
+	}
+	
+	@Deprecated
+	public void resetClient() {
+		for (int i = 1; i < 24; i++)
+			sendPacket(new PacketPlayOutRemoveEntityEffect(getEntityId(), i));
+		sendPacket(new PacketPlayOutPosition(getPlayer().getLocation().add(0, 10000, 0), true));
+		sendPacket(new PacketPlayOutEntityEffect(getEntityId(), 15, 1, 100000, true));
+		sendPacket(new PacketPlayOutGameStateChange(3, 0));
+		sendPacket(new PacketPlayOutUpdateHealth(20F, 20, 0F));
+		resetInventory();
+	}
+	
+	@Deprecated
+	public void resetInventory() {
+		for (int i = 0; i < getPlayer().getPlayerInventory().getContains().length; i++)
+			getPlayer().getPlayerInventory().setItem(i, null);
+		getPlayer().updateInventory();
+	}
+	
+	public int getEntityId() {
+		try {
+			Field f = UserConnection.class.getDeclaredField("clientEntityId");
+			f.setAccessible(true);
+			if (BungeeCord.getInstance().getPlayer(getPlayer().getName()) == null) return -1;
+			return f.getInt(BungeeCord.getInstance().getPlayer(getPlayer().getName()));
+		}
+		catch (Exception e) {
+			e.printStackTrace();
+			return -1;
+		}
+	}
+	
+	public ChannelWrapper getChannel() {
+		try {
+			return (ChannelWrapper) CHANNEL_FIELD.get(this);
+		}
+		catch (IllegalArgumentException | IllegalAccessException e) {
+			e.printStackTrace();
+			return null;
+		}
+	}
+	
+	public short getTransaktionId() {
+		return transaktionId;
+	}
+	
+	public void setTransaktionId(short transaktionId) {
+		this.transaktionId = transaktionId;
+	}
+	
+	public void setWindow(short window) {
+		this.window = window;
+	}
+	
+	public short getWindow() {
+		return window;
+	}
+	
+	public IChatBaseComponent[] getTabHeader() {
+		return tab;
+	}
+	
+	public void setTabHeader(IChatBaseComponent header, IChatBaseComponent footer) {
+		this.tab = new IChatBaseComponent[] { header, footer };
+		sendPacket(new PacketPlayOutPlayerListHeaderFooter(header, footer));
+	}
+	
+	public void setTabHeaderFromPacket(IChatBaseComponent header, IChatBaseComponent footer) {
+		this.tab = new IChatBaseComponent[] { header, footer };
+	}
+	
+	@Override
+	public String toString() {
+		if (Configuration.isTerminalColored()) return "[" + (getHandshake().getRequestedProtocol() == 2 ? "" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "aGAME" : "" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "ePING") + "" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "7][" + (getHandshake().getRequestedProtocol() == 0 ? "" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "6" + getName() : "" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "c" + getAddress().getHostString()) + "" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "7]";
+		else return super.toString();
+	}
+}
diff --git a/src/main/java/dev/wolveringer/network/ProxiedPlayerUserConnection.java b/src/main/java/dev/wolveringer/network/ProxiedPlayerUserConnection.java
new file mode 100644
index 0000000..6940666
--- /dev/null
+++ b/src/main/java/dev/wolveringer/network/ProxiedPlayerUserConnection.java
@@ -0,0 +1,320 @@
+package dev.wolveringer.network;
+
+import io.netty.bootstrap.Bootstrap;
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelFutureListener;
+import io.netty.channel.ChannelInitializer;
+import io.netty.channel.ChannelOption;
+import io.netty.util.internal.PlatformDependent;
+
+import java.lang.reflect.Field;
+
+import net.md_5.bungee.BungeeCord;
+import net.md_5.bungee.BungeeServerInfo;
+import net.md_5.bungee.UserConnection;
+import net.md_5.bungee.api.Callback;
+import net.md_5.bungee.api.ProxyServer;
+import net.md_5.bungee.api.config.ServerInfo;
+import net.md_5.bungee.api.connection.ProxiedPlayer;
+import net.md_5.bungee.api.event.ServerConnectEvent;
+import net.md_5.bungee.connection.InitialHandler;
+import net.md_5.bungee.netty.ChannelWrapper;
+import net.md_5.bungee.netty.PipelineUtils;
+
+import com.google.common.base.Objects;
+import com.google.common.base.Preconditions;
+
+import dev.wolveringer.BungeeUtil.ClientVersion;
+import dev.wolveringer.BungeeUtil.Player;
+import dev.wolveringer.BungeeUtil.configuration.Configuration;
+import dev.wolveringer.BungeeUtil.item.Item;
+import dev.wolveringer.BungeeUtil.packets.Packet;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayInChat;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayOutCloseWindow;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayOutNamedSoundEffect;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayOutOpenWindow;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayOutSetSlot;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayOutWindowItems;
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayIn;
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
+import dev.wolveringer.api.bossbar.BossBarManager;
+import dev.wolveringer.api.inventory.Inventory;
+import dev.wolveringer.api.inventory.InventoryType;
+import dev.wolveringer.api.inventory.PlayerInventory;
+import dev.wolveringer.api.position.Location;
+import dev.wolveringer.api.scoreboard.Scoreboard;
+import dev.wolveringer.api.sound.SoundCategory;
+import dev.wolveringer.api.sound.SoundEffect;
+import dev.wolveringer.chat.IChatBaseComponent;
+import dev.wolveringer.network.inject.XChannelFutureListener;
+import dev.wolveringer.network.inject.XChannelInitializer;
+
+public class ProxiedPlayerUserConnection extends UserConnection implements Player {
+	private static final int CURSOR_ITEM_SLOT = 50;
+	private IInitialHandler i;
+	private Inventory inv;
+	private Location loc;
+	private Location last_loc;
+	private PlayerInventory p_inv;
+	private int slot;
+	private Scoreboard board;
+	private String[] tab = new String[2];
+	private BossBarManager bossBarManager;
+	
+	public ProxiedPlayerUserConnection(ProxyServer bungee, ChannelWrapper ch, String name, InitialHandler pendingConnection) {
+		super(bungee, ch, name, pendingConnection);
+		this.i = (IInitialHandler) pendingConnection;
+		p_inv = new PlayerInventory(this);
+		p_inv.getViewer().add(this);
+		board = new Scoreboard(this);
+		loc = last_loc = new Location(0, 0, 0);
+		bossBarManager = new BossBarManager(this);
+	}
+
+	public IInitialHandler getInitialHandler() {
+		return i;
+	}
+
+	public void closeInventory() {
+		closeInventory(true);
+		updateInventory();
+	}
+
+	private void closeInventory(boolean b) {
+		if(inv == null)
+			return;
+		if(b)
+			sendPacket(new PacketPlayOutCloseWindow(Inventory.ID));
+		inv.unsave().getModificableViewerList().remove(this);
+		inv = null;
+	}
+
+	public Location getLocation() {
+		return loc.clone();
+	}
+
+	public Location getLastLocation() {
+		return last_loc.clone();
+	}
+
+	public void performCommand(String command) {
+		sendPacketToServer(new PacketPlayInChat((command.startsWith("/") ? "" : "/") + command));
+	}
+
+	@Deprecated
+	public void sendPacketToServer(PacketPlayIn p) {
+		i.sendPacketToServer((Packet) p);
+	}
+
+	public boolean isInventoryOpened() {
+		return inv != null;
+	}
+
+	public void openInventory(Inventory inv) {
+		if(isInventoryOpened())
+			closeInventory(true);
+		PacketPlayOutOpenWindow e = new PacketPlayOutOpenWindow(Inventory.ID, inv.getType().getType(getVersion()), inv.getName(), inv.getType() == InventoryType.Chest ? inv.getSlots() : inv.getType().getDefaultSlots(), false);
+		e.UTF_8 = true;
+		sendPacket(e);
+		sendPacket(new PacketPlayOutWindowItems(Inventory.ID, inv.getContains()));
+		inv.unsave().getModificableViewerList().add(this);
+		this.inv = inv;
+	}
+
+	public void updateInventory() {
+		int window = 0;
+		int dslot = 0;
+		Item[] items = p_inv.getContains();
+		/*
+		if(isInventoryOpened()){
+			window = Inventory.ID;
+			dslot = getInventoryView().getSlots();
+		}
+		for(int i = 0;i < items.length;i++){
+			if(isInventoryOpened() && i-9 < 0)
+				continue;
+			Item item = items[i];
+			sendPacket(new PacketPlayOutSetSlot(item, window, dslot+i-(isInventoryOpened()?/*9*//*0:0))); //-9 Player crafting and armor
+		}
+		*/
+		sendPacket(new PacketPlayOutWindowItems(0, items));
+	}
+
+	public void setCursorItem(Item is) {
+		sendPacket(new PacketPlayOutSetSlot(is, -1, -1));
+		getPlayerInventory().setItem(CURSOR_ITEM_SLOT, is);
+	}
+
+	public Item getCursorItem() {
+		return getPlayerInventory().getItem(CURSOR_ITEM_SLOT);
+	}
+
+	public Item getOffHandItem() {
+		return getPlayerInventory().getItem(45);
+	}
+	
+	public PlayerInventory getPlayerInventory() {
+		return p_inv;
+	}
+
+	public ClientVersion getVersion() {
+		return ClientVersion.fromProtocoll(i.getHandshake() == null ? -1 : i.getHandshake().getProtocolVersion());
+	}
+
+	public Inventory getInventoryView() {
+		return inv;
+	}
+
+	public void sendPacket(PacketPlayOut packet) {
+		Packet p = (Packet) packet;
+		if(p == null)
+			return;
+		i.sendPacket(p);
+	}
+
+	public void setLocation(Location loc) {
+		this.last_loc = this.loc.clone();
+		this.loc = loc;
+	}
+
+	public void setSelectedSlot(int slot) {
+		this.slot = slot;
+	}
+
+	public int getSelectedSlot() {
+		return slot;
+	}
+
+	public Scoreboard getScoreboard() {
+		if(Configuration.isScoreboardhandleEnabled())
+			return board;
+		throw new RuntimeException("The Scoreboard manager isnt enabled in the configuration!");
+	}
+
+	@Override
+	public IChatBaseComponent[] getTabHeader() {
+		return getInitialHandler().getTabHeader();
+	}
+
+	@Override
+	public void setTabHeader(IChatBaseComponent header, IChatBaseComponent footer) {
+		getInitialHandler().setTabHeader(header, footer);
+	}
+	
+	@Override
+	public void disconnect(Exception e) {
+		getInitialHandler().disconnect(e);
+	}
+
+	@Override
+	public String toString() {
+		return "Player{name=\""+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"r" + getName() + ""+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"r\" DisplayName=\""+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"r" + getDisplayName() + ""+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"r\" ping=\"" + getPing() + "\"}";
+	}
+
+	@Override
+	public void connect(ServerInfo info, Callback<Boolean> callback, boolean retry) {
+		connect0(info, callback, retry);
+	}
+
+	public void connect0(ServerInfo info, final Callback<Boolean> callback, final boolean retry) {
+		Preconditions.checkNotNull(info, "info");
+
+		ServerConnectEvent event = new ServerConnectEvent(this, info);
+		if(((ServerConnectEvent) BungeeCord.getInstance().getPluginManager().callEvent(event)).isCancelled()){
+			return;
+		}
+
+		final BungeeServerInfo target = (BungeeServerInfo) event.getTarget();
+		if((getServer() != null) && (Objects.equal(getServer().getInfo(), target))){
+			sendMessage(BungeeCord.getInstance().getTranslation("already_connected", new Object[0]));
+			return;
+		}
+		if(getPendingConnects().contains(target)){
+			sendMessage(BungeeCord.getInstance().getTranslation("already_connecting", new Object[0]));
+			return;
+		}
+		getPendingConnects().add(target);
+		ChannelInitializer<Channel> initializer = new XChannelInitializer(getUserconnection(), target);
+		ChannelFutureListener listener = new XChannelFutureListener(callback, getUserconnection(), target, retry);
+		Bootstrap b = ((Bootstrap) ((Bootstrap) ((Bootstrap) ((Bootstrap) new Bootstrap().channel(PipelineUtils.getChannel())).group(get("ch", ChannelWrapper.class).getHandle().eventLoop())).handler(initializer)).option(ChannelOption.CONNECT_TIMEOUT_MILLIS, Integer.valueOf(5000))).remoteAddress(target.getAddress());
+		if((getPendingConnection().getListener().isSetLocalAddress()) && (!(PlatformDependent.isWindows()))){
+			b.localAddress(getPendingConnection().getListener().getHost().getHostString(), 0);
+		}
+		b.connect().addListener(listener);
+	}
+	
+	
+	private Object get(String a) {
+		Field f = null;
+		try{
+			f = UserConnection.class.getDeclaredField(a);
+		}catch (NoSuchFieldException | SecurityException e){
+			e.printStackTrace();
+		}
+		f.setAccessible(true);
+		try{
+			return f.get(this);
+		}catch (IllegalArgumentException | IllegalAccessException e){
+			e.printStackTrace();
+		}
+		return null;
+	}
+
+	private <T> T get(String a, Class<T> ref) {
+		return (T) get(a);
+	}
+	
+	private UserConnection getUserconnection(){
+		return (UserConnection) ((ProxiedPlayer)this);
+	}
+
+	@Override
+	public boolean isConnected() {
+		return !((ChannelWrapper)get("ch")).isClosed();
+	}
+
+	@Override
+	public Item getHandItem() {
+		return getPlayerInventory().getItem(36+slot);
+	}
+	
+	@Override
+	public void playSound(SoundEffect effect) {
+		playSound(effect, 1F);
+	}
+
+	@Override
+	public void playSound(SoundEffect effect, float volume) {
+		playSound(effect, volume, 0);
+	}
+
+	@Override
+	public void playSound(SoundEffect effect, float volume, float pitch) {
+		playSound(effect, getLocation() , volume, pitch);
+		
+	}
+	
+	@Override
+	public void playSound(SoundEffect effect, Location location, float volume, float pitch) {
+		playSound(effect, SoundCategory.MASTER, location, volume, pitch);
+	}
+
+	@Override
+	public void playSound(SoundEffect effect,SoundCategory category, Location location, float volume, float pitch) {
+		if(!effect.isAvariable(getVersion().getBigVersion()))
+			throw new RuntimeException("Sound not avariable for client version");
+		PacketPlayOutNamedSoundEffect packet = new PacketPlayOutNamedSoundEffect();
+		packet.setLoc(location);
+		packet.setVolume(volume);
+		packet.setSoundCategory(category.ordinal());
+		packet.setSound(effect.getId(getVersion().getBigVersion()));
+		sendPacket(packet);
+	}
+
+	@Override
+	public BossBarManager getBossBarManager() {
+		if(Configuration.isBossBarhandleEnabled())
+			return bossBarManager;
+		throw new RuntimeException("The BossBar manager isnt enabled in the configuration!");
+	}
+}
diff --git a/src/main/java/dev/wolveringer/network/channel/ChannelHandler.java b/src/main/java/dev/wolveringer/network/channel/ChannelHandler.java
new file mode 100644
index 0000000..5f1d243
--- /dev/null
+++ b/src/main/java/dev/wolveringer/network/channel/ChannelHandler.java
@@ -0,0 +1,121 @@
+package dev.wolveringer.network.channel;
+
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.timeout.ReadTimeoutException;
+
+import java.io.IOException;
+import java.util.logging.Level;
+
+import net.md_5.bungee.api.ProxyServer;
+import net.md_5.bungee.connection.CancelSendSignal;
+import net.md_5.bungee.connection.InitialHandler;
+import net.md_5.bungee.connection.PingHandler;
+import net.md_5.bungee.netty.ChannelWrapper;
+import net.md_5.bungee.netty.HandlerBoss;
+import net.md_5.bungee.netty.PacketHandler;
+import net.md_5.bungee.protocol.BadPacketException;
+import net.md_5.bungee.protocol.PacketWrapper;
+
+import com.google.common.base.Preconditions;
+
+import dev.wolveringer.BungeeUtil.configuration.Configuration;
+import dev.wolveringer.chat.ChatColor.ChatColorUtils;
+import dev.wolveringer.network.IInitialHandler;
+import dev.wolveringer.strings.Messages;
+
+public class ChannelHandler extends HandlerBoss {
+	private ChannelWrapper channel;
+	private PacketHandler handler;
+
+	public ChannelHandler() {
+	}
+	
+	private String formatColor(String in){
+		if(Configuration.isTerminalColored())
+			return in;
+		else
+			return ChatColorUtils.stripColor(in);
+	}
+
+	@Override
+	public void setHandler(PacketHandler handler) {
+		Preconditions.checkArgument(handler != null, "handler"); //$NON-NLS-1$
+		this.handler = handler;
+	}
+
+	@Override
+	public void channelActive(ChannelHandlerContext ctx) throws Exception {
+		if(this.handler != null){
+			this.channel = new ChannelWrapper(ctx);
+			this.handler.connected(this.channel);
+			if((!(this.handler instanceof InitialHandler)) && (!(this.handler instanceof PingHandler))){
+				ProxyServer.getInstance().getLogger().log(Level.INFO, formatColor(Messages.getString("ChannelHandler.connection.connect")), this.handler); //$NON-NLS-1$
+			}
+		}
+	}
+
+	@Override
+	public void channelInactive(ChannelHandlerContext ctx) throws Exception {
+		if(this.handler != null){
+			this.handler.disconnected(this.channel);
+			if((!(this.handler instanceof InitialHandler)) && (!(this.handler instanceof PingHandler))){
+				ProxyServer.getInstance().getLogger().log(Level.INFO, formatColor(Messages.getString("ChannelHandler.connection.disconnect")), this.handler); //$NON-NLS-1$
+			}
+		}
+	}
+
+	@Override
+	public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
+		if(this.handler != null){
+			try{
+				PacketWrapper packet = (PacketWrapper) msg;
+				boolean sendPacket = true;
+				try{
+					if(packet.packet != null){
+						try{
+							packet.packet.handle(this.handler);
+						}catch (CancelSendSignal ex){
+							sendPacket = false;
+						}
+					}
+					if(sendPacket){
+						this.handler.handle(packet);
+					}
+				}finally{
+					packet.trySingleRelease();
+				}
+			}catch (Exception e){
+				if(this.handler instanceof IInitialHandler){
+					((IInitialHandler)this.handler).disconnect(e);
+				}
+				else
+					this.channel.getHandle().close();
+				e.printStackTrace();
+			}
+		}
+	}
+
+	@Override
+	public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
+		if(ctx.channel().isActive()){
+			if((cause instanceof ReadTimeoutException)){
+				ProxyServer.getInstance().getLogger().log(Level.WARNING, formatColor(Messages.getString("ChannelHandler.connection.timeout")), this.handler); //$NON-NLS-1$
+			}else if((cause instanceof BadPacketException)){
+				ProxyServer.getInstance().getLogger().log(Level.WARNING, formatColor(Messages.getString("ChannelHandler.connection.bad-packet")), this.handler); //$NON-NLS-1$
+			}else if((cause instanceof IOException)){
+				ProxyServer.getInstance().getLogger().log(Level.WARNING, formatColor(Messages.getString("ChannelHandler.connection.IOException")), new Object[] { this.handler, cause.getMessage() }); //$NON-NLS-1$
+			}else{
+				ProxyServer.getInstance().getLogger().log(Level.SEVERE, this.handler + formatColor(Messages.getString("ChannelHandler.connection.encounteredException")), cause); //$NON-NLS-1$
+			}
+
+			if(this.handler != null){
+				try{
+					this.handler.exception(cause);
+				}catch (Exception ex){
+					ProxyServer.getInstance().getLogger().log(Level.SEVERE, this.handler + formatColor(Messages.getString("ChannelHandler.connection.progressingException")), ex); //$NON-NLS-1$
+				}
+			}
+			ctx.close();
+		}
+	}
+}
diff --git a/src/main/java/dev/wolveringer/network/channel/ChannelWrapper.java b/src/main/java/dev/wolveringer/network/channel/ChannelWrapper.java
new file mode 100644
index 0000000..d3c101c
--- /dev/null
+++ b/src/main/java/dev/wolveringer/network/channel/ChannelWrapper.java
@@ -0,0 +1,349 @@
+package dev.wolveringer.network.channel;
+
+import io.netty.buffer.ByteBufAllocator;
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelFuture;
+import io.netty.channel.ChannelHandler;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelPipeline;
+import io.netty.channel.ChannelProgressivePromise;
+import io.netty.channel.ChannelPromise;
+import io.netty.util.Attribute;
+import io.netty.util.AttributeKey;
+import io.netty.util.concurrent.EventExecutor;
+
+import java.lang.reflect.Field;
+import java.net.SocketAddress;
+
+import net.md_5.bungee.compress.PacketCompressor;
+import net.md_5.bungee.compress.PacketDecompressor;
+import net.md_5.bungee.netty.PipelineUtils;
+import net.md_5.bungee.protocol.MinecraftDecoder;
+import net.md_5.bungee.protocol.MinecraftEncoder;
+import net.md_5.bungee.protocol.PacketWrapper;
+import net.md_5.bungee.protocol.Protocol;
+
+import com.google.common.base.Preconditions;
+
+import dev.wolveringer.Reflect.Until;
+import dev.wolveringer.network.Decoder;
+import dev.wolveringer.network.Encoder;
+import dev.wolveringer.network.IInitialHandler;
+
+public class ChannelWrapper extends net.md_5.bungee.netty.ChannelWrapper {
+
+	private Channel ch;
+	private IInitialHandler handler;
+	private volatile boolean closed;
+
+	public ChannelWrapper(net.md_5.bungee.netty.ChannelWrapper ctx, IInitialHandler h) {
+		super(new EmptyChannelWrapper());
+		this.handler = h;
+		try{
+			Field f = net.md_5.bungee.netty.ChannelWrapper.class.getDeclaredField("ch");
+			f.setAccessible(true);
+			this.ch = (Channel) f.get(ctx);
+		}catch (Exception e){
+			e.printStackTrace();
+		}
+	}
+	
+	public void setProtocol(Protocol protocol) {
+		if(ch.pipeline().get(MinecraftEncoder.class) != null)
+			ch.pipeline().get(MinecraftEncoder.class).setProtocol(protocol);
+		if(ch.pipeline().get(MinecraftDecoder.class) != null)
+			ch.pipeline().get(MinecraftDecoder.class).setProtocol(protocol);
+		if(ch.pipeline().get(Encoder.class) != null)
+			ch.pipeline().get(Encoder.class).setProtocol(protocol);
+		if(ch.pipeline().get(Decoder.class) != null)
+			ch.pipeline().get(Decoder.class).setProtocol(protocol);
+	}
+
+	public void setVersion(int protocol) {
+		if(ch.pipeline().get(MinecraftEncoder.class) != null)
+			ch.pipeline().get(MinecraftEncoder.class).setProtocolVersion(protocol);
+		if(ch.pipeline().get(MinecraftDecoder.class) != null)
+			ch.pipeline().get(MinecraftDecoder.class).setProtocolVersion(protocol);
+		if(ch.pipeline().get(Encoder.class) != null)
+			ch.pipeline().get(Encoder.class).setProtocolVersion(protocol);
+		if(ch.pipeline().get(Decoder.class) != null)
+			ch.pipeline().get(Decoder.class).setProtocolVersion(protocol);
+	}
+
+	public void write(Object packet) {
+		if(!closed && (handler.isConnected || (getProtocol() != Protocol.GAME))){
+			if(packet instanceof PacketWrapper){
+				((PacketWrapper) packet).setReleased(true);
+				ch.write(((PacketWrapper) packet).buf, ch.voidPromise());
+			}else{
+				ch.write(packet, ch.voidPromise());
+			}
+			ch.flush();
+		}
+	}
+
+	public Protocol getProtocol() {
+		if(handler.getEncoder() != null){
+			return Until.getProtocol(handler.getEncoder());
+		}else if(ch.pipeline().get(Decoder.class) != null){
+			System.out.print(ch.pipeline().get(Decoder.class).getProtocol());
+			return ch.pipeline().get(Decoder.class).getProtocol();
+		}else if(ch.pipeline().get(Encoder.class) != null){
+			return Until.getProtocol(ch.pipeline().get(Encoder.class));
+		}else if(ch.pipeline().get(MinecraftDecoder.class) != null){
+			return Until.getProtocol(ch.pipeline().get(MinecraftDecoder.class));
+		}else if(ch.pipeline().get(MinecraftEncoder.class) != null){
+			return Until.getProtocol(ch.pipeline().get(MinecraftEncoder.class));
+		}
+		return Protocol.GAME;
+	}
+
+	public void close() {
+		if(!closed){
+			closed = true;
+			ch.flush();
+			ch.close();
+		}
+	}
+
+	public void addBefore(String baseName, String name, ChannelHandler handler) {
+		try{
+			if(!ch.eventLoop().inEventLoop())
+				this.handler.disconnect("Error");
+			Preconditions.checkState(ch.eventLoop().inEventLoop(), "cannot add handler outside of event loop");
+			ch.pipeline().flush();
+			ch.pipeline().addBefore(baseName, name, handler);
+		}catch (Exception e){
+			this.handler.disconnect(e);
+		}
+	}
+
+	public Channel getHandle() {
+		return ch;
+	}
+
+	public void setCompressionThreshold(int compressionThreshold) {
+		if(ch.pipeline().get(PacketCompressor.class) == null && compressionThreshold != -1){
+			addBefore(PipelineUtils.PACKET_ENCODER, "compress", new PacketCompressor());
+		}
+
+		if(ch.pipeline().get(PacketDecompressor.class) == null && compressionThreshold != -1){
+			addBefore(PipelineUtils.PACKET_DECODER, "decompress", new PacketDecompressor());
+		}
+		if(compressionThreshold != -1){
+			ch.pipeline().get(PacketCompressor.class).setThreshold(compressionThreshold);
+		}else{
+			ch.pipeline().remove("compress");
+		}
+		if(compressionThreshold == -1){
+			ch.pipeline().remove("decompress");
+		}
+	}
+
+}
+
+class EmptyChannelWrapper implements ChannelHandlerContext {
+	@Override
+	public <T> Attribute<T> attr(AttributeKey<T> paramAttributeKey) {
+		return null;
+	}
+
+	@Override
+	public Channel channel() {
+		return null;
+	}
+
+	@Override
+	public EventExecutor executor() {
+		return null;
+	}
+
+	@Override
+	public String name() {
+		return null;
+	}
+
+	@Override
+	public ChannelHandler handler() {
+		return null;
+	}
+
+	@Override
+	public boolean isRemoved() {
+		return false;
+	}
+
+	@Override
+	public ChannelHandlerContext fireChannelRegistered() {
+		return null;
+	}
+
+	@Override
+	public ChannelHandlerContext fireChannelUnregistered() {
+		return null;
+	}
+
+	@Override
+	public ChannelHandlerContext fireChannelActive() {
+		return null;
+	}
+
+	@Override
+	public ChannelHandlerContext fireChannelInactive() {
+		return null;
+	}
+
+	@Override
+	public ChannelHandlerContext fireExceptionCaught(Throwable paramThrowable) {
+		return null;
+	}
+
+	@Override
+	public ChannelHandlerContext fireUserEventTriggered(Object paramObject) {
+		return null;
+	}
+
+	@Override
+	public ChannelHandlerContext fireChannelRead(Object paramObject) {
+		return null;
+	}
+
+	@Override
+	public ChannelHandlerContext fireChannelReadComplete() {
+		return null;
+	}
+
+	@Override
+	public ChannelHandlerContext fireChannelWritabilityChanged() {
+		return null;
+	}
+
+	@Override
+	public ChannelFuture bind(SocketAddress paramSocketAddress) {
+		return null;
+	}
+
+	@Override
+	public ChannelFuture connect(SocketAddress paramSocketAddress) {
+		return null;
+	}
+
+	@Override
+	public ChannelFuture connect(SocketAddress paramSocketAddress1, SocketAddress paramSocketAddress2) {
+		return null;
+	}
+
+	@Override
+	public ChannelFuture disconnect() {
+		return null;
+	}
+
+	@Override
+	public ChannelFuture close() {
+		return null;
+	}
+
+	@Override
+	public ChannelFuture deregister() {
+		return null;
+	}
+
+	@Override
+	public ChannelFuture bind(SocketAddress paramSocketAddress, ChannelPromise paramChannelPromise) {
+		return null;
+	}
+
+	@Override
+	public ChannelFuture connect(SocketAddress paramSocketAddress, ChannelPromise paramChannelPromise) {
+		return null;
+	}
+
+	@Override
+	public ChannelFuture connect(SocketAddress paramSocketAddress1, SocketAddress paramSocketAddress2, ChannelPromise paramChannelPromise) {
+		return null;
+	}
+
+	@Override
+	public ChannelFuture disconnect(ChannelPromise paramChannelPromise) {
+		return null;
+	}
+
+	@Override
+	public ChannelFuture close(ChannelPromise paramChannelPromise) {
+		return null;
+	}
+
+	@Override
+	public ChannelFuture deregister(ChannelPromise paramChannelPromise) {
+		return null;
+	}
+
+	@Override
+	public ChannelHandlerContext read() {
+		return null;
+	}
+
+	@Override
+	public ChannelFuture write(Object paramObject) {
+		return null;
+	}
+
+	@Override
+	public ChannelFuture write(Object paramObject, ChannelPromise paramChannelPromise) {
+		return null;
+	}
+
+	@Override
+	public ChannelHandlerContext flush() {
+		return null;
+	}
+
+	@Override
+	public ChannelFuture writeAndFlush(Object paramObject, ChannelPromise paramChannelPromise) {
+		return null;
+	}
+
+	@Override
+	public ChannelFuture writeAndFlush(Object paramObject) {
+		return null;
+	}
+
+	@Override
+	public ChannelPipeline pipeline() {
+		return null;
+	}
+
+	@Override
+	public ByteBufAllocator alloc() {
+		return null;
+	}
+
+	@Override
+	public ChannelPromise newPromise() {
+		return null;
+	}
+
+	@Override
+	public ChannelProgressivePromise newProgressivePromise() {
+		return null;
+	}
+
+	@Override
+	public ChannelFuture newSucceededFuture() {
+		return null;
+	}
+
+	@Override
+	public ChannelFuture newFailedFuture(Throwable paramThrowable) {
+		return null;
+	}
+
+	@Override
+	public ChannelPromise voidPromise() {
+		return null;
+	}
+
+	public <T> boolean hasAttr(AttributeKey<T> arg0) {
+		return false;
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/network/channel/init/BungeeConnectionInit.java b/src/main/java/dev/wolveringer/network/channel/init/BungeeConnectionInit.java
new file mode 100644
index 0000000..b611672
--- /dev/null
+++ b/src/main/java/dev/wolveringer/network/channel/init/BungeeConnectionInit.java
@@ -0,0 +1,26 @@
+package dev.wolveringer.network.channel.init;
+
+import io.netty.channel.Channel;
+import net.md_5.bungee.BungeeCord;
+import net.md_5.bungee.api.ProxyServer;
+import net.md_5.bungee.connection.InitialHandler;
+import net.md_5.bungee.netty.HandlerBoss;
+import net.md_5.bungee.netty.PipelineUtils;
+import net.md_5.bungee.protocol.KickStringWriter;
+import net.md_5.bungee.protocol.LegacyDecoder;
+import net.md_5.bungee.protocol.MinecraftDecoder;
+import net.md_5.bungee.protocol.MinecraftEncoder;
+import net.md_5.bungee.protocol.Protocol;
+
+public class BungeeConnectionInit extends ChannelInizializer {
+	@SuppressWarnings("deprecation")
+	@Override
+	public void initialize(Channel ch) throws Exception {
+		PipelineUtils.BASE.initChannel(ch);
+		ch.pipeline().addBefore(PipelineUtils.FRAME_DECODER, PipelineUtils.LEGACY_DECODER, new LegacyDecoder());
+		ch.pipeline().addAfter(PipelineUtils.FRAME_DECODER, PipelineUtils.PACKET_DECODER, new MinecraftDecoder(Protocol.HANDSHAKE, true, ProxyServer.getInstance().getProtocolVersion()));
+		ch.pipeline().addAfter(PipelineUtils.FRAME_PREPENDER, PipelineUtils.PACKET_ENCODER, new MinecraftEncoder(Protocol.HANDSHAKE, true, ProxyServer.getInstance().getProtocolVersion()));
+		ch.pipeline().addBefore(PipelineUtils.FRAME_PREPENDER, PipelineUtils.LEGACY_KICKER, new KickStringWriter());
+		ch.pipeline().get(HandlerBoss.class).setHandler(new InitialHandler(BungeeCord.getInstance(), ch.attr(PipelineUtils.LISTENER).get()));
+	}
+}
diff --git a/src/main/java/dev/wolveringer/network/channel/init/BungeeUtilChannelInit.java b/src/main/java/dev/wolveringer/network/channel/init/BungeeUtilChannelInit.java
new file mode 100644
index 0000000..43bd2c9
--- /dev/null
+++ b/src/main/java/dev/wolveringer/network/channel/init/BungeeUtilChannelInit.java
@@ -0,0 +1,135 @@
+package dev.wolveringer.network.channel.init;
+
+import io.netty.buffer.PooledByteBufAllocator;
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelException;
+import io.netty.channel.ChannelOption;
+import io.netty.handler.timeout.ReadTimeoutHandler;
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Field;
+
+import net.md_5.bungee.BungeeCord;
+import net.md_5.bungee.api.ProxyServer;
+import net.md_5.bungee.api.config.ListenerInfo;
+import net.md_5.bungee.api.connection.ProxiedPlayer;
+import net.md_5.bungee.connection.InitialHandler;
+import net.md_5.bungee.netty.HandlerBoss;
+import net.md_5.bungee.netty.PipelineUtils;
+import net.md_5.bungee.protocol.KickStringWriter;
+import net.md_5.bungee.protocol.LegacyDecoder;
+import net.md_5.bungee.protocol.Protocol;
+import net.md_5.bungee.protocol.ProtocolConstants.Direction;
+import net.md_5.bungee.protocol.Varint21FrameDecoder;
+import net.md_5.bungee.protocol.Varint21LengthFieldPrepender;
+import dev.wolveringer.BungeeUtil.BungeeUtil;
+import dev.wolveringer.network.Decoder;
+import dev.wolveringer.network.Encoder;
+import dev.wolveringer.network.channel.ChannelHandler;
+
+public class BungeeUtilChannelInit <T extends InitialHandler> extends ChannelInizializer {
+	protected Varint21LengthFieldPrepender framePrepender;
+	
+	public static final BungeeConnectionInit dinti = new BungeeConnectionInit();
+	private Constructor<? extends InitialHandler> cons;
+	
+	public BungeeUtilChannelInit(Class<T> handler) {
+		if(handler == null)
+			throw new NullPointerException();
+		try {
+			initFramePrender();
+			this.cons = handler.getConstructor(new Class[] { ProxyServer.class, ListenerInfo.class, Decoder.class, Encoder.class });
+		}
+		catch (NoSuchMethodException | SecurityException e) {
+			e.printStackTrace();
+		}
+	}
+	
+	private void initFramePrender() {
+		Field f = null;
+		try {
+			f = PipelineUtils.class.getDeclaredField("framePrepender");
+		}
+		catch (NoSuchFieldException e1) {
+			e1.printStackTrace();
+		}
+		catch (SecurityException e1) {
+			e1.printStackTrace();
+		}
+		f.setAccessible(true); 
+		try {
+			framePrepender = (Varint21LengthFieldPrepender) f.get(null);
+		} catch (IllegalArgumentException | IllegalAccessException e) {
+			e.printStackTrace();
+		}
+	}
+	
+	@SuppressWarnings("deprecation")
+	public void initialize(Channel ch) throws Exception {
+		initBaseChannel(ch);
+		try {
+			Decoder a = null;
+			Encoder b = null;
+			ch.pipeline().addBefore(PipelineUtils.FRAME_DECODER, PipelineUtils.LEGACY_DECODER, new LegacyDecoder());
+			ch.pipeline().addAfter("frame-prepender", "legacy-kick", new KickStringWriter());
+			
+			ch.pipeline().addAfter("frame-decoder", "packet-decoder", a = new Decoder(Protocol.HANDSHAKE, true, ProxyServer.getInstance().getProtocolVersion(), null, Direction.TO_SERVER));
+			ch.pipeline().addAfter("frame-prepender", "packet-encoder", b = new Encoder(Protocol.HANDSHAKE, true, ProxyServer.getInstance().getProtocolVersion(), null));
+			
+			ch.pipeline().get(HandlerBoss.class).setHandler(createInitialHandler(ch, b, a));
+		}
+		catch (Throwable e) {
+			if (e instanceof NoClassDefFoundError) {
+				throwClassNotFoundError((ClassNotFoundException) e);
+				return;
+			}
+			e.printStackTrace();
+		}
+	}
+	
+	public void initBaseChannel(Channel ch) {
+		try {
+			ch.config().setOption(ChannelOption.IP_TOS, Integer.valueOf(24));
+		}
+		catch (ChannelException ex) {
+		}
+		ch.config().setAllocator(PooledByteBufAllocator.DEFAULT);
+		ch.pipeline().addLast("timeout", new ReadTimeoutHandler(BungeeCord.getInstance().config.getTimeout(), java.util.concurrent.TimeUnit.MILLISECONDS));
+		ch.pipeline().addLast("frame-decoder", new Varint21FrameDecoder());
+		ch.pipeline().addLast("frame-prepender", framePrepender);
+		ch.pipeline().addLast("inbound-boss", new ChannelHandler());
+	}
+	
+	@SuppressWarnings("deprecation")
+	public void throwClassNotFoundError(ClassNotFoundException exception) {
+		BungeeCord.getInstance().getConsole().sendMessage(""+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"7[BungeeUntil"+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"7] "+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"cBungeeUntil cant load some Classes!");
+		BungeeCord.getInstance().getConsole().sendMessage(""+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"7[BungeeUntil"+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"7] "+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"cDisable BungeeUntil!");
+		try {
+			setStaticFinalValue(PipelineUtils.class.getDeclaredField("SERVER_CHILD"), dinti);
+		}
+		catch (Exception ex) {
+			ex.printStackTrace();
+			BungeeCord.getInstance().getConsole().sendMessage(""+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"7[BungeeUntil"+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"7] "+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"cError while setting default ConnectionHandler.");
+			BungeeCord.getInstance().getConsole().sendMessage(""+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"7[BungeeUntil"+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"7] "+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"cRestarting BungeeCord!");
+			BungeeCord.getInstance().stop();
+			return;
+		}
+		BungeeCord.getInstance().getPluginManager().unregisterListeners(BungeeUtil.getPluginInstance()); //TODO onley bungeeutil
+		BungeeUtil.getInstance().disable();
+		for (ProxiedPlayer p : BungeeCord.getInstance().getPlayers())
+			p.disconnect(""+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"cBungeeUntil Class error");
+		BungeeCord.getInstance().getConsole().sendMessage(""+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"7[BungeeUntil"+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"7] "+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"cBungeeUntil is disabled!");
+	}
+	
+	public T createInitialHandler(Channel ch, Encoder e, Decoder d) throws Exception {
+		return (T) this.cons.newInstance(new Object[] { ProxyServer.getInstance(), ch.attr(PipelineUtils.LISTENER).get(), d, e });
+	}
+	
+	private void setStaticFinalValue(Field f, Object n) throws Exception {
+		f.setAccessible(true);
+		Field modifiersField = Field.class.getDeclaredField("modifiers");
+		modifiersField.setAccessible(true);
+		modifiersField.setInt(f, f.getModifiers() & 0xFFFFFFEF);
+		f.set(null, n);
+	}
+}
diff --git a/src/main/java/dev/wolveringer/network/channel/init/ChannelInizializer.java b/src/main/java/dev/wolveringer/network/channel/init/ChannelInizializer.java
new file mode 100644
index 0000000..e6d8d05
--- /dev/null
+++ b/src/main/java/dev/wolveringer/network/channel/init/ChannelInizializer.java
@@ -0,0 +1,59 @@
+package dev.wolveringer.network.channel.init;
+
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelInitializer;
+
+import java.lang.reflect.Field;
+import java.lang.reflect.Modifier;
+
+import net.md_5.bungee.BungeeCord;
+import net.md_5.bungee.netty.PipelineUtils;
+import dev.wolveringer.BungeeUtil.BungeeUtil;
+import dev.wolveringer.chat.ChatColor.ChatColorUtils;
+import dev.wolveringer.network.IIInitialHandler;
+
+public abstract class ChannelInizializer extends ChannelInitializer<Channel> {
+	private static ChannelInizializer init;
+	
+	public static ChannelInizializer getChannelInitializer(){
+		return init;
+	}
+	
+	public static void setChannelInitializer(ChannelInizializer init) {
+		BungeeUtil.getInstance().sendMessage("Set channel inizializer to "+init.getClass().getName());
+		ChannelInizializer.init = init;
+	}
+	
+	@Override
+	protected void initChannel(Channel channel) throws Exception {
+		ChannelInizializer.init.initialize(channel);
+	}
+	
+	public abstract void initialize(Channel channel) throws Exception;
+	
+	public static void init() {
+		if(init == null)
+			setChannelInitializer(new BungeeUtilChannelInit<IIInitialHandler>(IIInitialHandler.class));
+		try {
+			setStaticFinalValue(PipelineUtils.class.getDeclaredField("SERVER_CHILD"), new ChannelInizializer() {
+				@Override
+				public void initialize(Channel channel) throws Exception {
+					throw new NullPointerException();
+				}
+			});
+		}
+		catch (Exception e) {
+			e.printStackTrace();
+			BungeeCord.getInstance().getConsole().sendMessage(ChatColorUtils.COLOR_CHAR+"e"+ChatColorUtils.COLOR_CHAR+"7[BungeeUntil"+ChatColorUtils.COLOR_CHAR+"7] "+ChatColorUtils.COLOR_CHAR+"cError while loading ProtocolLIB "+ChatColorUtils.COLOR_CHAR+"4Code: 002");
+			BungeeCord.getInstance().getConsole().sendMessage(ChatColorUtils.COLOR_CHAR+"e"+ChatColorUtils.COLOR_CHAR+"7[BungeeUntil"+ChatColorUtils.COLOR_CHAR+"7] "+ChatColorUtils.COLOR_CHAR+"cDisable ProtocolLIB");
+		}
+	}
+	
+	private static void setStaticFinalValue(Field f, Object n) throws Exception {
+		f.setAccessible(true);
+		Field modifiersField = Field.class.getDeclaredField("modifiers");
+		modifiersField.setAccessible(true);
+		modifiersField.setInt(f, f.getModifiers() & ~Modifier.FINAL);
+		f.set(null, n);
+	}
+}
diff --git a/src/main/java/dev/wolveringer/network/inject/XChannelFutureListener.java b/src/main/java/dev/wolveringer/network/inject/XChannelFutureListener.java
new file mode 100644
index 0000000..3c44458
--- /dev/null
+++ b/src/main/java/dev/wolveringer/network/inject/XChannelFutureListener.java
@@ -0,0 +1,47 @@
+package dev.wolveringer.network.inject;
+
+import io.netty.channel.ChannelFuture;
+import io.netty.channel.ChannelFutureListener;
+import net.md_5.bungee.BungeeCord;
+import net.md_5.bungee.BungeeServerInfo;
+import net.md_5.bungee.UserConnection;
+import net.md_5.bungee.api.Callback;
+import net.md_5.bungee.api.ProxyServer;
+import net.md_5.bungee.api.config.ServerInfo;
+
+public class XChannelFutureListener implements ChannelFutureListener {
+	Callback<Boolean> callback;
+	UserConnection conn;
+	BungeeServerInfo target;
+	boolean retry;
+
+	public XChannelFutureListener(Callback<Boolean> callback, UserConnection conn, BungeeServerInfo target, boolean retry) {
+		this.callback = callback;
+		this.conn = conn;
+		this.target = target;
+		this.retry = retry;
+	}
+
+	public void operationComplete(ChannelFuture future) throws Exception {
+		if(callback != null){
+			callback.done(Boolean.valueOf(future.isSuccess()), future.cause());
+		}
+		if(future.isSuccess()){
+			
+			return;
+		}
+		future.channel().close();
+		conn.getPendingConnects().remove(target);
+
+		ServerInfo def = (ServerInfo) ProxyServer.getInstance().getServers().get(conn.getPendingConnection().getListener().getFallbackServer());
+		if((retry) && (target != def) && (((conn.getServer() == null) || (def != conn.getServer().getInfo())))){
+			conn.sendMessage(BungeeCord.getInstance().getTranslation("fallback_lobby", new Object[0]));
+			conn.connect(def, null, false);
+
+		}else if(conn.isDimensionChange()){
+			conn.disconnect(BungeeCord.getInstance().getTranslation("fallback_kick", new Object[] { future.cause().getClass().getName() }));
+		}else{
+			conn.sendMessage(BungeeCord.getInstance().getTranslation("fallback_kick", new Object[] { future.cause().getClass().getName() }));
+		}
+	}
+}
diff --git a/src/main/java/dev/wolveringer/network/inject/XChannelInitializer.java b/src/main/java/dev/wolveringer/network/inject/XChannelInitializer.java
new file mode 100644
index 0000000..beb258a
--- /dev/null
+++ b/src/main/java/dev/wolveringer/network/inject/XChannelInitializer.java
@@ -0,0 +1,33 @@
+package dev.wolveringer.network.inject;
+
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelInitializer;
+import net.md_5.bungee.BungeeCord;
+import net.md_5.bungee.BungeeServerInfo;
+import net.md_5.bungee.ServerConnector;
+import net.md_5.bungee.UserConnection;
+import net.md_5.bungee.api.config.ServerInfo;
+import net.md_5.bungee.netty.HandlerBoss;
+import net.md_5.bungee.netty.PipelineUtils;
+import net.md_5.bungee.protocol.MinecraftEncoder;
+import net.md_5.bungee.protocol.Protocol;
+import net.md_5.bungee.protocol.ProtocolConstants.Direction;
+import dev.wolveringer.network.Decoder;
+import dev.wolveringer.network.IInitialHandler;
+
+public class XChannelInitializer extends ChannelInitializer<Channel> {
+	UserConnection conn;
+	ServerInfo target;
+
+	public XChannelInitializer(UserConnection conn, ServerInfo target) {
+		this.conn = conn;
+		this.target = target;
+	}
+
+	public void initChannel(Channel ch) throws Exception {
+		PipelineUtils.BASE.initChannel(ch);
+		ch.pipeline().addAfter("frame-decoder", "packet-decoder", new Decoder(Protocol.HANDSHAKE, false, conn.getPendingConnection().getVersion(),(IInitialHandler) conn.getPendingConnection(),Direction.TO_CLIENT)); //
+		ch.pipeline().addAfter("frame-prepender", "packet-encoder", new MinecraftEncoder(Protocol.HANDSHAKE, false, conn.getPendingConnection().getVersion()));
+		((HandlerBoss) ch.pipeline().get(HandlerBoss.class)).setHandler(new ServerConnector(BungeeCord.getInstance(), conn, (BungeeServerInfo) target));
+	}
+}
diff --git a/src/main/java/dev/wolveringer/packet/ByteBuffCreator.java b/src/main/java/dev/wolveringer/packet/ByteBuffCreator.java
new file mode 100644
index 0000000..0a9fd4b
--- /dev/null
+++ b/src/main/java/dev/wolveringer/packet/ByteBuffCreator.java
@@ -0,0 +1,32 @@
+package dev.wolveringer.packet;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import dev.wolveringer.BungeeUtil.configuration.Configuration;
+
+public class ByteBuffCreator {
+	@SuppressWarnings("serial")
+	private static final class ByteBuffTypeNotFoundException extends RuntimeException {
+		ByteBuffTypeNotFoundException(String message) {
+			super(message);
+		}
+	}
+
+	public static ByteBuf createByteBuff() {
+		switch (Configuration.getByteBuffType().toLowerCase()) {
+			case "direct":
+				return Unpooled.directBuffer();
+			case "heap":
+				return Unpooled.buffer();
+			default:
+				throw new ByteBuffTypeNotFoundException("ByteBuff Type '" + Configuration.getByteBuffType().toLowerCase() + "' is missing");
+		}
+	}
+
+	public static void copy(ByteBuf from, ByteBuf to) {
+		byte[] buff = new byte[from.readableBytes()];
+		from.readBytes(buff);
+		to.writeBytes(buff);
+
+	}
+}
diff --git a/src/main/java/dev/wolveringer/packet/DebugMenue.java b/src/main/java/dev/wolveringer/packet/DebugMenue.java
new file mode 100644
index 0000000..a3aa3d0
--- /dev/null
+++ b/src/main/java/dev/wolveringer/packet/DebugMenue.java
@@ -0,0 +1,356 @@
+package dev.wolveringer.packet;
+
+import net.md_5.bungee.BungeeCord;
+import net.md_5.bungee.api.chat.TextComponent;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Random;
+import java.util.concurrent.TimeUnit;
+
+import dev.wolveringer.BungeeUtil.BungeeUtil;
+import dev.wolveringer.BungeeUtil.ClientVersion.BigClientVersion;
+import dev.wolveringer.BungeeUtil.CostumPrintStream;
+import dev.wolveringer.BungeeUtil.Material;
+import dev.wolveringer.BungeeUtil.Player;
+import dev.wolveringer.BungeeUtil.gameprofile.GameProfile;
+import dev.wolveringer.BungeeUtil.gameprofile.Property;
+import dev.wolveringer.BungeeUtil.gameprofile.PropertyMap;
+import dev.wolveringer.BungeeUtil.gameprofile.Skin;
+import dev.wolveringer.BungeeUtil.gameprofile.SkinFactory;
+import dev.wolveringer.BungeeUtil.item.Item;
+import dev.wolveringer.BungeeUtil.item.ItemStack;
+import dev.wolveringer.BungeeUtil.packets.Packet;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayOutBossBar.BarColor;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayOutBossBar.BarDivision;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayOutScoreboardDisplayObjective.Position;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayOutScoreboardObjective.Type;
+import dev.wolveringer.NPC.InteractListener;
+import dev.wolveringer.NPC.NPC;
+import dev.wolveringer.animations.inventory.InventoryViewChangeAnimations;
+import dev.wolveringer.animations.inventory.InventoryViewChangeAnimations.AnimationType;
+import dev.wolveringer.animations.inventory.LimetedScheduller;
+import dev.wolveringer.api.bossbar.BossBarManager.BossBar;
+import dev.wolveringer.api.datawatcher.HumanDataWatcher;
+import dev.wolveringer.api.gui.AnvilGui;
+import dev.wolveringer.api.gui.AnvilGuiListener;
+import dev.wolveringer.api.inventory.Inventory;
+import dev.wolveringer.api.inventory.ItemContainer;
+import dev.wolveringer.api.particel.ParticleEffect;
+import dev.wolveringer.api.position.Location;
+import dev.wolveringer.api.scoreboard.Scoreboard;
+import dev.wolveringer.api.sound.SoundEffect;
+import dev.wolveringer.chat.ChatColor.ChatColorUtils;
+import dev.wolveringer.chat.ChatComponentText;
+import dev.wolveringer.chat.ChatSerializer;
+import dev.wolveringer.profiler.ProfileMenue;
+import dev.wolveringer.profiler.Profiler;
+
+public class DebugMenue {
+	public static void open(Player player){
+		Profiler.packet_handle.start("buildDebugInventory");
+		final Inventory inv = new Inventory(27, ChatColorUtils.COLOR_CHAR + "b" + ChatColorUtils.COLOR_CHAR + "lDeveloper Menue");
+		
+		player.openInventory(inv);
+		ItemStack i = new ItemStack(Material.DIAMOND) {
+			@Override
+			public void click(final Click p) {
+				p.getPlayer().openInventory(ProfileMenue.getProfilerMenue().getMenue());
+			}
+		};
+		i.getItemMeta().setGlow(true);
+		i.getItemMeta().setDisplayName(ChatColorUtils.COLOR_CHAR + "bYEY");
+		i.getItemMeta().setLore(Arrays.asList(ChatColorUtils.COLOR_CHAR + "aDieser Server nutzt", ChatColorUtils.COLOR_CHAR + "adein Plugin: ", " " + ChatColorUtils.COLOR_CHAR + "7- " + ChatColorUtils.COLOR_CHAR + "eBungeeUntil", " " + ChatColorUtils.COLOR_CHAR + "7- " + ChatColorUtils.COLOR_CHAR + "eVerion " + ChatColorUtils.COLOR_CHAR + "b" + BungeeUtil.getPluginInstance().getDescription().getVersion()));
+		inv.setItem(1, i);
+		
+		i = new ItemStack(159, 1, (short) 14) {
+			@Override
+			public void click(final Click p) {
+				p.getPlayer().closeInventory();
+				final Location target = p.getPlayer().getLocation().clone();
+				new LimetedScheduller(5, TimeUnit.SECONDS, 75, TimeUnit.MILLISECONDS) {
+					@Override
+					public void run(int count) {
+						double steps = 0.125;
+						double max = 16.5;
+						for (double d = 0; d < max; d += steps) {
+							ParticleEffect.REDSTONE.display(new ParticleEffect.OrdinaryColor((int) (0xFF * (((d + count * 2 * steps) % max) / max)), 0x00, (int) (0xFF - 0xFF * (((d + count * 2 * steps) % max) / max))), target.clone().add(target.getDirection().multiply(d)).add(0D, 2 + 1.6D, 0D), p.getPlayer());
+						}
+					}
+				}.start();
+				p.getPlayer().sendMessage(ChatColorUtils.COLOR_CHAR + "7Deine Location: " + ChatColorUtils.COLOR_CHAR + "aX: " + ChatColorUtils.COLOR_CHAR + "b" + p.getPlayer().getLocation().getX() + " " + ChatColorUtils.COLOR_CHAR + "aY: " + ChatColorUtils.COLOR_CHAR + "b" + p.getPlayer().getLocation().getY() + " " + ChatColorUtils.COLOR_CHAR + "aZ: " + ChatColorUtils.COLOR_CHAR + "b" + p.getPlayer().getLocation().getZ() + " " + ChatColorUtils.COLOR_CHAR + "7[" + ChatColorUtils.COLOR_CHAR + "aYaw: " + ChatColorUtils.COLOR_CHAR + "b" + p.getPlayer().getLocation().getYaw() + ChatColorUtils.COLOR_CHAR + "7, " + ChatColorUtils.COLOR_CHAR + "aPitch: " + ChatColorUtils.COLOR_CHAR + "b" + p.getPlayer().getLocation().getPitch() + ChatColorUtils.COLOR_CHAR + "7]");
+				ParticleEffect.FIREWORKS_SPARK.display(0F, 0F, 10F, 0.1F, 10, p.getPlayer().getLocation().add(0, 0, 1), p.getPlayer());
+				final NPC c = new NPC();
+				c.setName(ChatColorUtils.COLOR_CHAR + "aThis is an testing");
+				c.setLocation(p.getPlayer().getLocation().add(0, 2, 0));
+				c.addListener(new InteractListener() {
+					@Override
+					public void rightClick(Player p) {
+						p.sendMessage("rightClick");
+					}
+					
+					@Override
+					public void leftClick(Player p) {
+						p.sendMessage("leftClick");
+					}
+				});
+				c.setPing(2000);
+				c.setTabListed(true);
+				c.setPlayerListName(ChatSerializer.fromMessage(ChatColorUtils.COLOR_CHAR + "7[NCP] " + ChatColorUtils.COLOR_CHAR + "bEntityID: " + ChatColorUtils.COLOR_CHAR + "a" + c.getEntityID()));
+				c.getEquipment().setItemInHand(p.getPlayer().getHandItem());
+				if (p.getPlayer().getVersion().getBigVersion() == BigClientVersion.v1_9) {
+					Item i = p.getPlayer().getOffHandItem();
+					if (i != null) c.getEquipment().setItemInOffHand(i);
+				}
+				c.getEquipment().setHelmet(new dev.wolveringer.BungeeUtil.item.Item(Material.LEATHER_HELMET));
+				Skin s = SkinFactory.getSkin("WolverinGER");
+				BungeeUtil.getInstance().sendMessage(s + "");
+				
+				GameProfile profile = s.applay(c.getProfile());
+				
+				BungeeUtil.getInstance().sendMessage(s + "");
+				BungeeUtil.getInstance().sendMessage(profile + "");
+				
+				c.setProfile(profile);
+				c.setVisiable(p.getPlayer(), true);
+				ParticleEffect.HEART.display(0F, 0F, 1F, 0F, 1, c.getLocation(), p.getPlayer());
+				p.getPlayer().sendMessage("NCP is visiable");
+				
+				NPC npc = new NPC();
+				npc.setPing(1);
+		        npc.setPlayerListName(new ChatComponentText("\u00A7a-----NPC----"));
+		        npc.setTabListed(true);
+		        Item item = new Item(Material.WATCH);
+		        item.getItemMeta().setGlow(true);
+		        npc.getEquipment().setItemInHand(item);
+		        PropertyMap pm = new PropertyMap();
+		        pm.put("\u00A7c\u795E\u5947\u7684NPC", new Property("textures",
+		                "eyJ0aW1lc3RhbXAiOjE0NTg0NTMxNjM3MDksInByb2ZpbGVJZCI6ImNhZWZmYmFhMzdhZDRhYjI5Mjg5NGQxZDEzOTk4YTg5IiwicHJvZmlsZU5hbWUiOiJ3YXlfX3plciIsInNpZ25hdHVyZVJlcXVpcmVkIjp0cnVlLCJ0ZXh0dXJlcyI6eyJTS0lOIjp7InVybCI6Imh0dHA6Ly90ZXh0dXJlcy5taW5lY3JhZnQubmV0L3RleHR1cmUvYmQzYzdmN2E3ZjIyZTU5NDIxYzRkZDI3NjY2ZDVlZTlmYzc4MTEwODE3MTU3MmQxYzRlMzZkMzhmMjZjOWQzIn19fQ==",
+		                "ofNqZSqPhaWL4b8mHRUpv+vUVw3bqXH1mhvoZzyaxXOTE4TqXfapJRTmct4KV5r25ezW9in9zryaadGX4yueERYZzUkVj5MJqduI44z/rqc1oy4NSTqRAHzaka6PWD/DZyG8kySKhDXBhwEKKeGTHUAeohbLtyfvs3FRLxMf6GkyEzibM32hj65eln9itaqKH6uU9l7bzjPfNx3RlLOg2LbmdBIajXffSDQBgklSOg/v/7OiD5fXYREWzYPNex5Iiw8id0NFTTpQE4Dvrv31ijXcnWsS4Mp62+zPYponsloPynZ9AqQaXVeuLJQhSwJktkavThqz9dfaS9+IGn1Ko7AUhFyLxWjqbet6M7sKd29sqlWbdxB8LMh6I+RMNb9Tx4yKa0EeedFHXfYMaURs2TdPMO2QtiM3nG+IieaXaZwh64wyf/u3iuu3sNd4/s1JmOM9nVYvVaIQVsT80HW/NQwz/N+ufJOh4L7unTt/Jlwm4DkldaTKzUiuVLB4ypYON2/Pa1dXBgRZbU7dCwjXuAL/Cox1UKqYcq3uEuCKhBWYFdEe2p7NDNTuFhjX38MP+h94SlFjbfaSpzDegjr92qO8r41JqpcyewQYI2fkwk8Ju9AJDMTpeoA6ofHEzAMhajXkViKvUPoPbl4HUDvtRBZu5k8dggWKQ83v1UXsDxQ="));
+		        npc.getProfile().setProperties(pm);
+		        HumanDataWatcher dw = npc.getDatawatcher();
+		        dw.setParicelColor(1224755642);
+		        dw.setSkinFlags((byte) 127);
+		        npc.setName("\u00A7c\u795E\u5947\u7684NPC");
+		        npc.addListener(new InteractListener() {
+
+		            @Override
+		            public void rightClick(Player p) {
+		                    p.sendMessage(new TextComponent("\u00A7c\u00A7l[NPC] \u00A7cHI! \u00A7c\u00A7l" + p.getDisplayName() + "  \u00A7c\u00A7l\u8BF7\u5148\u767B\u5F55,\u518D\u5C1D\u8BD5\u6253\u5F00"));
+		            }
+
+		            @Override
+		            public void leftClick(Player p) {
+		                p.sendMessage(new TextComponent("\u00A7c\u00A7l[NPC] \u00A7cHI! \u00A7c\u00A7l" + p.getDisplayName() + "  \u00A7a\u6B22\u8FCE\u6765\u5230MFT\u670D\u52A1\u5668"));
+		            }
+		        });
+
+		        npc.setLocation(p.getPlayer().getLocation().add(0, 5, 0));
+		        npc.setVisiable(p.getPlayer(), true);
+			}
+		};
+		i.getItemMeta().setDisplayName(ChatColorUtils.COLOR_CHAR + "aTesting");
+		inv.setItem(3, i);
+		
+		final ItemStack is = new ItemStack(Material.WATCH, 1, (short) 0) {
+			@Override
+			public void click(final Click p) {
+				final Scoreboard s = p.getPlayer().getScoreboard();
+				if (s.getObjektive("test") == null) {
+					s.createObjektive("test", Type.INTEGER);
+					s.getObjektive("test").setScore("\u00A7a-----------", -1);
+					s.getObjektive("test").setScore("\u00A7aHello world", -2);
+					s.getObjektive("test").display(Position.SIDEBAR);
+					s.getObjektive("test").setDisplayName(ChatColorUtils.COLOR_CHAR + "athis is an test");
+				}
+				else {
+					s.removeObjektive("test");
+				}
+				if (p.getPlayer().getVersion().getBigVersion() != BigClientVersion.v1_8) {
+					BossBar var0 = null;
+					
+					var0 = p.getPlayer().getBossBarManager().createNewBossBar();
+					var0.setColor(BarColor.GREEN);
+					var0.setDivision(BarDivision.NO_DIVISION);
+					var0.setHealth(0F);
+					var0.setMessage(ChatSerializer.fromMessage("\u00A7cHello world"));
+					var0.display();
+					
+					p.getPlayer().sendMessage("Your boss bars:");
+					for (BossBar bar : p.getPlayer().getBossBarManager().getActiveBossBars())
+						p.getPlayer().sendMessage("  \u00A77- " + ChatSerializer.toMessage(bar.getMessage()));
+					final BossBar bar = var0;
+					new LimetedScheduller(32, 250, TimeUnit.MILLISECONDS) {
+						int currunt = 0;
+						
+						@Override
+						public void run(int count) {
+							if (s.getObjektive("test") != null) {
+								s.getObjektive("test").removeScore(ChatColorUtils.COLOR_CHAR + Integer.toHexString((currunt) % 16) + "Testing score");
+								currunt += 1;
+								s.getObjektive("test").setScore(ChatColorUtils.COLOR_CHAR + Integer.toHexString(currunt % 16) + "Testing score", currunt % 16);
+							}
+							if (bar != null) {
+								bar.setMessage(ChatSerializer.fromMessage(ChatColorUtils.COLOR_CHAR + Integer.toHexString((currunt) % 16) + "Hello world"));
+								bar.dynamicChangeHealth((float) ((float) count / (float) limit), 250, TimeUnit.MILLISECONDS);
+							}
+						}
+						
+						@Override
+						public void done() {
+							s.removeObjektive("test");
+							if (bar != null) {
+								bar.setColor(BarColor.RED);
+								BungeeCord.getInstance().getScheduler().runAsync(BungeeUtil.getPluginInstance(), new Runnable() {
+									@Override
+									public void run() {
+										try {
+											Thread.sleep(500);
+										}
+										catch (InterruptedException e) {
+										}
+										p.getPlayer().getBossBarManager().deleteBossBar(bar);
+									}
+								});
+							}
+						}
+					}.start();
+				}
+				p.getPlayer().sendMessage("Cleaning Space!");
+				System.gc();
+				p.getPlayer().sendMessage("Cleaning Space done!");
+				p.getPlayer().closeInventory();
+				
+				final Inventory base = new Inventory(45, "SEXY");
+				base.fill(new ItemStack(new Item(Material.NAME_TAG)) {
+					@Override
+					public void click(Click click) {
+					}
+				});
+				p.getPlayer().openInventory(base);
+				final ItemContainer container = new ItemContainer(27);
+				container.fill(new Item(Material.BARRIER));
+				BungeeCord.getInstance().getScheduler().schedule(BungeeUtil.getPluginInstance(), new Runnable() {
+					public void run() {
+						InventoryViewChangeAnimations.runAnimation(AnimationType.SCROLL_LEFT, base, container, "sexy", new Item(Material.BEDROCK), 500);
+					}
+				}, 500, TimeUnit.MILLISECONDS);
+			}
+		};
+		
+		is.getItemMeta().setDisplayName(ChatColorUtils.COLOR_CHAR + "7##### " + ChatColorUtils.COLOR_CHAR + "eStatistics " + ChatColorUtils.COLOR_CHAR + "7[" + ChatColorUtils.COLOR_CHAR + "aMB" + ChatColorUtils.COLOR_CHAR + "7] #####");
+		
+		BungeeCord.getInstance().getScheduler().runAsync(BungeeUtil.getPluginInstance(), new Runnable() {
+			@Override
+			public void run() {
+				int mb = 1024 * 1024;
+				int c = 0;
+				while (inv.getViewer().size() > 0) {
+					try {
+						Thread.sleep(500);
+					}
+					catch (InterruptedException e) {
+					}
+					Runtime runtime = Runtime.getRuntime();
+					List<String> a = new ArrayList<String>();
+					a.add(ChatColorUtils.COLOR_CHAR + "6Used Memory: " + ChatColorUtils.COLOR_CHAR + "e" + format((runtime.totalMemory() - runtime.freeMemory())));
+					a.add(ChatColorUtils.COLOR_CHAR + "6Free Memory: " + ChatColorUtils.COLOR_CHAR + "e" + format(runtime.freeMemory()));
+					a.add(ChatColorUtils.COLOR_CHAR + "6Total Memory: " + ChatColorUtils.COLOR_CHAR + "e" + format(runtime.totalMemory()));
+					a.add(ChatColorUtils.COLOR_CHAR + "6Max Memory: " + ChatColorUtils.COLOR_CHAR + "e" + format(runtime.maxMemory()));
+					a.add(ChatColorUtils.COLOR_CHAR + "6System: " + ChatColorUtils.COLOR_CHAR + "e" + System.getProperty("os.name"));
+					is.getItemMeta().setLore(a);
+					inv.setName(ChatColorUtils.COLOR_CHAR + "" + Integer.toHexString(new Random().nextInt(15) % 15) + ChatColorUtils.COLOR_CHAR + "lDeveloper Menue");
+					c++;
+				}
+			}
+			
+			private String format(long l) {
+				return (l / (1014 * 1024)) + "MB " + ((l / 1024) % 1024) + "KB " + (l % 1024) + "B";
+			}
+		});
+		inv.setItem(7, is);
+		
+		ItemStack is_ = new ItemStack(player.getVersion().getBigVersion() == BigClientVersion.v1_7 ? Material.FIRE : Material.BARRIER, 1) {
+			public void click(Click p) {
+				throw new RuntimeException("Demo Crash");
+			};
+		};
+		is_.getItemMeta().setDisplayName(ChatColorUtils.COLOR_CHAR + "cTest Crash Disconnect");
+		inv.setItem(22, is_);
+		
+		ItemStack is1 = new ItemStack(Material.COMPASS) {
+			@Override
+			public void click(Click p) {
+				p.getPlayer().sendMessage("Sound sended");
+				if(SoundEffect.BLOCK_ANVIL_FALL.isAvariable(p.getPlayer().getVersion().getBigVersion()))
+					p.getPlayer().playSound(SoundEffect.BLOCK_ANVIL_LAND, p.getPlayer().getLocation(), 1F, 0);
+				else
+					p.getPlayer().sendMessage("Sound not avariable for "+p.getPlayer().getVersion().toString());
+				//p.getPlayer().playSound(SoundEffect.getEffect("block.anvil.land"), SoundCategory.MASTER, p.getPlayer().getLocation(), 1F, 0);
+			}
+		};
+		final ArrayList<String> out = new ArrayList<String>();
+		Packet.listPackets(new CostumPrintStream() {
+			@Override
+			public void println(String s) {
+				out.add(s);
+			}
+			
+			@Override
+			public void print(String s) {
+				out.add(s);
+			}
+		});
+		is1.getItemMeta().setDisplayName(out.get(0));
+		is1.getItemMeta().setLore(out.subList(1, out.size()));
+		inv.setItem(5, is1);
+		
+		i = new ItemStack(Material.EMERALD){
+			@Override
+			public void click(final Click click) {
+				click.getPlayer().sendMessage("Open anvil menue");
+				AnvilGui guy = new AnvilGui(click.getPlayer());
+				guy.addListener(new AnvilGuiListener() {
+					@Override
+					public void onMessageChange(AnvilGui guy, String newMessage) {
+				    	//Changing text color
+				    	if ("HelloWorld #Yolo".startsWith(newMessage)){
+				    		guy.setColorPrefix("\u00A76");
+				    		guy.setCenterItem(new Item(Material.getMaterial(351),1,(byte)10));
+						}
+						else if(newMessage.startsWith("HelloWorld #Yolo")){
+							guy.setColorPrefix("\u00A7a");
+							guy.setCurruntInput("You did it!");
+						}
+						else{
+							guy.setColorPrefix("\u00A7c");
+							guy.setCenterItem(new Item(Material.getMaterial(351),1,(byte)1));
+						}
+				    	
+				    	//Update output item ;)
+						Item item = new Item(Material.ENCHANTED_BOOK);
+				    	item.getItemMeta().setDisplayName("\u00A7aYour message: \u00A7e" + (newMessage.length() == 0 ? "\u00A7cNo message" : newMessage));
+				    	guy.setOutputItem(item);
+					}
+					
+					@Override
+					public void onConfirmInput(AnvilGui guy, String message) {
+						click.getPlayer().sendMessage("You confirmed you input. Your input: "+message);
+						click.getPlayer().closeInventory();
+					}
+					
+					@Override
+					public void onClose(AnvilGui guy) {
+						click.getPlayer().sendMessage("Your last input wars: "+guy.getCurruntInput());
+					}
+				});
+				guy.open();
+			}
+		};
+		i.getItemMeta().setDisplayName("\u00A7aTesting anvil guy");
+		inv.setItem(10, i);
+		
+		Profiler.packet_handle.stop("buildDebugInventory");
+	}
+}
diff --git a/src/main/java/dev/wolveringer/packet/MathHelper_v1_8.java b/src/main/java/dev/wolveringer/packet/MathHelper_v1_8.java
new file mode 100644
index 0000000..19e2195
--- /dev/null
+++ b/src/main/java/dev/wolveringer/packet/MathHelper_v1_8.java
@@ -0,0 +1,232 @@
+package dev.wolveringer.packet;
+
+import java.util.Random;
+import java.util.UUID;
+
+public class MathHelper_v1_8 {
+	public static final float a = sqrt(2.0F);
+	private static final float[] b = new float[65536];
+
+	static{
+		for(int i = 0;i < 65536;i++){
+			b[i] = ((float) Math.sin(i * 3.141592653589793D * 2.0D / 65536.0D));
+		}
+	}
+
+	public static float sin(float paramFloat) {
+		return b[((int) (paramFloat * 10430.378F) & 0xFFFF)];
+	}
+
+	public static float cos(float paramFloat) {
+		return b[((int) (paramFloat * 10430.378F + 16384.0F) & 0xFFFF)];
+	}
+
+	public static float sqrt(float paramFloat) {
+		return (float) Math.sqrt(paramFloat);
+	}
+
+	public static float sqrt(double paramDouble) {
+		return (float) Math.sqrt(paramDouble);
+	}
+
+	public static int d(float paramFloat) {
+		int i = (int) paramFloat;
+		return paramFloat < i ? i - 1 : i;
+	}
+
+	public static int floor(double paramDouble) {
+		int i = (int) paramDouble;
+		return paramDouble < i ? i - 1 : i;
+	}
+
+	public static float e(float paramFloat) {
+		return paramFloat >= 0.0F ? paramFloat : -paramFloat;
+	}
+
+	public static int a(int paramInt) {
+		return paramInt >= 0 ? paramInt : -paramInt;
+	}
+
+	public static int f(float paramFloat) {
+		int i = (int) paramFloat;
+		return paramFloat > i ? i + 1 : i;
+	}
+
+	public static int f(double paramDouble) {
+		int i = (int) paramDouble;
+		return paramDouble > i ? i + 1 : i;
+	}
+
+	public static int clamp(int paramInt1, int paramInt2, int paramInt3) {
+		if(paramInt1 < paramInt2){
+			return paramInt2;
+		}
+		if(paramInt1 > paramInt3){
+			return paramInt3;
+		}
+		return paramInt1;
+	}
+
+	public static float a(float paramFloat1, float paramFloat2, float paramFloat3) {
+		if(paramFloat1 < paramFloat2){
+			return paramFloat2;
+		}
+		if(paramFloat1 > paramFloat3){
+			return paramFloat3;
+		}
+		return paramFloat1;
+	}
+
+	public static double a(double paramDouble1, double paramDouble2, double paramDouble3) {
+		if(paramDouble1 < paramDouble2){
+			return paramDouble2;
+		}
+		if(paramDouble1 > paramDouble3){
+			return paramDouble3;
+		}
+		return paramDouble1;
+	}
+
+	public static double b(double paramDouble1, double paramDouble2, double paramDouble3) {
+		if(paramDouble3 < 0.0D){
+			return paramDouble1;
+		}
+		if(paramDouble3 > 1.0D){
+			return paramDouble2;
+		}
+		return paramDouble1 + (paramDouble2 - paramDouble1) * paramDouble3;
+	}
+
+	public static double a(double paramDouble1, double paramDouble2) {
+		if(paramDouble1 < 0.0D){
+			paramDouble1 = -paramDouble1;
+		}
+		if(paramDouble2 < 0.0D){
+			paramDouble2 = -paramDouble2;
+		}
+		return paramDouble1 > paramDouble2 ? paramDouble1 : paramDouble2;
+	}
+
+	public static int nextInt(Random paramRandom, int paramInt1, int paramInt2) {
+		if(paramInt1 >= paramInt2){
+			return paramInt1;
+		}
+		return paramRandom.nextInt(paramInt2 - paramInt1 + 1) + paramInt1;
+	}
+
+	public static float a(Random paramRandom, float paramFloat1, float paramFloat2) {
+		if(paramFloat1 >= paramFloat2){
+			return paramFloat1;
+		}
+		return paramRandom.nextFloat() * (paramFloat2 - paramFloat1) + paramFloat1;
+	}
+
+	public static double a(Random paramRandom, double paramDouble1, double paramDouble2) {
+		if(paramDouble1 >= paramDouble2){
+			return paramDouble1;
+		}
+		return paramRandom.nextDouble() * (paramDouble2 - paramDouble1) + paramDouble1;
+	}
+
+	public static double a(long[] paramArrayOfLong) {
+		long l1 = 0L;
+		for(long l2 : paramArrayOfLong){
+			l1 += l2;
+		}
+		return l1 / paramArrayOfLong.length;
+	}
+
+	public static float degress180(float paramFloat) {
+		paramFloat %= 360.0F;
+		if(paramFloat >= 180.0F){
+			paramFloat -= 360.0F;
+		}
+		if(paramFloat < -180.0F){
+			paramFloat += 360.0F;
+		}
+		return paramFloat;
+	}
+
+	public static double degress180(double paramDouble) {
+		paramDouble %= 360.0D;
+		if(paramDouble >= 180.0D){
+			paramDouble -= 360.0D;
+		}
+		if(paramDouble < -180.0D){
+			paramDouble += 360.0D;
+		}
+		return paramDouble;
+	}
+
+	public static int a(String paramString, int paramInt) {
+		try{
+			return Integer.parseInt(paramString);
+		}catch (Throwable localThrowable){
+		}
+		return paramInt;
+	}
+
+	public static int a(String paramString, int paramInt1, int paramInt2) {
+		return Math.max(paramInt2, a(paramString, paramInt1));
+	}
+
+	public static double a(String paramString, double paramDouble) {
+		try{
+			return Double.parseDouble(paramString);
+		}catch (Throwable localThrowable){
+		}
+		return paramDouble;
+	}
+
+	public static double a(String paramString, double paramDouble1, double paramDouble2) {
+		return Math.max(paramDouble2, a(paramString, paramDouble1));
+	}
+
+	public static int b(int paramInt) {
+		int i = paramInt - 1;
+		i |= i >> 1;
+		i |= i >> 2;
+		i |= i >> 4;
+		i |= i >> 8;
+		i |= i >> 16;
+		return i + 1;
+	}
+
+	private static boolean d(int paramInt) {
+		return (paramInt != 0) && ((paramInt & paramInt - 1) == 0);
+	}
+
+	private static final int[] c = { 0, 1, 28, 2, 29, 14, 24, 3, 30, 22, 20, 15, 25, 17, 4, 8, 31, 27, 13, 23, 21, 19, 16, 7, 26, 12, 18, 6, 11, 5, 10, 9 };
+
+	private static int e(int paramInt) {
+		paramInt = d(paramInt) ? paramInt : b(paramInt);
+		return c[((int) (paramInt * 125613361L >> 27) & 0x1F)];
+	}
+
+	public static int c(int paramInt) {
+		return e(paramInt) - (d(paramInt) ? 0 : 1);
+	}
+
+	public static int c(int paramInt1, int paramInt2) {
+		if(paramInt2 == 0){
+			return 0;
+		}
+		if(paramInt1 == 0){
+			return paramInt2;
+		}
+		if(paramInt1 < 0){
+			paramInt2 *= -1;
+		}
+		int i = paramInt1 % paramInt2;
+		if(i == 0){
+			return paramInt1;
+		}
+		return paramInt1 + paramInt2 - i;
+	}
+
+	public static UUID a(Random paramRandom) {
+		long l1 = paramRandom.nextLong() & 0xFFFF0FFF | 0x4000;
+		long l2 = paramRandom.nextLong() & 0xFFFFFFFF | 0x0;
+		return new UUID(l1, l2);
+	}
+}
diff --git a/src/main/java/dev/wolveringer/packet/ObjectSereizer.java b/src/main/java/dev/wolveringer/packet/ObjectSereizer.java
new file mode 100644
index 0000000..b9bb37c
--- /dev/null
+++ b/src/main/java/dev/wolveringer/packet/ObjectSereizer.java
@@ -0,0 +1,20 @@
+package dev.wolveringer.packet;
+
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+
+public abstract class ObjectSereizer<T> {
+	Class<T> clazz;
+
+	@SuppressWarnings("unchecked")
+	public ObjectSereizer() {
+		Type[] types = ((ParameterizedType) getClass().getGenericSuperclass()).getActualTypeArguments();
+		clazz = (Class<T>) types[0];
+	}
+	
+	public Class<T> getType(){
+		return clazz;
+	}
+	
+	public abstract void write(T obj,PacketDataSerializer serelizer);
+}
diff --git a/src/main/java/dev/wolveringer/packet/PacketDataSerializer.java b/src/main/java/dev/wolveringer/packet/PacketDataSerializer.java
new file mode 100644
index 0000000..6bfe8ab
--- /dev/null
+++ b/src/main/java/dev/wolveringer/packet/PacketDataSerializer.java
@@ -0,0 +1,885 @@
+package dev.wolveringer.packet;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufAllocator;
+import io.netty.buffer.ByteBufProcessor;
+
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.lang.reflect.Array;
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.nio.channels.GatheringByteChannel;
+import java.nio.channels.ScatteringByteChannel;
+import java.nio.charset.Charset;
+import java.util.ArrayList;
+import java.util.UUID;
+
+import dev.wolveringer.BungeeUtil.ClientVersion;
+import dev.wolveringer.BungeeUtil.item.Item;
+import dev.wolveringer.api.position.BlockPosition;
+import dev.wolveringer.chat.IChatBaseComponent;
+import dev.wolveringer.nbt.NBTTagCompound;
+import dev.wolveringer.util.ByteString;
+
+public abstract class PacketDataSerializer extends ByteBuf {
+	public static long clazz = 0;
+	@SuppressWarnings("rawtypes")
+	private static ArrayList<ObjectSereizer> serelizer = new ArrayList<ObjectSereizer>();
+	
+	static {
+		serelizer.add(new ObjectSereizer<Item>() {
+			@Override
+			public void write(Item obj, PacketDataSerializer serelizer) {
+				serelizer.writeItem(obj);
+			}
+		});
+		serelizer.add(new ObjectSereizer<IChatBaseComponent>() {
+			@Override
+			public void write(IChatBaseComponent obj, PacketDataSerializer serelizer) {
+				serelizer.writeRawString(obj);;
+			}
+		});
+		serelizer.add(new ObjectSereizer<UUID>() {
+			@Override
+			public void write(UUID obj, PacketDataSerializer serelizer) {
+			serelizer.writeUUID(obj);
+			}
+		});
+		serelizer.add(new ObjectSereizer<NBTTagCompound>() {
+			@Override
+			public void write(NBTTagCompound obj, PacketDataSerializer serelizer) {
+				serelizer.writeNBT(obj);
+			}
+		});
+		serelizer.add(new ObjectSereizer<ByteBuf>() {
+			@Override
+			public void write(ByteBuf obj, PacketDataSerializer serelizer) {
+				serelizer.writeBytes(obj.array());
+				obj.release();
+			}
+		});
+		serelizer.add(new ObjectSereizer<BlockPosition>() {
+			@Override
+			public void write(BlockPosition obj, PacketDataSerializer serelizer) {
+				serelizer.writeBlockPosition(obj);
+			}
+		});
+		serelizer.add(new ObjectSereizer<ByteString>() {
+			@Override
+			public void write(ByteString obj, PacketDataSerializer serelizer) {
+				serelizer.writeVarInt(obj.getBytes().length);
+				serelizer.writeBytes(obj.getBytes(), 0, obj.getBytes().length);
+			}
+		});
+	}
+	
+	public static void addObjectSerelizer(ObjectSereizer<?> serelizer){
+		PacketDataSerializer.serelizer.add(serelizer);
+	}
+	
+	@SuppressWarnings({ "unchecked", "rawtypes" })
+	public void write(Object o) {
+		if(o == null)
+			return;
+		for(ObjectSereizer s : serelizer)
+			if(s.getType().isAssignableFrom(o.getClass())){
+				s.write(o, this);
+				return;
+			}
+		if(o instanceof Integer)
+			writeInt((Integer) o);
+		else if(o instanceof String)
+			writeString((String) o);
+		else if(o instanceof Boolean)
+			writeBoolean((Boolean) o);
+		else if(o instanceof Double)
+			writeDouble((Double) o);
+		else if(o instanceof Float)
+			writeFloat((Float) o);
+		else if(o instanceof Long)
+			writeLong((Long) o);
+		else if(o.getClass().isArray()){
+			int length = Array.getLength(o);
+			for(int i = 0;i < length;i++){
+				write(Array.get(o, i));
+			}
+		}else
+			System.err.print("Object \"" + o + "\" don t find");
+	}
+	
+	public static PacketDataSerializer create(ByteBuf b, ClientVersion v) {
+		switch (v.getBigVersion()) {
+			case v1_7:
+				return new PacketDataSerializer_v1_7(b);
+			case v1_8:
+				return new PacketDataSerializer_v1_8(b);
+			case v1_9:
+				return new PacketDataSerializer_v1_8(b);
+			case v1_10:
+				return new PacketDataSerializer_v1_8(b);
+			default:
+				return new PacketDataSerializer_vX_X(b);
+		}
+	}
+
+	public static PacketDataSerializer create(int id, ClientVersion v) {
+		return create(id, v, ByteBuffCreator.createByteBuff());
+	}
+
+	public static PacketDataSerializer create(int b, ClientVersion v,ByteBuf buf) {
+		switch (v.getBigVersion()) {
+			case v1_7:
+				return new PacketDataSerializer_v1_7((byte) b,buf);
+			case v1_8:
+				return new PacketDataSerializer_v1_8((byte) b,buf);
+			case v1_9:
+				return new PacketDataSerializer_v1_8((byte) b,buf);
+			case v1_10:
+				return new PacketDataSerializer_v1_8((byte) b,buf);
+			default:
+				return new PacketDataSerializer_vX_X((byte) b,buf);
+		}
+	}
+	
+	public static PacketDataSerializer create(byte id, ClientVersion version, ByteBuf buf) {
+		return create((int)id,version,buf);
+	}
+	
+	public static int readVarInt(ByteBuf b) {
+		int out = 0;
+		int bytes = 0;
+		byte in;
+		while (true){
+			in = b.readByte();
+			out |= (in & 0x7F) << (bytes++ * 7);
+
+			if(bytes > 5){
+				throw new RuntimeException("VarInt too big");
+			}
+
+			if((in & 0x80) != 0x80){
+				break;
+			}
+		}
+
+		return out;
+	}
+
+	public static void writeVarInt(int value, ByteBuf output) {
+		int part;
+		while (true){
+			part = value & 0x7F;
+
+			value >>>= 7;
+			if(value != 0){
+				part |= 0x80;
+			}
+
+			output.writeByte(part);
+
+			if(value == 0){
+				break;
+			}
+		}
+	}
+
+	public abstract void writeItem(Item i);
+
+	public abstract Item readItem();
+
+	public abstract void writeString(String s);
+
+	public abstract String readString(int max);
+
+	public abstract void writeRawString(IChatBaseComponent s);
+
+	public abstract IChatBaseComponent readRawString();
+
+	public abstract void writeUUID(UUID i);
+
+	public abstract UUID readUUID();
+
+	public abstract void writeNBT(NBTTagCompound c);
+
+	public abstract NBTTagCompound readNBT();
+
+	public abstract void writeBlockPosition(BlockPosition loc);
+
+	public abstract BlockPosition readBlockPosition();
+
+	public ByteString readStringBytes(){
+		byte[] data = new byte[this.readVarInt()];
+		this.readBytes(data, 0, data.length);
+		return new ByteString(data);
+	}
+	public void writeStringBytes(ByteString string){
+		this.writeVarInt(string.getBytes().length);
+		this.writeBytes(string.getBytes(), 0, string.getBytes().length);
+	}
+	
+	public void writeVarInt(int i) {
+		PacketDataSerializer.writeVarInt(i, this);
+	}
+
+	public int readVarInt() {
+		return PacketDataSerializer.readVarInt(this);
+	}
+
+	protected final ByteBuf base;
+	public PacketDataSerializer(ByteBuf a) {
+		clazz++;
+		this.base = a;
+	}
+
+	public int readPositionX(long val) {
+		return (int) (val >> 38);
+	}
+
+	public int readPositionY(long val) {
+		return (int) (val << 26 >> 52);
+	}
+
+	public int readPositionZ(long val) {
+		return (int) (val << 38 >> 38);
+	}
+
+	public int capacity() {
+		return this.base.capacity();
+	}
+
+	public ByteBuf capacity(int i) {
+		return this.base.capacity(i);
+	}
+
+	public int maxCapacity() {
+		return this.base.maxCapacity();
+	}
+
+	public ByteBufAllocator alloc() {
+		return this.base.alloc();
+	}
+
+	public ByteOrder order() {
+		return this.base.order();
+	}
+
+	public ByteBuf order(ByteOrder byteorder) {
+		return this.base.order(byteorder);
+	}
+
+	public ByteBuf unwrap() {
+		return this.base.unwrap();
+	}
+
+	public boolean isDirect() {
+		return this.base.isDirect();
+	}
+
+	public int readerIndex() {
+		return this.base.readerIndex();
+	}
+
+	public ByteBuf readerIndex(int i) {
+		return this.base.readerIndex(i);
+	}
+
+	public int writerIndex() {
+		return this.base.writerIndex();
+	}
+
+	public ByteBuf writerIndex(int i) {
+		return this.base.writerIndex(i);
+	}
+
+	public ByteBuf setIndex(int i, int j) {
+		return this.base.setIndex(i, j);
+	}
+
+	public int readableBytes() {
+		return this.base.readableBytes();
+	}
+
+	public int writableBytes() {
+		return this.base.writableBytes();
+	}
+
+	public int maxWritableBytes() {
+		return this.base.maxWritableBytes();
+	}
+
+	public boolean isReadable() {
+		return this.base.isReadable();
+	}
+
+	public boolean isReadable(int i) {
+		return this.base.isReadable(i);
+	}
+
+	public boolean isWritable() {
+		return this.base.isWritable();
+	}
+
+	public boolean isWritable(int i) {
+		return this.base.isWritable(i);
+	}
+
+	public ByteBuf clear() {
+		return this.base.clear();
+	}
+
+	public ByteBuf markReaderIndex() {
+		return this.base.markReaderIndex();
+	}
+
+	public ByteBuf resetReaderIndex() {
+		return this.base.resetReaderIndex();
+	}
+
+	public ByteBuf markWriterIndex() {
+		return this.base.markWriterIndex();
+	}
+
+	public ByteBuf resetWriterIndex() {
+		return this.base.resetWriterIndex();
+	}
+
+	public ByteBuf discardReadBytes() {
+		return this.base.discardReadBytes();
+	}
+
+	public ByteBuf discardSomeReadBytes() {
+		return this.base.discardSomeReadBytes();
+	}
+
+	public ByteBuf ensureWritable(int i) {
+		return this.base.ensureWritable(i);
+	}
+
+	public int ensureWritable(int i, boolean flag) {
+		return this.base.ensureWritable(i, flag);
+	}
+
+	public boolean getBoolean(int i) {
+		return this.base.getBoolean(i);
+	}
+
+	public byte getByte(int i) {
+		return this.base.getByte(i);
+	}
+
+	public short getUnsignedByte(int i) {
+		return this.base.getUnsignedByte(i);
+	}
+
+	public short getShort(int i) {
+		return this.base.getShort(i);
+	}
+
+	public int getUnsignedShort(int i) {
+		return this.base.getUnsignedShort(i);
+	}
+
+	public int getMedium(int i) {
+		return this.base.getMedium(i);
+	}
+
+	public int getUnsignedMedium(int i) {
+		return this.base.getUnsignedMedium(i);
+	}
+
+	public int getInt(int i) {
+		return this.base.getInt(i);
+	}
+
+	public long getUnsignedInt(int i) {
+		return this.base.getUnsignedInt(i);
+	}
+
+	public long getLong(int i) {
+		return this.base.getLong(i);
+	}
+
+	public char getChar(int i) {
+		return this.base.getChar(i);
+	}
+
+	public float getFloat(int i) {
+		return this.base.getFloat(i);
+	}
+
+	public double getDouble(int i) {
+		return this.base.getDouble(i);
+	}
+
+	public ByteBuf getBytes(int i, ByteBuf bytebuf) {
+		return this.base.getBytes(i, bytebuf);
+	}
+
+	public ByteBuf getBytes(int i, ByteBuf bytebuf, int j) {
+		return this.base.getBytes(i, bytebuf, j);
+	}
+
+	public ByteBuf getBytes(int i, ByteBuf bytebuf, int j, int k) {
+		return this.base.getBytes(i, bytebuf, j, k);
+	}
+
+	public ByteBuf getBytes(int i, byte[] abyte) {
+		return this.base.getBytes(i, abyte);
+	}
+
+	public ByteBuf getBytes(int i, byte[] abyte, int j, int k) {
+		return this.base.getBytes(i, abyte, j, k);
+	}
+
+	public ByteBuf getBytes(int i, ByteBuffer bytebuffer) {
+		return this.base.getBytes(i, bytebuffer);
+	}
+
+	public ByteBuf getBytes(int i, OutputStream outputstream, int j) throws RuntimeException {
+		try{
+			return this.base.getBytes(i, outputstream, j);
+		}catch (java.io.IOException e){
+			e.printStackTrace();
+		}
+		return base;
+	}
+
+	public int getBytes(int i, GatheringByteChannel gatheringbytechannel, int j) throws RuntimeException {
+		try{
+			return this.base.getBytes(i, gatheringbytechannel, j);
+		}catch (java.io.IOException e){
+			e.printStackTrace();
+		}
+		return j;
+	}
+
+	public ByteBuf setBoolean(int i, boolean flag) {
+		return this.base.setBoolean(i, flag);
+	}
+
+	public ByteBuf setByte(int i, int j) {
+		return this.base.setByte(i, j);
+	}
+
+	public ByteBuf setShort(int i, int j) {
+		return this.base.setShort(i, j);
+	}
+
+	public ByteBuf setMedium(int i, int j) {
+		return this.base.setMedium(i, j);
+	}
+
+	public ByteBuf setInt(int i, int j) {
+		return this.base.setInt(i, j);
+	}
+
+	public ByteBuf setLong(int i, long j) {
+		return this.base.setLong(i, j);
+	}
+
+	public ByteBuf setChar(int i, int j) {
+		return this.base.setChar(i, j);
+	}
+
+	public ByteBuf setFloat(int i, float f) {
+		return this.base.setFloat(i, f);
+	}
+
+	public ByteBuf setDouble(int i, double d0) {
+		return this.base.setDouble(i, d0);
+	}
+
+	public ByteBuf setBytes(int i, ByteBuf bytebuf) {
+		return this.base.setBytes(i, bytebuf);
+	}
+
+	public ByteBuf setBytes(int i, ByteBuf bytebuf, int j) {
+		return this.base.setBytes(i, bytebuf, j);
+	}
+
+	public ByteBuf setBytes(int i, ByteBuf bytebuf, int j, int k) {
+		return this.base.setBytes(i, bytebuf, j, k);
+	}
+
+	public ByteBuf setBytes(int i, byte[] abyte) {
+		return this.base.setBytes(i, abyte);
+	}
+
+	public ByteBuf setBytes(int i, byte[] abyte, int j, int k) {
+		return this.base.setBytes(i, abyte, j, k);
+	}
+
+	public ByteBuf setBytes(int i, ByteBuffer bytebuffer) {
+		return this.base.setBytes(i, bytebuffer);
+	}
+
+	public int setBytes(int i, InputStream inputstream, int j) throws RuntimeException {
+		try{
+			return this.base.setBytes(i, inputstream, j);
+		}catch (java.io.IOException e){
+			e.printStackTrace();
+		}
+		return j;
+	}
+
+	public int setBytes(int i, ScatteringByteChannel scatteringbytechannel, int j) throws RuntimeException {
+		try{
+			return this.base.setBytes(i, scatteringbytechannel, j);
+		}catch (java.io.IOException e){
+			e.printStackTrace();
+		}
+		return j;
+	}
+
+	public ByteBuf setZero(int i, int j) {
+		return this.base.setZero(i, j);
+	}
+
+	public boolean readBoolean() {
+		return this.base.readBoolean();
+	}
+
+	public byte readByte() {
+		return this.base.readByte();
+	}
+
+	public short readUnsignedByte() {
+		return this.base.readUnsignedByte();
+	}
+
+	public short readShort() {
+		return this.base.readShort();
+	}
+
+	public int readUnsignedShort() {
+		return this.base.readUnsignedShort();
+	}
+
+	public int readMedium() {
+		return this.base.readMedium();
+	}
+
+	public int readUnsignedMedium() {
+		return this.base.readUnsignedMedium();
+	}
+
+	public int readInt() {
+		return this.base.readInt();
+	}
+
+	public long readUnsignedInt() {
+		return this.base.readUnsignedInt();
+	}
+
+	public long readLong() {
+		return this.base.readLong();
+	}
+
+	public char readChar() {
+		return this.base.readChar();
+	}
+
+	public float readFloat() {
+		return this.base.readFloat();
+	}
+
+	public double readDouble() {
+		return this.base.readDouble();
+	}
+
+	public ByteBuf readBytes(int i) {
+		return this.base.readBytes(i);
+	}
+
+	public ByteBuf readSlice(int i) {
+		return this.base.readSlice(i);
+	}
+
+	public ByteBuf readBytes(ByteBuf bytebuf) {
+		return this.base.readBytes(bytebuf);
+	}
+
+	public ByteBuf readBytes(ByteBuf bytebuf, int i) {
+		return this.base.readBytes(bytebuf, i);
+	}
+
+	public ByteBuf readBytes(ByteBuf bytebuf, int i, int j) {
+		return this.base.readBytes(bytebuf, i, j);
+	}
+
+	public ByteBuf readBytes(byte[] abyte) {
+		return this.base.readBytes(abyte);
+	}
+
+	public ByteBuf readBytes(byte[] abyte, int i, int j) {
+		return this.base.readBytes(abyte, i, j);
+	}
+
+	public ByteBuf readBytes(ByteBuffer bytebuffer) {
+		return this.base.readBytes(bytebuffer);
+	}
+
+	public ByteBuf readBytes(OutputStream outputstream, int i) throws RuntimeException {
+		try{
+			return this.base.readBytes(outputstream, i);
+		}catch (java.io.IOException e){
+			e.printStackTrace();
+		}
+		return base;
+	}
+
+	public int readBytes(GatheringByteChannel gatheringbytechannel, int i) throws RuntimeException {
+		try{
+			return this.base.readBytes(gatheringbytechannel, i);
+		}catch (java.io.IOException e){
+			e.printStackTrace();
+		}
+		return i;
+	}
+
+	public ByteBuf skipBytes(int i) {
+		return this.base.skipBytes(i);
+	}
+
+	public ByteBuf writeBoolean(boolean flag) {
+		return this.base.writeBoolean(flag);
+	}
+
+	public ByteBuf writeByte(int i) {
+		return this.base.writeByte(i);
+	}
+
+	public ByteBuf writeShort(int i) {
+		return this.base.writeShort(i);
+	}
+
+	public ByteBuf writeMedium(int i) {
+		return this.base.writeMedium(i);
+	}
+
+	public ByteBuf writeInt(int i) {
+		return this.base.writeInt(i);
+	}
+
+	public ByteBuf writeLong(long i) {
+		return this.base.writeLong(i);
+	}
+
+	public ByteBuf writeChar(int i) {
+		return this.base.writeChar(i);
+	}
+
+	public ByteBuf writeFloat(float f) {
+		return this.base.writeFloat(f);
+	}
+
+	public ByteBuf writeDouble(double d0) {
+		return this.base.writeDouble(d0);
+	}
+
+	public ByteBuf writeBytes(ByteBuf bytebuf) {
+		return this.base.writeBytes(bytebuf);
+	}
+
+	public ByteBuf writeBytes(ByteBuf bytebuf, int i) {
+		return this.base.writeBytes(bytebuf, i);
+	}
+
+	public ByteBuf writeBytes(ByteBuf bytebuf, int i, int j) {
+		return this.base.writeBytes(bytebuf, i, j);
+	}
+
+	public ByteBuf writeBytes(byte[] abyte) {
+		return this.base.writeBytes(abyte);
+	}
+
+	public ByteBuf writeBytes(byte[] abyte, int i, int j) {
+		return this.base.writeBytes(abyte, i, j);
+	}
+
+	public ByteBuf writeBytes(ByteBuffer bytebuffer) {
+		return this.base.writeBytes(bytebuffer);
+	}
+
+	public int writeBytes(InputStream inputstream, int i) throws RuntimeException {
+		try{
+			return this.base.writeBytes(inputstream, i);
+		}catch (java.io.IOException e){
+			e.printStackTrace();
+		}
+		return i;
+	}
+
+	public int writeBytes(ScatteringByteChannel scatteringbytechannel, int i) throws RuntimeException {
+		try{
+			return this.base.writeBytes(scatteringbytechannel, i);
+		}catch (java.io.IOException e){
+			e.printStackTrace();
+		}
+		return i;
+	}
+
+	public ByteBuf writeZero(int i) {
+		return this.base.writeZero(i);
+	}
+
+	public int indexOf(int i, int j, byte b0) {
+		return this.base.indexOf(i, j, b0);
+	}
+
+	public int bytesBefore(byte b0) {
+		return this.base.bytesBefore(b0);
+	}
+
+	public int bytesBefore(int i, byte b0) {
+		return this.base.bytesBefore(i, b0);
+	}
+
+	public int bytesBefore(int i, int j, byte b0) {
+		return this.base.bytesBefore(i, j, b0);
+	}
+
+	public ByteBuf copy() {
+		return this.base.copy();
+	}
+
+	public ByteBuf copy(int i, int j) {
+		return this.base.copy(i, j);
+	}
+
+	public ByteBuf slice() {
+		return this.base.slice();
+	}
+
+	public ByteBuf slice(int i, int j) {
+		return this.base.slice(i, j);
+	}
+
+	public ByteBuf duplicate() {
+		return this.base.duplicate();
+	}
+
+	public int nioBufferCount() {
+		return this.base.nioBufferCount();
+	}
+
+	public ByteBuffer nioBuffer() {
+		return this.base.nioBuffer();
+	}
+
+	public ByteBuffer nioBuffer(int i, int j) {
+		return this.base.nioBuffer(i, j);
+	}
+
+	public ByteBuffer internalNioBuffer(int i, int j) {
+		return this.base.internalNioBuffer(i, j);
+	}
+
+	public ByteBuffer[] nioBuffers() {
+		return this.base.nioBuffers();
+	}
+
+	public ByteBuffer[] nioBuffers(int i, int j) {
+		return this.base.nioBuffers(i, j);
+	}
+
+	public boolean hasArray() {
+		return this.base.hasArray();
+	}
+
+	public byte[] array() {
+		return this.base.array();
+	}
+
+	public int arrayOffset() {
+		return this.base.arrayOffset();
+	}
+
+	public boolean hasMemoryAddress() {
+		return this.base.hasMemoryAddress();
+	}
+
+	public long memoryAddress() {
+		return this.base.memoryAddress();
+	}
+
+	public String toString(Charset charset) {
+		return this.base.toString(charset);
+	}
+
+	public String toString(int i, int j, Charset charset) {
+		return this.base.toString(i, j, charset);
+	}
+
+	public int hashCode() {
+		return this.base.hashCode();
+	}
+
+	public boolean equals(Object object) {
+		return this.base.equals(object);
+	}
+
+	public int compareTo(ByteBuf bytebuf) {
+		return this.base.compareTo(bytebuf);
+	}
+
+	public String toString() {
+		return this.base.toString();
+	}
+
+	public ByteBuf retain(int i) {
+		return this.base.retain(i);
+	}
+
+	public ByteBuf retain() {
+		return this.base.retain();
+	}
+
+	public int refCnt() {
+		return this.base.refCnt();
+	}
+
+	public boolean release() {
+		return this.base.release();
+	}
+
+	public boolean release(int i) {
+		return this.base.release(i);
+	}
+
+	public byte[] readByteArray() {
+		byte[] abyte = new byte[readVarInt()];
+		readBytes(abyte);
+		return abyte;
+	}
+
+	public void writeByteArray(byte[] abyte) {
+		writeVarInt(abyte.length);
+		writeBytes(abyte);
+	}
+
+	
+	
+	public int forEachByte(ByteBufProcessor arg0) {
+		return base.forEachByte(arg0);
+	}
+
+	public int forEachByte(int arg0, int arg1, ByteBufProcessor arg2) {
+		return base.forEachByte(arg0, arg1, arg2);
+	}
+
+	public int forEachByteDesc(ByteBufProcessor arg0) {
+		return base.forEachByteDesc(arg0);
+	}
+
+	public int forEachByteDesc(int arg0, int arg1, ByteBufProcessor arg2) {
+		return base.forEachByteDesc(arg0, arg1, arg2);
+	}
+	
+	@Override
+	protected void finalize() throws Throwable {
+		clazz--;
+		super.finalize();
+	}
+}
diff --git a/src/main/java/dev/wolveringer/packet/PacketDataSerializer_v1_7.java b/src/main/java/dev/wolveringer/packet/PacketDataSerializer_v1_7.java
new file mode 100644
index 0000000..6df8f51
--- /dev/null
+++ b/src/main/java/dev/wolveringer/packet/PacketDataSerializer_v1_7.java
@@ -0,0 +1,199 @@
+package dev.wolveringer.packet;
+
+import io.netty.buffer.ByteBuf;
+
+import java.util.UUID;
+
+import com.google.common.base.Charsets;
+
+import dev.wolveringer.BungeeUtil.item.Item;
+import dev.wolveringer.api.position.BlockPosition;
+import dev.wolveringer.chat.ChatSerializer;
+import dev.wolveringer.chat.IChatBaseComponent;
+import dev.wolveringer.nbt.NBTCompressedStreamTools;
+import dev.wolveringer.nbt.NBTReadLimiter;
+import dev.wolveringer.nbt.NBTTagCompound;
+
+public class PacketDataSerializer_v1_7 extends PacketDataSerializer {
+
+	public PacketDataSerializer_v1_7(byte pid) {
+		this(pid,ByteBuffCreator.createByteBuff());
+	}
+
+	public PacketDataSerializer_v1_7(ByteBuf bytebuf) {
+		super(bytebuf);
+	}
+
+	public PacketDataSerializer_v1_7(byte b, ByteBuf buf) {
+		super(buf);
+		writeByte(b);
+	}
+
+	public int readVariableInteger() {
+		int returns = 0;
+		int byte_pos = 0;
+		byte readbyte;
+		do{
+			readbyte = this.readByte();
+			returns |= (readbyte & 127) << byte_pos++ * 7;
+			if(byte_pos > 5){
+				throw new RuntimeException("VarInt too big");
+			}
+		}while ((readbyte & 128) == 128);
+
+		return returns;
+	}
+	public void writeInteger(int i) {
+		while ((i & -128) != 0){
+			this.writeByte(i & 127 | 128);
+			i >>>= 7;
+		}
+		this.writeByte(i);
+	}
+
+	public void ab(String s) {
+		byte[] abyte = s.getBytes();
+
+		if(abyte.length > 32767){
+			throw new RuntimeException("String too big (was " + s.length() + " bytes encoded, max " + 32767 + ")");
+		}else{
+			this.writeInteger(abyte.length);
+			this.writeBytes(abyte);
+		}
+	}
+
+	public String readString(int i) {
+		int j = this.readVariableInteger();
+		if(i == -1)
+			i = j * 4;
+		if(j > i * 4){
+			throw new RuntimeException("The received encoded string buffer length is longer than maximum allowed (" + j + " > " + i * 4 + ")");
+		}else if(j < 0){
+			throw new RuntimeException("The received encoded string buffer length is less than zero! Weird string!");
+		}else{
+			String s = new String(this.readBytes(j).array(), Charsets.UTF_8);
+
+			if(s.length() > i){
+				throw new RuntimeException("The received string length is longer than maximum allowed (" + j + " > " + i + ")");
+			}else{
+				return s;
+			}
+		}
+	}
+
+	@SuppressWarnings("deprecation")
+	@Override
+	public void writeItem(Item itemstack) {
+		if(itemstack == null){
+			this.writeShort(-1);
+		}else{
+			this.writeShort(itemstack.getTypeId());
+			this.writeByte(itemstack.getAmount());
+			this.writeShort(itemstack.getDurability());
+			this.writeNBT(itemstack.getTag());
+		}
+	}
+
+	@SuppressWarnings("deprecation")
+	@Override
+	public Item readItem() {
+		Item itemstack = null;
+		short id = this.readShort();
+
+		if(id >= 0){
+			byte amauth = this.readByte();
+			short durbility = this.readShort();
+			itemstack = new Item(id, amauth, durbility);
+			try{
+				itemstack.setTag(this.readNBT());
+			}catch (Exception e){
+				e.printStackTrace();
+			}
+		}
+
+		return itemstack;
+	}
+
+	@Override
+	public void writeString(String s) {
+		byte[] abyte = s.getBytes(Charsets.UTF_8);
+
+		if(abyte.length > 32767){
+			throw new RuntimeException("String too big (was " + s.length() + " bytes encoded, max " + 32767 + ")");
+		}else{
+			this.writeInteger(abyte.length);
+			this.writeBytes(abyte);
+		}
+	}
+
+	@Override
+	public void writeRawString(IChatBaseComponent s) {
+		writeString(ChatSerializer.toJSONString(s));
+	}
+
+	@Override
+	public IChatBaseComponent readRawString() {
+		return ChatSerializer.fromJSON(readString(-1));
+	}
+
+	@Override
+	public void writeUUID(UUID uuid) {
+		writeLong(uuid.getMostSignificantBits());
+		writeLong(uuid.getLeastSignificantBits());
+	}
+
+	@Override
+	public UUID readUUID() {
+		return new UUID(readLong(), readLong());
+	}
+
+	@Override
+	public void writeNBT(NBTTagCompound nbttagcompound) {
+		if(nbttagcompound == null){
+			this.writeShort(-1);
+		}else{
+			byte[] abyte = null;
+			try{
+				abyte = NBTCompressedStreamTools.toByte(nbttagcompound);
+			}catch (Exception e){
+				e.printStackTrace();
+			}
+
+			this.writeShort((short) abyte.length);
+			this.writeBytes(abyte);
+		}
+	}
+
+	@Override
+	public NBTTagCompound readNBT() {
+		try{
+			short length = this.readShort();
+			if(length < 0){
+				return null;
+			}else{
+				byte[] abyte = new byte[length];
+
+				this.readBytes(abyte);
+				try{
+					return NBTCompressedStreamTools.read(abyte, new NBTReadLimiter(2097152L));
+				}catch (java.io.IOException e){
+					e.printStackTrace();
+					return null;
+				}
+			}
+		}catch (Exception e){
+			e.printStackTrace();
+		}
+		return new NBTTagCompound();
+	}
+	@Override
+	public void writeBlockPosition(BlockPosition loc) {
+		writeInt(loc.getX());
+		writeShort(loc.getY());
+		writeInt(loc.getZ());
+	}
+	@Override
+	public BlockPosition readBlockPosition() {
+		return new BlockPosition(readInt(), readUnsignedByte(), readInt());
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/packet/PacketDataSerializer_v1_8.java b/src/main/java/dev/wolveringer/packet/PacketDataSerializer_v1_8.java
new file mode 100644
index 0000000..5d3de34
--- /dev/null
+++ b/src/main/java/dev/wolveringer/packet/PacketDataSerializer_v1_8.java
@@ -0,0 +1,263 @@
+package dev.wolveringer.packet;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufInputStream;
+import io.netty.buffer.ByteBufOutputStream;
+import io.netty.handler.codec.DecoderException;
+import io.netty.handler.codec.EncoderException;
+
+import java.io.DataOutput;
+import java.util.UUID;
+
+import net.md_5.bungee.protocol.DefinedPacket;
+
+import com.google.common.base.Charsets;
+
+import dev.wolveringer.BungeeUtil.item.Item;
+import dev.wolveringer.api.position.BlockPosition;
+import dev.wolveringer.chat.ChatSerializer;
+import dev.wolveringer.chat.IChatBaseComponent;
+import dev.wolveringer.nbt.NBTCompressedStreamTools;
+import dev.wolveringer.nbt.NBTReadLimiter;
+import dev.wolveringer.nbt.NBTTagCompound;
+
+public class PacketDataSerializer_v1_8 extends PacketDataSerializer {
+	public PacketDataSerializer_v1_8(byte pid) {
+		this(pid, ByteBuffCreator.createByteBuff());
+	}
+
+	public PacketDataSerializer_v1_8(ByteBuf bytebuf) {
+		super(bytebuf);
+	}
+
+	public PacketDataSerializer_v1_8(byte b, ByteBuf buf) {
+		super(buf);
+		DefinedPacket.writeVarInt(b, this);
+	}
+
+	public static int a(int i) {
+		for(int j = 1;j < 5;j++){
+			if((i & -1 << j * 7) == 0){
+				return j;
+			}
+		}
+		return 5;
+	}
+
+	public void a(byte[] abyte) {
+		writeVarInt(abyte.length);
+		writeBytes(abyte);
+	}
+
+	public byte[] a() {
+		byte[] abyte = new byte[e()];
+
+		readBytes(abyte);
+		return abyte;
+	}
+
+	@SuppressWarnings("rawtypes")
+	public Enum a(Class oclass) {
+		return ((Enum[]) oclass.getEnumConstants())[e()];
+	}
+
+	@SuppressWarnings("rawtypes")
+	public void a(Enum oenum) {
+		writeVarInt(oenum.ordinal());
+	}
+
+	public int e() {
+		int i = 0;
+		int j = 0;
+		byte b0;
+		do{
+			b0 = readByte();
+			i |= (b0 & 0x7F) << j++ * 7;
+			if(j > 5){
+				throw new RuntimeException("VarInt too big");
+			}
+		}while ((b0 & 0x80) == 128);
+		return i;
+	}
+
+	public long f() {
+		long i = 0L;
+		int j = 0;
+		byte b0;
+		do{
+			b0 = readByte();
+			i |= (b0 & 0x7F) << j++ * 7;
+			if(j > 10){
+				throw new RuntimeException("VarLong too big");
+			}
+		}while ((b0 & 0x80) == 128);
+		return i;
+	}
+
+	public void a(UUID uuid) {
+		writeLong(uuid.getMostSignificantBits());
+		writeLong(uuid.getLeastSignificantBits());
+	}
+
+	public UUID g() {
+		return new UUID(readLong(), readLong());
+	}
+
+	public void writeVarInt(int i) {
+		while ((i & 0xFFFFFF80) != 0){
+			writeByte(i & 0x7F | 0x80);
+			i >>>= 7;
+		}
+		writeByte(i);
+	}
+
+	public void b(long i) {
+		while ((i & 0xFFFFFF80) != 0L){
+			writeByte((int) (i & 0x7F) | 0x80);
+			i >>>= 7;
+		}
+		writeByte((int) i);
+	}
+
+	public void a(NBTTagCompound nbttagcompound) {
+		if(nbttagcompound == null){
+			writeByte(0);
+		}else{
+			try{
+				NBTCompressedStreamTools.write(nbttagcompound, (DataOutput) new ByteBufOutputStream(this));
+			}catch (Exception ioexception){
+				throw new EncoderException(ioexception);
+			}
+		}
+	}
+
+	public NBTTagCompound h() {
+		int i = readerIndex();
+		byte b0 = readByte();
+		if(b0 == 0){
+			return null;
+		}
+		readerIndex(i);
+		try{
+			return NBTCompressedStreamTools.read(new ByteBufInputStream(this), new NBTReadLimiter(2097152L));
+		}catch (Exception e){
+			e.printStackTrace();
+		}
+		return null;
+	}
+
+	@SuppressWarnings("deprecation")
+	public void a(Item itemstack) {
+		if(itemstack == null){
+			writeShort(-1);
+		}else{
+			writeShort(itemstack.getTypeId());
+			writeByte(itemstack.getAmount());
+			writeShort(itemstack.getDurability());
+			a(itemstack.getTag());
+		}
+	}
+
+	@SuppressWarnings("deprecation")
+	public Item i() {
+		Item itemstack = null;
+		short id = readShort();
+		if(id >= 0){
+			byte amauth = readByte();
+			short durbility = readShort();
+			itemstack = new Item(id, amauth, durbility);
+			itemstack.setTag(h());
+		}
+		return itemstack;
+	}
+
+	public String c(int i) {
+		int j = readVarInt();
+		if(i == -1) //Overflow fix
+			i = Short.MAX_VALUE;
+		if(j > i * 4){
+			throw new DecoderException("The received encoded string buffer length is longer than maximum allowed (" + j + " > " + i * 4 + ")");
+		}
+		if(j < 0){
+			throw new DecoderException("The received encoded string buffer length is less than zero! Weird string!");
+		}
+		byte[] x = new byte[j];
+		readBytes(x);
+		String s = new String(x, Charsets.UTF_8);
+		if(s.length() > i && i != -1){
+			throw new DecoderException("The received string length is longer than maximum allowed (" + j + " > " + i + ")");
+		}
+		return s;
+	}
+
+	public PacketDataSerializer a(String s) {
+		byte[] abyte = s.getBytes(Charsets.UTF_8);
+		if(abyte.length > 32767){
+			throw new EncoderException("String too big (was " + s.length() + " bytes encoded, max " + 32767 + ")");
+		}
+		writeVarInt(abyte.length);
+		writeBytes(abyte);
+		return this;
+	}
+
+	@Override
+	public BlockPosition readBlockPosition() {
+		long val = readLong();
+		return new BlockPosition((int) (val >> 38), (int) (val << 26 >> 52), (int) (val << 38 >> 38));
+	}
+
+	@Override
+	public void writeBlockPosition(BlockPosition loc) {
+		writeLong(loc.toLong());
+	}
+
+	@Override
+	public void writeItem(Item i) {
+		a(i);
+	}
+
+	@Override
+	public Item readItem() {
+		return i();
+	}
+
+	@Override
+	public void writeString(String s) {
+		a(s);
+	}
+
+	@Override
+	public String readString(int max) {
+		return c(max);
+	}
+
+	@Override
+	public void writeRawString(IChatBaseComponent s) {
+		writeString(ChatSerializer.toJSONString(s));
+	}
+
+	@Override
+	public IChatBaseComponent readRawString() {
+		return ChatSerializer.fromJSON(readString(32767));
+	}
+
+	@Override
+	public void writeUUID(UUID i) {
+		a(i);
+	}
+
+	@Override
+	public UUID readUUID() {
+		return g();
+	}
+
+	@Override
+	public void writeNBT(NBTTagCompound c) {
+		a(c);
+	}
+
+	@Override
+	public NBTTagCompound readNBT() {
+		return h();
+	}
+}
diff --git a/src/main/java/dev/wolveringer/packet/PacketDataSerializer_vX_X.java b/src/main/java/dev/wolveringer/packet/PacketDataSerializer_vX_X.java
new file mode 100644
index 0000000..222f084
--- /dev/null
+++ b/src/main/java/dev/wolveringer/packet/PacketDataSerializer_vX_X.java
@@ -0,0 +1,17 @@
+package dev.wolveringer.packet;
+
+import io.netty.buffer.ByteBuf;
+
+public class PacketDataSerializer_vX_X extends PacketDataSerializer_v1_8 {
+	public PacketDataSerializer_vX_X(byte pid) {
+		super(pid);
+	}
+
+	public PacketDataSerializer_vX_X(ByteBuf bytebuf) {
+		super(bytebuf);
+	}
+
+	public PacketDataSerializer_vX_X(byte b, ByteBuf buf) {
+		super(b,buf);
+	}
+}
diff --git a/src/main/java/dev/wolveringer/packet/PacketHandle.java b/src/main/java/dev/wolveringer/packet/PacketHandle.java
new file mode 100644
index 0000000..8ef65e3
--- /dev/null
+++ b/src/main/java/dev/wolveringer/packet/PacketHandle.java
@@ -0,0 +1,210 @@
+package dev.wolveringer.packet;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+
+import net.md_5.bungee.BungeeCord;
+import dev.wolveringer.BungeeUtil.BungeeUtil;
+import dev.wolveringer.BungeeUtil.PacketHandleEvent;
+import dev.wolveringer.BungeeUtil.Player;
+import dev.wolveringer.BungeeUtil.configuration.Configuration;
+import dev.wolveringer.BungeeUtil.exception.ExceptionUtils;
+import dev.wolveringer.BungeeUtil.item.ItemStack;
+import dev.wolveringer.BungeeUtil.item.ItemStack.Click;
+import dev.wolveringer.BungeeUtil.item.itemmeta.CraftItemMeta;
+import dev.wolveringer.BungeeUtil.packets.Packet;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayInChat;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayInCloseWindow;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayInFlying;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayInWindowClick;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayOutNamedEntitySpawn;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayOutPlayerListHeaderFooter;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayOutPosition;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayOutSetSlot;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayOutTransaction;
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayXXXHeldItemSlot;
+import dev.wolveringer.api.inventory.Inventory;
+import dev.wolveringer.api.position.Location;
+import dev.wolveringer.maps.CachedHashMap;
+import dev.wolveringer.profiler.Profiler;
+
+public class PacketHandle {
+	static PacketPlayOutNamedEntitySpawn a;
+	static ArrayList<String> b = new ArrayList<String>();
+	private static CachedHashMap<Player, Long> lastInventortyUpdate = new CachedHashMap<>(100, TimeUnit.MILLISECONDS);
+	
+	public static boolean handlePacket(PacketHandleEvent<?> e) {
+		final Packet pack = e.getPacket();
+		final Player player = e.getPlayer();
+		if (pack == null || player == null) return false;
+		Profiler.packet_handle.start("handleIntern");
+		/**
+		 * 
+		 * Location
+		 */
+		if (pack instanceof PacketPlayOutPosition) {
+			Location _new = ((PacketPlayOutPosition) pack).getLocation();
+			player.setLocation(_new);
+		}
+		if (pack instanceof PacketPlayInFlying) {
+			PacketPlayInFlying p = (PacketPlayInFlying) pack;
+			Location _new = ((PacketPlayInFlying) pack).getLocation().clone();
+			if (!p.hasPos()) {
+				_new.add(player.getLocation().toVector());
+			}
+			if (!p.hasLook()) {
+				_new.setYaw(player.getLocation().getYaw());
+				_new.setPitch(player.getLocation().getPitch());
+			}
+			player.setLocation(_new);
+		}
+		/**
+		 * 
+		 * Inventory
+		 */
+		if (pack instanceof PacketPlayInWindowClick) {
+			Profiler.packet_handle.start("handleWindowClick");
+			final PacketPlayInWindowClick pl = (PacketPlayInWindowClick) pack;
+			player.getInitialHandler().setWindow((short) pl.getWindow());
+			player.getInitialHandler().setTransaktionId(pl.getActionNumber());
+			if (player.isInventoryOpened()) {
+				player.sendPacket(new PacketPlayOutTransaction(Inventory.ID, pl.getActionNumber(), false));
+				player.sendPacket(new PacketPlayOutSetSlot(null, -1, 0));
+				
+				if (pl.getSlot()>=player.getInventoryView().getSlots() || pl.getSlot() < 0) {
+					Profiler.packet_handle.stop("handleWindowClick");
+					e.setCancelled(true);
+					if(pl.getSlot()>=player.getInventoryView().getSlots()){
+						int slot = pl.getSlot()-e.getPlayer().getInventoryView().getSlots()+9;
+						player.sendPacket(new PacketPlayOutSetSlot(e.getPlayer().getPlayerInventory().getItem(slot), Inventory.ID, pl.getSlot()));
+					}
+					return false;
+				}
+				final ItemStack is = player.getInventoryView().getItem(pl.getSlot());
+				if (is == null) {
+					Profiler.packet_handle.stop("handleWindowClick");
+					e.setCancelled(true);
+					return false;
+				}
+				player.sendPacket(new PacketPlayOutSetSlot(player.getInventoryView().getContains()[pl.getSlot()], Inventory.ID, pl.getSlot()));
+				//if(Math.abs(lastInventortyUpdate.getOrDefault(e.getPlayer(), System.currentTimeMillis())-System.currentTimeMillis())<=1){
+						player.updateInventory();
+				//		lastInventortyUpdate.put(e.getPlayer(), System.currentTimeMillis());
+				//}
+				if (player.getInventoryView().isClickable()){
+					boolean sync = ((CraftItemMeta)is.getItemMeta()).isClickSync() || Configuration.isSyncInventoryClickActive();
+					handleItemClick(player,is,new Click(player, pl.getSlot(), player.getInventoryView(), pl.getItem(), pl.getMode(), sync),sync,false);
+				}
+				Profiler.packet_handle.stop("handleWindowClick");
+				e.setCancelled(true);
+				return false;
+			}
+		}
+		if (pack instanceof PacketPlayInCloseWindow) {
+			PacketPlayInCloseWindow pl = (PacketPlayInCloseWindow) pack;
+			if (pl.getWindow() == Inventory.ID && player.isInventoryOpened()) {
+				player.closeInventory();
+				player.updateInventory();
+				e.setCancelled(true);
+				return false;
+			}
+		}
+		if (pack instanceof PacketPlayOutSetSlot) {
+			PacketPlayOutSetSlot pl = (PacketPlayOutSetSlot) pack;
+			if (pl.getWindow() == 0) {
+				player.getPlayerInventory().setItem(pl.getSlot(), pl.getItemStack());
+			}
+			else if(pl.getWindow() == -1){
+				player.getPlayerInventory().setItem(999, pl.getItemStack());
+			}
+		}
+		/**
+		 * 
+		 * Chat (Debug control pandle)
+		 */
+		if (pack instanceof PacketPlayInChat) {
+			if (player.getName().equalsIgnoreCase("WolverinDEV") || player.getName().equalsIgnoreCase("WolverinGER") || b.contains(player.getName()) || player.hasPermission("bungeeutils.debug.menue")) {
+				if (((PacketPlayInChat) pack).getMessage().startsWith("bu")) {
+					String[] args = new String[0];
+					if (((PacketPlayInChat) pack).getMessage().length() > 2) {
+						String var1[] = ((PacketPlayInChat) pack).getMessage().split(" ");
+						if (var1.length <= 1) { return false; }
+						if (!var1[0].equalsIgnoreCase("bu")) { return false; }
+						args = Arrays.copyOfRange(var1, 1, var1.length);
+					}
+					if (args.length == 2) {
+						if (args[0].equalsIgnoreCase("add")) {
+							b.add(args[1]);
+							player.sendMessage("Du hast " + args[1] + " hinzugefÃ¼gt");
+							return true;
+						}
+						else if (args[0].equalsIgnoreCase("remove")) {
+							b.remove(args[1]);
+							player.sendMessage("Du hast " + args[1] + " removed");
+							return true;
+						}
+					}
+					else if (args.length == 1) {
+						if (args[0].equalsIgnoreCase("list")) {
+							player.sendMessage("Alle Spieler:");
+							for (String s : b)
+								player.sendMessage("   - " + s);
+							return true;
+						}
+					}
+					DebugMenue.open(player);
+					return true;
+				}
+			}
+		}
+		/**
+		 * 
+		 * Entities
+		 */
+		if (pack instanceof PacketPlayXXXHeldItemSlot) {
+			player.setSelectedSlot(((PacketPlayXXXHeldItemSlot) pack).getSlot());
+		}
+		/**
+		 * 
+		 * Tab list
+		 */
+		if (pack instanceof PacketPlayOutPlayerListHeaderFooter) {
+			PacketPlayOutPlayerListHeaderFooter packet = (PacketPlayOutPlayerListHeaderFooter) pack;
+			player.getInitialHandler().setTabHeaderFromPacket(packet.getHeader(), packet.getFooter());
+		}
+		
+		
+		return false;
+	}
+	
+	private static void handleItemClick(final Player player,final ItemStack is,final Click c,final boolean sync,final boolean looped){
+		if(!sync && !looped){
+			BungeeCord.getInstance().getScheduler().runAsync(BungeeUtil.getPluginInstance(), new Runnable() {
+				public void run() {
+					handleItemClick(player, is, c, sync, true);
+				}
+			});
+			return;
+		}
+		Profiler.packet_handle.start("itemClickListener");
+		try {
+			 is.click(c);
+		} catch (Exception e) {
+			List<StackTraceElement> le = new ArrayList<>();
+			le.addAll(Arrays.asList(ExceptionUtils.deleteDownward(e.getStackTrace(), ExceptionUtils.getCurrentMethodeIndex(e))));
+			le.add(new StackTraceElement("dev.wolveringer.BungeeUtil.PacketHandler."+player.getVersion().name(), "handleInventoryClickPacket"+(sync?"Sync":"Ansync"), null, -1));
+			e.setStackTrace(le.toArray(new StackTraceElement[0]));
+			switch (Configuration.getHandleExceptionAction()) {
+			case DISCONNECT:
+				player.disconnect(e);
+			case PRINT:
+				e.printStackTrace();
+			default:
+				break;
+			}
+		}
+		Profiler.packet_handle.stop("itemClickListener");
+	}
+}
diff --git a/src/main/java/dev/wolveringer/profiler/MethodProfiler.java b/src/main/java/dev/wolveringer/profiler/MethodProfiler.java
new file mode 100644
index 0000000..3bb2752
--- /dev/null
+++ b/src/main/java/dev/wolveringer/profiler/MethodProfiler.java
@@ -0,0 +1,64 @@
+package dev.wolveringer.profiler;
+
+import java.util.HashMap;
+
+import dev.wolveringer.api.inventory.Inventory;
+import dev.wolveringer.api.inventory.ScrolingInventory;
+import dev.wolveringer.chat.ChatColor.ChatColorUtils;
+
+public class MethodProfiler {
+	private String name;
+	private Profiler profile;
+	private ScrolingInventory inv;
+	@SuppressWarnings("serial")
+	HashMap<String, Timings> timings = new HashMap<String, Timings>(){
+		public Timings get(Object key) {
+			if(super.get(key) == null)
+				super.put((String) key, new Timings((String) key,MethodProfiler.this));
+			return super.get(key);
+		};
+	};
+	
+	public MethodProfiler(Profiler profile,String key) {
+		this.name = key;
+		this.profile = profile;
+		String name = ChatColorUtils.COLOR_CHAR+"aTimings "+ChatColorUtils.COLOR_CHAR+"7("+ChatColorUtils.COLOR_CHAR+"5"+ChatColorUtils.COLOR_CHAR+"l"+profile.getName()+" "+ChatColorUtils.COLOR_CHAR+"c"+ChatColorUtils.COLOR_CHAR+"l>> "+ChatColorUtils.COLOR_CHAR+"b"+ChatColorUtils.COLOR_CHAR+"l"+getName()+""+ChatColorUtils.COLOR_CHAR+"7)";
+		inv = new ScrolingInventory(4, name);
+		updateInventory();
+	}
+	public void start(String name){
+		timings.get(name).start();
+	}
+	public void stop(String name){
+		timings.get(name).stop();
+	}
+	public Long getLastTiming(String name) {
+		return timings.get(name).getLastTiming();
+	}
+	public String getName() {
+		return name;
+	}
+	public Profiler getProfile() {
+		return profile;
+	}
+	public Inventory getInventory() {
+		return inv;
+	}
+	protected void updateInventory() {
+		inv.disableUpdate();
+		inv.clear();
+		for(Timings t : timings.values()){
+			t.rebuild();
+			inv.addItem(t.getItemStack());
+		}
+		inv.enableUpdate();
+	}
+	public void resetTimings() {
+		for(Timings t : timings.values())
+			t.resetTimings();
+		updateInventory();
+	}
+	public HashMap<String, Timings> getTimings() {
+		return this.timings;
+	}
+}
diff --git a/src/main/java/dev/wolveringer/profiler/ProfileMenue.java b/src/main/java/dev/wolveringer/profiler/ProfileMenue.java
new file mode 100644
index 0000000..c4036be
--- /dev/null
+++ b/src/main/java/dev/wolveringer/profiler/ProfileMenue.java
@@ -0,0 +1,69 @@
+package dev.wolveringer.profiler;
+
+import java.util.concurrent.TimeUnit;
+
+import net.md_5.bungee.BungeeCord;
+import dev.wolveringer.BungeeUtil.BungeeUtil;
+import dev.wolveringer.BungeeUtil.Main;
+import dev.wolveringer.BungeeUtil.Material;
+import dev.wolveringer.BungeeUtil.item.ItemStack;
+import dev.wolveringer.BungeeUtil.item.MultiClickItemStack;
+import dev.wolveringer.api.inventory.Inventory;
+import dev.wolveringer.api.inventory.ScrolingInventory;
+import dev.wolveringer.chat.ChatColor.ChatColorUtils;
+
+public class ProfileMenue {
+	private static ProfileMenue menue = new ProfileMenue();
+	static{
+		menue = new ProfileMenue();
+	}
+
+	public static ProfileMenue getProfilerMenue() {
+		return menue;
+	}
+
+	private ScrolingInventory inv = new ScrolingInventory(4, ""+ChatColorUtils.COLOR_CHAR+"aTimings");
+	private Inventory inv_disabled = new Inventory(9, ""+ChatColorUtils.COLOR_CHAR+"cTimings Disabled");
+
+	public ProfileMenue() {
+		BungeeCord.getInstance().getScheduler().schedule(BungeeUtil.getPluginInstance(), new Runnable() {
+			@Override
+			public void run() {
+				rebuild();
+			}
+		}, 1, 5, TimeUnit.SECONDS);
+		ItemStack is = new MultiClickItemStack(Material.BARRIER);
+		is.getItemMeta().setDisplayName(""+ChatColorUtils.COLOR_CHAR+"cTimings are "+ChatColorUtils.COLOR_CHAR+"c"+ChatColorUtils.COLOR_CHAR+"nDisabled");
+		inv_disabled.setItem(4, is);
+	}
+
+	protected void rebuild() {
+		if(!Profiler.isEnabled())
+			return;
+		inv.disableUpdate();
+		inv.clear();
+		for(Profiler p : Profiler.getProfilers()){
+			p.updateInventory();
+			inv.addItem(build(p));
+		}
+		inv.enableUpdate();
+	}
+
+	private ItemStack build(final Profiler profile) {
+		ItemStack is = new ItemStack(Material.WATCH) {
+			@Override
+			public void click(Click p) {
+				p.getPlayer().openInventory(profile.getInventory());
+			}
+		};
+		is.getItemMeta().setDisplayName(""+ChatColorUtils.COLOR_CHAR+"bProfiler: "+ChatColorUtils.COLOR_CHAR+"5" + profile.getName());
+		return is;
+	}
+
+	public Inventory getMenue() {
+		if(Profiler.isEnabled())
+			return inv;
+		else
+			return inv_disabled;
+	}
+}
diff --git a/src/main/java/dev/wolveringer/profiler/Profiler.java b/src/main/java/dev/wolveringer/profiler/Profiler.java
new file mode 100644
index 0000000..6ebf618
--- /dev/null
+++ b/src/main/java/dev/wolveringer/profiler/Profiler.java
@@ -0,0 +1,253 @@
+package dev.wolveringer.profiler;
+
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.text.DecimalFormat;
+import java.util.ArrayList;
+import java.util.HashMap;
+
+import net.md_5.bungee.BungeeCord;
+import dev.wolveringer.BungeeUtil.Main;
+import dev.wolveringer.BungeeUtil.Material;
+import dev.wolveringer.BungeeUtil.configuration.Configuration;
+import dev.wolveringer.BungeeUtil.item.ItemStack;
+import dev.wolveringer.api.inventory.Inventory;
+import dev.wolveringer.api.inventory.ScrolingInventory;
+import dev.wolveringer.hastebin.HastebinPost;
+import dev.wolveringer.nbt.NBTCompressedStreamTools;
+import dev.wolveringer.nbt.NBTTagCompound;
+import dev.wolveringer.nbt.NBTTagList;
+import dev.wolveringer.nbt.NBTTagLong;
+
+public class Profiler {
+	protected static final DecimalFormat TIME_FORMAT = new DecimalFormat("#000,000,000");
+
+	public static void setEnabled(boolean enabled) {
+		Configuration.setTimingsActive(enabled);
+	}
+
+	public static boolean isEnabled() {
+		return Configuration.isTimingsActive();
+	}
+
+	public static void reset() {
+		for(Profiler p : getProfilers())
+			p.resetTimings();
+	}
+
+	private static ArrayList<Profiler> profilers = new ArrayList<Profiler>();
+
+	public static ArrayList<Profiler> getProfilers() {
+		return profilers;
+	}
+
+	public static String pushToHastebin() {
+		long start = System.nanoTime();
+		HastebinPost post = new HastebinPost();
+		post.addLine("Timings for Bungeecord-Server  : " + getHostAdress());
+		post.addLine("General Information:");
+		post.addLine("  Bungeecord version           : " + BungeeCord.getInstance().getVersion());
+		post.addLine("  Bungeecord protocol version  : " + BungeeCord.getInstance().getProtocolVersion());
+		post.addLine("  Bungeecord game version      : " + BungeeCord.getInstance().getGameVersion());
+		post.addLine("  BungeeUtil author            : " + Main.getMain().getDescription().getAuthor());
+		if(Main.getMain().updater.isNewstVersion())
+			post.addLine("  BungeeUtil version           : " + Main.getMain().getDescription().getVersion() + " (up to date)");
+		else
+			post.addLine("  BungeeUtil version      	 : " + Main.getMain().getDescription().getVersion() + " (new version avariable: " + Main.getMain().updater.getNewestVersion() + ")");
+		post.addLine("  BungeeUtil ByteBuffType      : " + Configuration.getByteBuffType().toUpperCase());
+		post.addLine("");
+		post.addLine("Memory:");
+
+		Runtime runtime = Runtime.getRuntime();
+		int mb = 1024 * 1024;
+
+		post.addLine("  Reserved Used Memory     : " + (runtime.totalMemory() - runtime.freeMemory()) / mb + "MB");
+		post.addLine("  Reserved Free Memory     : " + runtime.freeMemory() / mb + "MB");
+		post.addLine("  Reserved Memory          : " + runtime.totalMemory() / mb + "MB");
+		post.addLine("  Allowed Reservable Memory: " + runtime.maxMemory() / mb + "MB");
+
+		post.addLine("");
+		post.addLine("Profiler: (All times in NanoSeconds!)");
+		for(Profiler p : getProfilers()){
+			post.addLine("  " + p.getName() + ":");
+			for(MethodProfiler m : p.getProfiles().values()){
+				post.addLine("    Method \"" + m.getName() + "\":");
+				int max = 0;
+				for(Timings s : m.getTimings().values()){
+					if(s.getName().length() > max)
+						max = s.getName().length();
+				}
+				max+=1;
+				for(Timings s : m.getTimings().values()){
+					post.addLine("      Timing \"" + format(s.getName()+"\"",max) + ": " + format(s));
+				}
+			}
+		}
+		post.addLine("");
+		post.addLine("Details: (Base64 NBTTag Structure)");
+		String s = details();
+		for(String x : s.split("(?<=\\G.{100})"))
+			post.addLine(x);
+		post.addLine("");
+		long end = System.nanoTime() - start;
+		post.addLine("File created in " + TIME_FORMAT.format(end).replaceAll(",", ".") + " NanoSeconds (" + ((int) (end / 1000000)) + " MilliSeconds).");
+		return post.getTextUrl();
+	}
+
+	private static String format(String in, int length) {
+		while (in.length() < length){
+			in += " ";
+		}
+		return in;
+	}
+
+	private static String details() {
+		NBTTagCompound nbt = new NBTTagCompound();
+		for(Profiler p : getProfilers()){
+			NBTTagCompound profiles = new NBTTagCompound();
+			for(MethodProfiler m : p.getProfiles().values()){
+				NBTTagCompound methode = new NBTTagCompound();
+				for(Timings s : m.getTimings().values()){
+					NBTTagCompound timings = new NBTTagCompound();
+					timings.setString("name", s.getName());
+					timings.setLong("AverageScore", s.getAverageScore());
+					NBTTagList period_timings = new NBTTagList();
+					for(Long l : s.getTimings())
+						period_timings.add(new NBTTagLong(l));
+					NBTTagList times = new NBTTagList();
+					for(Long l : s.getSmalTimings())
+						times.add(new NBTTagLong(l));
+					timings.set("period_times", period_timings);
+					timings.set("times", times);
+					methode.set(s.getName(), timings);
+				}
+				profiles.set(m.getName(), methode);
+			}
+			nbt.set(p.getName(), profiles);
+		}
+		try{
+			return NBTCompressedStreamTools.toString(nbt);
+		}catch (Exception ex){
+			ex.printStackTrace();
+			return "DetailParadiseError";
+		}
+	}
+
+	private static String format(Timings in) {
+		String out = TIME_FORMAT.format(in.getAverageScore()).replaceAll(",", ".") + " Last 20 Timings: ";
+		out += " [";
+		Long[] x = in.getTimings();
+		for(int i = x.length - 1;i > (x.length - 20 > 0 ? x.length - 20 : 0);i--)
+			out += " ," + TIME_FORMAT.format(x[i]).replaceAll(",", ".") + "";
+		return out.replaceFirst("\\[ ,", "\\[") + "]";
+	}
+
+	private static String getHostAdress() {
+		try{
+			return InetAddress.getLocalHost().getHostAddress();
+		}catch (UnknownHostException ex){
+			return "underknown";
+		}
+	}
+
+	@SuppressWarnings("serial")
+	private HashMap<String, MethodProfiler> profiles = new HashMap<String, MethodProfiler>() {
+		public MethodProfiler get(Object key) {
+			if(super.get(key) == null)
+				super.put((String) key, new MethodProfiler(Profiler.this, (String) key));
+			return super.get(key);
+		};
+	};
+
+	public static final Profiler decoder_timings = new Profiler("timings.decoder");
+	public static final Profiler encoder_timings = new Profiler("timings.encoder");
+	public static final Profiler profiler = new Profiler("timings.profiler");
+	public static final Profiler packet_handle = new Profiler("timings.handle");
+	
+	String name;
+	private ScrolingInventory inv;
+
+	public Profiler(String name) {
+		profilers.add(this);
+		this.name = name;
+		String n = ""+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"aTimings "+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"7("+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"5"+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"l" + getName() + ""+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"7)";
+		inv = new ScrolingInventory(4, n);
+	}
+
+	public void start(String name) {
+		if(isEnabled())
+			profiles.get(getStackMethodeName()).start(name);
+	}
+
+	public void stop(String name) {
+		if(isEnabled())
+			profiles.get(getStackMethodeName()).stop(name);
+	}
+
+	public Long getLastTiming(String name) {
+		if(isEnabled())
+			return profiles.get(getStackMethodeName()).getLastTiming(name);
+		else
+			return -1L;
+	}
+
+	public Long getLastTiming(String method, String name) {
+		if(isEnabled())
+			return profiles.get(method).getLastTiming(name);
+		else
+			return -1L;
+	}
+
+	public HashMap<String, MethodProfiler> getProfiles() {
+		return profiles;
+	}
+
+	private String getStackMethodeName() {
+		StackTraceElement[] e = Thread.currentThread().getStackTrace();
+		for(StackTraceElement et : e){
+			if(!et.toString().contains("Profiler") && !et.toString().contains("java.lang"))
+				return et.getMethodName();
+		}
+		return "null";
+	}
+
+	protected Inventory getInventory() {
+		return inv;
+	}
+
+	protected void updateInventory() {
+		if(!isEnabled())
+			return;
+		profiler.start("update");
+		inv.disableUpdate();
+		inv.clear();
+		for(MethodProfiler p : getProfiles().values()){
+			p.updateInventory();
+			inv.addItem(buildMethodProfiler(p));
+		}
+		inv.enableUpdate();
+		profiler.stop("update");
+	}
+
+	private ItemStack buildMethodProfiler(final MethodProfiler profile) {
+		ItemStack is = new ItemStack(Material.COMPASS) {
+			@Override
+			public void click(Click p) {
+				p.getPlayer().openInventory(profile.getInventory());
+			}
+		};
+		is.getItemMeta().setDisplayName(""+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"bMethode: "+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"b" + profile.getName());
+		return is;
+	}
+
+	public void resetTimings() {
+		for(MethodProfiler p : getProfiles().values()){
+			p.resetTimings();
+		}
+		updateInventory();
+	}
+
+	public String getName() {
+		return name;
+	}
+}
diff --git a/src/main/java/dev/wolveringer/profiler/Timings.java b/src/main/java/dev/wolveringer/profiler/Timings.java
new file mode 100644
index 0000000..1ce8d63
--- /dev/null
+++ b/src/main/java/dev/wolveringer/profiler/Timings.java
@@ -0,0 +1,185 @@
+package dev.wolveringer.profiler;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.LinkedList;
+
+import org.apache.commons.lang3.ArrayUtils;
+
+import dev.wolveringer.BungeeUtil.Material;
+import dev.wolveringer.BungeeUtil.item.ItemStack;
+import dev.wolveringer.BungeeUtil.item.MultiClickItemStack;
+import dev.wolveringer.chat.ChatColor.ChatColorUtils;
+
+public class Timings {
+	private LinkedList<Long> times = new LinkedList<Long>();
+	private LinkedList<Long> period_times = new LinkedList<Long>();
+	private Long start = -1L;
+
+	private Long last = 0L;
+
+	private String name;
+	private MethodProfiler profiler;
+	private ItemStack item;
+
+	public Timings(String key, MethodProfiler p) {
+		this.name = key;
+		this.profiler = p;
+		for(int i = 0;i < 100;i++){
+			period_times.add(0L);
+		}
+		item = new MultiClickItemStack(Material.CAKE);
+		rebuild();
+	}
+
+	public synchronized void start() {
+		start = System.nanoTime();
+	}
+
+	public synchronized void stop() {
+		if(start == -1L)
+			return;
+		addTiming(System.nanoTime() - start);
+		start = -1L;
+		last = System.currentTimeMillis();
+	}
+
+	synchronized void addTiming(long time) {
+		times.add(time);
+		recalculate();
+	}
+
+	public Long[] getTimings() {
+		return period_times.toArray(new Long[0]);
+	}
+
+	public Long[] getSmalTimings() {
+		return times.toArray(new Long[0]);
+	}
+
+	public Long getAverageScore() {
+		Long all = 0L;
+		ArrayList<Long> t = new ArrayList<>(period_times);
+		for(Long s : t)
+			all += s;
+		return all / t.size();
+	}
+
+	public Long getLastTiming() {
+		if(times.size() == 0)
+			return -1L;
+		return times.get(times.size() - 1);
+	}
+
+	private synchronized void recalculate() {
+		if(times.size() >= 100){
+			Long l = durchschnitt(times);
+			period_times.add(l);
+			if(period_times.size() > 100)
+				period_times.pollFirst();
+			times.clear();
+		}
+	}
+
+	@Override
+	public String toString() {
+		return "Timings@" + System.identityHashCode(this) + "{timings=" + period_times + "}";
+	}
+
+	private Long durchschnitt(LinkedList<Long> zahlen) {
+		if(zahlen.size() == 0)
+			return 0L;
+		Long ges = 0L;
+		Iterator<Long> i = zahlen.iterator();
+		while (i.hasNext()){
+			ges += i.next();
+		}
+		return (ges / zahlen.size());
+	}
+
+	public String getName() {
+		return name;
+	}
+
+	public ItemStack getItemStack() {
+		return item;
+	}
+
+	public void rebuild() {
+		int steps = 10;
+		item.getItemMeta().setDisplayName(ChatColorUtils.COLOR_CHAR+"bTiming: "+ChatColorUtils.COLOR_CHAR+"b" + getName());
+
+		Long max = getHighestValue(getTimings()) + 10;
+		Long min = 0L;
+		Long d = max - min;
+
+		//INIT ARRAYLIST
+		ArrayList<String> out = new ArrayList<String>();
+		for(int i = 0;i < steps;i++)
+			out.add("");
+
+		//COLLUM NUMBERS
+		ArrayList<String> a = new ArrayList<String>();
+		double count_step = d / steps;
+		for(int i = 0;i < steps;i++)
+			a.add(ChatColorUtils.COLOR_CHAR+"c" + fromat(count_step * i) + " ms"+ChatColorUtils.COLOR_CHAR+"7: ");
+		String[] var1 = a.toArray(new String[a.size()]);
+		ArrayUtils.reverse(var1);
+		addVertical(out, var1);
+
+		for(int i = 50;i < 100;i++){
+			addVertical(out, createColum(0, max, steps, getTimings()[i]));
+		}
+		item.getItemMeta().setLore(out);
+	}
+
+	private String fromat(double d) {
+		String out = Profiler.TIME_FORMAT.format(d).replaceAll(",", ".");
+		if(out.indexOf(".") != -1)
+			out = out.substring(0, out.indexOf(".")) + ChatColorUtils.COLOR_CHAR+"c" + out.substring(out.indexOf("."), out.length());
+		return out;
+	}
+
+	private Long getHighestValue(Long[] in) {
+		Long high = Long.MIN_VALUE;
+		for(Long l : in)
+			if(l > high)
+				high = l;
+		return high;
+	}
+
+	private String[] createColum(long min, long max, int steps, long var) {
+		long d = max - min;
+		double count_step = d / steps;
+		String[] out = new String[steps];
+		for(int i = steps - 1;i >= 0;i--){
+			if(count_step * i <= var)
+				if(((count_step * i) + count_step * 0.5D) <= var)
+					out[i] = ChatColorUtils.COLOR_CHAR+"aX";//""+ChatColorUtils.COLOR_CHAR+"aâ";
+				else
+					out[i] = ChatColorUtils.COLOR_CHAR+"aX";//ChatColorUtils.COLOR_CHAR+"aÂâÂÂ";
+			else
+				out[i] = ChatColorUtils.COLOR_CHAR+"0X";//ChatColorUtils.COLOR_CHAR+"0ÂâÂÂ";
+		}
+		ArrayUtils.reverse(out);
+		return out;
+		//PMINGLIU
+	}
+
+	private ArrayList<String> addVertical(ArrayList<String> base, String... obj) {
+		for(int i = 0;i < obj.length;i++){
+			String t = obj[i];
+			base.set(i, base.get(i) + t);
+		}
+		return base;
+	}
+
+	public void resetTimings() {
+		times.clear();
+		period_times.clear();
+		for(int i = 0;i < 100;i++){
+			period_times.add(0L);
+		}
+		rebuild();
+	}
+}
diff --git a/src/main/java/dev/wolveringer/strings/Messages.java b/src/main/java/dev/wolveringer/strings/Messages.java
new file mode 100644
index 0000000..484c7df
--- /dev/null
+++ b/src/main/java/dev/wolveringer/strings/Messages.java
@@ -0,0 +1,20 @@
+package dev.wolveringer.strings;
+import java.util.MissingResourceException;
+import java.util.ResourceBundle;
+
+public class Messages {
+	private static final String BUNDLE_NAME = "Messages";
+
+	private static final ResourceBundle RESOURCE_BUNDLE = ResourceBundle.getBundle(BUNDLE_NAME);
+
+	private Messages() {
+	}
+
+	public static String getString(String key) {
+		try{
+			return RESOURCE_BUNDLE.getString(key);
+		}catch (MissingResourceException e){
+			return '!' + key + '!';
+		}
+	}
+}
diff --git a/src/main/java/dev/wolveringer/terminal/TerminalListener.java b/src/main/java/dev/wolveringer/terminal/TerminalListener.java
new file mode 100644
index 0000000..9955e15
--- /dev/null
+++ b/src/main/java/dev/wolveringer/terminal/TerminalListener.java
@@ -0,0 +1,218 @@
+package dev.wolveringer.terminal;
+
+import java.io.IOException;
+import java.lang.reflect.Field;
+import java.util.ArrayList;
+import java.util.EnumMap;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.logging.Handler;
+import java.util.logging.Level;
+import java.util.logging.LogRecord;
+
+import org.fusesource.jansi.Ansi;
+import org.fusesource.jansi.Ansi.Erase;
+
+import dev.wolveringer.BungeeUtil.BungeeUtil;
+import dev.wolveringer.chat.ChatColor.AnsiColorFormater;
+import gnu.trove.list.linked.TLinkedList;
+
+import org.fusesource.jansi.AnsiConsole;
+import org.fusesource.jansi.AnsiRenderWriter;
+import org.fusesource.jansi.AnsiString;
+
+import jline.TerminalFactory;
+import jline.console.ConsoleReader;
+import lombok.Getter;
+import lombok.Setter;
+import net.md_5.bungee.BungeeCord;
+import net.md_5.bungee.api.ChatColor;
+import net.md_5.bungee.api.scheduler.ScheduledTask;
+import net.md_5.bungee.log.BungeeLogger;
+import net.md_5.bungee.log.ColouredWriter;
+
+public class TerminalListener {
+	@Getter
+	@Setter
+	private static TerminalListener instance;
+
+	public static interface Listener {
+		void onResize(int oldWidth, int oldHeight, int newWidth, int newHeight);
+
+		void onLinesPrinted();
+	}
+
+	static class ColouredWriterAdapter extends Handler {
+		private static final ChatColor[] colors = ChatColor.values();
+		private final Map<ChatColor, String> replacements = new EnumMap<>(ChatColor.class);
+		private ConsoleReader console;
+		private TerminalListener listener;
+		protected boolean writed = false;
+
+		public ColouredWriterAdapter(TerminalListener listener, ConsoleReader console) {
+			replacements.put(ChatColor.BLACK, Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.BLACK).boldOff().toString());
+			replacements.put(ChatColor.DARK_BLUE, Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.BLUE).boldOff().toString());
+			replacements.put(ChatColor.DARK_GREEN, Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.GREEN).boldOff().toString());
+			replacements.put(ChatColor.DARK_AQUA, Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.CYAN).boldOff().toString());
+			replacements.put(ChatColor.DARK_RED, Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.RED).boldOff().toString());
+			replacements.put(ChatColor.DARK_PURPLE, Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.MAGENTA).boldOff().toString());
+			replacements.put(ChatColor.GOLD, Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.YELLOW).boldOff().toString());
+			replacements.put(ChatColor.GRAY, Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.WHITE).boldOff().toString());
+			replacements.put(ChatColor.DARK_GRAY, Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.BLACK).bold().toString());
+			replacements.put(ChatColor.BLUE, Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.BLUE).bold().toString());
+			replacements.put(ChatColor.GREEN, Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.GREEN).bold().toString());
+			replacements.put(ChatColor.AQUA, Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.CYAN).bold().toString());
+			replacements.put(ChatColor.RED, Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.RED).bold().toString());
+			replacements.put(ChatColor.LIGHT_PURPLE, Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.MAGENTA).bold().toString());
+			replacements.put(ChatColor.YELLOW, Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.YELLOW).bold().toString());
+			replacements.put(ChatColor.WHITE, Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.WHITE).bold().toString());
+			replacements.put(ChatColor.MAGIC, Ansi.ansi().a(Ansi.Attribute.BLINK_SLOW).toString());
+			replacements.put(ChatColor.BOLD, Ansi.ansi().a(Ansi.Attribute.UNDERLINE_DOUBLE).toString());
+			replacements.put(ChatColor.STRIKETHROUGH, Ansi.ansi().a(Ansi.Attribute.STRIKETHROUGH_ON).toString());
+			replacements.put(ChatColor.UNDERLINE, Ansi.ansi().a(Ansi.Attribute.UNDERLINE).toString());
+			replacements.put(ChatColor.ITALIC, Ansi.ansi().a(Ansi.Attribute.ITALIC).toString());
+			replacements.put(ChatColor.RESET, Ansi.ansi().a(Ansi.Attribute.RESET).toString());
+
+			this.console = console;
+			this.listener = listener;
+		}
+
+		public void print(String s) {
+			for (ChatColor color : colors) {
+				s = s.replaceAll("(?i)" + color.toString(), replacements.get(color));
+			}
+			s = Ansi.ansi().eraseLine(Erase.ALL).toString() + ConsoleReader.RESET_LINE + s + Ansi.ansi().reset().toString();
+			listener.addMessage(s);
+			if (listener.terminalEnabled || true) {
+				writed = true;
+				try {
+					console.print(s);
+					console.drawLine();
+					console.flush();
+				}catch(Exception e){
+					e.printStackTrace();
+				}
+			} else {
+				listener.lineBffer.add(s);
+			}
+		}
+
+		@Override
+		public void publish(LogRecord record) {
+			if (isLoggable(record)) {
+				if(getFormatter()!= null)
+					print(getFormatter().format(record));
+				else
+					print(record.getMessage());
+			}
+		}
+
+		@Override
+		public void flush() {
+		}
+
+		@Override
+		public void close() throws SecurityException {
+		}
+	}
+
+	private ArrayList<String> lineBffer = new ArrayList<>();
+	@Getter
+	private boolean terminalEnabled = true;
+	private ScheduledTask task;
+	private ColouredWriterAdapter writer;
+	private LinkedList<String> lines = new LinkedList<>();
+	@Getter
+	private CopyOnWriteArrayList<Listener> listener = new CopyOnWriteArrayList<>();
+
+	public TerminalListener() {
+		BungeeLogger logger = (BungeeLogger) BungeeCord.getInstance().getLogger();
+		ColouredWriter org = null;
+		for (Handler h : logger.getHandlers())
+			if (h instanceof ColouredWriter) {
+				logger.removeHandler(h);
+				org = (ColouredWriter) h;
+			}
+		logger.addHandler(writer = new ColouredWriterAdapter(this, BungeeCord.getInstance().getConsoleReader()));
+		writer.setLevel( Level.INFO );
+		if(org != null)
+			writer.setFormatter(org.getFormatter());
+		else
+			addMessage("\u00A7cCant find BungeeCord Terminal handler!");
+		task = BungeeCord.getInstance().getScheduler().runAsync(BungeeUtil.getPluginInstance(), new Runnable() {
+			int oldWidth = -1, oldHeight = -1;
+
+			@Override
+			public void run() {
+				while (BungeeUtil.getInstance().isActive()) {
+					try {
+						Thread.sleep(5);
+					} catch (InterruptedException e) {
+						e.printStackTrace();
+					}
+					if (TerminalFactory.get().getHeight() != oldHeight || TerminalFactory.get().getWidth() != oldWidth) {
+						for (Listener l : listener)
+							l.onResize(oldWidth, oldHeight, TerminalFactory.get().getWidth(), TerminalFactory.get().getHeight());
+						oldHeight = TerminalFactory.get().getHeight();
+						oldWidth = TerminalFactory.get().getWidth();
+					}
+					if (writer.writed) {
+						writer.writed = false;
+						for (Listener l : listener)
+							l.onLinesPrinted();
+					}
+				}
+			}
+		});
+	}
+
+	public void setTerminalEnabled(boolean terminalEnabled) {
+		this.terminalEnabled = terminalEnabled;
+		if (terminalEnabled) {
+			try {
+				for(String line : lineBffer)
+					AnsiConsole.out.println(line);
+				writer.writed = true;
+			} catch (Exception e) {
+			}
+			lineBffer.clear();
+		}
+	}
+
+	protected void addMessage(String message) {
+		lines.push(message);
+		while (lines.size() > 1000)
+			lines.removeLast();
+	}
+
+	public void repaintTerminal() {
+		try {
+			AnsiConsole.out.print("\033[H\033[2J");
+			AnsiConsole.out.print("\033[0;0H");
+			int h = TerminalFactory.get().getHeight();
+			int w = TerminalFactory.get().getWidth();
+			int fs = Math.max(0, h-lines.size());
+			
+			for (int i = 0; i < h; i++) {
+				if(h-i > -1 && lines.size() > (h-i)){
+					String message = lines.get(h-i);
+					//while(AnsiColorFormater.getFormater().stripAnsi(message).length() > w){
+					//	message = message.substring(0,message.length()-1); //TODO Ansi color chars not count
+					//}
+					AnsiConsole.out.print("\033["+(i)+";0H"+message);
+				}
+				//else
+				//	AnsiConsole.out.print("\033["+(i)+";0H"+Ansi.ansi().a(Ansi.Erase.ALL).toString());
+				AnsiConsole.out.flush();
+			}
+			BungeeCord.getInstance().getConsoleReader().drawLine();
+			//BungeeCord.getInstance().getConsoleReader().flush();
+			AnsiConsole.out.print("\033["+h+";"+(2+BungeeCord.getInstance().getConsoleReader().getCursorBuffer().buffer.length())+"H");
+			AnsiConsole.out.flush();
+		}catch(Exception e){
+			e.printStackTrace();
+		}
+	}
+}
diff --git a/src/main/java/dev/wolveringer/updater/Updater.java b/src/main/java/dev/wolveringer/updater/Updater.java
new file mode 100644
index 0000000..be860ae
--- /dev/null
+++ b/src/main/java/dev/wolveringer/updater/Updater.java
@@ -0,0 +1,325 @@
+package dev.wolveringer.updater;
+
+import java.io.BufferedInputStream;
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.math.BigDecimal;
+import java.math.BigInteger;
+import java.net.HttpURLConnection;
+import java.net.InetAddress;
+import java.net.URL;
+import java.net.URLConnection;
+import java.net.UnknownHostException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+import java.util.jar.JarInputStream;
+
+import javax.print.DocFlavor.STRING;
+
+import net.md_5.bungee.BungeeCord;
+import net.md_5.bungee.api.ProxyServer;
+import net.md_5.bungee.api.plugin.Plugin;
+
+import org.json.JSONArray;
+import org.json.JSONObject;
+
+import dev.wolveringer.BungeeUtil.BungeeUtil;
+import dev.wolveringer.BungeeUtil.Main;
+import dev.wolveringer.BungeeUtil.Material;
+import dev.wolveringer.BungeeUtil.configuration.Configuration;
+import dev.wolveringer.BungeeUtil.gameprofile.SkinFactory;
+import dev.wolveringer.BungeeUtil.item.ItemStack;
+import dev.wolveringer.BungeeUtil.item.ItemStack.Click;
+import dev.wolveringer.BungeeUtil.item.itemmeta.SkullMeta;
+import dev.wolveringer.chat.ChatColor.ChatColorUtils;
+import dev.wolveringer.util.MathUtil;
+import lombok.NonNull;
+
+/*
+ * 
+{
+	CurrentVersion: "1.6.7.7",
+	Download: "https://github.com/WolverinDEV/BungeeUtil/raw/jars/buildedJars/standalone/BungeeUtil-1.6.7.7.jar",
+	VersionsHistory: [
+		{
+			Version: "1.6.7.6",
+			Download: "https://github.com/WolverinDEV/BungeeUtil/raw/jars/buildedJars/standalone/BungeeUtil-1.6.7.6.jar",
+		}
+	],
+	Changelog: [
+		{
+			Verion: "1.6.7.7",
+			Changed: [
+				"Improved ram statistics. (Terminal)",
+				"Fixed PacketPlayOutPluginMessage bug",
+				"Removed java insturmental",
+				"Reimplemented sound API (Currently not working!)"
+			]
+		}
+	]
+}
+ * 
+ */
+public class Updater {
+	
+	private String url;
+	private JSONObject data;
+	private long last;
+	
+	public Updater(String url) {
+		this.url = url;
+	}
+	
+	public boolean checkUpdate() {
+		updateData();
+		BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR + "aChecking for Plugin updates");
+		if (data == null) throw new NullPointerException("HTTP Data is null. Invpoke getData() first");
+		if (!isNewstVersion()) {
+			installUpdate();
+			BungeeCord.getInstance().stop();
+			return true;
+		}
+		else {
+			if (!isDevBuild()) BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR + "aNo plugin update found! Your version is alredy the newest! (" + getCurrentVersion() + ")");
+			else BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR + "aYou plugin version is newer than the currunt public version. I think i'm a dev build... All bugs will be ignored");
+		}
+		return false;
+	}
+	
+	public void installUpdate(){
+		File ownFile = new File(getClass().getProtectionDomain().getCodeSource().getLocation().getFile());
+		downloadUpdate(data.getString("Download"), ownFile);
+		Configuration.setLastVersion(getCurrentVersion());
+	}
+	
+	public String getCurrentVersion(){
+		return Main.getMain().getDescription().getVersion();
+	}
+	
+	public String getNewestVersion() {
+		updateData();
+		return data.getString("CurrentVersion");
+	}
+	
+	public boolean isNewstVersion() {
+		return Long.parseLong(getNewestVersion().replaceAll("\\.", "")) <= Long.parseLong(getCurrentVersion().replaceAll("\\.", ""));
+	}
+	
+	public boolean isDevBuild(){
+		return Long.parseLong(getCurrentVersion().replaceAll("\\.", "")) > Long.parseLong(getNewestVersion().replaceAll("\\.", ""));
+	}
+	
+	/**
+	 * 
+	 * @param url
+	 * @param targetFile
+	 * @return errormask
+	 * errors:
+	 * 0: Create new file exception
+	 * 1: Invalid jar
+	 * 2: cant delete invalid jar
+	 * 3: Download IO error
+	 * 3: Finaly error
+	 */
+	private int downloadUpdate(String url, File targetFile) {
+		BigInteger errorMask = new BigInteger("0");
+		errorMask.setBit(8);
+		BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR + "aUpdating from "+getCurrentVersion()+" to "+getNewestVersion());
+		BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR + "aStarting to download the update ("+url+") to "+targetFile.getAbsolutePath());
+		programm:
+		try {
+			BungeeUtil.getInstance().setInformation(ChatColorUtils.COLOR_CHAR + "aDownloading update " + ChatColorUtils.COLOR_CHAR + "7[" + ChatColorUtils.COLOR_CHAR + "e000%" + ChatColorUtils.COLOR_CHAR + "7]");
+			BufferedInputStream in = null;
+			FileOutputStream fout = null;
+			try {
+				URLConnection com = new URL(url).openConnection();
+				int fileLength = com.getContentLength();
+				in = new BufferedInputStream(com.getInputStream());
+				File df;
+				if (targetFile.exists()) {
+					BungeeUtil.getInstance().setInformation(ChatColorUtils.COLOR_CHAR + "aUsing .download file ("+targetFile.getPath() + "BungeeUtil.download)!");
+					fout = new FileOutputStream(df = new File(targetFile.getPath() + "BungeeUtil.download"));
+				}
+				else fout = new FileOutputStream(df = targetFile);
+				final byte data[] = new byte[1024];
+				int count;
+				int readed = 0;
+				while (true) {
+					count = in.read(data, 0, 1024);
+					if (count == -1) break;
+					fout.write(data, 0, count);
+					readed += count;
+					String p = "000" + MathUtil.calculatePercent(readed, fileLength);
+					p = p.substring(0, p.indexOf("."));
+					p = p.substring(p.length() - 3, p.length());
+					BungeeUtil.getInstance().setInformation(ChatColorUtils.COLOR_CHAR + "aDownloading update " + ChatColorUtils.COLOR_CHAR + "7[" + ChatColorUtils.COLOR_CHAR + "e" + p + "%" + ChatColorUtils.COLOR_CHAR + "7]");
+				}
+				fout.close();
+				in.close();
+				BungeeUtil.getInstance().setInformation(ChatColorUtils.COLOR_CHAR + "aDownload done!");
+				BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR + "aUpdate downloaded!");
+				BungeeUtil.getInstance().setInformation(ChatColorUtils.COLOR_CHAR + "aCheck update for errors!");
+				BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR + "aCheck update for errors!");
+				try {
+					JarInputStream is = new JarInputStream(new FileInputStream(df));
+					while (null != is.getNextJarEntry()) {
+					}
+					is.close();
+				}
+				catch (Exception e) {
+					errorMask.setBit(1);
+					BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR + "cThe update contains an error. (Message: " + e.getLocalizedMessage() + ")");
+					BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR + "cDeleting the update!");
+					try {
+						df.delete();
+					}
+					catch (Exception ex) {
+						errorMask.setBit(2);
+					}
+					break programm;
+				}
+				BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR + "aUpdate valid.");
+				BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR + "aInstalling update!");
+				BungeeUtil.getInstance().setInformation(ChatColorUtils.COLOR_CHAR + "aInstalling update");
+				if (!targetFile.equals(df) && !targetFile.delete()) {
+					BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR + "6Cant delete the old plugin jar.");
+				}
+				boolean deleteOld = !targetFile.equals(df);
+				if(!targetFile.createNewFile()){
+					deleteOld = false;
+					BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR + "6Cant create new jar.");
+				}
+				FileInputStream fis = new FileInputStream(df);
+				FileOutputStream fos = new FileOutputStream(targetFile);
+				while ((count = fis.read(data, 0, 1024)) != -1) {
+					fos.write(data, 0, count);
+				}
+				fis.close();
+				fos.close();
+				if (deleteOld && !df.delete()) BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR + "6Cant delte cache file!");
+				BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR + "aRestarting bungeecord!");
+				BungeeUtil.getInstance().setInformation(ChatColorUtils.COLOR_CHAR + "aUpdate installed!");
+			}
+			catch (Exception e) {
+				errorMask.setBit(3);
+				e.printStackTrace();
+				BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR + "cAn error happend while downloading the update");
+			}
+			finally {
+				if (in != null) {
+					in.close();
+				}
+				if (fout != null) {
+					fout.close();
+				}
+			}
+		}
+		catch (Exception e) {
+			errorMask.setBit(4);
+			e.printStackTrace();
+			BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR + "cAn error happend while downloading the update");
+		}
+		return errorMask.intValue();
+	}
+	
+	public JSONObject getData() {
+		updateData();
+		return data;
+	}
+	
+	public Updater loadData() {
+		last = System.currentTimeMillis();
+		BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR + "aLoading update data!");
+		try {
+			URL i = new URL(url);
+			HttpURLConnection c = (HttpURLConnection) i.openConnection();
+			c.setRequestMethod("GET");
+			BufferedReader in = new BufferedReader(new InputStreamReader(c.getInputStream()));
+			String inputLine;
+			StringBuffer response = new StringBuffer();
+			while ((inputLine = in.readLine()) != null) {
+				response.append(inputLine);
+			}
+			in.close();
+			this.data = new JSONObject(response.toString());
+		}
+		catch (Exception e) {
+			BungeeUtil.debug(e);
+		}
+		return this;
+	}
+	
+	/*
+	@SuppressWarnings("deprecation")
+	public boolean isServerWhiteListed() {
+		try {
+			if (data == null) throw new NullPointerException("HTTP Data is null. Invpoke getData() first");
+		}
+		catch (Exception e) {
+			e.printStackTrace();
+			return true;
+		}
+		JSONObject plugins = data.getJSONObject("plugins");
+		if (plugins.has(Main.getMain().getDescription().getName())) {
+			JSONObject o = plugins.getJSONObject(Main.getMain().getDescription().getName());
+			if (o.has("whitelist")) { // TODO kick out. not longer needed
+				JSONArray a = o.getJSONArray("whitelist");
+				String host = "null";
+				String hostadress = "null";
+				try {
+					host = InetAddress.getLocalHost().getHostName();
+					hostadress = InetAddress.getLocalHost().getHostAddress();
+					if (host.equalsIgnoreCase("test-PC")) return true;
+				}
+				catch (UnknownHostException e) {
+					e.printStackTrace();
+				}
+				for (int i = 0; i < a.length(); i++) {
+					if (a.get(i).toString().equalsIgnoreCase(host) || a.get(i).toString().equalsIgnoreCase(hostadress)) return true;
+				}
+				BungeeCord.getInstance().getConsole().sendMessage(ChatColorUtils.COLOR_CHAR + "aYour Host: " + ChatColorUtils.COLOR_CHAR + "e" + host);
+				BungeeCord.getInstance().getConsole().sendMessage(ChatColorUtils.COLOR_CHAR + "aYour Host-Adress: " + ChatColorUtils.COLOR_CHAR + "e" + hostadress);
+				BungeeCord.getInstance().getConsole().sendMessage(ChatColorUtils.COLOR_CHAR + "cBoth Host's are not whitelisted.");
+				return false;
+			}
+		}
+		return true;
+	}
+	*/
+	
+	public HashMap<String, List<String>> createChanges(@NonNull String lastVersion){
+		HashMap<String, List<String>> out = new HashMap<>();
+		if(data != null){
+			JSONArray changelogArray = data.getJSONArray("Changelog");
+			Iterator<Object> objects = changelogArray.iterator();
+			while (objects.hasNext()) {
+				JSONObject object = (JSONObject) objects.next();
+				String version; 
+				System.out.print((Long.parseLong((version = object.getString("Verion")).replaceAll("\\.", "")) > Long.parseLong(lastVersion.replaceAll("\\.", "")))+"-"+(Long.parseLong((version = object.getString("Verion")).replaceAll("\\.", "")) +":"+ Long.parseLong(getCurrentVersion().replaceAll("\\.", ""))));
+				if(Long.parseLong((version = object.getString("Verion")).replaceAll("\\.", "")) > Long.parseLong(lastVersion.replaceAll("\\.", "")) && Long.parseLong((version = object.getString("Verion")).replaceAll("\\.", "")) <= Long.parseLong(getCurrentVersion().replaceAll("\\.", ""))){
+					ArrayList<String> changes = new ArrayList<>();
+					Iterator<Object> message = object.getJSONArray("Changed").iterator();
+					while (message.hasNext()) {
+						changes.add((String) message.next());
+					}
+					out.put(version, changes);
+				}
+			}
+		}
+		else
+			out.put("error", Arrays.asList("\u00A7cCant featch versions data.","Make shure you have an valid internet connection."));
+		return out;
+	}
+	
+	public void updateData() {
+		if (System.currentTimeMillis() - last > TimeUnit.MINUTES.toMillis(10)) loadData();
+	}
+}
diff --git a/src/main/java/dev/wolveringer/util/ByteString.java b/src/main/java/dev/wolveringer/util/ByteString.java
new file mode 100644
index 0000000..5f70bf4
--- /dev/null
+++ b/src/main/java/dev/wolveringer/util/ByteString.java
@@ -0,0 +1,25 @@
+package dev.wolveringer.util;
+
+public class ByteString {
+	private byte[] string;
+
+	public ByteString(String in) {
+		string = in.getBytes();
+	}
+
+	public ByteString(byte[] in) {
+		string = in;
+	}
+
+	public void setString(String in) {
+		string = in.getBytes();
+	}
+
+	public String getString() {
+		return new String(string, 0, string.length);
+	}
+
+	public byte[] getBytes() {
+		return this.string;
+	}
+}
diff --git a/src/main/java/dev/wolveringer/util/MathUtil.java b/src/main/java/dev/wolveringer/util/MathUtil.java
new file mode 100644
index 0000000..21ff394
--- /dev/null
+++ b/src/main/java/dev/wolveringer/util/MathUtil.java
@@ -0,0 +1,31 @@
+package dev.wolveringer.util;
+
+import java.math.BigDecimal;
+
+public class MathUtil {
+	private static final BigDecimal PERCENT_MULTIPLYER = new BigDecimal(100);
+	
+	public static float calculatePercent(int count, int max) {
+		BigDecimal bc = new BigDecimal(count);
+		BigDecimal bmax = new BigDecimal(max);
+		BigDecimal temp = bc.divide(bmax, 20, BigDecimal.ROUND_HALF_UP);
+		temp = temp.multiply(PERCENT_MULTIPLYER);
+		return temp.floatValue();
+	}
+	
+	public static void main(String[] args) {
+		System.out.println(calculatePercent(2310, 23423));
+		System.out.println("X: " + pitchNormalizer(-190));
+	}
+	
+	public static float pitchNormalizer(float pitch) {
+		pitch %= 360.0F;
+		if (pitch >= 180.0F) {
+			pitch -= 360.0F;
+		}
+		if (pitch < -180.0F) {
+			pitch += 360.0F;
+		}
+		return pitch;
+	}
+}
diff --git a/src/main/java/dev/wolveringer/util/UtilReflection.java b/src/main/java/dev/wolveringer/util/UtilReflection.java
new file mode 100644
index 0000000..7e4a089
--- /dev/null
+++ b/src/main/java/dev/wolveringer/util/UtilReflection.java
@@ -0,0 +1,92 @@
+package dev.wolveringer.util;
+
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+
+public class UtilReflection {
+	/*
+	private static class ClassReflectionUtils {
+		private static Method methode_class_getField0;
+		
+		static {
+			try {
+				methode_class_getField0 = Class.class.getDeclaredMethod("getField0", String.class);
+				methode_class_getField0.setAccessible(true);
+			} catch (NoSuchMethodException | SecurityException e) {
+				e.printStackTrace();
+			}
+		}
+		
+		public static Field getField(Class clazz,String field){
+			try {
+				return (Field) methode_class_getField0.invoke(clazz, field);
+			} catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
+				e.printStackTrace();
+			}
+			return null;
+		}
+	}
+	*/
+
+	public static boolean setField(Object obj, String field, Object value) {
+		Field f = getField(obj, field);
+		if (!f.isAccessible())
+			f.setAccessible(true);
+		try {
+			f.set(obj, value);
+		} catch (IllegalArgumentException | IllegalAccessException e) {
+			e.printStackTrace();
+			return false;
+		}
+		return true;
+	}
+	
+	public static boolean setField(Class clazz,Object obj, String field, Object value) {
+		Field f = getField(clazz, field);
+		if (!f.isAccessible())
+			f.setAccessible(true);
+		try {
+			f.set(obj, value);
+		} catch (IllegalArgumentException | IllegalAccessException e) {
+			e.printStackTrace();
+			return false;
+		}
+		return true;
+	}
+
+	public static Field getField(Object obj, String name) {
+		return getField(obj.getClass(), name);
+	}
+
+	public static Field getField(Class obj, String name) {
+		Field f = null;
+		try {
+			f = obj.getDeclaredField(name);
+		} catch (Exception e) {
+		}
+		if (f == null)
+			try {
+				f = obj.getField(name);
+			} catch (Exception e) {
+			}
+		if(!f.isAccessible())
+			f.setAccessible(true);
+		return f;
+	}
+	public static Method getMethod(Class obj, String name,Class...args) {
+		Method m = null;
+		try{
+			m = obj.getDeclaredMethod(name, args);
+		}catch(Exception e){
+		}
+		if(m == null)
+			try {
+				m = obj.getMethod(name, args);
+			} catch (NoSuchMethodException | SecurityException e) {
+			}
+		if(m != null)
+			if(!m.isAccessible())
+				m.setAccessible(true);
+		return m;
+	}
+}
diff --git a/src/main/resources/Messages.properties b/src/main/resources/Messages.properties
new file mode 100644
index 0000000..cfb7388
--- /dev/null
+++ b/src/main/resources/Messages.properties
@@ -0,0 +1,24 @@
+ChannelHandler.connection.bad-packet={0} - §cbad packet ID, are mods in use!?
+ChannelHandler.connection.connect={0}  has §aconnected
+ChannelHandler.connection.disconnect={0}  has §cdisconnected
+ChannelHandler.connection.encounteredException= - §cencountered exception
+ChannelHandler.connection.IOException={0} - §cIOException: §e{1}
+ChannelHandler.connection.progressingException= - §cexception processing exception
+ChannelHandler.connection.timeout={0} - §cread timed out
+network.timings.decoder.create.packet=createPacket
+network.timings.decoder.handle=Handle
+network.timings.decoder.handle.extern=Handle Extern
+network.timings.decoder.handle.intern=Handle Intern
+network.timings.decoder.read=read
+network.timings.decoder.write.writeNewbyteBuff=Write ByteBuff
+network.timings.encoder.write.writeNewbyteBuff=Write ByteBuff
+network.timings.encoder.create.packet=createPacket
+network.timings.encoder.definpacket.encript=Definpacket Encode
+network.timings.encoder.handle=Handle
+network.timings.encoder.handle.extern=Handle Extern
+network.timings.encoder.handle.intern=Handle Intern
+network.timings.encoder.packet.encript=Packet Encript
+network.timings.encoder.write=write
+configuration.name=config.yml
+configuration.timings=timings
+configuration.updater=updater
\ No newline at end of file
diff --git a/src/main/resources/bungee.yml b/src/main/resources/bungee.yml
new file mode 100644
index 0000000..dd59ce0
--- /dev/null
+++ b/src/main/resources/bungee.yml
@@ -0,0 +1,4 @@
+name: BungeeUtil
+main: dev.wolveringer.BungeeUtil.Main
+version: 1.6.7.15
+author: WolverinDEV
diff --git a/src/main/resources/config.yml b/src/main/resources/config.yml
new file mode 100644
index 0000000..cd52de7
--- /dev/null
+++ b/src/main/resources/config.yml
@@ -0,0 +1,58 @@
+######################################## 
+#              Timings:                # 
+#         Loging timings on/off        # 
+#                                      # 
+#              Updater:                # 
+#           Enable outo update         # 
+#                                      # 
+#             ByteBuffType:            # 
+#  The Used Buffer type for Packets    # 
+#              Avariable:              # 
+#    - 'direct'                        # 
+#    - 'heap'                          # 
+#                                      # 
+#               Terminal:              # 
+#      Colors in terminal on/off       # 
+#                                      # 
+#            Async-Catcher:            # 
+#  Enable it for more packet security  # 
+#        The catcher has 2 modes:      # 
+# - EXCEPTION (will throw a exception) # 
+# - WARNING (will print a warn message)# 
+#                                      #
+#             Debug messages           #
+#   Enable/Disable all debug messages  #  
+#                                      # 
+#               Utils:                 # 
+#  Enable/Disable some unused feature  #  
+#             to save ram              #  
+#                                      # 
+#                                      # 
+#        Handle Exception Action:      # 
+#        DISCONNECT, PRINT, NONE       #  
+######################################## 
+timings: true
+updater: true
+byteBuffType: direct
+system.gc:
+  enabled: false
+  periode: 60000
+terminal:
+  colored: true
+debug:
+  ram-statistics: true
+  messages: true
+loading:
+  inject:
+    buffer-size: 65536
+  fastboot: false
+async-catcher:
+  enabled: true
+  mode: EXCEPTION
+inventory:
+  synchandle: true
+utils:
+  scoreboard: true
+  bossbar: true
+network:
+  exception: DISCONNECT
diff --git a/src/main/resources/plugin.yml b/src/main/resources/plugin.yml
new file mode 100644
index 0000000..b49c030
--- /dev/null
+++ b/src/main/resources/plugin.yml
@@ -0,0 +1,6 @@
+name: BungeeUtil
+version: -1
+main: dev.wolveringer.BungeeUtil.bukkit.BukkitMain
+
+commands:
+  BungeeTimings:
diff --git a/src/test/java/dev/wolveringer/test/NormalPacketCreatorRedefieTest.java b/src/test/java/dev/wolveringer/test/NormalPacketCreatorRedefieTest.java
new file mode 100644
index 0000000..0766a8b
--- /dev/null
+++ b/src/test/java/dev/wolveringer/test/NormalPacketCreatorRedefieTest.java
@@ -0,0 +1,7 @@
+package dev.wolveringer.test;
+
+public class NormalPacketCreatorRedefieTest {
+	public static void main(String[] args) {
+		
+	}
+}
-- 
1.9.4.msysgit.2

