From fe2f855ccfa826a892b0876959e6f65e3a2bcb37 Mon Sep 17 00:00:00 2001
From: Acquized <flare.returns@outlook.com>
Date: Wed, 5 Oct 2016 11:04:24 +0200
Subject: [PATCH] [Cleanup] Rearrange Files, Reformat Imports and add two
 Annotations

---
 .../dev/wolveringer/BungeeUtil/AsyncCatcher.java   |  116 +-
 .../java/dev/wolveringer/BungeeUtil/BlockFace.java |   90 +-
 .../dev/wolveringer/BungeeUtil/BungeeUtil.java     |  535 ++--
 .../dev/wolveringer/BungeeUtil/ClientVersion.java  |  240 +-
 .../wolveringer/BungeeUtil/CostumPrintStream.java  |    5 +-
 .../wolveringer/BungeeUtil/DebugProperties.java    |   12 +-
 .../java/dev/wolveringer/BungeeUtil/HandType.java  |    4 +-
 .../wolveringer/BungeeUtil/HandleErrorAction.java  |    6 +-
 src/main/java/dev/wolveringer/BungeeUtil/Main.java |  174 +-
 .../java/dev/wolveringer/BungeeUtil/Material.java  | 1884 +++++++------
 .../dev/wolveringer/BungeeUtil/MaterialData.java   |  220 +-
 .../wolveringer/BungeeUtil/NumberConversions.java  |    3 +-
 .../OperatingSystem/OperatingSystemType.java       |  290 +-
 .../wolveringer/BungeeUtil/OperationCalback.java   |    2 +-
 .../wolveringer/BungeeUtil/PacketHandleEvent.java  |   83 +-
 .../dev/wolveringer/BungeeUtil/PacketHandler.java  |    2 +-
 .../java/dev/wolveringer/BungeeUtil/PacketLib.java |  337 +--
 .../java/dev/wolveringer/BungeeUtil/Player.java    |  140 +-
 .../dev/wolveringer/BungeeUtil/RamStatistics.java  |  251 +-
 .../BungeeUtil/RamStatisticsPainter.java           |  150 +-
 .../wolveringer/BungeeUtil/bukkit/BukkitMain.java  |    4 +-
 .../BungeeUtil/configuration/Configuration.java    |  198 +-
 .../BungeeUtil/exception/ExceptionUtils.java       |  226 +-
 .../BungeeUtil/gameprofile/GameProfile.java        |   93 +-
 .../gameprofile/GameProfileSerializer.java         |  172 +-
 .../BungeeUtil/gameprofile/PlayerInfoData.java     |  103 +-
 .../BungeeUtil/gameprofile/Property.java           |   68 +-
 .../BungeeUtil/gameprofile/PropertyMap.java        |  122 +-
 .../wolveringer/BungeeUtil/gameprofile/Skin.java   |  430 ++-
 .../BungeeUtil/gameprofile/SkinCache.java          |  151 +-
 .../BungeeUtil/gameprofile/SkinFactory.java        |  217 +-
 .../BungeeUtil/gameprofile/SkinRequest.java        |   70 +-
 .../BungeeUtil/gameprofile/SteveSkin.java          |  212 +-
 .../wolveringer/BungeeUtil/gameprofile/Test.java   |   12 +-
 .../BungeeUtil/gameprofile/UUIDFetcher.java        |  103 +-
 .../BungeeUtil/injector/InjectFiles.java           |  189 +-
 .../wolveringer/BungeeUtil/item/ClickListener.java |    2 +-
 .../java/dev/wolveringer/BungeeUtil/item/Item.java |  785 +++---
 .../wolveringer/BungeeUtil/item/ItemBuilder.java   |  250 +-
 .../dev/wolveringer/BungeeUtil/item/ItemStack.java |  150 +-
 .../BungeeUtil/item/MultiClickItemStack.java       |   70 +-
 .../wolveringer/BungeeUtil/item/SyncHandle.java    |    3 +-
 .../java/dev/wolveringer/BungeeUtil/item/Test.java |   17 +-
 .../BungeeUtil/item/itemmeta/CraftItemMeta.java    |  318 ++-
 .../BungeeUtil/item/itemmeta/ItemMeta.java         |   98 +-
 .../BungeeUtil/item/itemmeta/MetaFactory.java      |  163 +-
 .../BungeeUtil/item/itemmeta/MetaListener.java     |    2 +-
 .../BungeeUtil/item/itemmeta/SkullMeta.java        |  214 +-
 .../packets/Abstract/PacketAbstract.java           |   34 +-
 .../BungeeUtil/packets/Abstract/PacketPlayIn.java  |    3 +-
 .../BungeeUtil/packets/Abstract/PacketPlayOut.java |    3 +-
 .../Abstract/PacketPlayOutEntityAbstract.java      |   61 +-
 .../Abstract/PacketPlayXXXHeldItemSlot.java        |   37 +-
 .../BungeeUtil/packets/AbstractPacketCreator.java  |  340 +--
 .../wolveringer/BungeeUtil/packets/BetaPacket.java |   55 +-
 .../BungeeUtil/packets/NormalPacketCreator.java    |  306 +--
 .../dev/wolveringer/BungeeUtil/packets/Packet.java |  543 ++--
 .../BungeeUtil/packets/PacketLoginDisconnect.java  |   42 +-
 .../packets/PacketPlayInArmAnimation.java          |   67 +-
 .../BungeeUtil/packets/PacketPlayInBlockDig.java   |  121 +-
 .../BungeeUtil/packets/PacketPlayInBlockPlace.java |  165 +-
 .../BungeeUtil/packets/PacketPlayInChat.java       |   64 +-
 .../packets/PacketPlayInClientState.java           |   45 +-
 .../packets/PacketPlayInCloseWindow.java           |   36 +-
 .../BungeeUtil/packets/PacketPlayInFlying.java     |   98 +-
 .../packets/PacketPlayInHeldItemSlot.java          |   35 +-
 .../BungeeUtil/packets/PacketPlayInLook.java       |   32 +-
 .../packets/PacketPlayInPluginMessage.java         |  140 +-
 .../BungeeUtil/packets/PacketPlayInPosition.java   |   51 +-
 .../packets/PacketPlayInPositionLook.java          |   57 +-
 .../BungeeUtil/packets/PacketPlayInUpdateSign.java |   77 +-
 .../BungeeUtil/packets/PacketPlayInUseEntity.java  |  163 +-
 .../packets/PacketPlayInWindowClick.java           |  280 +-
 .../BungeeUtil/packets/PacketPlayOutBossBar.java   |  348 +--
 .../BungeeUtil/packets/PacketPlayOutChat.java      |   98 +-
 .../packets/PacketPlayOutCloseWindow.java          |   46 +-
 .../packets/PacketPlayOutDisconnect.java           |   50 +-
 .../packets/PacketPlayOutEntityDestroy.java        |   79 +-
 .../packets/PacketPlayOutEntityEffect.java         |  102 +-
 .../packets/PacketPlayOutEntityEquipment.java      |  120 +-
 .../packets/PacketPlayOutEntityHeadRotation.java   |   65 +-
 .../packets/PacketPlayOutEntityMetadata.java       |   64 +-
 .../packets/PacketPlayOutEntityProperties.java     |  310 ++-
 .../packets/PacketPlayOutEntityTeleport.java       |  180 +-
 .../packets/PacketPlayOutGameStateChange.java      |   80 +-
 .../packets/PacketPlayOutHeldItemSlot.java         |   35 +-
 .../BungeeUtil/packets/PacketPlayOutKeepAlive.java |   43 +-
 .../packets/PacketPlayOutNamedEntitySpawn.java     |  290 +-
 .../packets/PacketPlayOutNamedSoundEffect.java     |  104 +-
 .../packets/PacketPlayOutOpenWindow.java           |  207 +-
 .../packets/PacketPlayOutPlayerInfo.java           |  281 +-
 .../PacketPlayOutPlayerListHeaderFooter.java       |   85 +-
 .../packets/PacketPlayOutPluginMessage.java        |  134 +-
 .../BungeeUtil/packets/PacketPlayOutPosition.java  |  112 +-
 .../packets/PacketPlayOutRemoveEntityEffect.java   |   85 +-
 .../PacketPlayOutScoreboardDisplayObjective.java   |  106 +-
 .../packets/PacketPlayOutScoreboardObjective.java  |  213 +-
 .../packets/PacketPlayOutScoreboardScore.java      |  175 +-
 .../packets/PacketPlayOutScoreboardTeam.java       |  420 +--
 .../packets/PacketPlayOutSetExperience.java        |   92 +-
 .../BungeeUtil/packets/PacketPlayOutSetSlot.java   |  106 +-
 .../packets/PacketPlayOutSpawnEntity.java          |  114 +-
 .../packets/PacketPlayOutSpawnEntityLiving.java    |  251 +-
 .../packets/PacketPlayOutSpawnPostition.java       |   45 +-
 .../BungeeUtil/packets/PacketPlayOutStatistic.java |   78 +-
 .../BungeeUtil/packets/PacketPlayOutTitle.java     |  102 +-
 .../packets/PacketPlayOutTransaction.java          |  112 +-
 .../packets/PacketPlayOutUpdateHealth.java         |   61 +-
 .../packets/PacketPlayOutUpdateSign.java           |   81 +-
 .../packets/PacketPlayOutWindowData.java           |  110 +-
 .../packets/PacketPlayOutWindowItems.java          |   94 +-
 .../packets/PacketPlayOutWorldParticles.java       |  262 +-
 .../BungeeUtil/packets/UnderknownPacket.java       |   20 +-
 src/main/java/dev/wolveringer/NPC/Equipment.java   |  136 +-
 .../java/dev/wolveringer/NPC/InteractListener.java |    5 +-
 src/main/java/dev/wolveringer/NPC/NPC.java         |  600 +++--
 src/main/java/dev/wolveringer/NPC/NPCData.java     |  654 ++---
 .../java/dev/wolveringer/Reflect/Test/Main.java    |   40 +-
 .../java/dev/wolveringer/Reflect/Test/TEST.java    |   72 +-
 .../dev/wolveringer/Reflect/Test/TestClass.java    |    4 +-
 src/main/java/dev/wolveringer/Reflect/Until.java   |   50 +-
 src/main/java/dev/wolveringer/ServerDatReader.java |   76 +-
 .../java/dev/wolveringer/TimingsDataReader.java    |   79 +-
 .../java/dev/wolveringer/animations/Animation.java |   12 +-
 .../wolveringer/animations/AnimationCallback.java  |    2 +-
 .../inventory/InventoryViewChangeAnimations.java   |  417 ++-
 .../animations/inventory/LimetedScheduller.java    |   88 +-
 .../wolveringer/animations/text/FormatTest.java    |   36 +-
 .../wolveringer/animations/text/NumericUntil.java  |   54 +-
 .../animations/text/RunningTextFormater.java       |   91 +-
 .../dev/wolveringer/animations/text/Scroller.java  |  105 +-
 .../wolveringer/animations/text/StringUntils.java  |   40 +-
 .../wolveringer/animations/text/TextFormater.java  |  181 +-
 .../animations/text/TickedTextFormater.java        |   56 +-
 .../java/dev/wolveringer/annotations/Beta.java     |   37 +
 .../dev/wolveringer/annotations/Documented.java    |   37 +
 .../wolveringer/api/bossbar/BossBarListener.java   |   93 +-
 .../wolveringer/api/bossbar/BossBarManager.java    |  289 +-
 .../dev/wolveringer/api/datawatcher/BlockData.java |   22 +-
 .../wolveringer/api/datawatcher/DataWatcher.java   |   84 +-
 .../api/datawatcher/DataWatcherObjekt.java         |   80 +-
 .../dev/wolveringer/api/datawatcher/Direction.java |   20 +-
 .../api/datawatcher/EntityDataWatcher.java         |  115 +-
 .../api/datawatcher/HumanDataWatcher.java          |   20 +-
 .../api/datawatcher/LivingEntityDataWatcher.java   |   34 +-
 .../api/datawatcher/OptionalBlockPosition.java     |   26 +-
 .../wolveringer/api/datawatcher/OptionalUUID.java  |   22 +-
 .../api/datawatcher/impl/DataWatcherObjekt.java    |   80 +-
 .../api/datawatcher/impl/v1_10_DataWatcher.java    |  512 ++--
 .../datawatcher/impl/v1_10_EntityDataWatcher.java  |  309 +--
 .../impl/v1_10_HumanEntityDataWatcher.java         |   96 +-
 .../impl/v1_10_LivingEntityDataWatcher.java        |  107 +-
 .../api/datawatcher/impl/v1_8_DataWatcher.java     |  445 +--
 .../datawatcher/impl/v1_8_EntityDataWatcher.java   |  294 +-
 .../impl/v1_8_HumanEntityDataWatcher.java          |  105 +-
 .../impl/v1_8_LivingEntityDataWatcher.java         |  178 +-
 .../api/datawatcher/impl/v1_9_DataWatcher.java     |  510 ++--
 .../datawatcher/impl/v1_9_EntityDataWatcher.java   |  306 +--
 .../impl/v1_9_HumanEntityDataWatcher.java          |   96 +-
 .../impl/v1_9_LivingEntityDataWatcher.java         |  118 +-
 .../java/dev/wolveringer/api/gui/AnvilGui.java     |  660 +++--
 .../dev/wolveringer/api/gui/AnvilGuiListener.java  |   26 +-
 .../dev/wolveringer/api/inventory/Inventory.java   |  565 ++--
 .../wolveringer/api/inventory/InventoryType.java   |   67 +-
 .../wolveringer/api/inventory/ItemContainer.java   |  256 +-
 .../wolveringer/api/inventory/PlayerInventory.java |  216 +-
 .../api/inventory/ScrolingInventory.java           |  342 +--
 .../wolveringer/api/particel/ParticleEffect.java   | 2390 ++++++++---------
 .../wolveringer/api/position/BlockPosition.java    |   13 +-
 .../dev/wolveringer/api/position/Location.java     |  925 ++++---
 .../dev/wolveringer/api/position/Potision.java     |  107 +-
 .../java/dev/wolveringer/api/position/Vector.java  | 1299 +++++----
 .../dev/wolveringer/api/position/Vector3f.java     |   86 +-
 .../dev/wolveringer/api/scoreboard/Objektive.java  |  226 +-
 .../api/scoreboard/PacketListenerScoreboard.java   |  230 +-
 .../dev/wolveringer/api/scoreboard/Scoreboard.java |  169 +-
 .../java/dev/wolveringer/api/scoreboard/Team.java  |  184 +-
 .../dev/wolveringer/api/sound/SoundCategory.java   |   40 +-
 .../dev/wolveringer/api/sound/SoundEffect.java     | 2828 ++++++++++----------
 .../dev/wolveringer/chat/ChatBaseComponent.java    |  242 +-
 .../dev/wolveringer/chat/ChatClickListener.java    |    2 +-
 .../java/dev/wolveringer/chat/ChatClickable.java   |  106 +-
 .../chat/ChatColor/AnsiColorFormater.java          |  103 +-
 .../wolveringer/chat/ChatColor/ChatColorUtils.java |  282 +-
 .../dev/wolveringer/chat/ChatComponentText.java    |  139 +-
 .../java/dev/wolveringer/chat/ChatFunction1.java   |   13 +-
 .../java/dev/wolveringer/chat/ChatFunction2.java   |   19 +-
 .../java/dev/wolveringer/chat/ChatHoverable.java   |  106 +-
 .../java/dev/wolveringer/chat/ChatMessage.java     |  274 +-
 .../dev/wolveringer/chat/ChatMessageException.java |   18 +-
 .../java/dev/wolveringer/chat/ChatModifier.java    |  529 ++--
 .../wolveringer/chat/ChatModifierSerializer.java   |  258 +-
 .../java/dev/wolveringer/chat/ChatSerializer.java  |  578 ++--
 .../java/dev/wolveringer/chat/ChatStyleRoot.java   |  204 +-
 .../java/dev/wolveringer/chat/ChatTextBuilder.java |  115 +-
 .../java/dev/wolveringer/chat/ChatTypeAdapter.java |   92 +-
 .../wolveringer/chat/ChatTypeAdapterFactory.java   |   54 +-
 .../java/dev/wolveringer/chat/EnumClickAction.java |   72 +-
 .../java/dev/wolveringer/chat/EnumHoverAction.java |   68 +-
 .../dev/wolveringer/chat/IChatBaseComponent.java   |   30 +-
 .../dev/wolveringer/chat/PlayerChatListener.java   |   91 +-
 .../java/dev/wolveringer/chat/StringMethode.java   |   10 +-
 .../dev/wolveringer/commands/BungeeTimings.java    |  133 +-
 .../dev/wolveringer/commands/RamStatistics.java    |   81 +-
 .../wolveringer/configuration/Configuration.java   |   24 +-
 .../configuration/ConfigurationOptions.java        |    2 +-
 .../configuration/ConfigurationSection.java        |   41 +-
 .../InvalidConfigurationException.java             |    5 +-
 .../configuration/MemoryConfiguration.java         |   15 +-
 .../wolveringer/configuration/MemorySection.java   |  145 +-
 .../configuration/file/FileConfiguration.java      |   66 +-
 .../configuration/file/YamlConfiguration.java      |  456 ++--
 .../configuration/file/YamlConstructor.java        |    6 +-
 .../configuration/file/YamlRepresenter.java        |    6 +-
 .../serialization/ConfigurationSerialization.java  |  197 +-
 .../hastebin/DocumentNotFoundException.java        |   10 +-
 .../dev/wolveringer/hastebin/HastebinDocument.java |  133 +-
 .../dev/wolveringer/hastebin/HastebinPost.java     |  153 +-
 .../listener/InventoryResetListener.java           |   13 +-
 .../java/dev/wolveringer/maps/CachedArrayList.java |  490 ++--
 .../java/dev/wolveringer/maps/CachedHashMap.java   |  174 +-
 src/main/java/dev/wolveringer/nbt/LimitStream.java |   34 +-
 src/main/java/dev/wolveringer/nbt/MathHelper.java  |  257 +-
 src/main/java/dev/wolveringer/nbt/NBTBase.java     |  128 +-
 .../wolveringer/nbt/NBTCompressedStreamTools.java  |  294 +-
 src/main/java/dev/wolveringer/nbt/NBTNumber.java   |   16 +-
 .../java/dev/wolveringer/nbt/NBTReadLimiter.java   |   24 +-
 .../wolveringer/nbt/NBTReadLimiterUnlimited.java   |   11 +-
 src/main/java/dev/wolveringer/nbt/NBTTagByte.java  |  186 +-
 .../java/dev/wolveringer/nbt/NBTTagByteArray.java  |  157 +-
 .../java/dev/wolveringer/nbt/NBTTagCompound.java   |  652 ++---
 .../java/dev/wolveringer/nbt/NBTTagDouble.java     |  190 +-
 src/main/java/dev/wolveringer/nbt/NBTTagEnd.java   |   60 +-
 src/main/java/dev/wolveringer/nbt/NBTTagFloat.java |  186 +-
 src/main/java/dev/wolveringer/nbt/NBTTagInt.java   |  186 +-
 .../java/dev/wolveringer/nbt/NBTTagIntArray.java   |  204 +-
 src/main/java/dev/wolveringer/nbt/NBTTagList.java  |  336 +--
 src/main/java/dev/wolveringer/nbt/NBTTagLong.java  |  185 +-
 src/main/java/dev/wolveringer/nbt/NBTTagShort.java |  186 +-
 .../java/dev/wolveringer/nbt/NBTTagString.java     |  141 +-
 src/main/java/dev/wolveringer/network/Cleaner.java |   16 +-
 src/main/java/dev/wolveringer/network/Decoder.java |  401 ++-
 src/main/java/dev/wolveringer/network/Encoder.java |  142 +-
 .../dev/wolveringer/network/IIInitialHandler.java  |  678 ++---
 .../dev/wolveringer/network/IInitialHandler.java   |  401 ++-
 .../network/ProxiedPlayerUserConnection.java       |  537 ++--
 .../network/channel/ChannelHandler.java            |  184 +-
 .../network/channel/ChannelWrapper.java            |  649 +++--
 .../network/channel/init/BungeeConnectionInit.java |   23 +-
 .../channel/init/BungeeUtilChannelInit.java        |  221 +-
 .../network/channel/init/ChannelInizializer.java   |   93 +-
 .../network/inject/XChannelFutureListener.java     |   73 +-
 .../network/inject/XChannelInitializer.java        |   29 +-
 .../dev/wolveringer/packet/ByteBuffCreator.java    |   44 +-
 .../java/dev/wolveringer/packet/DebugMenue.java    |  153 +-
 .../dev/wolveringer/packet/MathHelper_v1_8.java    |  449 ++--
 .../dev/wolveringer/packet/ObjectSereizer.java     |   24 +-
 .../wolveringer/packet/PacketDataSerializer.java   | 1683 ++++++------
 .../packet/PacketDataSerializer_v1_7.java          |  368 +--
 .../packet/PacketDataSerializer_v1_8.java          |  493 ++--
 .../packet/PacketDataSerializer_vX_X.java          |   18 +-
 .../java/dev/wolveringer/packet/PacketHandle.java  |  358 +--
 .../dev/wolveringer/profiler/MethodProfiler.java   |  119 +-
 .../dev/wolveringer/profiler/ProfileMenue.java     |   99 +-
 .../java/dev/wolveringer/profiler/Profiler.java    |  461 ++--
 .../java/dev/wolveringer/profiler/Timings.java     |  344 +--
 .../java/dev/wolveringer/strings/Messages.java     |   23 +-
 .../dev/wolveringer/terminal/TerminalListener.java |  394 ++-
 src/main/java/dev/wolveringer/updater/Updater.java |  442 ++-
 src/main/java/dev/wolveringer/util/ByteString.java |   32 +-
 src/main/java/dev/wolveringer/util/MathUtil.java   |   50 +-
 .../java/dev/wolveringer/util/UtilReflection.java  |  123 +-
 272 files changed, 26473 insertions(+), 26302 deletions(-)
 create mode 100644 src/main/java/dev/wolveringer/annotations/Beta.java
 create mode 100644 src/main/java/dev/wolveringer/annotations/Documented.java

diff --git a/src/main/java/dev/wolveringer/BungeeUtil/AsyncCatcher.java b/src/main/java/dev/wolveringer/BungeeUtil/AsyncCatcher.java
index 1c80c43..083d892 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/AsyncCatcher.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/AsyncCatcher.java
@@ -1,66 +1,70 @@
 package dev.wolveringer.BungeeUtil;
 
+import net.md_5.bungee.api.plugin.Plugin;
+
 import java.util.ArrayList;
 
 import dev.wolveringer.BungeeUtil.configuration.Configuration;
 import dev.wolveringer.BungeeUtil.exception.ExceptionUtils;
-import net.md_5.bungee.api.plugin.Plugin;
 
 public class AsyncCatcher {
-	
-	public static enum AsyncCatcherMode {
-		DISABLED,
-		EXCEPTION,
-		WARNING;
-		
-		private AsyncCatcherMode() {}
-	}
-	
-	private static AsyncCatcherMode mode = AsyncCatcherMode.EXCEPTION;
-	private static ArrayList<ThreadGroup> unchecked_threads = new ArrayList<ThreadGroup>();
-	private static ArrayList<Plugin> unchecked_plugins = new ArrayList<Plugin>();
-	
-	public static void catchOp(String reason) {
-		if(mode != AsyncCatcherMode.DISABLED){
-			if(unchecked_threads.size() != 0)
-				for(Plugin p : unchecked_plugins)
-					if(p.getDescription().getName().contains(Thread.currentThread().getThreadGroup().getName()))
-						return;
-			if(unchecked_threads.size() != 0)
-				if(unchecked_threads.contains(Thread.currentThread().getThreadGroup()))
-					return;
-			if(mode == AsyncCatcherMode.EXCEPTION)
-				throw new IllegalStateException("Asynchronous " + reason + "!"); 
-			else if(mode == AsyncCatcherMode.WARNING){
-				StackTraceElement e = ExceptionUtils.getCurruntMethodeStackTraceElement();
-				if(e == null)
-					BungeeUtil.getInstance().sendMessage("Async catcher catched from underknown src. Message: "+reason);
-				else
-					BungeeUtil.getInstance().sendMessage("Async catcher catched from "+e.getClassName()+"#"+e.getMethodName()+"("+e.getLineNumber()+"). Message: "+reason);
-			}
-		}
-	}
-	
-	public static void disable(Plugin plugin){
-		if(unchecked_threads.contains(Thread.currentThread().getThreadGroup()));
-			//throw new UnsupportedOperationException("Thread alredy unregistered!");
-		unchecked_threads.add(Thread.currentThread().getThreadGroup());
-		unchecked_plugins.add(plugin);
-	}
-	public static void enable(Plugin plugin){
-		if(!unchecked_threads.contains(Thread.currentThread().getThreadGroup()));
-			//throw new UnsupportedOperationException("Thread alredy registered!");
-		unchecked_plugins.remove(plugin);
-		unchecked_threads.remove(Thread.currentThread().getThreadGroup());
-	}
-	@Deprecated
-	public static void disableAll(){
-		mode = AsyncCatcherMode.DISABLED;
-	}
 
-	public static void init() {
-		mode = Configuration.getAsyncMode();
-		if(mode == null)
-			throw new RuntimeException("Async catcher mode not found!");
-	}
+    private static AsyncCatcherMode mode = AsyncCatcherMode.EXCEPTION;
+    private static ArrayList<ThreadGroup> unchecked_threads = new ArrayList<ThreadGroup>();
+    private static ArrayList<Plugin> unchecked_plugins = new ArrayList<Plugin>();
+
+    public static void catchOp(String reason) {
+        if (mode != AsyncCatcherMode.DISABLED) {
+            if (unchecked_threads.size() != 0)
+                for (Plugin p : unchecked_plugins)
+                    if (p.getDescription().getName().contains(Thread.currentThread().getThreadGroup().getName()))
+                        return;
+            if (unchecked_threads.size() != 0)
+                if (unchecked_threads.contains(Thread.currentThread().getThreadGroup()))
+                    return;
+            if (mode == AsyncCatcherMode.EXCEPTION)
+                throw new IllegalStateException("Asynchronous " + reason + "!");
+            else if (mode == AsyncCatcherMode.WARNING) {
+                StackTraceElement e = ExceptionUtils.getCurruntMethodeStackTraceElement();
+                if (e == null)
+                    BungeeUtil.getInstance().sendMessage("Async catcher catched from underknown src. Message: " + reason);
+                else
+                    BungeeUtil.getInstance().sendMessage("Async catcher catched from " + e.getClassName() + "#" + e.getMethodName() + "(" + e.getLineNumber() + "). Message: " + reason);
+            }
+        }
+    }
+
+    public static void disable(Plugin plugin) {
+        if (unchecked_threads.contains(Thread.currentThread().getThreadGroup())) ;
+        //throw new UnsupportedOperationException("Thread alredy unregistered!");
+        unchecked_threads.add(Thread.currentThread().getThreadGroup());
+        unchecked_plugins.add(plugin);
+    }
+
+    public static void enable(Plugin plugin) {
+        if (!unchecked_threads.contains(Thread.currentThread().getThreadGroup())) ;
+        //throw new UnsupportedOperationException("Thread alredy registered!");
+        unchecked_plugins.remove(plugin);
+        unchecked_threads.remove(Thread.currentThread().getThreadGroup());
+    }
+
+    @Deprecated
+    public static void disableAll() {
+        mode = AsyncCatcherMode.DISABLED;
+    }
+
+    public static void init() {
+        mode = Configuration.getAsyncMode();
+        if (mode == null)
+            throw new RuntimeException("Async catcher mode not found!");
+    }
+
+    public static enum AsyncCatcherMode {
+        DISABLED,
+        EXCEPTION,
+        WARNING;
+
+        private AsyncCatcherMode() {
+        }
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/BlockFace.java b/src/main/java/dev/wolveringer/BungeeUtil/BlockFace.java
index 524e65d..6d4bd19 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/BlockFace.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/BlockFace.java
@@ -37,6 +37,13 @@ public enum BlockFace {
         this.modZ = face1.getModZ() + face2.getModZ();
     }
 
+    public static BlockFace getBlockFace(int modx, int mody, int modz) {
+        for (BlockFace f : values())
+            if (f.getModX() == modx && f.getModY() == mody && f.getModZ() == modz)
+                return f;
+        return null;
+    }
+
     /**
      * Get the amount of X-coordinates to modify to get the represented block
      *
@@ -66,71 +73,64 @@ public enum BlockFace {
 
     public BlockFace getOppositeFace() {
         switch (this) {
-        case NORTH:
-            return BlockFace.SOUTH;
+            case NORTH:
+                return BlockFace.SOUTH;
 
-        case SOUTH:
-            return BlockFace.NORTH;
+            case SOUTH:
+                return BlockFace.NORTH;
 
-        case EAST:
-            return BlockFace.WEST;
+            case EAST:
+                return BlockFace.WEST;
 
-        case WEST:
-            return BlockFace.EAST;
+            case WEST:
+                return BlockFace.EAST;
 
-        case UP:
-            return BlockFace.DOWN;
+            case UP:
+                return BlockFace.DOWN;
 
-        case DOWN:
-            return BlockFace.UP;
+            case DOWN:
+                return BlockFace.UP;
 
-        case NORTH_EAST:
-            return BlockFace.SOUTH_WEST;
+            case NORTH_EAST:
+                return BlockFace.SOUTH_WEST;
 
-        case NORTH_WEST:
-            return BlockFace.SOUTH_EAST;
+            case NORTH_WEST:
+                return BlockFace.SOUTH_EAST;
 
-        case SOUTH_EAST:
-            return BlockFace.NORTH_WEST;
+            case SOUTH_EAST:
+                return BlockFace.NORTH_WEST;
 
-        case SOUTH_WEST:
-            return BlockFace.NORTH_EAST;
+            case SOUTH_WEST:
+                return BlockFace.NORTH_EAST;
 
-        case WEST_NORTH_WEST:
-            return BlockFace.EAST_SOUTH_EAST;
+            case WEST_NORTH_WEST:
+                return BlockFace.EAST_SOUTH_EAST;
 
-        case NORTH_NORTH_WEST:
-            return BlockFace.SOUTH_SOUTH_EAST;
+            case NORTH_NORTH_WEST:
+                return BlockFace.SOUTH_SOUTH_EAST;
 
-        case NORTH_NORTH_EAST:
-            return BlockFace.SOUTH_SOUTH_WEST;
+            case NORTH_NORTH_EAST:
+                return BlockFace.SOUTH_SOUTH_WEST;
 
-        case EAST_NORTH_EAST:
-            return BlockFace.WEST_SOUTH_WEST;
+            case EAST_NORTH_EAST:
+                return BlockFace.WEST_SOUTH_WEST;
 
-        case EAST_SOUTH_EAST:
-            return BlockFace.WEST_NORTH_WEST;
+            case EAST_SOUTH_EAST:
+                return BlockFace.WEST_NORTH_WEST;
 
-        case SOUTH_SOUTH_EAST:
-            return BlockFace.NORTH_NORTH_WEST;
+            case SOUTH_SOUTH_EAST:
+                return BlockFace.NORTH_NORTH_WEST;
 
-        case SOUTH_SOUTH_WEST:
-            return BlockFace.NORTH_NORTH_EAST;
+            case SOUTH_SOUTH_WEST:
+                return BlockFace.NORTH_NORTH_EAST;
 
-        case WEST_SOUTH_WEST:
-            return BlockFace.EAST_NORTH_EAST;
+            case WEST_SOUTH_WEST:
+                return BlockFace.EAST_NORTH_EAST;
 
-        case SELF:
-            return BlockFace.SELF;
+            case SELF:
+                return BlockFace.SELF;
         }
 
         return BlockFace.SELF;
     }
-    
-    public static BlockFace getBlockFace(int modx,int mody,int modz){
-    	for(BlockFace f : values())
-    		if(f.getModX() == modx && f.getModY() == mody && f.getModZ() == modz)
-    			return f;
-    	return null;
-    }
 }
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/BungeeUtil.java b/src/main/java/dev/wolveringer/BungeeUtil/BungeeUtil.java
index 605b7d0..96e17df 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/BungeeUtil.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/BungeeUtil.java
@@ -23,274 +23,269 @@ import dev.wolveringer.terminal.TerminalListener;
 import lombok.Getter;
 
 public final class BungeeUtil {
-	@Getter
-	private static Plugin pluginInstance;
-	@Getter
-	private static BungeeUtil instance;
-	
-	public static BungeeUtil createInstance(Plugin plugin){
-		if(instance == null){
-			if(System.getProperty("bungeetil.instance") == null){
-				System.setProperty("bungeetil.instance", "WolverinDEV");
-			}
-			else
-				throw new NullPointerException("BungeeUtil have alredy an instance!");
-			pluginInstance = plugin;
-			instance = new BungeeUtil();
-		}
-		return instance;
-	}
-	
-	private BigInteger state = new BigDecimal(0).toBigInteger();
-	@Getter
-	private boolean active;
-	private boolean costumPromtLine = false;
-	private String costumPormtLineMessage = "";
-	private String costumPormtLineRawMessage = "";
-	private SimpleDateFormat date_format = new SimpleDateFormat("HH:mm:ss");
-	public RamStatistics ramStatistiks;
-	
-	private BungeeUtil() {}
-	
-	public void load(){
-		if(state.testBit(0) || active)
-			throw new RuntimeException("Alredy loading plugin.");
-		if(state.testBit(1))
-			throw new RuntimeException("BungeeUtil alredy loaded!");
-		if(!isInjected() && !state.testBit(3))
-			throw new RuntimeException("BungeeUtil isnt injected!");
-		state.setBit(0);
-		try{
-			active =  true;
-			setInformation("\u00A7aLoading configuration.");
-			sendMessage("\u00A7aLoading configuration.");
-			Configuration.init();
-			sleep(500);
-			setInformation("\u00A7aValidate configuration.");
-			sendMessage("\u00A7aValidate configuration.");
-			if(Configuration.getHandleExceptionAction() == null){
-				sendMessage("\u00A7cCant find the NetworkExceptionAction for "+Configuration.getConfig().getString("network.exception")+". \u00A76Using default ("+HandleErrorAction.DISCONNECT+")");
-				Configuration.getConfig().set("network.exception", HandleErrorAction.DISCONNECT.name().toUpperCase());
-			}
-			sleep(500);
-			setInformation("\u00A7aConfiguration valid.");
-			sendMessage("\u00A7aConfiguration valid.");
-			sleep(500);
-			setInformation("\u00A7aLoading AsyncCatcher");
-			sendMessage("\u00A7aLoading AsyncCatcher");
-			AsyncCatcher.init();
-			AsyncCatcher.disable(pluginInstance);
-			AsyncCatcher.catchOp("Async test failed");
-			TerminalListener.setInstance(new TerminalListener());
-			sleep(500);
-			setInformation("\u00A7aAsyncCatcher successfull loaded");
-			sendMessage("\u00A7aAsyncCatcher successfull loaded");
-			sleep(500);
-			setInformation("\u00A7aLoading ChannelInizializer");
-			sendMessage("\u00A7aLoading ChannelInizializer");
-			boolean flag = true;
-			try {
-				ChannelInizializer.init();
-			} catch (Exception e) {
-				flag = false;
-				e.printStackTrace();
-				sendMessage(ChatColorUtils.COLOR_CHAR + "7[" + ChatColorUtils.COLOR_CHAR + "eBungeeUntil" + ChatColorUtils.COLOR_CHAR + "7] " + ChatColorUtils.COLOR_CHAR + "cError while loading ProtocolLIB " + ChatColorUtils.COLOR_CHAR + "4Code: 002");
-				sendMessage(ChatColorUtils.COLOR_CHAR + "7[" + ChatColorUtils.COLOR_CHAR + "eBungeeUntil" + ChatColorUtils.COLOR_CHAR + "7] " + ChatColorUtils.COLOR_CHAR + "cDisable ProtocolLIB");
-			}
-			sleep(500);
-			if(!flag){
-				setInformation("\u00A7cAn error happend while loading aChannelInizializer.");
-				sendMessage("\u00A7cAn error happend while loading aChannelInizializer.");
-				sleep(500);
-				return;
-			}
-			setInformation("\u00A7aChannelInizializer successfull loaded.");
-			sendMessage("\u00A7aChannelInizializer successfull loaded.");
-			sleep(500);
-			setInformation("\u00A7aLoading player class");
-			sendMessage("\u00A7aLoading player class");
-			IIInitialHandler.init(ProxiedPlayerUserConnection.class);
-			sleep(500);
-			setInformation("\u00A7aPlayer class loaded");
-			sendMessage("\u00A7aPlayer class loaded");
-			
-			sleep(500);
-			setInformation("\u00A7aRegister commands and scheduler");
-			sendMessage("\u00A7aRegister commands and scheduler");
-			BungeeCord.getInstance().getPluginManager().registerListener(pluginInstance, new InventoryResetListener());
-			BungeeCord.getInstance().getPluginManager().registerCommand(pluginInstance, new BungeeTimings());
-			BungeeCord.getInstance().getScheduler().runAsync(pluginInstance, new Runnable() {
-				@Override
-				public void run() {
-					sendMessage("\u00A7eSystem.gc() -> Enabled: " + Configuration.isGCEnabled());
-					while (Configuration.isGCEnabled()) {
-						try {
-							Thread.sleep(5 * 1000);
-						}
-						catch (InterruptedException e) {
-						}
-						if (!active) return;
-						System.gc();
-					}
-				}
-			});
-			if (Configuration.ramStatistics()) {
-				ramStatistiks = new RamStatistics();
-				ramStatistiks.start();
-				RamStatisticsPainter tsp = new RamStatisticsPainter();
-				TerminalListener.getInstance().getListener().add(tsp);
-				BungeeCord.getInstance().getScheduler().runAsync(pluginInstance, tsp);
-				BungeeCord.getInstance().getPluginManager().registerCommand(pluginInstance, new dev.wolveringer.commands.RamStatistics());
-			}
-			
-			sleep(500);
-			setInformation("\u00A7aRegister packets");
-			sendMessage("\u00A7aRegister packets");
-			Packet.countPackets();
-			sleep(500);
-			setInformation("\u00A7aPackets registered");
-			sendMessage("\u00A7aPackets registered");
-			sleep(500);
-			setInformation(null);
-			state.setBit(1);
-			active = true;
-		}catch(Exception e){
-			active = false;
-			throw e;
-		}finally{
-			state.clearBit(0);
-		}
-	}
-	
-	public int inject(){
-		if(state.testBit(2))
-			throw new RuntimeException("Alredy injecting plugin.");
-		if(state.testBit(3))
-			throw new RuntimeException("BungeeUtil alredy injected!");
-		state.setBit(2);
-		try{
-			if(isInjected())
-				return -1;
-			setInformation("\u00A7aInjecting patches");
-			sendMessage("\u00A7aInjecting patches");
-			switch (InjectFiles.inject()) {
-			case -1:
-				return -1;
-			case 0:
-				sendMessage(ChatColorUtils.COLOR_CHAR + "7[" + ChatColorUtils.COLOR_CHAR + "eBungeeUntil" + ChatColorUtils.COLOR_CHAR + "7] " + ChatColorUtils.COLOR_CHAR + "cA fatal error has blocked in the injection of BungeeUtil.");
-				sendMessage(ChatColorUtils.COLOR_CHAR + "7[" + ChatColorUtils.COLOR_CHAR + "eBungeeUntil" + ChatColorUtils.COLOR_CHAR + "7] " + ChatColorUtils.COLOR_CHAR + "cDisable BungeeUtil");
-				setInformation(null);
-				return 2;
-			case 1:
-				sendMessage(ChatColorUtils.COLOR_CHAR + "7[" + ChatColorUtils.COLOR_CHAR + "eBungeeUntil" + ChatColorUtils.COLOR_CHAR + "7] " + ChatColorUtils.COLOR_CHAR + "aBungeeUtil injection successful. Need a BungeeCord restart.");
-				setInformation(null);
-				state.setBit(3);
-				return 0;
-		};
-		}finally{
-			state.clearBit(2);
-		}
-		return 2;
-	}
-	
-	public boolean isInjected(){
-		return InjectFiles.isInjected() || state.testBit(3);
-	}
-	
-	public static void debug(String string) {
-		if (pluginInstance == null || Configuration.isDebugEnabled()) System.out.println(string); // Debug if this not a plugin
-	}
-	
-	public static void debug(Exception e, String otherMessage) {
-		if (pluginInstance == null || Configuration.isDebugEnabled()) 
-			e.printStackTrace(); // Debug isf this not a plugin
-		else
-			System.out.println(otherMessage);
-	}
-	
-	public static void debug(Exception e) {
-		debug(e, "An error happed. "+e.getClass().getName().substring(e.getClass().getName().lastIndexOf('.'))+" message -> " + e.getMessage());
-	}
-	
-	void sleep(int millis) {
-		if (!Configuration.isFastBoot()) {
-			int procent = millis / 100;
-			int now = 0;
-			while (now * procent < millis) {
-				setPromt(costumPormtLineRawMessage + " [" + now + "%]");
-				try {
-					Thread.sleep(procent);
-				}
-				catch (InterruptedException ex) {
-					ex.printStackTrace();
-				}
-				now++;
-			}
-			setPromt(costumPormtLineRawMessage + " [100%]");
-			try {
-				Thread.sleep(100);
-			}
-			catch (InterruptedException ex) {
-				ex.printStackTrace();
-			}
-		}
-	}
-	
-	
-	public void disable(){
-		active = false;
-		BungeeCord.getInstance().getConsole().sendMessage(ChatColorUtils.COLOR_CHAR + "7[" + ChatColorUtils.COLOR_CHAR + "eBungeeUntil" + ChatColorUtils.COLOR_CHAR + "7] " + ChatColorUtils.COLOR_CHAR + "aThank you for using BungeeUntil");
-	}
-	
-	public void setInformation(String info) {
-		if ("".equalsIgnoreCase(info) || info == null) costumPromtLine = false;
-		else costumPromtLine = true;
-		costumPormtLineRawMessage = info;
-		setPromt(info);
-	}
-	
-	private void setPromt(String info) {
-		try {
-			if (costumPromtLine){
-				try{
-					BungeeCord.getInstance().getConsoleReader().resetPromptLine(costumPormtLineMessage = AnsiColorFormater.getFormater().format(ChatColorUtils.COLOR_CHAR + "aLoading BungeeUtil >> " + ChatColorUtils.COLOR_CHAR + "b" + info), "", 0);
-				}catch(Exception e){
-					try{
-						BungeeCord.getInstance().getConsoleReader().resetPromptLine("", "", 0);
-						BungeeCord.getInstance().getConsoleReader().resetPromptLine(costumPormtLineMessage = AnsiColorFormater.getFormater().format(ChatColorUtils.COLOR_CHAR + "aLoading BungeeUtil >> " + ChatColorUtils.COLOR_CHAR + "b" + info), "", 0);
-					}catch(Exception e2){
-						debug(e2);
-					}
-				}
-			}
-			else{
-				BungeeCord.getInstance().getConsoleReader().resetPromptLine(">", "", 1);
-			}
-		}
-		catch (IOException ex) {
-			ex.printStackTrace();
-		}
-	}
-	
-	@SuppressWarnings("deprecation")
-	public void sendMessage(String message) {
-		if (!message.startsWith(ChatColorUtils.PREFIX + " ")) message = ChatColorUtils.PREFIX + " " + message;
-		message = "\r" + date_format.format(new Date()) + " " + message;
-		if (costumPromtLine) {
-			try {
-				while (message.length() < costumPormtLineMessage.length()) {
-					message += " ";
-				}
-				BungeeCord.getInstance().getConsoleReader().resetPromptLine("", "", 0);
-				BungeeCord.getInstance().getConsole().sendMessage(message);
-				BungeeCord.getInstance().getConsoleReader().resetPromptLine(costumPormtLineMessage, "", 0);
-			}
-			catch (Exception e) {
-				e.printStackTrace();
-			}
-		}
-		else {
-			BungeeCord.getInstance().getConsole().sendMessage(message);
-		}
-	}
+    @Getter
+    private static Plugin pluginInstance;
+    @Getter
+    private static BungeeUtil instance;
+    public RamStatistics ramStatistiks;
+    private BigInteger state = new BigDecimal(0).toBigInteger();
+    @Getter
+    private boolean active;
+    private boolean costumPromtLine = false;
+    private String costumPormtLineMessage = "";
+    private String costumPormtLineRawMessage = "";
+    private SimpleDateFormat date_format = new SimpleDateFormat("HH:mm:ss");
+
+    private BungeeUtil() {
+    }
+
+    public static BungeeUtil createInstance(Plugin plugin) {
+        if (instance == null) {
+            if (System.getProperty("bungeetil.instance") == null) {
+                System.setProperty("bungeetil.instance", "WolverinDEV");
+            } else
+                throw new NullPointerException("BungeeUtil have alredy an instance!");
+            pluginInstance = plugin;
+            instance = new BungeeUtil();
+        }
+        return instance;
+    }
+
+    public static void debug(String string) {
+        if (pluginInstance == null || Configuration.isDebugEnabled())
+            System.out.println(string); // Debug if this not a plugin
+    }
+
+    public static void debug(Exception e, String otherMessage) {
+        if (pluginInstance == null || Configuration.isDebugEnabled())
+            e.printStackTrace(); // Debug isf this not a plugin
+        else
+            System.out.println(otherMessage);
+    }
+
+    public static void debug(Exception e) {
+        debug(e, "An error happed. " + e.getClass().getName().substring(e.getClass().getName().lastIndexOf('.')) + " message -> " + e.getMessage());
+    }
+
+    public void load() {
+        if (state.testBit(0) || active)
+            throw new RuntimeException("Alredy loading plugin.");
+        if (state.testBit(1))
+            throw new RuntimeException("BungeeUtil alredy loaded!");
+        if (!isInjected() && !state.testBit(3))
+            throw new RuntimeException("BungeeUtil isnt injected!");
+        state.setBit(0);
+        try {
+            active = true;
+            setInformation("\u00A7aLoading configuration.");
+            sendMessage("\u00A7aLoading configuration.");
+            Configuration.init();
+            sleep(500);
+            setInformation("\u00A7aValidate configuration.");
+            sendMessage("\u00A7aValidate configuration.");
+            if (Configuration.getHandleExceptionAction() == null) {
+                sendMessage("\u00A7cCant find the NetworkExceptionAction for " + Configuration.getConfig().getString("network.exception") + ". \u00A76Using default (" + HandleErrorAction.DISCONNECT + ")");
+                Configuration.getConfig().set("network.exception", HandleErrorAction.DISCONNECT.name().toUpperCase());
+            }
+            sleep(500);
+            setInformation("\u00A7aConfiguration valid.");
+            sendMessage("\u00A7aConfiguration valid.");
+            sleep(500);
+            setInformation("\u00A7aLoading AsyncCatcher");
+            sendMessage("\u00A7aLoading AsyncCatcher");
+            AsyncCatcher.init();
+            AsyncCatcher.disable(pluginInstance);
+            AsyncCatcher.catchOp("Async test failed");
+            TerminalListener.setInstance(new TerminalListener());
+            sleep(500);
+            setInformation("\u00A7aAsyncCatcher successfull loaded");
+            sendMessage("\u00A7aAsyncCatcher successfull loaded");
+            sleep(500);
+            setInformation("\u00A7aLoading ChannelInizializer");
+            sendMessage("\u00A7aLoading ChannelInizializer");
+            boolean flag = true;
+            try {
+                ChannelInizializer.init();
+            } catch (Exception e) {
+                flag = false;
+                e.printStackTrace();
+                sendMessage(ChatColorUtils.COLOR_CHAR + "7[" + ChatColorUtils.COLOR_CHAR + "eBungeeUntil" + ChatColorUtils.COLOR_CHAR + "7] " + ChatColorUtils.COLOR_CHAR + "cError while loading ProtocolLIB " + ChatColorUtils.COLOR_CHAR + "4Code: 002");
+                sendMessage(ChatColorUtils.COLOR_CHAR + "7[" + ChatColorUtils.COLOR_CHAR + "eBungeeUntil" + ChatColorUtils.COLOR_CHAR + "7] " + ChatColorUtils.COLOR_CHAR + "cDisable ProtocolLIB");
+            }
+            sleep(500);
+            if (!flag) {
+                setInformation("\u00A7cAn error happend while loading aChannelInizializer.");
+                sendMessage("\u00A7cAn error happend while loading aChannelInizializer.");
+                sleep(500);
+                return;
+            }
+            setInformation("\u00A7aChannelInizializer successfull loaded.");
+            sendMessage("\u00A7aChannelInizializer successfull loaded.");
+            sleep(500);
+            setInformation("\u00A7aLoading player class");
+            sendMessage("\u00A7aLoading player class");
+            IIInitialHandler.init(ProxiedPlayerUserConnection.class);
+            sleep(500);
+            setInformation("\u00A7aPlayer class loaded");
+            sendMessage("\u00A7aPlayer class loaded");
+
+            sleep(500);
+            setInformation("\u00A7aRegister commands and scheduler");
+            sendMessage("\u00A7aRegister commands and scheduler");
+            BungeeCord.getInstance().getPluginManager().registerListener(pluginInstance, new InventoryResetListener());
+            BungeeCord.getInstance().getPluginManager().registerCommand(pluginInstance, new BungeeTimings());
+            BungeeCord.getInstance().getScheduler().runAsync(pluginInstance, new Runnable() {
+                @Override
+                public void run() {
+                    sendMessage("\u00A7eSystem.gc() -> Enabled: " + Configuration.isGCEnabled());
+                    while (Configuration.isGCEnabled()) {
+                        try {
+                            Thread.sleep(5 * 1000);
+                        } catch (InterruptedException e) {
+                        }
+                        if (!active) return;
+                        System.gc();
+                    }
+                }
+            });
+            if (Configuration.ramStatistics()) {
+                ramStatistiks = new RamStatistics();
+                ramStatistiks.start();
+                RamStatisticsPainter tsp = new RamStatisticsPainter();
+                TerminalListener.getInstance().getListener().add(tsp);
+                BungeeCord.getInstance().getScheduler().runAsync(pluginInstance, tsp);
+                BungeeCord.getInstance().getPluginManager().registerCommand(pluginInstance, new dev.wolveringer.commands.RamStatistics());
+            }
+
+            sleep(500);
+            setInformation("\u00A7aRegister packets");
+            sendMessage("\u00A7aRegister packets");
+            Packet.countPackets();
+            sleep(500);
+            setInformation("\u00A7aPackets registered");
+            sendMessage("\u00A7aPackets registered");
+            sleep(500);
+            setInformation(null);
+            state.setBit(1);
+            active = true;
+        } catch (Exception e) {
+            active = false;
+            throw e;
+        } finally {
+            state.clearBit(0);
+        }
+    }
+
+    public int inject() {
+        if (state.testBit(2))
+            throw new RuntimeException("Alredy injecting plugin.");
+        if (state.testBit(3))
+            throw new RuntimeException("BungeeUtil alredy injected!");
+        state.setBit(2);
+        try {
+            if (isInjected())
+                return -1;
+            setInformation("\u00A7aInjecting patches");
+            sendMessage("\u00A7aInjecting patches");
+            switch (InjectFiles.inject()) {
+                case -1:
+                    return -1;
+                case 0:
+                    sendMessage(ChatColorUtils.COLOR_CHAR + "7[" + ChatColorUtils.COLOR_CHAR + "eBungeeUntil" + ChatColorUtils.COLOR_CHAR + "7] " + ChatColorUtils.COLOR_CHAR + "cA fatal error has blocked in the injection of BungeeUtil.");
+                    sendMessage(ChatColorUtils.COLOR_CHAR + "7[" + ChatColorUtils.COLOR_CHAR + "eBungeeUntil" + ChatColorUtils.COLOR_CHAR + "7] " + ChatColorUtils.COLOR_CHAR + "cDisable BungeeUtil");
+                    setInformation(null);
+                    return 2;
+                case 1:
+                    sendMessage(ChatColorUtils.COLOR_CHAR + "7[" + ChatColorUtils.COLOR_CHAR + "eBungeeUntil" + ChatColorUtils.COLOR_CHAR + "7] " + ChatColorUtils.COLOR_CHAR + "aBungeeUtil injection successful. Need a BungeeCord restart.");
+                    setInformation(null);
+                    state.setBit(3);
+                    return 0;
+            }
+            ;
+        } finally {
+            state.clearBit(2);
+        }
+        return 2;
+    }
+
+    public boolean isInjected() {
+        return InjectFiles.isInjected() || state.testBit(3);
+    }
+
+    void sleep(int millis) {
+        if (!Configuration.isFastBoot()) {
+            int procent = millis / 100;
+            int now = 0;
+            while (now * procent < millis) {
+                setPromt(costumPormtLineRawMessage + " [" + now + "%]");
+                try {
+                    Thread.sleep(procent);
+                } catch (InterruptedException ex) {
+                    ex.printStackTrace();
+                }
+                now++;
+            }
+            setPromt(costumPormtLineRawMessage + " [100%]");
+            try {
+                Thread.sleep(100);
+            } catch (InterruptedException ex) {
+                ex.printStackTrace();
+            }
+        }
+    }
+
+
+    public void disable() {
+        active = false;
+        BungeeCord.getInstance().getConsole().sendMessage(ChatColorUtils.COLOR_CHAR + "7[" + ChatColorUtils.COLOR_CHAR + "eBungeeUntil" + ChatColorUtils.COLOR_CHAR + "7] " + ChatColorUtils.COLOR_CHAR + "aThank you for using BungeeUntil");
+    }
+
+    public void setInformation(String info) {
+        if ("".equalsIgnoreCase(info) || info == null) costumPromtLine = false;
+        else costumPromtLine = true;
+        costumPormtLineRawMessage = info;
+        setPromt(info);
+    }
+
+    private void setPromt(String info) {
+        try {
+            if (costumPromtLine) {
+                try {
+                    BungeeCord.getInstance().getConsoleReader().resetPromptLine(costumPormtLineMessage = AnsiColorFormater.getFormater().format(ChatColorUtils.COLOR_CHAR + "aLoading BungeeUtil >> " + ChatColorUtils.COLOR_CHAR + "b" + info), "", 0);
+                } catch (Exception e) {
+                    try {
+                        BungeeCord.getInstance().getConsoleReader().resetPromptLine("", "", 0);
+                        BungeeCord.getInstance().getConsoleReader().resetPromptLine(costumPormtLineMessage = AnsiColorFormater.getFormater().format(ChatColorUtils.COLOR_CHAR + "aLoading BungeeUtil >> " + ChatColorUtils.COLOR_CHAR + "b" + info), "", 0);
+                    } catch (Exception e2) {
+                        debug(e2);
+                    }
+                }
+            } else {
+                BungeeCord.getInstance().getConsoleReader().resetPromptLine(">", "", 1);
+            }
+        } catch (IOException ex) {
+            ex.printStackTrace();
+        }
+    }
+
+    @SuppressWarnings("deprecation")
+    public void sendMessage(String message) {
+        if (!message.startsWith(ChatColorUtils.PREFIX + " "))
+            message = ChatColorUtils.PREFIX + " " + message;
+        message = "\r" + date_format.format(new Date()) + " " + message;
+        if (costumPromtLine) {
+            try {
+                while (message.length() < costumPormtLineMessage.length()) {
+                    message += " ";
+                }
+                BungeeCord.getInstance().getConsoleReader().resetPromptLine("", "", 0);
+                BungeeCord.getInstance().getConsole().sendMessage(message);
+                BungeeCord.getInstance().getConsoleReader().resetPromptLine(costumPormtLineMessage, "", 0);
+            } catch (Exception e) {
+                e.printStackTrace();
+            }
+        } else {
+            BungeeCord.getInstance().getConsole().sendMessage(message);
+        }
+    }
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/ClientVersion.java b/src/main/java/dev/wolveringer/BungeeUtil/ClientVersion.java
index e736db5..0914649 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/ClientVersion.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/ClientVersion.java
@@ -2,128 +2,126 @@ package dev.wolveringer.BungeeUtil;
 
 import java.util.ArrayList;
 
-import lombok.AllArgsConstructor;
 import lombok.Getter;
-import net.md_5.bungee.api.ChatMessageType;
-import net.md_5.bungee.api.connection.ProxiedPlayer;
 
 public enum ClientVersion {
-	UnderknownVersion(-1, BigClientVersion.UnderknownVersion, ProtocollVersion.Unsupported),
-	v1_7_1(4, BigClientVersion.v1_7, ProtocollVersion.v1_7),
-	v1_7_2(4, BigClientVersion.v1_7, ProtocollVersion.v1_7),
-	v1_7_3(4, BigClientVersion.v1_7, ProtocollVersion.v1_7),
-	v1_7_4(4, BigClientVersion.v1_7, ProtocollVersion.v1_7),
-	v1_7_5(4, BigClientVersion.v1_7, ProtocollVersion.v1_7),
-	v1_7_6(5, BigClientVersion.v1_7, ProtocollVersion.v1_7),
-	v1_7_7(5, BigClientVersion.v1_7, ProtocollVersion.v1_7),
-	v1_7_8(5, BigClientVersion.v1_7, ProtocollVersion.v1_7),
-	v1_7_9(5, BigClientVersion.v1_7, ProtocollVersion.v1_7),
-	v1_7_10(5, BigClientVersion.v1_7, ProtocollVersion.v1_7),
-	v1_8_0(47, BigClientVersion.v1_8, ProtocollVersion.v1_8),
-	v1_8_1(47, BigClientVersion.v1_8, ProtocollVersion.v1_8),
-	v1_8_2(47, BigClientVersion.v1_8, ProtocollVersion.v1_8), // 1.8.2-1.8.10
-	                                                          // //Unchanged
-	v1_8_3(47, BigClientVersion.v1_8, ProtocollVersion.v1_8),
-	v1_8_4(47, BigClientVersion.v1_8, ProtocollVersion.v1_8),
-	v1_8_5(47, BigClientVersion.v1_8, ProtocollVersion.v1_8),
-	v1_8_6(47, BigClientVersion.v1_8, ProtocollVersion.v1_8),
-	v1_8_7(47, BigClientVersion.v1_8, ProtocollVersion.v1_8),
-	v1_8_8(47, BigClientVersion.v1_8, ProtocollVersion.v1_8),
-	v1_8_9(47, BigClientVersion.v1_8, ProtocollVersion.v1_8),
-	v1_8_10(47, BigClientVersion.v1_8, ProtocollVersion.v1_8),
-	// Skip snapshots
-	v1_9_0(107, BigClientVersion.v1_9, ProtocollVersion.v1_9),
-	v1_9_1(107, BigClientVersion.v1_9, ProtocollVersion.v1_9),
-	v1_9_2(108, BigClientVersion.v1_9, ProtocollVersion.v1_9_2),
-	v1_9_3(109, BigClientVersion.v1_9, ProtocollVersion.v1_9_3),
-	v1_9_4(110, BigClientVersion.v1_9, ProtocollVersion.v1_9_4),
-	v1_9_5(110, BigClientVersion.v1_9, ProtocollVersion.v1_9_4),
-	v1_10_0(210, BigClientVersion.v1_10, ProtocollVersion.v1_10);
-	
-	@Getter
-	private int version;
-	private BigClientVersion bigClientVersion;
-	@Getter
-	private ProtocollVersion protocollVersion;
-	
-	private ClientVersion(int v, BigClientVersion bv, ProtocollVersion protocol) {
-		this.version = v;
-		this.bigClientVersion = bv;
-		this.protocollVersion = protocol;
-	}
-	
-	public BigClientVersion getBigVersion() {
-		return bigClientVersion;
-	}
-	
-	public static enum BigClientVersion {
-		UnderknownVersion(0),
-		v1_7(1),
-		v1_8(2),
-		v1_9(3),
-		v1_10(7);
-		
-		private ProtocollVersion protocollVersion;
-		private int protocollVersionInt;
-		private ProtocollVersion[] protocollVersions;
-		
-		private BigClientVersion(int basedVersion) {
-			this.protocollVersionInt = basedVersion;
-		}
-		public ProtocollVersion getProtocollVersion() {
-			if(protocollVersion == null)
-				protocollVersion = ProtocollVersion.values()[protocollVersionInt];
-			return protocollVersion;
-		}
-
-		public ProtocollVersion[] getProtocollVersions(){
-			if(protocollVersions != null)
-				return protocollVersions;
-			ArrayList<ProtocollVersion> versions = new ArrayList<>();
-			for(ProtocollVersion v : ProtocollVersion.values())
-				if(v.getBasedVersion() == this)
-					versions.add(v);
-			this.protocollVersions = versions.toArray(new ProtocollVersion[0]);
-			return protocollVersions;
-		}
-	}
-	
-	@Getter
-	public static enum ProtocollVersion {
-		Unsupported(0, -1, false),
-		v1_7(1, 5, false),
-		v1_8(2, 47, true),
-		v1_9(3, 107, true),
-		v1_9_2(3,108, true),
-		v1_9_3(3, 109, true),
-		v1_9_4(3, 110, true),
-		v1_10(4, 210, true);
-		
-		private int basedVersionInt;
-		private BigClientVersion basedVersion;
-		private boolean supported;
-		private int protocollVersion;
-		
-		private ProtocollVersion(int basedVersion,int protocoll, boolean supported) {
-			this.basedVersionInt = basedVersion;
-			this.supported = supported;
-			this.protocollVersion = protocoll;
-		}
-		
-		public BigClientVersion getBasedVersion(){
-			if(basedVersion == null)
-				basedVersion = BigClientVersion.values()[basedVersionInt];
-			return basedVersion;
-		}
-		
-		public int getProtocollVersion(){
-			return protocollVersion;
-		}
-	}
-	
-	public static ClientVersion fromProtocoll(int protocolVersion) {
-		for (ClientVersion v : ClientVersion.values())
-			if (v.getVersion() == protocolVersion) return v;
-		return null;
-	}
+    UnderknownVersion(-1, BigClientVersion.UnderknownVersion, ProtocollVersion.Unsupported),
+    v1_7_1(4, BigClientVersion.v1_7, ProtocollVersion.v1_7),
+    v1_7_2(4, BigClientVersion.v1_7, ProtocollVersion.v1_7),
+    v1_7_3(4, BigClientVersion.v1_7, ProtocollVersion.v1_7),
+    v1_7_4(4, BigClientVersion.v1_7, ProtocollVersion.v1_7),
+    v1_7_5(4, BigClientVersion.v1_7, ProtocollVersion.v1_7),
+    v1_7_6(5, BigClientVersion.v1_7, ProtocollVersion.v1_7),
+    v1_7_7(5, BigClientVersion.v1_7, ProtocollVersion.v1_7),
+    v1_7_8(5, BigClientVersion.v1_7, ProtocollVersion.v1_7),
+    v1_7_9(5, BigClientVersion.v1_7, ProtocollVersion.v1_7),
+    v1_7_10(5, BigClientVersion.v1_7, ProtocollVersion.v1_7),
+    v1_8_0(47, BigClientVersion.v1_8, ProtocollVersion.v1_8),
+    v1_8_1(47, BigClientVersion.v1_8, ProtocollVersion.v1_8),
+    v1_8_2(47, BigClientVersion.v1_8, ProtocollVersion.v1_8), // 1.8.2-1.8.10
+    // //Unchanged
+    v1_8_3(47, BigClientVersion.v1_8, ProtocollVersion.v1_8),
+    v1_8_4(47, BigClientVersion.v1_8, ProtocollVersion.v1_8),
+    v1_8_5(47, BigClientVersion.v1_8, ProtocollVersion.v1_8),
+    v1_8_6(47, BigClientVersion.v1_8, ProtocollVersion.v1_8),
+    v1_8_7(47, BigClientVersion.v1_8, ProtocollVersion.v1_8),
+    v1_8_8(47, BigClientVersion.v1_8, ProtocollVersion.v1_8),
+    v1_8_9(47, BigClientVersion.v1_8, ProtocollVersion.v1_8),
+    v1_8_10(47, BigClientVersion.v1_8, ProtocollVersion.v1_8),
+    // Skip snapshots
+    v1_9_0(107, BigClientVersion.v1_9, ProtocollVersion.v1_9),
+    v1_9_1(107, BigClientVersion.v1_9, ProtocollVersion.v1_9),
+    v1_9_2(108, BigClientVersion.v1_9, ProtocollVersion.v1_9_2),
+    v1_9_3(109, BigClientVersion.v1_9, ProtocollVersion.v1_9_3),
+    v1_9_4(110, BigClientVersion.v1_9, ProtocollVersion.v1_9_4),
+    v1_9_5(110, BigClientVersion.v1_9, ProtocollVersion.v1_9_4),
+    v1_10_0(210, BigClientVersion.v1_10, ProtocollVersion.v1_10);
+
+    @Getter
+    private int version;
+    private BigClientVersion bigClientVersion;
+    @Getter
+    private ProtocollVersion protocollVersion;
+
+    private ClientVersion(int v, BigClientVersion bv, ProtocollVersion protocol) {
+        this.version = v;
+        this.bigClientVersion = bv;
+        this.protocollVersion = protocol;
+    }
+
+    public static ClientVersion fromProtocoll(int protocolVersion) {
+        for (ClientVersion v : ClientVersion.values())
+            if (v.getVersion() == protocolVersion) return v;
+        return null;
+    }
+
+    public BigClientVersion getBigVersion() {
+        return bigClientVersion;
+    }
+
+    public static enum BigClientVersion {
+        UnderknownVersion(0),
+        v1_7(1),
+        v1_8(2),
+        v1_9(3),
+        v1_10(7);
+
+        private ProtocollVersion protocollVersion;
+        private int protocollVersionInt;
+        private ProtocollVersion[] protocollVersions;
+
+        private BigClientVersion(int basedVersion) {
+            this.protocollVersionInt = basedVersion;
+        }
+
+        public ProtocollVersion getProtocollVersion() {
+            if (protocollVersion == null)
+                protocollVersion = ProtocollVersion.values()[protocollVersionInt];
+            return protocollVersion;
+        }
+
+        public ProtocollVersion[] getProtocollVersions() {
+            if (protocollVersions != null)
+                return protocollVersions;
+            ArrayList<ProtocollVersion> versions = new ArrayList<>();
+            for (ProtocollVersion v : ProtocollVersion.values())
+                if (v.getBasedVersion() == this)
+                    versions.add(v);
+            this.protocollVersions = versions.toArray(new ProtocollVersion[0]);
+            return protocollVersions;
+        }
+    }
+
+    @Getter
+    public static enum ProtocollVersion {
+        Unsupported(0, -1, false),
+        v1_7(1, 5, false),
+        v1_8(2, 47, true),
+        v1_9(3, 107, true),
+        v1_9_2(3, 108, true),
+        v1_9_3(3, 109, true),
+        v1_9_4(3, 110, true),
+        v1_10(4, 210, true);
+
+        private int basedVersionInt;
+        private BigClientVersion basedVersion;
+        private boolean supported;
+        private int protocollVersion;
+
+        private ProtocollVersion(int basedVersion, int protocoll, boolean supported) {
+            this.basedVersionInt = basedVersion;
+            this.supported = supported;
+            this.protocollVersion = protocoll;
+        }
+
+        public BigClientVersion getBasedVersion() {
+            if (basedVersion == null)
+                basedVersion = BigClientVersion.values()[basedVersionInt];
+            return basedVersion;
+        }
+
+        public int getProtocollVersion() {
+            return protocollVersion;
+        }
+    }
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/CostumPrintStream.java b/src/main/java/dev/wolveringer/BungeeUtil/CostumPrintStream.java
index ba51998..32962f9 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/CostumPrintStream.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/CostumPrintStream.java
@@ -1,6 +1,7 @@
 package dev.wolveringer.BungeeUtil;
 
 public interface CostumPrintStream {
-	public void print(String s);
-	public void println(String s);
+    public void print(String s);
+
+    public void println(String s);
 }
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/DebugProperties.java b/src/main/java/dev/wolveringer/BungeeUtil/DebugProperties.java
index ac44f76..36c9326 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/DebugProperties.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/DebugProperties.java
@@ -1,10 +1,10 @@
 package dev.wolveringer.BungeeUtil;
 
 public class DebugProperties {
-	public static final boolean CONSOHLE_COLORED_OUTPUT = true;
-	public static final boolean CONSOHLE_CONNECTION_INFORMATION = true;
-	public static final boolean PACKET_ERROR_DISCCONNECT = true;
-	public static final boolean PACKET_DEVELOPMENT = true;
-	public static final boolean TAB_SCOREBORD_FIX = true;
-	public static final boolean WHITELISTED = false;
+    public static final boolean CONSOHLE_COLORED_OUTPUT = true;
+    public static final boolean CONSOHLE_CONNECTION_INFORMATION = true;
+    public static final boolean PACKET_ERROR_DISCCONNECT = true;
+    public static final boolean PACKET_DEVELOPMENT = true;
+    public static final boolean TAB_SCOREBORD_FIX = true;
+    public static final boolean WHITELISTED = false;
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/HandType.java b/src/main/java/dev/wolveringer/BungeeUtil/HandType.java
index d15e23e..c5c5a0f 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/HandType.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/HandType.java
@@ -1,6 +1,6 @@
 package dev.wolveringer.BungeeUtil;
 
 public enum HandType {
-	MAIN,
-	OFF;
+    MAIN,
+    OFF;
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/HandleErrorAction.java b/src/main/java/dev/wolveringer/BungeeUtil/HandleErrorAction.java
index e5bbafc..1a7cce5 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/HandleErrorAction.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/HandleErrorAction.java
@@ -1,7 +1,7 @@
 package dev.wolveringer.BungeeUtil;
 
 public enum HandleErrorAction {
-	DISCONNECT,
-	PRINT,
-	NONE;
+    DISCONNECT,
+    PRINT,
+    NONE;
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/Main.java b/src/main/java/dev/wolveringer/BungeeUtil/Main.java
index 2e39e15..15f4b08 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/Main.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/Main.java
@@ -1,5 +1,9 @@
 package dev.wolveringer.BungeeUtil;
 
+import net.md_5.bungee.api.plugin.Plugin;
+
+import org.fusesource.jansi.AnsiConsole;
+
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Comparator;
@@ -7,9 +11,6 @@ import java.util.HashMap;
 import java.util.List;
 import java.util.Map.Entry;
 
-import org.fusesource.jansi.AnsiConsole;
-
-import net.md_5.bungee.api.plugin.Plugin;
 import dev.wolveringer.BungeeUtil.configuration.Configuration;
 import dev.wolveringer.BungeeUtil.packets.Packet;
 import dev.wolveringer.chat.ChatColor.ChatColorUtils;
@@ -19,90 +20,87 @@ import dev.wolveringer.terminal.table.TerminalTable.TerminalRow;
 import dev.wolveringer.updater.Updater;
 
 public class Main extends Plugin {
-	public Updater updater;
-	private static Main main = null;
-	
-	public static Main getMain() {
-		return main;
-	}
-	
-	@Override
-	public void onLoad() {
-		main = this;
+    private static Main main = null;
+    public Updater updater;
+
+    public static Main getMain() {
+        return main;
+    }
+
+    @Override
+    public void onLoad() {
+        main = this;
+
+    }
+
+    @Override
+    public void onEnable() {
+        main = this;
+        if (BungeeUtil.getInstance() == null)
+            BungeeUtil.createInstance(main);
+        Configuration.init();
+        BungeeUtil.getInstance().sendMessage("Ansi consolen class: " + AnsiConsole.out.getClass());
+        BungeeUtil.getInstance().setInformation("Check for updates");
+        try {
+            updater = new Updater("https://raw.githubusercontent.com/WolverinDEV/BungeeUtil/jars/versions.json");
+            updater.loadData();
+            if (updater.getData() == null) {
+                BungeeUtil.getInstance().sendMessage("\u00A7cCant get versions informations.");
+            } else {
+                if (Configuration.isUpdaterActive() && updater.checkUpdate()) {
+                    BungeeUtil.getInstance().setInformation("\u00A7cRestarting bungeecord");
+                    BungeeUtil.getInstance().sleep(1000);
+                    BungeeUtil.getInstance().setInformation(null);
+                    System.exit(-1);
+                    return;
+                }
+            }
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+
+        if (Configuration.getLastVersion() != null && updater != null) {
+            BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR + "aBungeeUtil successful updated!");
+            BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR + "aUpdates:");
+            TerminalTable table = new TerminalTable(new TerminalTable.TerminalColumn[]{
+                    new TerminalTable.TerminalColumn("Version", Align.LEFT),
+                    new TerminalTable.TerminalColumn("Changes", Align.LEFT)
+            });
+            HashMap<String, List<String>> _changes = updater.createChanges(Configuration.getLastVersion());
+            List<Entry<String, List<String>>> changes = new ArrayList<>(_changes.entrySet());
+            Collections.sort(changes, new Comparator<Entry<String, List<String>>>() {
+                @Override
+                public int compare(Entry<String, List<String>> o1, Entry<String, List<String>> o2) {
+                    return Long.compare(Long.parseLong(o2.getKey().replaceAll("\\.", "")), Long.parseLong(o1.getKey().replaceAll("\\.", "")));
+                }
+            });
+            for (Entry<String, List<String>> e : changes) {
+                TerminalRow row = new TerminalRow(2);
+                row.getColumns()[1].addAll(e.getValue());
+                row.setText(0, e.getKey());
+                table.addRow(row);
+            }
+            for (String message : table.buildLines())
+                BungeeUtil.getInstance().sendMessage(message);
+        }
+
+        if (!BungeeUtil.getInstance().isInjected()) {
+            switch (BungeeUtil.getInstance().inject()) {
+                case 0:
+                    System.exit(-1);
+                    break;
+                case -1:
+                    break;
+                default:
+                    return;
+            }
+        }
+        BungeeUtil.getInstance().load();
+        Packet.listPackets();
+    }
 
-	}
-	
-	@Override
-	public void onEnable() {
-		main = this;
-		if(BungeeUtil.getInstance() == null)
-			BungeeUtil.createInstance(main);
-		Configuration.init();
-		BungeeUtil.getInstance().sendMessage("Ansi consolen class: "+AnsiConsole.out.getClass());
-		BungeeUtil.getInstance().setInformation("Check for updates");
-		try {
-			updater = new Updater("https://raw.githubusercontent.com/WolverinDEV/BungeeUtil/jars/versions.json");
-			updater.loadData();
-			if(updater.getData() == null){
-				BungeeUtil.getInstance().sendMessage("\u00A7cCant get versions informations.");
-			}
-			else
-			{
-				if (Configuration.isUpdaterActive() && updater.checkUpdate()) {
-					BungeeUtil.getInstance().setInformation("\u00A7cRestarting bungeecord");
-					BungeeUtil.getInstance().sleep(1000);
-					BungeeUtil.getInstance().setInformation(null);
-					System.exit(-1);
-					return;
-				}
-			}
-		}
-		catch (Exception e) {
-			e.printStackTrace();
-		}
-		
-		if (Configuration.getLastVersion() != null && updater != null) {
-			BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR + "aBungeeUtil successful updated!");
-			BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR + "aUpdates:");
-			TerminalTable table = new TerminalTable(new TerminalTable.TerminalColumn[]{
-					new TerminalTable.TerminalColumn("Version", Align.LEFT),
-					new TerminalTable.TerminalColumn("Changes", Align.LEFT)
-			});
-			HashMap<String, List<String>> _changes = updater.createChanges(Configuration.getLastVersion());
-			List<Entry<String, List<String>>> changes = new ArrayList<>(_changes.entrySet());
-			Collections.sort(changes, new Comparator<Entry<String, List<String>>>() {
-				@Override
-				public int compare(Entry<String, List<String>> o1, Entry<String, List<String>> o2) {
-					return Long.compare(Long.parseLong(o2.getKey().replaceAll("\\.", "")), Long.parseLong(o1.getKey().replaceAll("\\.", "")));
-				}
-			});
-			for(Entry<String, List<String>> e : changes){
-				TerminalRow row = new TerminalRow(2);
-				row.getColumns()[1].addAll(e.getValue());
-				row.setText(0, e.getKey());
-				table.addRow(row);
-			}
-			for(String message : table.buildLines())
-				BungeeUtil.getInstance().sendMessage(message);
-		}
-		
-		if(!BungeeUtil.getInstance().isInjected()){
-			switch (BungeeUtil.getInstance().inject()) {
-			case 0:
-				System.exit(-1);
-				break;
-			case -1:
-				break;
-			default:
-				return;
-			}
-		}
-		BungeeUtil.getInstance().load();
-		Packet.listPackets();
-	}
-	
-	@Override
-	public void onDisable() {
-		BungeeUtil.getInstance().disable();
-	}
+    @Override
+    public void onDisable() {
+        BungeeUtil.getInstance().disable();
+    }
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/Material.java b/src/main/java/dev/wolveringer/BungeeUtil/Material.java
index d785a9b..3e2c2c7 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/Material.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/Material.java
@@ -1,980 +1,976 @@
 package dev.wolveringer.BungeeUtil;
 
-import java.lang.reflect.Array;
-import java.util.Map;
-
 import com.google.common.collect.Maps;
 
-class Java15Compat {
-	@SuppressWarnings("unchecked")
-	public static <T> T[] Arrays_copyOfRange(T[] original, int start, int end) {
-		if(original.length >= start && 0 <= start){
-			if(start <= end){
-				int length = end - start;
-				int copyLength = Math.min(length, original.length - start);
-				T[] copy = (T[]) Array.newInstance(original.getClass().getComponentType(), length);
-
-				System.arraycopy(original, start, copy, 0, copyLength);
-				return copy;
-			}
-			throw new IllegalArgumentException();
-		}
-		throw new ArrayIndexOutOfBoundsException();
-	}
-}
+import java.lang.reflect.Array;
+import java.util.Map;
 
 /**
  * An enum of all material IDs accepted by the official server and client
  */
 public enum Material {
-	AIR(0, 0),
-	STONE(1),
-	GRASS(2),
-	DIRT(3),
-	COBBLESTONE(4),
-	WOOD(5),
-	SAPLING(6),
-	BEDROCK(7),
-	WATER(8),
-	STATIONARY_WATER(9),
-	LAVA(10),
-	STATIONARY_LAVA(11),
-	SAND(12),
-	GRAVEL(13),
-	GOLD_ORE(14),
-	IRON_ORE(15),
-	COAL_ORE(16),
-	LOG(17),
-	LEAVES(18),
-	SPONGE(19),
-	GLASS(20),
-	LAPIS_ORE(21),
-	LAPIS_BLOCK(22),
-	DISPENSER(23),
-	SANDSTONE(24),
-	NOTE_BLOCK(25),
-	BED_BLOCK(26),
-	POWERED_RAIL(27),
-	DETECTOR_RAIL(28),
-	PISTON_STICKY_BASE(29),
-	WEB(30),
-	LONG_GRASS(31),
-	DEAD_BUSH(32),
-	PISTON_BASE(33),
-	PISTON_EXTENSION(34),
-	WOOL(35),
-	PISTON_MOVING_PIECE(36),
-	YELLOW_FLOWER(37),
-	RED_ROSE(38),
-	BROWN_MUSHROOM(39),
-	RED_MUSHROOM(40),
-	GOLD_BLOCK(41),
-	IRON_BLOCK(42),
-	DOUBLE_STEP(43),
-	STEP(44),
-	BRICK(45),
-	TNT(46),
-	BOOKSHELF(47),
-	MOSSY_COBBLESTONE(48),
-	OBSIDIAN(49),
-	TORCH(50),
-	FIRE(51),
-	MOB_SPAWNER(52),
-	WOOD_STAIRS(53),
-	CHEST(54),
-	REDSTONE_WIRE(55),
-	DIAMOND_ORE(56),
-	DIAMOND_BLOCK(57),
-	WORKBENCH(58),
-	CROPS(59),
-	SOIL(60),
-	FURNACE(61),
-	BURNING_FURNACE(62),
-	SIGN_POST(63, 64),
-	WOODEN_DOOR(64),
-	LADDER(65),
-	RAILS(66),
-	COBBLESTONE_STAIRS(67),
-	WALL_SIGN(68, 64),
-	LEVER(69),
-	STONE_PLATE(70),
-	IRON_DOOR_BLOCK(71),
-	WOOD_PLATE(72),
-	REDSTONE_ORE(73),
-	GLOWING_REDSTONE_ORE(74),
-	REDSTONE_TORCH_OFF(75),
-	REDSTONE_TORCH_ON(76),
-	STONE_BUTTON(77),
-	SNOW(78),
-	ICE(79),
-	SNOW_BLOCK(80),
-	CACTUS(81),
-	CLAY(82),
-	SUGAR_CANE_BLOCK(83),
-	JUKEBOX(84),
-	FENCE(85),
-	PUMPKIN(86),
-	NETHERRACK(87),
-	SOUL_SAND(88),
-	GLOWSTONE(89),
-	PORTAL(90),
-	JACK_O_LANTERN(91),
-	CAKE_BLOCK(92, 64),
-	DIODE_BLOCK_OFF(93),
-	DIODE_BLOCK_ON(94),
-	LOCKED_CHEST(95),
-	STAINED_GLASS(95),
-	TRAP_DOOR(96),
-	MONSTER_EGGS(97),
-	SMOOTH_BRICK(98),
-	HUGE_MUSHROOM_1(99),
-	HUGE_MUSHROOM_2(100),
-	IRON_FENCE(101),
-	THIN_GLASS(102),
-	MELON_BLOCK(103),
-	PUMPKIN_STEM(10),
-	MELON_STEM(105),
-	VINE(106),
-	FENCE_GATE(107),
-	BRICK_STAIRS(108),
-	SMOOTH_STAIRS(109),
-	MYCEL(110),
-	WATER_LILY(111),
-	NETHER_BRICK(112),
-	NETHER_FENCE(113),
-	NETHER_BRICK_STAIRS(114),
-	NETHER_WARTS(115),
-	ENCHANTMENT_TABLE(116),
-	BREWING_STAND(117),
-	CAULDRON(118),
-	ENDER_PORTAL(119),
-	ENDER_PORTAL_FRAME(120),
-	ENDER_STONE(121),
-	DRAGON_EGG(122),
-	REDSTONE_LAMP_OFF(123),
-	REDSTONE_LAMP_ON(124),
-	WOOD_DOUBLE_STEP(125),
-	WOOD_STEP(126),
-	COCOA(127),
-	SANDSTONE_STAIRS(128),
-	EMERALD_ORE(129),
-	ENDER_CHEST(130),
-	TRIPWIRE_HOOK(131),
-	TRIPWIRE(132),
-	EMERALD_BLOCK(133),
-	SPRUCE_WOOD_STAIRS(134),
-	BIRCH_WOOD_STAIRS(135),
-	JUNGLE_WOOD_STAIRS(136),
-	COMMAND(137),
-	BEACON(138),
-	COBBLE_WALL(139),
-	FLOWER_POT(140),
-	CARROT(141),
-	POTATO(142),
-	WOOD_BUTTON(143),
-	SKULL(144),
-	ANVIL(145),
-	TRAPPED_CHEST(146),
-	GOLD_PLATE(147),
-	IRON_PLATE(148),
-	REDSTONE_COMPARATOR_OFF(149),
-	REDSTONE_COMPARATOR_ON(150),
-	DAYLIGHT_DETECTOR(151),
-	REDSTONE_BLOCK(152),
-	QUARTZ_ORE(153),
-	HOPPER(154),
-	QUARTZ_BLOCK(155),
-	QUARTZ_STAIRS(156),
-	ACTIVATOR_RAIL(157),
-	DROPPER(158),
-	STAINED_CLAY(159),
-	STAINED_GLASS_PANE(160),
-	LEAVES_2(161),
-	LOG_2(162),
-	ACACIA_STAIRS(163),
-	DARK_OAK_STAIRS(164),
-	SLIME_BLOCK(165),
-	BARRIER(166),
-	IRON_TRAPDOOR(167),
-	PRISMARINE(168),
-	SEA_LANTERN(169),
-	HAY_BLOCK(170),
-	CARPET(171),
-	HARD_CLAY(172),
-	COAL_BLOCK(173),
-	PACKED_ICE(174),
-	DOUBLE_PLANT(175),
-	STANDING_BANNER(176),
-	WALL_BANNER(177),
-	DAYLIGHT_DETECTOR_INVERTED(178),
-	RED_SANDSTONE(179),
-	RED_SANDSTONE_STAIRS(180),
-	DOUBLE_STONE_SLAB2(181),
-	STONE_SLAB2(182),
-	SPRUCE_FENCE_GATE(183),
-	BIRCH_FENCE_GATE(184),
-	JUNGLE_FENCE_GATE(185),
-	DARK_OAK_FENCE_GATE(186),
-	ACACIA_FENCE_GATE(187),
-	SPRUCE_FENCE(188),
-	BIRCH_FENCE(189),
-	JUNGLE_FENCE(190),
-	DARK_OAK_FENCE(191),
-	ACACIA_FENCE(192),
-	SPRUCE_DOOR(193),
-	BIRCH_DOOR(194),
-	JUNGLE_DOOR(195),
-	ACACIA_DOOR(196),
-	DARK_OAK_DOOR(197),
-	IRON_SPADE(256, 1, 250),
-	IRON_PICKAXE(257, 1, 250),
-	IRON_AXE(258, 1, 250),
-	FLINT_AND_STEEL(259, 1, 64),
-	APPLE(260),
-	BOW(261, 1, 384),
-	ARROW(262),
-	COAL(263),
-	DIAMOND(264),
-	IRON_INGOT(265),
-	GOLD_INGOT(266),
-	IRON_SWORD(267, 1, 250),
-	WOOD_SWORD(268, 1, 59),
-	WOOD_SPADE(269, 1, 59),
-	WOOD_PICKAXE(270, 1, 59),
-	WOOD_AXE(271, 1, 59),
-	STONE_SWORD(272, 1, 131),
-	STONE_SPADE(273, 1, 131),
-	STONE_PICKAXE(274, 1, 131),
-	STONE_AXE(275, 1, 131),
-	DIAMOND_SWORD(276, 1, 1561),
-	DIAMOND_SPADE(277, 1, 1561),
-	DIAMOND_PICKAXE(278, 1, 1561),
-	DIAMOND_AXE(279, 1, 1561),
-	STICK(280),
-	BOWL(281),
-	MUSHROOM_SOUP(282, 1),
-	GOLD_SWORD(283, 1, 32),
-	GOLD_SPADE(284, 1, 32),
-	GOLD_PICKAXE(285, 1, 32),
-	GOLD_AXE(286, 1, 32),
-	STRING(287),
-	FEATHER(288),
-	SULPHUR(289),
-	WOOD_HOE(290, 1, 59),
-	STONE_HOE(291, 1, 131),
-	IRON_HOE(292, 1, 250),
-	DIAMOND_HOE(293, 1, 1561),
-	GOLD_HOE(294, 1, 32),
-	SEEDS(295),
-	WHEAT(296),
-	BREAD(297),
-	LEATHER_HELMET(298, 1, 55),
-	LEATHER_CHESTPLATE(299, 1, 80),
-	LEATHER_LEGGINGS(300, 1, 75),
-	LEATHER_BOOTS(301, 1, 65),
-	CHAINMAIL_HELMET(302, 1, 165),
-	CHAINMAIL_CHESTPLATE(303, 1, 240),
-	CHAINMAIL_LEGGINGS(304, 1, 225),
-	CHAINMAIL_BOOTS(305, 1, 195),
-	IRON_HELMET(306, 1, 165),
-	IRON_CHESTPLATE(307, 1, 240),
-	IRON_LEGGINGS(308, 1, 225),
-	IRON_BOOTS(309, 1, 195),
-	DIAMOND_HELMET(310, 1, 363),
-	DIAMOND_CHESTPLATE(311, 1, 528),
-	DIAMOND_LEGGINGS(312, 1, 495),
-	DIAMOND_BOOTS(313, 1, 429),
-	GOLD_HELMET(314, 1, 77),
-	GOLD_CHESTPLATE(315, 1, 112),
-	GOLD_LEGGINGS(316, 1, 105),
-	GOLD_BOOTS(317, 1, 91),
-	FLINT(318),
-	PORK(319),
-	GRILLED_PORK(320),
-	PAINTING(321),
-	GOLDEN_APPLE(322),
-	SIGN(323, 16),
-	WOOD_DOOR(324, 64),
-	BUCKET(325, 16),
-	WATER_BUCKET(326, 1),
-	LAVA_BUCKET(327, 1),
-	MINECART(328, 1),
-	SADDLE(329, 1),
-	IRON_DOOR(330, 64),
-	REDSTONE(331),
-	SNOW_BALL(332, 16),
-	BOAT(333, 1),
-	LEATHER(334),
-	MILK_BUCKET(335, 1),
-	CLAY_BRICK(336),
-	CLAY_BALL(337),
-	SUGAR_CANE(338),
-	PAPER(339),
-	BOOK(340),
-	SLIME_BALL(341),
-	STORAGE_MINECART(342, 1),
-	POWERED_MINECART(343, 1),
-	EGG(344, 16),
-	COMPASS(345),
-	FISHING_ROD(346, 1, 64),
-	WATCH(347),
-	GLOWSTONE_DUST(348),
-	RAW_FISH(349),
-	COOKED_FISH(350),
-	INK_SACK(351),
-	BONE(352),
-	SUGAR(353),
-	CAKE(354, 1),
-	BED(355, 1),
-	DIODE(356),
-	COOKIE(357),
-	MAP(358),
-	SHEARS(359, 1, 238),
-	MELON(360),
-	PUMPKIN_SEEDS(361),
-	MELON_SEEDS(362),
-	RAW_BEEF(363),
-	COOKED_BEEF(364),
-	RAW_CHICKEN(365),
-	COOKED_CHICKEN(366),
-	ROTTEN_FLESH(367),
-	ENDER_PEARL(368, 16),
-	BLAZE_ROD(369),
-	GHAST_TEAR(370),
-	GOLD_NUGGET(371),
-	NETHER_STALK(372),
-	POTION(373, 1),
-	GLASS_BOTTLE(374),
-	SPIDER_EYE(375),
-	FERMENTED_SPIDER_EYE(376),
-	BLAZE_POWDER(377),
-	MAGMA_CREAM(378),
-	BREWING_STAND_ITEM(379),
-	CAULDRON_ITEM(380),
-	EYE_OF_ENDER(381),
-	SPECKLED_MELON(382),
-	MONSTER_EGG(383, 64),
-	EXP_BOTTLE(384, 64),
-	FIREBALL(385, 64),
-	BOOK_AND_QUILL(386, 1),
-	WRITTEN_BOOK(387, 16),
-	EMERALD(388, 64),
-	ITEM_FRAME(389),
-	FLOWER_POT_ITEM(390),
-	CARROT_ITEM(391),
-	POTATO_ITEM(392),
-	BAKED_POTATO(393),
-	POISONOUS_POTATO(394),
-	EMPTY_MAP(395),
-	GOLDEN_CARROT(396),
-	SKULL_ITEM(397),
-	CARROT_STICK(398, 1, 25),
-	NETHER_STAR(399),
-	PUMPKIN_PIE(400),
-	FIREWORK(401),
-	FIREWORK_CHARGE(402),
-	ENCHANTED_BOOK(403, 1),
-	REDSTONE_COMPARATOR(404),
-	NETHER_BRICK_ITEM(405),
-	QUARTZ(406),
-	EXPLOSIVE_MINECART(407, 1),
-	HOPPER_MINECART(408, 1),
-	PRISMARINE_SHARD(409),
-	PRISMARINE_CRYSTALS(410),
-	RABBIT(411),
-	COOKED_RABBIT(412),
-	RABBIT_STEW(413, 1),
-	RABBIT_FOOT(414),
-	RABBIT_HIDE(415),
-	ARMOR_STAND(416, 16),
-	IRON_BARDING(417, 1),
-	GOLD_BARDING(418, 1),
-	DIAMOND_BARDING(419, 1),
-	LEASH(420),
-	NAME_TAG(421),
-	COMMAND_MINECART(422, 1),
-	MUTTON(423),
-	COOKED_MUTTON(424),
-	BANNER(425, 16),
-	SPRUCE_DOOR_ITEM(427),
-	BIRCH_DOOR_ITEM(428),
-	JUNGLE_DOOR_ITEM(429),
-	ACACIA_DOOR_ITEM(430),
-	DARK_OAK_DOOR_ITEM(431),
-	GOLD_RECORD(2256, 1),
-	GREEN_RECORD(2257, 1),
-	RECORD_3(2258, 1),
-	RECORD_4(2259, 1),
-	RECORD_5(2260, 1),
-	RECORD_6(2261, 1),
-	RECORD_7(2262, 1),
-	RECORD_8(2263, 1),
-	RECORD_9(2264, 1),
-	RECORD_10(2265, 1),
-	RECORD_11(2266, 1),
-	RECORD_12(2267, 1);
+    AIR(0, 0),
+    STONE(1),
+    GRASS(2),
+    DIRT(3),
+    COBBLESTONE(4),
+    WOOD(5),
+    SAPLING(6),
+    BEDROCK(7),
+    WATER(8),
+    STATIONARY_WATER(9),
+    LAVA(10),
+    STATIONARY_LAVA(11),
+    SAND(12),
+    GRAVEL(13),
+    GOLD_ORE(14),
+    IRON_ORE(15),
+    COAL_ORE(16),
+    LOG(17),
+    LEAVES(18),
+    SPONGE(19),
+    GLASS(20),
+    LAPIS_ORE(21),
+    LAPIS_BLOCK(22),
+    DISPENSER(23),
+    SANDSTONE(24),
+    NOTE_BLOCK(25),
+    BED_BLOCK(26),
+    POWERED_RAIL(27),
+    DETECTOR_RAIL(28),
+    PISTON_STICKY_BASE(29),
+    WEB(30),
+    LONG_GRASS(31),
+    DEAD_BUSH(32),
+    PISTON_BASE(33),
+    PISTON_EXTENSION(34),
+    WOOL(35),
+    PISTON_MOVING_PIECE(36),
+    YELLOW_FLOWER(37),
+    RED_ROSE(38),
+    BROWN_MUSHROOM(39),
+    RED_MUSHROOM(40),
+    GOLD_BLOCK(41),
+    IRON_BLOCK(42),
+    DOUBLE_STEP(43),
+    STEP(44),
+    BRICK(45),
+    TNT(46),
+    BOOKSHELF(47),
+    MOSSY_COBBLESTONE(48),
+    OBSIDIAN(49),
+    TORCH(50),
+    FIRE(51),
+    MOB_SPAWNER(52),
+    WOOD_STAIRS(53),
+    CHEST(54),
+    REDSTONE_WIRE(55),
+    DIAMOND_ORE(56),
+    DIAMOND_BLOCK(57),
+    WORKBENCH(58),
+    CROPS(59),
+    SOIL(60),
+    FURNACE(61),
+    BURNING_FURNACE(62),
+    SIGN_POST(63, 64),
+    WOODEN_DOOR(64),
+    LADDER(65),
+    RAILS(66),
+    COBBLESTONE_STAIRS(67),
+    WALL_SIGN(68, 64),
+    LEVER(69),
+    STONE_PLATE(70),
+    IRON_DOOR_BLOCK(71),
+    WOOD_PLATE(72),
+    REDSTONE_ORE(73),
+    GLOWING_REDSTONE_ORE(74),
+    REDSTONE_TORCH_OFF(75),
+    REDSTONE_TORCH_ON(76),
+    STONE_BUTTON(77),
+    SNOW(78),
+    ICE(79),
+    SNOW_BLOCK(80),
+    CACTUS(81),
+    CLAY(82),
+    SUGAR_CANE_BLOCK(83),
+    JUKEBOX(84),
+    FENCE(85),
+    PUMPKIN(86),
+    NETHERRACK(87),
+    SOUL_SAND(88),
+    GLOWSTONE(89),
+    PORTAL(90),
+    JACK_O_LANTERN(91),
+    CAKE_BLOCK(92, 64),
+    DIODE_BLOCK_OFF(93),
+    DIODE_BLOCK_ON(94),
+    LOCKED_CHEST(95),
+    STAINED_GLASS(95),
+    TRAP_DOOR(96),
+    MONSTER_EGGS(97),
+    SMOOTH_BRICK(98),
+    HUGE_MUSHROOM_1(99),
+    HUGE_MUSHROOM_2(100),
+    IRON_FENCE(101),
+    THIN_GLASS(102),
+    MELON_BLOCK(103),
+    PUMPKIN_STEM(10),
+    MELON_STEM(105),
+    VINE(106),
+    FENCE_GATE(107),
+    BRICK_STAIRS(108),
+    SMOOTH_STAIRS(109),
+    MYCEL(110),
+    WATER_LILY(111),
+    NETHER_BRICK(112),
+    NETHER_FENCE(113),
+    NETHER_BRICK_STAIRS(114),
+    NETHER_WARTS(115),
+    ENCHANTMENT_TABLE(116),
+    BREWING_STAND(117),
+    CAULDRON(118),
+    ENDER_PORTAL(119),
+    ENDER_PORTAL_FRAME(120),
+    ENDER_STONE(121),
+    DRAGON_EGG(122),
+    REDSTONE_LAMP_OFF(123),
+    REDSTONE_LAMP_ON(124),
+    WOOD_DOUBLE_STEP(125),
+    WOOD_STEP(126),
+    COCOA(127),
+    SANDSTONE_STAIRS(128),
+    EMERALD_ORE(129),
+    ENDER_CHEST(130),
+    TRIPWIRE_HOOK(131),
+    TRIPWIRE(132),
+    EMERALD_BLOCK(133),
+    SPRUCE_WOOD_STAIRS(134),
+    BIRCH_WOOD_STAIRS(135),
+    JUNGLE_WOOD_STAIRS(136),
+    COMMAND(137),
+    BEACON(138),
+    COBBLE_WALL(139),
+    FLOWER_POT(140),
+    CARROT(141),
+    POTATO(142),
+    WOOD_BUTTON(143),
+    SKULL(144),
+    ANVIL(145),
+    TRAPPED_CHEST(146),
+    GOLD_PLATE(147),
+    IRON_PLATE(148),
+    REDSTONE_COMPARATOR_OFF(149),
+    REDSTONE_COMPARATOR_ON(150),
+    DAYLIGHT_DETECTOR(151),
+    REDSTONE_BLOCK(152),
+    QUARTZ_ORE(153),
+    HOPPER(154),
+    QUARTZ_BLOCK(155),
+    QUARTZ_STAIRS(156),
+    ACTIVATOR_RAIL(157),
+    DROPPER(158),
+    STAINED_CLAY(159),
+    STAINED_GLASS_PANE(160),
+    LEAVES_2(161),
+    LOG_2(162),
+    ACACIA_STAIRS(163),
+    DARK_OAK_STAIRS(164),
+    SLIME_BLOCK(165),
+    BARRIER(166),
+    IRON_TRAPDOOR(167),
+    PRISMARINE(168),
+    SEA_LANTERN(169),
+    HAY_BLOCK(170),
+    CARPET(171),
+    HARD_CLAY(172),
+    COAL_BLOCK(173),
+    PACKED_ICE(174),
+    DOUBLE_PLANT(175),
+    STANDING_BANNER(176),
+    WALL_BANNER(177),
+    DAYLIGHT_DETECTOR_INVERTED(178),
+    RED_SANDSTONE(179),
+    RED_SANDSTONE_STAIRS(180),
+    DOUBLE_STONE_SLAB2(181),
+    STONE_SLAB2(182),
+    SPRUCE_FENCE_GATE(183),
+    BIRCH_FENCE_GATE(184),
+    JUNGLE_FENCE_GATE(185),
+    DARK_OAK_FENCE_GATE(186),
+    ACACIA_FENCE_GATE(187),
+    SPRUCE_FENCE(188),
+    BIRCH_FENCE(189),
+    JUNGLE_FENCE(190),
+    DARK_OAK_FENCE(191),
+    ACACIA_FENCE(192),
+    SPRUCE_DOOR(193),
+    BIRCH_DOOR(194),
+    JUNGLE_DOOR(195),
+    ACACIA_DOOR(196),
+    DARK_OAK_DOOR(197),
+    IRON_SPADE(256, 1, 250),
+    IRON_PICKAXE(257, 1, 250),
+    IRON_AXE(258, 1, 250),
+    FLINT_AND_STEEL(259, 1, 64),
+    APPLE(260),
+    BOW(261, 1, 384),
+    ARROW(262),
+    COAL(263),
+    DIAMOND(264),
+    IRON_INGOT(265),
+    GOLD_INGOT(266),
+    IRON_SWORD(267, 1, 250),
+    WOOD_SWORD(268, 1, 59),
+    WOOD_SPADE(269, 1, 59),
+    WOOD_PICKAXE(270, 1, 59),
+    WOOD_AXE(271, 1, 59),
+    STONE_SWORD(272, 1, 131),
+    STONE_SPADE(273, 1, 131),
+    STONE_PICKAXE(274, 1, 131),
+    STONE_AXE(275, 1, 131),
+    DIAMOND_SWORD(276, 1, 1561),
+    DIAMOND_SPADE(277, 1, 1561),
+    DIAMOND_PICKAXE(278, 1, 1561),
+    DIAMOND_AXE(279, 1, 1561),
+    STICK(280),
+    BOWL(281),
+    MUSHROOM_SOUP(282, 1),
+    GOLD_SWORD(283, 1, 32),
+    GOLD_SPADE(284, 1, 32),
+    GOLD_PICKAXE(285, 1, 32),
+    GOLD_AXE(286, 1, 32),
+    STRING(287),
+    FEATHER(288),
+    SULPHUR(289),
+    WOOD_HOE(290, 1, 59),
+    STONE_HOE(291, 1, 131),
+    IRON_HOE(292, 1, 250),
+    DIAMOND_HOE(293, 1, 1561),
+    GOLD_HOE(294, 1, 32),
+    SEEDS(295),
+    WHEAT(296),
+    BREAD(297),
+    LEATHER_HELMET(298, 1, 55),
+    LEATHER_CHESTPLATE(299, 1, 80),
+    LEATHER_LEGGINGS(300, 1, 75),
+    LEATHER_BOOTS(301, 1, 65),
+    CHAINMAIL_HELMET(302, 1, 165),
+    CHAINMAIL_CHESTPLATE(303, 1, 240),
+    CHAINMAIL_LEGGINGS(304, 1, 225),
+    CHAINMAIL_BOOTS(305, 1, 195),
+    IRON_HELMET(306, 1, 165),
+    IRON_CHESTPLATE(307, 1, 240),
+    IRON_LEGGINGS(308, 1, 225),
+    IRON_BOOTS(309, 1, 195),
+    DIAMOND_HELMET(310, 1, 363),
+    DIAMOND_CHESTPLATE(311, 1, 528),
+    DIAMOND_LEGGINGS(312, 1, 495),
+    DIAMOND_BOOTS(313, 1, 429),
+    GOLD_HELMET(314, 1, 77),
+    GOLD_CHESTPLATE(315, 1, 112),
+    GOLD_LEGGINGS(316, 1, 105),
+    GOLD_BOOTS(317, 1, 91),
+    FLINT(318),
+    PORK(319),
+    GRILLED_PORK(320),
+    PAINTING(321),
+    GOLDEN_APPLE(322),
+    SIGN(323, 16),
+    WOOD_DOOR(324, 64),
+    BUCKET(325, 16),
+    WATER_BUCKET(326, 1),
+    LAVA_BUCKET(327, 1),
+    MINECART(328, 1),
+    SADDLE(329, 1),
+    IRON_DOOR(330, 64),
+    REDSTONE(331),
+    SNOW_BALL(332, 16),
+    BOAT(333, 1),
+    LEATHER(334),
+    MILK_BUCKET(335, 1),
+    CLAY_BRICK(336),
+    CLAY_BALL(337),
+    SUGAR_CANE(338),
+    PAPER(339),
+    BOOK(340),
+    SLIME_BALL(341),
+    STORAGE_MINECART(342, 1),
+    POWERED_MINECART(343, 1),
+    EGG(344, 16),
+    COMPASS(345),
+    FISHING_ROD(346, 1, 64),
+    WATCH(347),
+    GLOWSTONE_DUST(348),
+    RAW_FISH(349),
+    COOKED_FISH(350),
+    INK_SACK(351),
+    BONE(352),
+    SUGAR(353),
+    CAKE(354, 1),
+    BED(355, 1),
+    DIODE(356),
+    COOKIE(357),
+    MAP(358),
+    SHEARS(359, 1, 238),
+    MELON(360),
+    PUMPKIN_SEEDS(361),
+    MELON_SEEDS(362),
+    RAW_BEEF(363),
+    COOKED_BEEF(364),
+    RAW_CHICKEN(365),
+    COOKED_CHICKEN(366),
+    ROTTEN_FLESH(367),
+    ENDER_PEARL(368, 16),
+    BLAZE_ROD(369),
+    GHAST_TEAR(370),
+    GOLD_NUGGET(371),
+    NETHER_STALK(372),
+    POTION(373, 1),
+    GLASS_BOTTLE(374),
+    SPIDER_EYE(375),
+    FERMENTED_SPIDER_EYE(376),
+    BLAZE_POWDER(377),
+    MAGMA_CREAM(378),
+    BREWING_STAND_ITEM(379),
+    CAULDRON_ITEM(380),
+    EYE_OF_ENDER(381),
+    SPECKLED_MELON(382),
+    MONSTER_EGG(383, 64),
+    EXP_BOTTLE(384, 64),
+    FIREBALL(385, 64),
+    BOOK_AND_QUILL(386, 1),
+    WRITTEN_BOOK(387, 16),
+    EMERALD(388, 64),
+    ITEM_FRAME(389),
+    FLOWER_POT_ITEM(390),
+    CARROT_ITEM(391),
+    POTATO_ITEM(392),
+    BAKED_POTATO(393),
+    POISONOUS_POTATO(394),
+    EMPTY_MAP(395),
+    GOLDEN_CARROT(396),
+    SKULL_ITEM(397),
+    CARROT_STICK(398, 1, 25),
+    NETHER_STAR(399),
+    PUMPKIN_PIE(400),
+    FIREWORK(401),
+    FIREWORK_CHARGE(402),
+    ENCHANTED_BOOK(403, 1),
+    REDSTONE_COMPARATOR(404),
+    NETHER_BRICK_ITEM(405),
+    QUARTZ(406),
+    EXPLOSIVE_MINECART(407, 1),
+    HOPPER_MINECART(408, 1),
+    PRISMARINE_SHARD(409),
+    PRISMARINE_CRYSTALS(410),
+    RABBIT(411),
+    COOKED_RABBIT(412),
+    RABBIT_STEW(413, 1),
+    RABBIT_FOOT(414),
+    RABBIT_HIDE(415),
+    ARMOR_STAND(416, 16),
+    IRON_BARDING(417, 1),
+    GOLD_BARDING(418, 1),
+    DIAMOND_BARDING(419, 1),
+    LEASH(420),
+    NAME_TAG(421),
+    COMMAND_MINECART(422, 1),
+    MUTTON(423),
+    COOKED_MUTTON(424),
+    BANNER(425, 16),
+    SPRUCE_DOOR_ITEM(427),
+    BIRCH_DOOR_ITEM(428),
+    JUNGLE_DOOR_ITEM(429),
+    ACACIA_DOOR_ITEM(430),
+    DARK_OAK_DOOR_ITEM(431),
+    GOLD_RECORD(2256, 1),
+    GREEN_RECORD(2257, 1),
+    RECORD_3(2258, 1),
+    RECORD_4(2259, 1),
+    RECORD_5(2260, 1),
+    RECORD_6(2261, 1),
+    RECORD_7(2262, 1),
+    RECORD_8(2263, 1),
+    RECORD_9(2264, 1),
+    RECORD_10(2265, 1),
+    RECORD_11(2266, 1),
+    RECORD_12(2267, 1);
 
-	private final static Map<String, Material> BY_NAME = Maps.newHashMap();
-	private static Material[] byId = new Material[383];
-	static{
-		for(Material material : values()){
-			if(byId.length > material.id){
-				byId[material.id] = material;
-			}else{
-				byId = Java15Compat.Arrays_copyOfRange(byId, 0, material.id + 2);
-				byId[material.id] = material;
-			}
-			BY_NAME.put(material.name(), material);
-		}
-	}
+    private final static Map<String, Material> BY_NAME = Maps.newHashMap();
+    private static Material[] byId = new Material[383];
 
-	/**
-	 * Attempts to get the Material with the given ID
-	 *
-	 * @param id
-	 *            ID of the material to get
-	 * @return Material if found, or null
-	 * @deprecated Magic value
-	 */
-	@Deprecated
-	public static Material getMaterial(final int id) {
-		if(byId.length > id && id >= 0){
-			return byId[id];
-		}else{
-			return null;
-		}
-	}
+    static {
+        for (Material material : values()) {
+            if (byId.length > material.id) {
+                byId[material.id] = material;
+            } else {
+                byId = Java15Compat.Arrays_copyOfRange(byId, 0, material.id + 2);
+                byId[material.id] = material;
+            }
+            BY_NAME.put(material.name(), material);
+        }
+    }
 
-	/**
-	 * Attempts to get the Material with the given name.
-	 * <p>
-	 * This is a normal lookup, names must be the precise name they are given in
-	 * the enum.
-	 *
-	 * @param name
-	 *            Name of the material to get
-	 * @return Material if found, or null
-	 */
-	public static Material getMaterial(final String name) {
-		return BY_NAME.get(name);
-	}
+    private final short durability;
+    private final int id;
+    private final int maxStack;
 
-	/**
-	 * Attempts to match the Material with the given name.
-	 * <p>
-	 * This is a match lookup; names will be converted to uppercase, then
-	 * stripped of special characters in an attempt to format it like the enum.
-	 * <p>
-	 * Using this for match by ID is deprecated.
-	 *
-	 * @param name
-	 *            Name of the material to get
-	 * @return Material if found, or null
-	 */
-	public static Material matchMaterial(final String name) {
-		Material result = null;
+    private Material(final int id) {
+        this(id, 64);
+    }
 
-		try{
-			result = getMaterial(Integer.parseInt(name));
-		}catch (NumberFormatException ex){
-		}
+    private Material(final int id, final int stack) {
+        this(id, stack, 0);
+    }
 
-		if(result == null){
-			String filtered = name.toUpperCase();
+    private Material(final int id, final int stack, final int durability) {
+        this.id = id;
+        this.durability = (short) durability;
+        this.maxStack = stack;
+    }
 
-			filtered = filtered.replaceAll("\\s+", "_").replaceAll("\\W", "");
-			result = BY_NAME.get(filtered);
-		}
+    /**
+     * Attempts to get the Material with the given ID
+     *
+     * @param id ID of the material to get
+     * @return Material if found, or null
+     * @deprecated Magic value
+     */
+    @Deprecated
+    public static Material getMaterial(final int id) {
+        if (byId.length > id && id >= 0) {
+            return byId[id];
+        } else {
+            return null;
+        }
+    }
 
-		return result;
-	}
+    /**
+     * Attempts to get the Material with the given name.
+     * <p>
+     * This is a normal lookup, names must be the precise name they are given in
+     * the enum.
+     *
+     * @param name Name of the material to get
+     * @return Material if found, or null
+     */
+    public static Material getMaterial(final String name) {
+        return BY_NAME.get(name);
+    }
 
-	private final short durability;
+    /**
+     * Attempts to match the Material with the given name.
+     * <p>
+     * This is a match lookup; names will be converted to uppercase, then
+     * stripped of special characters in an attempt to format it like the enum.
+     * <p>
+     * Using this for match by ID is deprecated.
+     *
+     * @param name Name of the material to get
+     * @return Material if found, or null
+     */
+    public static Material matchMaterial(final String name) {
+        Material result = null;
 
-	private final int id;
+        try {
+            result = getMaterial(Integer.parseInt(name));
+        } catch (NumberFormatException ex) {
+        }
 
-	private final int maxStack;
+        if (result == null) {
+            String filtered = name.toUpperCase();
 
-	private Material(final int id) {
-		this(id, 64);
-	}
+            filtered = filtered.replaceAll("\\s+", "_").replaceAll("\\W", "");
+            result = BY_NAME.get(filtered);
+        }
 
-	private Material(final int id, final int stack) {
-		this(id, stack, 0);
-	}
+        return result;
+    }
 
-	private Material(final int id, final int stack, final int durability) {
-		this.id = id;
-		this.durability = (short) durability;
-		this.maxStack = stack;
-	}
+    /**
+     * Gets the item ID or block ID of this Material
+     *
+     * @return ID of this material
+     * @deprecated Magic value
+     */
+    @Deprecated
+    public int getId() {
+        return id;
+    }
 
-	/**
-	 * Gets the item ID or block ID of this Material
-	 *
-	 * @return ID of this material
-	 * @deprecated Magic value
-	 */
-	@Deprecated
-	public int getId() {
-		return id;
-	}
+    /**
+     * Gets the maximum durability of this material
+     *
+     * @return Maximum durability for this material
+     */
+    public short getMaxDurability() {
+        return durability;
+    }
 
-	/**
-	 * Gets the maximum durability of this material
-	 *
-	 * @return Maximum durability for this material
-	 */
-	public short getMaxDurability() {
-		return durability;
-	}
+    /**
+     * Gets the maximum amount of this material that can be held in a stack
+     *
+     * @return Maximum stack size for this material
+     */
+    public int getMaxStackSize() {
+        return maxStack;
+    }
 
-	/**
-	 * Gets the maximum amount of this material that can be held in a stack
-	 *
-	 * @return Maximum stack size for this material
-	 */
-	public int getMaxStackSize() {
-		return maxStack;
-	}
+    /**
+     * @return True if this material is affected by gravity.
+     */
+    public boolean hasGravity() {
+        if (!isBlock()) {
+            return false;
+        }
+        switch (this) {
+            case SAND:
+            case GRAVEL:
+            case ANVIL:
+                return true;
+            default:
+                return false;
+        }
+    }
 
-	/**
-	 * @return True if this material is affected by gravity.
-	 */
-	public boolean hasGravity() {
-		if(!isBlock()){
-			return false;
-		}
-		switch (this) {
-			case SAND:
-			case GRAVEL:
-			case ANVIL:
-				return true;
-			default:
-				return false;
-		}
-	}
+    /**
+     * Checks if this Material is a placable block
+     *
+     * @return true if this material is a block
+     */
+    public boolean isBlock() {
+        return id < 256;
+    }
 
-	/**
-	 * Checks if this Material is a placable block
-	 *
-	 * @return true if this material is a block
-	 */
-	public boolean isBlock() {
-		return id < 256;
-	}
+    /**
+     * Check if the material is a block and can burn away
+     *
+     * @return True if this material is a block and can burn away
+     */
+    public boolean isBurnable() {
+        if (!isBlock()) {
+            return false;
+        }
+        switch (this) {
+            case WOOD:
+            case LOG:
+            case LEAVES:
+            case LONG_GRASS:
+            case WOOL:
+            case YELLOW_FLOWER:
+            case RED_ROSE:
+            case TNT:
+            case BOOKSHELF:
+            case WOOD_STAIRS:
+            case FENCE:
+            case VINE:
+            case WOOD_DOUBLE_STEP:
+            case WOOD_STEP:
+            case SPRUCE_WOOD_STAIRS:
+            case BIRCH_WOOD_STAIRS:
+            case JUNGLE_WOOD_STAIRS:
+            case HAY_BLOCK:
+            case COAL_BLOCK:
+            case LEAVES_2:
+            case LOG_2:
+            case CARPET:
+            case DOUBLE_PLANT:
+                return true;
+            default:
+                return false;
+        }
+    }
 
-	/**
-	 * Check if the material is a block and can burn away
-	 *
-	 * @return True if this material is a block and can burn away
-	 */
-	public boolean isBurnable() {
-		if(!isBlock()){
-			return false;
-		}
-		switch (this) {
-			case WOOD:
-			case LOG:
-			case LEAVES:
-			case LONG_GRASS:
-			case WOOL:
-			case YELLOW_FLOWER:
-			case RED_ROSE:
-			case TNT:
-			case BOOKSHELF:
-			case WOOD_STAIRS:
-			case FENCE:
-			case VINE:
-			case WOOD_DOUBLE_STEP:
-			case WOOD_STEP:
-			case SPRUCE_WOOD_STAIRS:
-			case BIRCH_WOOD_STAIRS:
-			case JUNGLE_WOOD_STAIRS:
-			case HAY_BLOCK:
-			case COAL_BLOCK:
-			case LEAVES_2:
-			case LOG_2:
-			case CARPET:
-			case DOUBLE_PLANT:
-				return true;
-			default:
-				return false;
-		}
-	}
+    /**
+     * Checks if this Material is edible.
+     *
+     * @return true if this Material is edible.
+     */
+    public boolean isEdible() {
+        switch (this) {
+            case BREAD:
+            case CARROT_ITEM:
+            case BAKED_POTATO:
+            case POTATO_ITEM:
+            case POISONOUS_POTATO:
+            case GOLDEN_CARROT:
+            case PUMPKIN_PIE:
+            case COOKIE:
+            case MELON:
+            case MUSHROOM_SOUP:
+            case RAW_CHICKEN:
+            case COOKED_CHICKEN:
+            case RAW_BEEF:
+            case COOKED_BEEF:
+            case RAW_FISH:
+            case COOKED_FISH:
+            case PORK:
+            case GRILLED_PORK:
+            case APPLE:
+            case GOLDEN_APPLE:
+            case ROTTEN_FLESH:
+            case SPIDER_EYE:
+                return true;
+            default:
+                return false;
+        }
+    }
 
-	/**
-	 * Checks if this Material is edible.
-	 *
-	 * @return true if this Material is edible.
-	 */
-	public boolean isEdible() {
-		switch (this) {
-			case BREAD:
-			case CARROT_ITEM:
-			case BAKED_POTATO:
-			case POTATO_ITEM:
-			case POISONOUS_POTATO:
-			case GOLDEN_CARROT:
-			case PUMPKIN_PIE:
-			case COOKIE:
-			case MELON:
-			case MUSHROOM_SOUP:
-			case RAW_CHICKEN:
-			case COOKED_CHICKEN:
-			case RAW_BEEF:
-			case COOKED_BEEF:
-			case RAW_FISH:
-			case COOKED_FISH:
-			case PORK:
-			case GRILLED_PORK:
-			case APPLE:
-			case GOLDEN_APPLE:
-			case ROTTEN_FLESH:
-			case SPIDER_EYE:
-				return true;
-			default:
-				return false;
-		}
-	}
+    /**
+     * Check if the material is a block and can catch fire
+     *
+     * @return True if this material is a block and can catch fire
+     */
+    public boolean isFlammable() {
+        if (!isBlock()) {
+            return false;
+        }
+        switch (this) {
+            case WOOD:
+            case LOG:
+            case LEAVES:
+            case NOTE_BLOCK:
+            case BED_BLOCK:
+            case LONG_GRASS:
+            case DEAD_BUSH:
+            case WOOL:
+            case TNT:
+            case BOOKSHELF:
+            case WOOD_STAIRS:
+            case CHEST:
+            case WORKBENCH:
+            case SIGN_POST:
+            case WOODEN_DOOR:
+            case WALL_SIGN:
+            case WOOD_PLATE:
+            case JUKEBOX:
+            case FENCE:
+            case TRAP_DOOR:
+            case HUGE_MUSHROOM_1:
+            case HUGE_MUSHROOM_2:
+            case VINE:
+            case FENCE_GATE:
+            case WOOD_DOUBLE_STEP:
+            case WOOD_STEP:
+            case SPRUCE_WOOD_STAIRS:
+            case BIRCH_WOOD_STAIRS:
+            case JUNGLE_WOOD_STAIRS:
+            case TRAPPED_CHEST:
+            case DAYLIGHT_DETECTOR:
+            case CARPET:
+            case LEAVES_2:
+            case LOG_2:
+            case ACACIA_STAIRS:
+            case DARK_OAK_STAIRS:
+                return true;
+            default:
+                return false;
+        }
+    }
 
-	/**
-	 * Check if the material is a block and can catch fire
-	 *
-	 * @return True if this material is a block and can catch fire
-	 */
-	public boolean isFlammable() {
-		if(!isBlock()){
-			return false;
-		}
-		switch (this) {
-			case WOOD:
-			case LOG:
-			case LEAVES:
-			case NOTE_BLOCK:
-			case BED_BLOCK:
-			case LONG_GRASS:
-			case DEAD_BUSH:
-			case WOOL:
-			case TNT:
-			case BOOKSHELF:
-			case WOOD_STAIRS:
-			case CHEST:
-			case WORKBENCH:
-			case SIGN_POST:
-			case WOODEN_DOOR:
-			case WALL_SIGN:
-			case WOOD_PLATE:
-			case JUKEBOX:
-			case FENCE:
-			case TRAP_DOOR:
-			case HUGE_MUSHROOM_1:
-			case HUGE_MUSHROOM_2:
-			case VINE:
-			case FENCE_GATE:
-			case WOOD_DOUBLE_STEP:
-			case WOOD_STEP:
-			case SPRUCE_WOOD_STAIRS:
-			case BIRCH_WOOD_STAIRS:
-			case JUNGLE_WOOD_STAIRS:
-			case TRAPPED_CHEST:
-			case DAYLIGHT_DETECTOR:
-			case CARPET:
-			case LEAVES_2:
-			case LOG_2:
-			case ACACIA_STAIRS:
-			case DARK_OAK_STAIRS:
-				return true;
-			default:
-				return false;
-		}
-	}
+    /**
+     * Check if the material is a block and completely blocks vision
+     *
+     * @return True if this material is a block and completely blocks vision
+     */
+    public boolean isOccluding() {
+        if (!isBlock()) {
+            return false;
+        }
+        switch (this) {
+            case STONE:
+            case GRASS:
+            case DIRT:
+            case COBBLESTONE:
+            case WOOD:
+            case BEDROCK:
+            case SAND:
+            case GRAVEL:
+            case GOLD_ORE:
+            case IRON_ORE:
+            case COAL_ORE:
+            case LOG:
+            case SPONGE:
+            case LAPIS_ORE:
+            case LAPIS_BLOCK:
+            case DISPENSER:
+            case SANDSTONE:
+            case NOTE_BLOCK:
+            case WOOL:
+            case GOLD_BLOCK:
+            case IRON_BLOCK:
+            case DOUBLE_STEP:
+            case BRICK:
+            case BOOKSHELF:
+            case MOSSY_COBBLESTONE:
+            case OBSIDIAN:
+            case MOB_SPAWNER:
+            case DIAMOND_ORE:
+            case DIAMOND_BLOCK:
+            case WORKBENCH:
+            case FURNACE:
+            case BURNING_FURNACE:
+            case REDSTONE_ORE:
+            case GLOWING_REDSTONE_ORE:
+            case SNOW_BLOCK:
+            case CLAY:
+            case JUKEBOX:
+            case PUMPKIN:
+            case NETHERRACK:
+            case SOUL_SAND:
+            case JACK_O_LANTERN:
+            case MONSTER_EGGS:
+            case SMOOTH_BRICK:
+            case HUGE_MUSHROOM_1:
+            case HUGE_MUSHROOM_2:
+            case MELON_BLOCK:
+            case MYCEL:
+            case NETHER_BRICK:
+            case ENDER_PORTAL_FRAME:
+            case ENDER_STONE:
+            case REDSTONE_LAMP_OFF:
+            case REDSTONE_LAMP_ON:
+            case WOOD_DOUBLE_STEP:
+            case EMERALD_ORE:
+            case EMERALD_BLOCK:
+            case COMMAND:
+            case QUARTZ_ORE:
+            case QUARTZ_BLOCK:
+            case DROPPER:
+            case STAINED_CLAY:
+            case HAY_BLOCK:
+            case HARD_CLAY:
+            case COAL_BLOCK:
+            case LOG_2:
+            case PACKED_ICE:
+                return true;
+            default:
+                return false;
+        }
+    }
 
-	/**
-	 * Check if the material is a block and completely blocks vision
-	 *
-	 * @return True if this material is a block and completely blocks vision
-	 */
-	public boolean isOccluding() {
-		if(!isBlock()){
-			return false;
-		}
-		switch (this) {
-			case STONE:
-			case GRASS:
-			case DIRT:
-			case COBBLESTONE:
-			case WOOD:
-			case BEDROCK:
-			case SAND:
-			case GRAVEL:
-			case GOLD_ORE:
-			case IRON_ORE:
-			case COAL_ORE:
-			case LOG:
-			case SPONGE:
-			case LAPIS_ORE:
-			case LAPIS_BLOCK:
-			case DISPENSER:
-			case SANDSTONE:
-			case NOTE_BLOCK:
-			case WOOL:
-			case GOLD_BLOCK:
-			case IRON_BLOCK:
-			case DOUBLE_STEP:
-			case BRICK:
-			case BOOKSHELF:
-			case MOSSY_COBBLESTONE:
-			case OBSIDIAN:
-			case MOB_SPAWNER:
-			case DIAMOND_ORE:
-			case DIAMOND_BLOCK:
-			case WORKBENCH:
-			case FURNACE:
-			case BURNING_FURNACE:
-			case REDSTONE_ORE:
-			case GLOWING_REDSTONE_ORE:
-			case SNOW_BLOCK:
-			case CLAY:
-			case JUKEBOX:
-			case PUMPKIN:
-			case NETHERRACK:
-			case SOUL_SAND:
-			case JACK_O_LANTERN:
-			case MONSTER_EGGS:
-			case SMOOTH_BRICK:
-			case HUGE_MUSHROOM_1:
-			case HUGE_MUSHROOM_2:
-			case MELON_BLOCK:
-			case MYCEL:
-			case NETHER_BRICK:
-			case ENDER_PORTAL_FRAME:
-			case ENDER_STONE:
-			case REDSTONE_LAMP_OFF:
-			case REDSTONE_LAMP_ON:
-			case WOOD_DOUBLE_STEP:
-			case EMERALD_ORE:
-			case EMERALD_BLOCK:
-			case COMMAND:
-			case QUARTZ_ORE:
-			case QUARTZ_BLOCK:
-			case DROPPER:
-			case STAINED_CLAY:
-			case HAY_BLOCK:
-			case HARD_CLAY:
-			case COAL_BLOCK:
-			case LOG_2:
-			case PACKED_ICE:
-				return true;
-			default:
-				return false;
-		}
-	}
+    /**
+     * @return True if this material represents a playable music disk.
+     */
+    public boolean isRecord() {
+        return id >= GOLD_RECORD.id && id <= RECORD_12.id;
+    }
 
-	/**
-	 * @return True if this material represents a playable music disk.
-	 */
-	public boolean isRecord() {
-		return id >= GOLD_RECORD.id && id <= RECORD_12.id;
-	}
+    /**
+     * Check if the material is a block and solid (cannot be passed through by
+     * a player)
+     *
+     * @return True if this material is a block and solid
+     */
+    public boolean isSolid() {
+        if (!isBlock() || id == 0) {
+            return false;
+        }
+        switch (this) {
+            case STONE:
+            case GRASS:
+            case DIRT:
+            case COBBLESTONE:
+            case WOOD:
+            case BEDROCK:
+            case SAND:
+            case GRAVEL:
+            case GOLD_ORE:
+            case IRON_ORE:
+            case COAL_ORE:
+            case LOG:
+            case LEAVES:
+            case SPONGE:
+            case GLASS:
+            case LAPIS_ORE:
+            case LAPIS_BLOCK:
+            case DISPENSER:
+            case SANDSTONE:
+            case NOTE_BLOCK:
+            case BED_BLOCK:
+            case PISTON_STICKY_BASE:
+            case PISTON_BASE:
+            case PISTON_EXTENSION:
+            case WOOL:
+            case PISTON_MOVING_PIECE:
+            case GOLD_BLOCK:
+            case IRON_BLOCK:
+            case DOUBLE_STEP:
+            case STEP:
+            case BRICK:
+            case TNT:
+            case BOOKSHELF:
+            case MOSSY_COBBLESTONE:
+            case OBSIDIAN:
+            case MOB_SPAWNER:
+            case WOOD_STAIRS:
+            case CHEST:
+            case DIAMOND_ORE:
+            case DIAMOND_BLOCK:
+            case WORKBENCH:
+            case SOIL:
+            case FURNACE:
+            case BURNING_FURNACE:
+            case SIGN_POST:
+            case WOODEN_DOOR:
+            case COBBLESTONE_STAIRS:
+            case WALL_SIGN:
+            case STONE_PLATE:
+            case IRON_DOOR_BLOCK:
+            case WOOD_PLATE:
+            case REDSTONE_ORE:
+            case GLOWING_REDSTONE_ORE:
+            case ICE:
+            case SNOW_BLOCK:
+            case CACTUS:
+            case CLAY:
+            case JUKEBOX:
+            case FENCE:
+            case PUMPKIN:
+            case NETHERRACK:
+            case SOUL_SAND:
+            case GLOWSTONE:
+            case JACK_O_LANTERN:
+            case CAKE_BLOCK:
+            case LOCKED_CHEST:
+            case STAINED_GLASS:
+            case TRAP_DOOR:
+            case MONSTER_EGGS:
+            case SMOOTH_BRICK:
+            case HUGE_MUSHROOM_1:
+            case HUGE_MUSHROOM_2:
+            case IRON_FENCE:
+            case THIN_GLASS:
+            case MELON_BLOCK:
+            case FENCE_GATE:
+            case BRICK_STAIRS:
+            case SMOOTH_STAIRS:
+            case MYCEL:
+            case NETHER_BRICK:
+            case NETHER_FENCE:
+            case NETHER_BRICK_STAIRS:
+            case ENCHANTMENT_TABLE:
+            case BREWING_STAND:
+            case CAULDRON:
+            case ENDER_PORTAL_FRAME:
+            case ENDER_STONE:
+            case DRAGON_EGG:
+            case REDSTONE_LAMP_OFF:
+            case REDSTONE_LAMP_ON:
+            case WOOD_DOUBLE_STEP:
+            case WOOD_STEP:
+            case SANDSTONE_STAIRS:
+            case EMERALD_ORE:
+            case ENDER_CHEST:
+            case EMERALD_BLOCK:
+            case SPRUCE_WOOD_STAIRS:
+            case BIRCH_WOOD_STAIRS:
+            case JUNGLE_WOOD_STAIRS:
+            case COMMAND:
+            case BEACON:
+            case COBBLE_WALL:
+            case ANVIL:
+            case TRAPPED_CHEST:
+            case GOLD_PLATE:
+            case IRON_PLATE:
+            case DAYLIGHT_DETECTOR:
+            case REDSTONE_BLOCK:
+            case QUARTZ_ORE:
+            case HOPPER:
+            case QUARTZ_BLOCK:
+            case QUARTZ_STAIRS:
+            case DROPPER:
+            case STAINED_CLAY:
+            case HAY_BLOCK:
+            case HARD_CLAY:
+            case COAL_BLOCK:
+            case STAINED_GLASS_PANE:
+            case LEAVES_2:
+            case LOG_2:
+            case ACACIA_STAIRS:
+            case DARK_OAK_STAIRS:
+            case PACKED_ICE:
+                return true;
+            default:
+                return false;
+        }
+    }
 
-	/**
-	 * Check if the material is a block and solid (cannot be passed through by
-	 * a player)
-	 *
-	 * @return True if this material is a block and solid
-	 */
-	public boolean isSolid() {
-		if(!isBlock() || id == 0){
-			return false;
-		}
-		switch (this) {
-			case STONE:
-			case GRASS:
-			case DIRT:
-			case COBBLESTONE:
-			case WOOD:
-			case BEDROCK:
-			case SAND:
-			case GRAVEL:
-			case GOLD_ORE:
-			case IRON_ORE:
-			case COAL_ORE:
-			case LOG:
-			case LEAVES:
-			case SPONGE:
-			case GLASS:
-			case LAPIS_ORE:
-			case LAPIS_BLOCK:
-			case DISPENSER:
-			case SANDSTONE:
-			case NOTE_BLOCK:
-			case BED_BLOCK:
-			case PISTON_STICKY_BASE:
-			case PISTON_BASE:
-			case PISTON_EXTENSION:
-			case WOOL:
-			case PISTON_MOVING_PIECE:
-			case GOLD_BLOCK:
-			case IRON_BLOCK:
-			case DOUBLE_STEP:
-			case STEP:
-			case BRICK:
-			case TNT:
-			case BOOKSHELF:
-			case MOSSY_COBBLESTONE:
-			case OBSIDIAN:
-			case MOB_SPAWNER:
-			case WOOD_STAIRS:
-			case CHEST:
-			case DIAMOND_ORE:
-			case DIAMOND_BLOCK:
-			case WORKBENCH:
-			case SOIL:
-			case FURNACE:
-			case BURNING_FURNACE:
-			case SIGN_POST:
-			case WOODEN_DOOR:
-			case COBBLESTONE_STAIRS:
-			case WALL_SIGN:
-			case STONE_PLATE:
-			case IRON_DOOR_BLOCK:
-			case WOOD_PLATE:
-			case REDSTONE_ORE:
-			case GLOWING_REDSTONE_ORE:
-			case ICE:
-			case SNOW_BLOCK:
-			case CACTUS:
-			case CLAY:
-			case JUKEBOX:
-			case FENCE:
-			case PUMPKIN:
-			case NETHERRACK:
-			case SOUL_SAND:
-			case GLOWSTONE:
-			case JACK_O_LANTERN:
-			case CAKE_BLOCK:
-			case LOCKED_CHEST:
-			case STAINED_GLASS:
-			case TRAP_DOOR:
-			case MONSTER_EGGS:
-			case SMOOTH_BRICK:
-			case HUGE_MUSHROOM_1:
-			case HUGE_MUSHROOM_2:
-			case IRON_FENCE:
-			case THIN_GLASS:
-			case MELON_BLOCK:
-			case FENCE_GATE:
-			case BRICK_STAIRS:
-			case SMOOTH_STAIRS:
-			case MYCEL:
-			case NETHER_BRICK:
-			case NETHER_FENCE:
-			case NETHER_BRICK_STAIRS:
-			case ENCHANTMENT_TABLE:
-			case BREWING_STAND:
-			case CAULDRON:
-			case ENDER_PORTAL_FRAME:
-			case ENDER_STONE:
-			case DRAGON_EGG:
-			case REDSTONE_LAMP_OFF:
-			case REDSTONE_LAMP_ON:
-			case WOOD_DOUBLE_STEP:
-			case WOOD_STEP:
-			case SANDSTONE_STAIRS:
-			case EMERALD_ORE:
-			case ENDER_CHEST:
-			case EMERALD_BLOCK:
-			case SPRUCE_WOOD_STAIRS:
-			case BIRCH_WOOD_STAIRS:
-			case JUNGLE_WOOD_STAIRS:
-			case COMMAND:
-			case BEACON:
-			case COBBLE_WALL:
-			case ANVIL:
-			case TRAPPED_CHEST:
-			case GOLD_PLATE:
-			case IRON_PLATE:
-			case DAYLIGHT_DETECTOR:
-			case REDSTONE_BLOCK:
-			case QUARTZ_ORE:
-			case HOPPER:
-			case QUARTZ_BLOCK:
-			case QUARTZ_STAIRS:
-			case DROPPER:
-			case STAINED_CLAY:
-			case HAY_BLOCK:
-			case HARD_CLAY:
-			case COAL_BLOCK:
-			case STAINED_GLASS_PANE:
-			case LEAVES_2:
-			case LOG_2:
-			case ACACIA_STAIRS:
-			case DARK_OAK_STAIRS:
-			case PACKED_ICE:
-				return true;
-			default:
-				return false;
-		}
-	}
+    /**
+     * Check if the material is a block and does not block any light
+     *
+     * @return True if this material is a block and does not block any light
+     */
+    public boolean isTransparent() {
+        if (!isBlock()) {
+            return false;
+        }
+        switch (this) {
+            case AIR:
+            case SAPLING:
+            case POWERED_RAIL:
+            case DETECTOR_RAIL:
+            case LONG_GRASS:
+            case DEAD_BUSH:
+            case YELLOW_FLOWER:
+            case RED_ROSE:
+            case BROWN_MUSHROOM:
+            case RED_MUSHROOM:
+            case TORCH:
+            case FIRE:
+            case REDSTONE_WIRE:
+            case CROPS:
+            case LADDER:
+            case RAILS:
+            case LEVER:
+            case REDSTONE_TORCH_OFF:
+            case REDSTONE_TORCH_ON:
+            case STONE_BUTTON:
+            case SNOW:
+            case SUGAR_CANE_BLOCK:
+            case PORTAL:
+            case DIODE_BLOCK_OFF:
+            case DIODE_BLOCK_ON:
+            case PUMPKIN_STEM:
+            case MELON_STEM:
+            case VINE:
+            case WATER_LILY:
+            case NETHER_WARTS:
+            case ENDER_PORTAL:
+            case COCOA:
+            case TRIPWIRE_HOOK:
+            case TRIPWIRE:
+            case FLOWER_POT:
+            case CARROT:
+            case POTATO:
+            case WOOD_BUTTON:
+            case SKULL:
+            case REDSTONE_COMPARATOR_OFF:
+            case REDSTONE_COMPARATOR_ON:
+            case ACTIVATOR_RAIL:
+            case CARPET:
+            case DOUBLE_PLANT:
+                return true;
+            default:
+                return false;
+        }
+    }
+}
+
+class Java15Compat {
+    @SuppressWarnings("unchecked")
+    public static <T> T[] Arrays_copyOfRange(T[] original, int start, int end) {
+        if (original.length >= start && 0 <= start) {
+            if (start <= end) {
+                int length = end - start;
+                int copyLength = Math.min(length, original.length - start);
+                T[] copy = (T[]) Array.newInstance(original.getClass().getComponentType(), length);
 
-	/**
-	 * Check if the material is a block and does not block any light
-	 *
-	 * @return True if this material is a block and does not block any light
-	 */
-	public boolean isTransparent() {
-		if(!isBlock()){
-			return false;
-		}
-		switch (this) {
-			case AIR:
-			case SAPLING:
-			case POWERED_RAIL:
-			case DETECTOR_RAIL:
-			case LONG_GRASS:
-			case DEAD_BUSH:
-			case YELLOW_FLOWER:
-			case RED_ROSE:
-			case BROWN_MUSHROOM:
-			case RED_MUSHROOM:
-			case TORCH:
-			case FIRE:
-			case REDSTONE_WIRE:
-			case CROPS:
-			case LADDER:
-			case RAILS:
-			case LEVER:
-			case REDSTONE_TORCH_OFF:
-			case REDSTONE_TORCH_ON:
-			case STONE_BUTTON:
-			case SNOW:
-			case SUGAR_CANE_BLOCK:
-			case PORTAL:
-			case DIODE_BLOCK_OFF:
-			case DIODE_BLOCK_ON:
-			case PUMPKIN_STEM:
-			case MELON_STEM:
-			case VINE:
-			case WATER_LILY:
-			case NETHER_WARTS:
-			case ENDER_PORTAL:
-			case COCOA:
-			case TRIPWIRE_HOOK:
-			case TRIPWIRE:
-			case FLOWER_POT:
-			case CARROT:
-			case POTATO:
-			case WOOD_BUTTON:
-			case SKULL:
-			case REDSTONE_COMPARATOR_OFF:
-			case REDSTONE_COMPARATOR_ON:
-			case ACTIVATOR_RAIL:
-			case CARPET:
-			case DOUBLE_PLANT:
-				return true;
-			default:
-				return false;
-		}
-	}
+                System.arraycopy(original, start, copy, 0, copyLength);
+                return copy;
+            }
+            throw new IllegalArgumentException();
+        }
+        throw new ArrayIndexOutOfBoundsException();
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/MaterialData.java b/src/main/java/dev/wolveringer/BungeeUtil/MaterialData.java
index 2eeb3d9..5bc33f6 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/MaterialData.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/MaterialData.java
@@ -6,115 +6,113 @@ import dev.wolveringer.BungeeUtil.item.Item;
  * Handles specific metadata for certain items or blocks
  */
 public class MaterialData implements Cloneable {
-	private byte data = 0;
-	private final int type;
-
-	public MaterialData(final int type) {
-		this(type, (byte) 0);
-	}
-
-	public MaterialData(final int type, final byte data) {
-		this.type = type;
-		this.data = data;
-	}
-
-	public MaterialData(final Material type) {
-		this(type, (byte) 0);
-	}
-
-	@SuppressWarnings("deprecation")
-	public MaterialData(final Material type, final byte data) {
-		this(type.getId(), data);
-	}
-
-	@Override
-	public MaterialData clone() {
-		try{
-			return (MaterialData) super.clone();
-		}catch (CloneNotSupportedException e){
-			throw new Error(e);
-		}
-	}
-
-	@Override
-	public boolean equals(Object obj) {
-		if(obj != null && obj instanceof MaterialData){
-			MaterialData md = (MaterialData) obj;
-
-			return md.getItemTypeId() == getItemTypeId() && md.getData() == getData();
-		}else{
-			return false;
-		}
-	}
-
-	/**
-	 * Gets the raw data in this material
-	 *
-	 * @return Raw data
-	 */
-	public byte getData() {
-		return data;
-	}
-
-	/**
-	 * Gets the Material that this MaterialData represents
-	 *
-	 * @return Material represented by this MaterialData
-	 */
-	@SuppressWarnings("deprecation")
-	public Material getItemType() {
-		return Material.getMaterial(type);
-	}
-
-	/**
-	 * Gets the Material Id that this MaterialData represents
-	 *
-	 * @return Material Id represented by this MaterialData
-	 * @deprecated Magic value
-	 */
-	public int getItemTypeId() {
-		return type;
-	}
-
-	public int hashCode() {
-		return getItemTypeId() << 8 ^ getData();
-	}
-
-	/**
-	 * Sets the raw data of this material
-	 *
-	 * @param data
-	 *            New raw data
-	 * @deprecated Magic value
-	 */
-	public void setData(byte data) {
-		this.data = data;
-	}
-
-	/**
-	 * Creates a new ItemStack based on this MaterialData
-	 *
-	 * @return New ItemStack containing a copy of this MaterialData
-	 */
-	@SuppressWarnings("deprecation")
-	public Item toItemStack() {
-		return new Item(type, 1, data);
-	}
-
-	/**
-	 * Creates a new ItemStack based on this MaterialData
-	 *
-	 * @param amount
-	 *            The stack size of the new stack
-	 * @return New ItemStack containing a copy of this MaterialData
-	 */
-	@SuppressWarnings("deprecation")
-	public Item toItemStack(int amount) {
-		return new Item(type, amount, data);
-	}
-
-	@Override
-	public String toString() {
-		return getItemType() + "(" + getData() + ")";
-	}
+    private final int type;
+    private byte data = 0;
+
+    public MaterialData(final int type) {
+        this(type, (byte) 0);
+    }
+
+    public MaterialData(final int type, final byte data) {
+        this.type = type;
+        this.data = data;
+    }
+
+    public MaterialData(final Material type) {
+        this(type, (byte) 0);
+    }
+
+    @SuppressWarnings("deprecation")
+    public MaterialData(final Material type, final byte data) {
+        this(type.getId(), data);
+    }
+
+    @Override
+    public MaterialData clone() {
+        try {
+            return (MaterialData) super.clone();
+        } catch (CloneNotSupportedException e) {
+            throw new Error(e);
+        }
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (obj != null && obj instanceof MaterialData) {
+            MaterialData md = (MaterialData) obj;
+
+            return md.getItemTypeId() == getItemTypeId() && md.getData() == getData();
+        } else {
+            return false;
+        }
+    }
+
+    /**
+     * Gets the raw data in this material
+     *
+     * @return Raw data
+     */
+    public byte getData() {
+        return data;
+    }
+
+    /**
+     * Sets the raw data of this material
+     *
+     * @param data New raw data
+     * @deprecated Magic value
+     */
+    public void setData(byte data) {
+        this.data = data;
+    }
+
+    /**
+     * Gets the Material that this MaterialData represents
+     *
+     * @return Material represented by this MaterialData
+     */
+    @SuppressWarnings("deprecation")
+    public Material getItemType() {
+        return Material.getMaterial(type);
+    }
+
+    /**
+     * Gets the Material Id that this MaterialData represents
+     *
+     * @return Material Id represented by this MaterialData
+     * @deprecated Magic value
+     */
+    public int getItemTypeId() {
+        return type;
+    }
+
+    public int hashCode() {
+        return getItemTypeId() << 8 ^ getData();
+    }
+
+    /**
+     * Creates a new ItemStack based on this MaterialData
+     *
+     * @return New ItemStack containing a copy of this MaterialData
+     */
+    @SuppressWarnings("deprecation")
+    public Item toItemStack() {
+        return new Item(type, 1, data);
+    }
+
+    /**
+     * Creates a new ItemStack based on this MaterialData
+     *
+     * @param amount The stack size of the new stack
+     * @return New ItemStack containing a copy of this MaterialData
+     */
+    @SuppressWarnings("deprecation")
+    public Item toItemStack(int amount) {
+        return new Item(type, amount, data);
+    }
+
+    @Override
+    public String toString() {
+        return getItemType() + "(" + getData() + ")";
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/NumberConversions.java b/src/main/java/dev/wolveringer/BungeeUtil/NumberConversions.java
index 0b2da24..0ce072e 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/NumberConversions.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/NumberConversions.java
@@ -1,7 +1,8 @@
 package dev.wolveringer.BungeeUtil;
 
 public final class NumberConversions {
-    private NumberConversions() {}
+    private NumberConversions() {
+    }
 
     public static int floor(double num) {
         final int floor = (int) num;
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/OperatingSystem/OperatingSystemType.java b/src/main/java/dev/wolveringer/BungeeUtil/OperatingSystem/OperatingSystemType.java
index 34c9b77..86adf84 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/OperatingSystem/OperatingSystemType.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/OperatingSystem/OperatingSystemType.java
@@ -3,134 +3,164 @@ package dev.wolveringer.BungeeUtil.OperatingSystem;
 import java.util.HashMap;
 
 public class OperatingSystemType {
-	public static abstract class OperatingSystem {
-		public OperatingSystem() {
-			types.put(getIdentifier(), this);
-		}
-		public abstract String getIdentifier();
-		
-		public boolean isWindows(){
-			return getIdentifier().toLowerCase().contains("windows");
-		}
-		public boolean isLinux(){
-			return getIdentifier().toLowerCase().contains("linux");
-		}
-		public boolean isMac(){
-			return getIdentifier().toLowerCase().contains("mac");
-		}
-	}
-	private static HashMap<String, OperatingSystem> types = new HashMap<String, OperatingSystemType.OperatingSystem>();
-	
-	public static final OperatingSystemWindows WINDOWS = new OperatingSystemWindows() {
-		@Override
-		public String getIdentifier() {
-			return "Windows";
-		}
-	};
-	public static final OperatingSystemLinux LINUX = new OperatingSystemLinux() {
-		@Override
-		public String getIdentifier() {
-			return "Linux";
-		}
-	};
-	public static final OperatingSystemMac MAC = new OperatingSystemMac() {
-		@Override
-		public String getIdentifier() {
-			return "Mac";
-		}
-	};
-	public static final OperatingSystem UNDEFINED = new OperatingSystem() {
-		@Override
-		public String getIdentifier() {
-			return "undefined";
-		}
-	};
-	String name;
-	
-	private OperatingSystemType(String name) {
-		this.name = name;
-	}
-	
-	private static OperatingSystem type = null;
-	public static OperatingSystem getSystemType(){
-		if(type == null){
-			type = types.get(System.getProperty("os.name"));
-			if(type == null)
-				type = UNDEFINED;
-		}
-		return type;
-	}
-	
-	
-	public static abstract class OperatingSystemWindows extends OperatingSystem{
-		public static final OperatingSystem WINDOWS_95 = new OperatingSystemWindows() {
-			public String getIdentifier() {
-				return "Windows 95";
-			};
-		};
-		public static final OperatingSystem WINDOWS_98 = new OperatingSystemWindows() {
-			public String getIdentifier() {
-				return "Windows 98";
-			};
-		};
-		public static final OperatingSystem WINDOWS_ME = new OperatingSystemWindows() {
-			public String getIdentifier() {
-				return "Windows Me";
-			};
-		};
-		public static final OperatingSystem WINDOWS_NT = new OperatingSystemWindows() {
-			public String getIdentifier() {
-				return "Windows NT";
-			};
-		};
-		public static final OperatingSystem WINDOWS_2000 = new OperatingSystemWindows() {
-			public String getIdentifier() {
-				return "Windows 2000";
-			};
-		};
-		public static final OperatingSystem WINDOWS_XP = new OperatingSystemWindows() {
-			public String getIdentifier() {
-				return "Windows XP";
-			};
-		};
-		public static final OperatingSystem WINDOWS_2003 = new OperatingSystemWindows() {
-			public String getIdentifier() {
-				return "Windows 2003";
-			};
-		};
-		public static final OperatingSystem WINDOWS_CE = new OperatingSystemWindows() {
-			public String getIdentifier() {
-				return "Windows CE";
-			};
-		};
-		public static final OperatingSystem WINDOWS_7 = new OperatingSystemWindows() {
-			public String getIdentifier() {
-				return "Windows 7";
-			};
-		};
-		public static final OperatingSystem WINDOWS_8 = new OperatingSystemWindows() {
-			public String getIdentifier() {
-				return "Windows 8";
-			};
-		};
-		public static final OperatingSystem WINDOWS_10 = new OperatingSystemWindows() {
-			public String getIdentifier() {
-				return "Windows 10";
-			};
-		};
-	}
-	public static abstract class OperatingSystemLinux extends OperatingSystem{}
-	
-	public static abstract class OperatingSystemMac extends OperatingSystem{
-		public static final OperatingSystem MAC_OS = new OperatingSystemMac() {
-			public String getIdentifier() {
-				return "Mac OS";
-			};
-		};
-		public static final OperatingSystem MAC_OS_X = new OperatingSystemMac() {
-			public String getIdentifier() {
-				return "Mac OS X";
-			};
-		};
-	}
+    public static final OperatingSystemWindows WINDOWS = new OperatingSystemWindows() {
+        @Override
+        public String getIdentifier() {
+            return "Windows";
+        }
+    };
+    public static final OperatingSystemLinux LINUX = new OperatingSystemLinux() {
+        @Override
+        public String getIdentifier() {
+            return "Linux";
+        }
+    };
+    public static final OperatingSystemMac MAC = new OperatingSystemMac() {
+        @Override
+        public String getIdentifier() {
+            return "Mac";
+        }
+    };
+    public static final OperatingSystem UNDEFINED = new OperatingSystem() {
+        @Override
+        public String getIdentifier() {
+            return "undefined";
+        }
+    };
+    private static HashMap<String, OperatingSystem> types = new HashMap<String, OperatingSystemType.OperatingSystem>();
+    private static OperatingSystem type = null;
+    String name;
+
+    private OperatingSystemType(String name) {
+        this.name = name;
+    }
+
+    public static OperatingSystem getSystemType() {
+        if (type == null) {
+            type = types.get(System.getProperty("os.name"));
+            if (type == null)
+                type = UNDEFINED;
+        }
+        return type;
+    }
+
+    public static abstract class OperatingSystem {
+        public OperatingSystem() {
+            types.put(getIdentifier(), this);
+        }
+
+        public abstract String getIdentifier();
+
+        public boolean isWindows() {
+            return getIdentifier().toLowerCase().contains("windows");
+        }
+
+        public boolean isLinux() {
+            return getIdentifier().toLowerCase().contains("linux");
+        }
+
+        public boolean isMac() {
+            return getIdentifier().toLowerCase().contains("mac");
+        }
+    }
+
+    public static abstract class OperatingSystemWindows extends OperatingSystem {
+        public static final OperatingSystem WINDOWS_95 = new OperatingSystemWindows() {
+            public String getIdentifier() {
+                return "Windows 95";
+            }
+
+            ;
+        };
+        public static final OperatingSystem WINDOWS_98 = new OperatingSystemWindows() {
+            public String getIdentifier() {
+                return "Windows 98";
+            }
+
+            ;
+        };
+        public static final OperatingSystem WINDOWS_ME = new OperatingSystemWindows() {
+            public String getIdentifier() {
+                return "Windows Me";
+            }
+
+            ;
+        };
+        public static final OperatingSystem WINDOWS_NT = new OperatingSystemWindows() {
+            public String getIdentifier() {
+                return "Windows NT";
+            }
+
+            ;
+        };
+        public static final OperatingSystem WINDOWS_2000 = new OperatingSystemWindows() {
+            public String getIdentifier() {
+                return "Windows 2000";
+            }
+
+            ;
+        };
+        public static final OperatingSystem WINDOWS_XP = new OperatingSystemWindows() {
+            public String getIdentifier() {
+                return "Windows XP";
+            }
+
+            ;
+        };
+        public static final OperatingSystem WINDOWS_2003 = new OperatingSystemWindows() {
+            public String getIdentifier() {
+                return "Windows 2003";
+            }
+
+            ;
+        };
+        public static final OperatingSystem WINDOWS_CE = new OperatingSystemWindows() {
+            public String getIdentifier() {
+                return "Windows CE";
+            }
+
+            ;
+        };
+        public static final OperatingSystem WINDOWS_7 = new OperatingSystemWindows() {
+            public String getIdentifier() {
+                return "Windows 7";
+            }
+
+            ;
+        };
+        public static final OperatingSystem WINDOWS_8 = new OperatingSystemWindows() {
+            public String getIdentifier() {
+                return "Windows 8";
+            }
+
+            ;
+        };
+        public static final OperatingSystem WINDOWS_10 = new OperatingSystemWindows() {
+            public String getIdentifier() {
+                return "Windows 10";
+            }
+
+            ;
+        };
+    }
+
+    public static abstract class OperatingSystemLinux extends OperatingSystem {
+    }
+
+    public static abstract class OperatingSystemMac extends OperatingSystem {
+        public static final OperatingSystem MAC_OS = new OperatingSystemMac() {
+            public String getIdentifier() {
+                return "Mac OS";
+            }
+
+            ;
+        };
+        public static final OperatingSystem MAC_OS_X = new OperatingSystemMac() {
+            public String getIdentifier() {
+                return "Mac OS X";
+            }
+
+            ;
+        };
+    }
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/OperationCalback.java b/src/main/java/dev/wolveringer/BungeeUtil/OperationCalback.java
index 2032307..012371f 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/OperationCalback.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/OperationCalback.java
@@ -1,5 +1,5 @@
 package dev.wolveringer.BungeeUtil;
 
 public interface OperationCalback<T> {
-	public void done(T response);
+    public void done(T response);
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/PacketHandleEvent.java b/src/main/java/dev/wolveringer/BungeeUtil/PacketHandleEvent.java
index 604c3f5..6ebb21a 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/PacketHandleEvent.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/PacketHandleEvent.java
@@ -2,48 +2,49 @@ package dev.wolveringer.BungeeUtil;
 
 import net.md_5.bungee.api.plugin.Cancellable;
 import net.md_5.bungee.api.plugin.Event;
+
 import dev.wolveringer.BungeeUtil.packets.Packet;
 
 public class PacketHandleEvent<T extends Packet> extends Event implements Cancellable {
-	private boolean cancelled = false;
-	private T packet;
-	private Player player;
-
-	public PacketHandleEvent(T p, Player pl) {
-		this.packet = p;
-		this.player = pl;
-	}
-
-	public T getPacket() {
-		return packet;
-	}
-
-	public Player getPlayer() {
-		return player;
-	}
-
-	public boolean isCancelled() {
-		return cancelled;
-	}
-
-	public void setCancelled(boolean c) {
-		this.cancelled = c;
-	}
-
-	public void setPacket(T p) {
-		this.packet = p;
-	}
-
-	/**
-	 * {@code The player change dont will change the destination of the packet!!!}
-	 */
-
-	public void setPlayer(Player pl) {
-		this.player = pl;
-	}
-
-	@Override
-	public String toString() {
-		return "PacketHandleEvent@" + System.identityHashCode(this) + "[cancelled=" + this.cancelled + ", packet=" + this.packet + ", player=" + this.player + "]";
-	}
+    private boolean cancelled = false;
+    private T packet;
+    private Player player;
+
+    public PacketHandleEvent(T p, Player pl) {
+        this.packet = p;
+        this.player = pl;
+    }
+
+    public T getPacket() {
+        return packet;
+    }
+
+    public void setPacket(T p) {
+        this.packet = p;
+    }
+
+    public Player getPlayer() {
+        return player;
+    }
+
+    /**
+     * {@code The player change dont will change the destination of the packet!!!}
+     */
+
+    public void setPlayer(Player pl) {
+        this.player = pl;
+    }
+
+    public boolean isCancelled() {
+        return cancelled;
+    }
+
+    public void setCancelled(boolean c) {
+        this.cancelled = c;
+    }
+
+    @Override
+    public String toString() {
+        return "PacketHandleEvent@" + System.identityHashCode(this) + "[cancelled=" + this.cancelled + ", packet=" + this.packet + ", player=" + this.player + "]";
+    }
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/PacketHandler.java b/src/main/java/dev/wolveringer/BungeeUtil/PacketHandler.java
index 8e69af9..7b40f61 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/PacketHandler.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/PacketHandler.java
@@ -3,5 +3,5 @@ package dev.wolveringer.BungeeUtil;
 import dev.wolveringer.BungeeUtil.packets.Packet;
 
 public interface PacketHandler<T extends Packet> {
-	public void handle(PacketHandleEvent<T> e);
+    public void handle(PacketHandleEvent<T> e);
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/PacketLib.java b/src/main/java/dev/wolveringer/BungeeUtil/PacketLib.java
index abb1bca..e82e474 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/PacketLib.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/PacketLib.java
@@ -14,173 +14,174 @@ import dev.wolveringer.BungeeUtil.packets.PacketPlayInPosition;
 import lombok.AllArgsConstructor;
 import lombok.Getter;
 
-@SuppressWarnings({ "unchecked", "rawtypes" })
+@SuppressWarnings({"unchecked", "rawtypes"})
 public class PacketLib {
-	@AllArgsConstructor
-	@Getter
-	private static class PacketHandlerHolder implements Comparable<PacketHandlerHolder> {
-		private PacketHandler handler;
-		private int importance;
-		
-		@Override
-		public int compareTo(PacketHandlerHolder o) {
-			return Integer.compare(o.importance, importance);
-		}
-
-		@Override
-		public int hashCode() {
-			final int prime = 31;
-			int result = 1;
-			result = prime * result + ((handler == null) ? 0 : handler.hashCode());
-			//result = prime * result + importance;
-			return result;
-		}
-
-		@Override
-		public boolean equals(Object obj) {
-			if (this == obj)
-				return true;
-			if (obj == null)
-				return false;
-			if(obj instanceof PacketHandler)
-				return obj.equals(handler);
-			if (getClass() != obj.getClass())
-				return false;
-			PacketHandlerHolder other = (PacketHandlerHolder) obj;
-			if (handler == null) {
-				if (other.handler != null)
-					return false;
-			} else if (!handler.equals(other.handler))
-				return false;
-			if (importance != other.importance)
-				return false;
-			return true;
-		}
-	}
-	
-	@Deprecated
-	public static void printListener(){
-		for(Entry<Class<? extends Packet>, ArrayList<PacketHandlerHolder>> e : handlers.entrySet()){
-			StringBuilder out = new StringBuilder();
-			for(PacketHandlerHolder h : e.getValue())
-				out.append(", "+h.getHandler().toString());
-			if( e.getValue().size() > 0)
-			System.out.print(e.getKey()+" -> "+out.toString().substring(2));
-		}
-	}
-	
-	private static HashMap<Class<? extends Packet>, ArrayList<PacketHandlerHolder>> handlers = new HashMap<Class<? extends Packet>, ArrayList<PacketHandlerHolder>>() {
-		private static final long serialVersionUID = 1L;
-
-		@Override
-		public ArrayList<PacketHandlerHolder> get(Object paramObject) {
-			Object r = super.get(paramObject);
-			if(r == null)
-				try{
-					super.put((Class<? extends Packet>) paramObject, new ArrayList<PacketHandlerHolder>(){
-						private static final long serialVersionUID = 1L;
-						public void insertSorted(PacketHandlerHolder value) {
-					        super.add(value);
-					        Comparable<PacketHandlerHolder> cmp = (Comparable<PacketHandlerHolder>) value;
-					        for (int i = size()-1; i > 0 && cmp.compareTo(get(i-1)) < 0; i--)
-					            Collections.swap(this, i, i-1);
-					    }
-						public boolean add(PacketHandlerHolder value) {
-							insertSorted(value);
-							return true;
-						}
-					});
-				}catch (Exception e){
-				}
-			return super.get(paramObject);
-		}
-	};
-
-	@SuppressWarnings("serial")
-	private static HashMap<Class<? extends Packet>, ArrayList<Class<? extends Packet>>> superclazzes = new HashMap<Class<? extends Packet>, ArrayList<Class<? extends Packet>>>() {
-		@Override
-		public ArrayList<Class<? extends Packet>> get(Object paramObject) {
-			ArrayList<Class<? extends Packet>> r = super.get(paramObject);
-			if(r == null)
-				try{
-					ArrayList<Class<? extends Packet>> list = new ArrayList<Class<? extends Packet>>();
-					Class c = (Class) paramObject;
-					BungeeUtil.getInstance().debug("Sarching for subinstances of "+c);
-					if(c != Packet.class)
-						for(Class<? extends Packet> clazz : Packet.getRegisteredPackets()){
-							if(c.isAssignableFrom(clazz)){
-								list.add(clazz);
-							}
-						}
-					list.add(c);
-					r = (list = new ArrayList<>(new HashSet<>(list)));
-					for(Class x : list)
-						BungeeUtil.getInstance().debug("Found class instance of "+c+" -> "+x);
-					super.put((Class<? extends Packet>) paramObject, r);
-				}catch (Exception e){ }
-			return r;
-		}
-	};
-
-	public static void addHandler(PacketHandler h) {
-		addHandler(h, 0);
-	}
-
-	public static void addHandler(PacketHandler h,int importance) {
-		for(Class c : superclazzes.get(getPacketType(h))){
-			handlers.get(c).add(new PacketHandlerHolder(h, importance));
-		}
-	}
-
-	
-	public static void removeHandler(PacketHandler h) {
-		for(Class c : superclazzes.get(getPacketType(h))){
-			for(PacketHandlerHolder h1 : new ArrayList<>(handlers.get(c)))
-				if(h1 != null && h1.getHandler() != null && h1.getHandler().equals(h))
-					handlers.get(c).remove(h1);
-		}
-		for(PacketHandlerHolder h1 : handlers.get(Packet.class))
-			if(h1 != null && h1.getHandler() != null && h1.getHandler().equals(h))
-				handlers.get(Packet.class).remove(h1);
-	}
-	
-	public static PacketHandleEvent handle(PacketHandleEvent e) {
-		Class<? extends Packet> c = e.getPacket().getClass();
-		for(PacketHandlerHolder h : new ArrayList<>(handlers.get(c)))
-			h.handler.handle(e);
-		for(PacketHandlerHolder h : new ArrayList<>(handlers.get(Packet.class)))
-			h.handler.handle(e);
-		return e;
-	}
-
-	private static Class getPacketType(PacketHandler s) {
-		for(Type interfaces : s.getClass().getGenericInterfaces())
-			if(interfaces instanceof ParameterizedType)
-				for(Type c : ((ParameterizedType) interfaces).getActualTypeArguments())
-					try{
-						if(c.equals(Packet.class))
-							continue;
-						try{
-							return Class.forName(c.toString().split(" ")[1]);
-						}catch(ExceptionInInitializerError e){
-							System.out.println("Cant find class "+c.toString().split(" ")[1]);
-							throw e;
-						}
-					}catch (ClassNotFoundException e){
-						e.printStackTrace();
-					}
-		return Packet.class;
-	}
-	
-	public static void main(String[] args) {
-		PacketHandler handler = new PacketHandler<PacketPlayInFlying>() {
-			@Override
-			public void handle(PacketHandleEvent<PacketPlayInFlying> e) {
-				System.out.println("Handle "+e);
-			}
-		};
-		System.out.println("Type: "+getPacketType(handler));
-		addHandler(handler);
-		handle(new PacketHandleEvent(new PacketPlayInPosition(), null));
-	}
+    private static HashMap<Class<? extends Packet>, ArrayList<PacketHandlerHolder>> handlers = new HashMap<Class<? extends Packet>, ArrayList<PacketHandlerHolder>>() {
+        private static final long serialVersionUID = 1L;
+
+        @Override
+        public ArrayList<PacketHandlerHolder> get(Object paramObject) {
+            Object r = super.get(paramObject);
+            if (r == null)
+                try {
+                    super.put((Class<? extends Packet>) paramObject, new ArrayList<PacketHandlerHolder>() {
+                        private static final long serialVersionUID = 1L;
+
+                        public void insertSorted(PacketHandlerHolder value) {
+                            super.add(value);
+                            Comparable<PacketHandlerHolder> cmp = (Comparable<PacketHandlerHolder>) value;
+                            for (int i = size() - 1; i > 0 && cmp.compareTo(get(i - 1)) < 0; i--)
+                                Collections.swap(this, i, i - 1);
+                        }
+
+                        public boolean add(PacketHandlerHolder value) {
+                            insertSorted(value);
+                            return true;
+                        }
+                    });
+                } catch (Exception e) {
+                }
+            return super.get(paramObject);
+        }
+    };
+    @SuppressWarnings("serial")
+    private static HashMap<Class<? extends Packet>, ArrayList<Class<? extends Packet>>> superclazzes = new HashMap<Class<? extends Packet>, ArrayList<Class<? extends Packet>>>() {
+        @Override
+        public ArrayList<Class<? extends Packet>> get(Object paramObject) {
+            ArrayList<Class<? extends Packet>> r = super.get(paramObject);
+            if (r == null)
+                try {
+                    ArrayList<Class<? extends Packet>> list = new ArrayList<Class<? extends Packet>>();
+                    Class c = (Class) paramObject;
+                    BungeeUtil.getInstance().debug("Sarching for subinstances of " + c);
+                    if (c != Packet.class)
+                        for (Class<? extends Packet> clazz : Packet.getRegisteredPackets()) {
+                            if (c.isAssignableFrom(clazz)) {
+                                list.add(clazz);
+                            }
+                        }
+                    list.add(c);
+                    r = (list = new ArrayList<>(new HashSet<>(list)));
+                    for (Class x : list)
+                        BungeeUtil.getInstance().debug("Found class instance of " + c + " -> " + x);
+                    super.put((Class<? extends Packet>) paramObject, r);
+                } catch (Exception e) {
+                }
+            return r;
+        }
+    };
+
+    @Deprecated
+    public static void printListener() {
+        for (Entry<Class<? extends Packet>, ArrayList<PacketHandlerHolder>> e : handlers.entrySet()) {
+            StringBuilder out = new StringBuilder();
+            for (PacketHandlerHolder h : e.getValue())
+                out.append(", " + h.getHandler().toString());
+            if (e.getValue().size() > 0)
+                System.out.print(e.getKey() + " -> " + out.toString().substring(2));
+        }
+    }
+
+    public static void addHandler(PacketHandler h) {
+        addHandler(h, 0);
+    }
+
+    public static void addHandler(PacketHandler h, int importance) {
+        for (Class c : superclazzes.get(getPacketType(h))) {
+            handlers.get(c).add(new PacketHandlerHolder(h, importance));
+        }
+    }
+
+    public static void removeHandler(PacketHandler h) {
+        for (Class c : superclazzes.get(getPacketType(h))) {
+            for (PacketHandlerHolder h1 : new ArrayList<>(handlers.get(c)))
+                if (h1 != null && h1.getHandler() != null && h1.getHandler().equals(h))
+                    handlers.get(c).remove(h1);
+        }
+        for (PacketHandlerHolder h1 : handlers.get(Packet.class))
+            if (h1 != null && h1.getHandler() != null && h1.getHandler().equals(h))
+                handlers.get(Packet.class).remove(h1);
+    }
+
+    public static PacketHandleEvent handle(PacketHandleEvent e) {
+        Class<? extends Packet> c = e.getPacket().getClass();
+        for (PacketHandlerHolder h : new ArrayList<>(handlers.get(c)))
+            h.handler.handle(e);
+        for (PacketHandlerHolder h : new ArrayList<>(handlers.get(Packet.class)))
+            h.handler.handle(e);
+        return e;
+    }
+
+    private static Class getPacketType(PacketHandler s) {
+        for (Type interfaces : s.getClass().getGenericInterfaces())
+            if (interfaces instanceof ParameterizedType)
+                for (Type c : ((ParameterizedType) interfaces).getActualTypeArguments())
+                    try {
+                        if (c.equals(Packet.class))
+                            continue;
+                        try {
+                            return Class.forName(c.toString().split(" ")[1]);
+                        } catch (ExceptionInInitializerError e) {
+                            System.out.println("Cant find class " + c.toString().split(" ")[1]);
+                            throw e;
+                        }
+                    } catch (ClassNotFoundException e) {
+                        e.printStackTrace();
+                    }
+        return Packet.class;
+    }
+
+    public static void main(String[] args) {
+        PacketHandler handler = new PacketHandler<PacketPlayInFlying>() {
+            @Override
+            public void handle(PacketHandleEvent<PacketPlayInFlying> e) {
+                System.out.println("Handle " + e);
+            }
+        };
+        System.out.println("Type: " + getPacketType(handler));
+        addHandler(handler);
+        handle(new PacketHandleEvent(new PacketPlayInPosition(), null));
+    }
+
+    @AllArgsConstructor
+    @Getter
+    private static class PacketHandlerHolder implements Comparable<PacketHandlerHolder> {
+        private PacketHandler handler;
+        private int importance;
+
+        @Override
+        public int compareTo(PacketHandlerHolder o) {
+            return Integer.compare(o.importance, importance);
+        }
+
+        @Override
+        public int hashCode() {
+            final int prime = 31;
+            int result = 1;
+            result = prime * result + ((handler == null) ? 0 : handler.hashCode());
+            //result = prime * result + importance;
+            return result;
+        }
+
+        @Override
+        public boolean equals(Object obj) {
+            if (this == obj)
+                return true;
+            if (obj == null)
+                return false;
+            if (obj instanceof PacketHandler)
+                return obj.equals(handler);
+            if (getClass() != obj.getClass())
+                return false;
+            PacketHandlerHolder other = (PacketHandlerHolder) obj;
+            if (handler == null) {
+                if (other.handler != null)
+                    return false;
+            } else if (!handler.equals(other.handler))
+                return false;
+            if (importance != other.importance)
+                return false;
+            return true;
+        }
+    }
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/Player.java b/src/main/java/dev/wolveringer/BungeeUtil/Player.java
index 054cbfb..f7335bc 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/Player.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/Player.java
@@ -1,6 +1,7 @@
 package dev.wolveringer.BungeeUtil;
 
 import net.md_5.bungee.api.connection.ProxiedPlayer;
+
 import dev.wolveringer.BungeeUtil.item.Item;
 import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayIn;
 import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
@@ -15,77 +16,70 @@ import dev.wolveringer.chat.IChatBaseComponent;
 import dev.wolveringer.network.IInitialHandler;
 
 public interface Player extends ProxiedPlayer {
-	public IInitialHandler getInitialHandler();
-	
-	public Location getLocation();
-	
-	public void setLocation(Location loc);
-
-	public Location getLastLocation();
-
-	
-	
-	public void performCommand(String command);
-	
-	public boolean isInventoryOpened();
-
-	public void openInventory(Inventory inv);
-
-	public void updateInventory();
-
-	public Inventory getInventoryView();
-	
-	public PlayerInventory getPlayerInventory();
-	
-	public void closeInventory();
-	
-	
-	public void setCursorItem(Item is);
-
-	public Item getCursorItem();
-
-	public Item getHandItem();
-	
-	public Item getOffHandItem();
-
-	public ClientVersion getVersion();
-
-	public void sendPacket(PacketPlayOut packet);
-	
-	@Deprecated
-	public void sendPacketToServer(PacketPlayIn p);
-
-	
-	public void setSelectedSlot(int slot);
-
-	public int getSelectedSlot();
-
-	
-	public void setTabHeader(IChatBaseComponent header,IChatBaseComponent footer);
-	
-	public IChatBaseComponent[] getTabHeader();
-	
-	
-	public Scoreboard getScoreboard();
-
-	public void disconnect(Exception e);
-	
-	public void playSound(SoundEffect effect);
-	
-	public void playSound(SoundEffect effect,float volume);
-	
-	public void playSound(SoundEffect effect,float volume,float pitch);
-	
-	/**
-	 * @param effect
-	 * @param location
-	 * @param volume
-	 * @param pitch (0-360)
-	 */
-	public void playSound(SoundEffect effect, Location location,float volume,float pitch);
-
-	public void playSound(SoundEffect effect, SoundCategory blocks, Location location, float f, float g);
-	
-	
-	public BossBarManager getBossBarManager();
+    public IInitialHandler getInitialHandler();
+
+    public Location getLocation();
+
+    public void setLocation(Location loc);
+
+    public Location getLastLocation();
+
+
+    public void performCommand(String command);
+
+    public boolean isInventoryOpened();
+
+    public void openInventory(Inventory inv);
+
+    public void updateInventory();
+
+    public Inventory getInventoryView();
+
+    public PlayerInventory getPlayerInventory();
+
+    public void closeInventory();
+
+    public Item getCursorItem();
+
+    public void setCursorItem(Item is);
+
+    public Item getHandItem();
+
+    public Item getOffHandItem();
+
+    public ClientVersion getVersion();
+
+    public void sendPacket(PacketPlayOut packet);
+
+    @Deprecated
+    public void sendPacketToServer(PacketPlayIn p);
+
+    public int getSelectedSlot();
+
+    public void setSelectedSlot(int slot);
+
+    public void setTabHeader(IChatBaseComponent header, IChatBaseComponent footer);
+
+    public IChatBaseComponent[] getTabHeader();
+
+
+    public Scoreboard getScoreboard();
+
+    public void disconnect(Exception e);
+
+    public void playSound(SoundEffect effect);
+
+    public void playSound(SoundEffect effect, float volume);
+
+    public void playSound(SoundEffect effect, float volume, float pitch);
+
+    /**
+     * @param pitch (0-360)
+     */
+    public void playSound(SoundEffect effect, Location location, float volume, float pitch);
+
+    public void playSound(SoundEffect effect, SoundCategory blocks, Location location, float f, float g);
+
+
+    public BossBarManager getBossBarManager();
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/RamStatistics.java b/src/main/java/dev/wolveringer/BungeeUtil/RamStatistics.java
index cce3fbc..9f6b186 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/RamStatistics.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/RamStatistics.java
@@ -1,5 +1,9 @@
 package dev.wolveringer.BungeeUtil;
 
+import net.md_5.bungee.BungeeCord;
+import net.md_5.bungee.api.ChatColor;
+import net.md_5.bungee.api.scheduler.ScheduledTask;
+
 import java.util.LinkedList;
 import java.util.concurrent.TimeUnit;
 
@@ -7,133 +11,130 @@ import dev.wolveringer.string.ColoredChar;
 import dev.wolveringer.terminal.graph.TerminalGraph;
 import dev.wolveringer.terminal.graph.TerminalGraph.Graph;
 import dev.wolveringer.terminal.graph.TerminalGraph.Point;
-import net.md_5.bungee.BungeeCord;
-import net.md_5.bungee.api.ChatColor;
-import net.md_5.bungee.api.scheduler.ScheduledTask;
 import lombok.AllArgsConstructor;
 import lombok.Getter;
 
 public class RamStatistics {
-	@AllArgsConstructor
-	public static class RamStatistic {
-		private RamStatistics handle;
-		@Getter
-		private long timestamp;
-		@Getter
-		private long usedMemory;
-		@Getter
-		private long reservedMemory;
-		@Getter
-		private long maxMemory;
-		
-		public RamStatistic getPreviousStatistic(int time,TimeUnit untit){
-			return handle.getPreviousStatistic(this,time,untit);
-		}
-	}
-	private LinkedList<RamStatistic> last = new LinkedList<RamStatistic>();
-	private Runtime runtime;
-	private ScheduledTask task;
-	
-	public RamStatistics() {
-		runtime = Runtime.getRuntime();
-	}
-	
-	public void start(){
-		if(task == null){
-			task = BungeeCord.getInstance().getScheduler().runAsync(BungeeUtil.getPluginInstance(), new Runnable() {
-				@Override
-				public void run() {
-					while (true) {
-						logCurruntRam();
-						try {
-							Thread.sleep(1000);
-						} catch (InterruptedException e) {
-						}
-					}
-				}
-			});
-		}
-	}
-	
-	protected RamStatistic getPreviousStatistic(RamStatistic currunt){
-		int index = last.indexOf(currunt);
-		if(index == -1)
-			return null;
-		if(index-1<0)
-			return null;
-		return last.get(index);
-	}
-	
-	protected RamStatistic getPreviousStatistic(RamStatistic currunt, int time, TimeUnit untit) {
-		int index = last.indexOf(currunt);
-		if(index == -1)
-			return null;
-		index = index-1;
-		while (index>0) {
-			if(last.get(index).timestamp<currunt.timestamp-untit.toMillis(time))
-				return last.get(index);
-			index--;
-		}
-		return null;
-	}
-
-	
-	public void stop(){
-		if(task != null)
-			task.cancel();
-		task = null;
-	}
-	
-	private void logCurruntRam(){
-		last.add(new RamStatistic(this,System.currentTimeMillis(),runtime.totalMemory() - runtime.freeMemory(), runtime.totalMemory(), runtime.maxMemory()));
-		recalculate();
-	}
-	
-	private void recalculate(){
-		while (last.size()> 60*60*5) { //Log for 5 Houers
-			last.pollFirst();
-		}
-	}
-	
-	public RamStatistic getLastState(){
-		return last.getLast();
-	}
-	
-	public TerminalGraph createGrath(int seconds,int divisor){
-		TerminalGraph base = new TerminalGraph();
-		
-		Graph graphUsedMemory = new Graph();
-		graphUsedMemory.setReturnZeroByNoData(true);
-		graphUsedMemory.setCharacter(new ColoredChar('#'));
-		graphUsedMemory.getCharacter().setColor(ChatColor.GREEN);
-		
-		Graph graphAllocatedMemory = new Graph();
-		graphAllocatedMemory.setReturnZeroByNoData(true);
-		graphAllocatedMemory.setCharacter(new ColoredChar('+'));
-		graphAllocatedMemory.getCharacter().setColor(ChatColor.GOLD);
-		
-		int max = 0;
-		
-		for(RamStatistic stats : this.last){
-			if(stats.getTimestamp() > System.currentTimeMillis()-seconds*1000){
-				graphUsedMemory.addPoint(new Point((int)((System.currentTimeMillis()-stats.getTimestamp())/1000), (int) stats.getUsedMemory()/divisor));
-				if(stats.getUsedMemory()/divisor > max)
-					max = (int) stats.getUsedMemory()/divisor;
-				
-				graphAllocatedMemory.addPoint(new Point((int)((System.currentTimeMillis()-stats.getTimestamp())/1000), (int) stats.getReservedMemory()/divisor));
-				if(stats.getReservedMemory()/divisor > max)
-					max = (int) stats.getReservedMemory()/divisor;
-			}
-		}
-		
-		base.addGraph(graphAllocatedMemory);
-		base.addGraph(graphUsedMemory);
-		
-		base.setStartX(seconds);
-		base.setEndX(0);
-		base.setStepX(10);
-		base.setStartY(0);
-		base.setEndY((int) (max+(max*0.1)));
-		return base;
-	}
+    private LinkedList<RamStatistic> last = new LinkedList<RamStatistic>();
+    private Runtime runtime;
+    private ScheduledTask task;
+
+    public RamStatistics() {
+        runtime = Runtime.getRuntime();
+    }
+
+    public void start() {
+        if (task == null) {
+            task = BungeeCord.getInstance().getScheduler().runAsync(BungeeUtil.getPluginInstance(), new Runnable() {
+                @Override
+                public void run() {
+                    while (true) {
+                        logCurruntRam();
+                        try {
+                            Thread.sleep(1000);
+                        } catch (InterruptedException e) {
+                        }
+                    }
+                }
+            });
+        }
+    }
+
+    protected RamStatistic getPreviousStatistic(RamStatistic currunt) {
+        int index = last.indexOf(currunt);
+        if (index == -1)
+            return null;
+        if (index - 1 < 0)
+            return null;
+        return last.get(index);
+    }
+
+    protected RamStatistic getPreviousStatistic(RamStatistic currunt, int time, TimeUnit untit) {
+        int index = last.indexOf(currunt);
+        if (index == -1)
+            return null;
+        index = index - 1;
+        while (index > 0) {
+            if (last.get(index).timestamp < currunt.timestamp - untit.toMillis(time))
+                return last.get(index);
+            index--;
+        }
+        return null;
+    }
+
+    public void stop() {
+        if (task != null)
+            task.cancel();
+        task = null;
+    }
+
+    private void logCurruntRam() {
+        last.add(new RamStatistic(this, System.currentTimeMillis(), runtime.totalMemory() - runtime.freeMemory(), runtime.totalMemory(), runtime.maxMemory()));
+        recalculate();
+    }
+
+    private void recalculate() {
+        while (last.size() > 60 * 60 * 5) { //Log for 5 Houers
+            last.pollFirst();
+        }
+    }
+
+    public RamStatistic getLastState() {
+        return last.getLast();
+    }
+
+    public TerminalGraph createGrath(int seconds, int divisor) {
+        TerminalGraph base = new TerminalGraph();
+
+        Graph graphUsedMemory = new Graph();
+        graphUsedMemory.setReturnZeroByNoData(true);
+        graphUsedMemory.setCharacter(new ColoredChar('#'));
+        graphUsedMemory.getCharacter().setColor(ChatColor.GREEN);
+
+        Graph graphAllocatedMemory = new Graph();
+        graphAllocatedMemory.setReturnZeroByNoData(true);
+        graphAllocatedMemory.setCharacter(new ColoredChar('+'));
+        graphAllocatedMemory.getCharacter().setColor(ChatColor.GOLD);
+
+        int max = 0;
+
+        for (RamStatistic stats : this.last) {
+            if (stats.getTimestamp() > System.currentTimeMillis() - seconds * 1000) {
+                graphUsedMemory.addPoint(new Point((int) ((System.currentTimeMillis() - stats.getTimestamp()) / 1000), (int) stats.getUsedMemory() / divisor));
+                if (stats.getUsedMemory() / divisor > max)
+                    max = (int) stats.getUsedMemory() / divisor;
+
+                graphAllocatedMemory.addPoint(new Point((int) ((System.currentTimeMillis() - stats.getTimestamp()) / 1000), (int) stats.getReservedMemory() / divisor));
+                if (stats.getReservedMemory() / divisor > max)
+                    max = (int) stats.getReservedMemory() / divisor;
+            }
+        }
+
+        base.addGraph(graphAllocatedMemory);
+        base.addGraph(graphUsedMemory);
+
+        base.setStartX(seconds);
+        base.setEndX(0);
+        base.setStepX(10);
+        base.setStartY(0);
+        base.setEndY((int) (max + (max * 0.1)));
+        return base;
+    }
+
+    @AllArgsConstructor
+    public static class RamStatistic {
+        private RamStatistics handle;
+        @Getter
+        private long timestamp;
+        @Getter
+        private long usedMemory;
+        @Getter
+        private long reservedMemory;
+        @Getter
+        private long maxMemory;
+
+        public RamStatistic getPreviousStatistic(int time, TimeUnit untit) {
+            return handle.getPreviousStatistic(this, time, untit);
+        }
+    }
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/RamStatisticsPainter.java b/src/main/java/dev/wolveringer/BungeeUtil/RamStatisticsPainter.java
index ba78b0d..cc819c4 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/RamStatisticsPainter.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/RamStatisticsPainter.java
@@ -1,95 +1,97 @@
 package dev.wolveringer.BungeeUtil;
 
+import jline.TerminalFactory;
+
+import net.md_5.bungee.BungeeCord;
+import net.md_5.bungee.api.ChatColor;
+
+import org.fusesource.jansi.AnsiConsole;
+
 import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.TimeUnit;
 
-import org.fusesource.jansi.AnsiConsole;
-
 import dev.wolveringer.BungeeUtil.RamStatistics.RamStatistic;
 import dev.wolveringer.BungeeUtil.configuration.Configuration;
 import dev.wolveringer.chat.ChatColor.AnsiColorFormater;
 import dev.wolveringer.chat.ChatColor.ChatColorUtils;
 import dev.wolveringer.terminal.TerminalListener;
 import dev.wolveringer.terminal.TerminalListener.Listener;
-import jline.TerminalFactory;
-import net.md_5.bungee.BungeeCord;
-import net.md_5.bungee.api.ChatColor;
 
 public class RamStatisticsPainter implements Runnable, Listener {
-	@Override
-	public void run() {
-		while (Configuration.ramStatistics()) {
-			try {
-				Thread.sleep(100);
-			} catch (InterruptedException e) {
-			}
-			if (!BungeeUtil.getInstance().isActive())
-				return;
-			if (BungeeUtil.getInstance().ramStatistiks.getLastState() == null)
-				continue;
-			paint();
-		}
-	}
-	
-	private void paint(){
-		int mb = 1024 * 1024;
+    @Override
+    public void run() {
+        while (Configuration.ramStatistics()) {
+            try {
+                Thread.sleep(100);
+            } catch (InterruptedException e) {
+            }
+            if (!BungeeUtil.getInstance().isActive())
+                return;
+            if (BungeeUtil.getInstance().ramStatistiks.getLastState() == null)
+                continue;
+            paint();
+        }
+    }
+
+    private void paint() {
+        int mb = 1024 * 1024;
 
-		RamStatistic state = BungeeUtil.getInstance().ramStatistiks.getLastState();
-		String var1 = (state.getUsedMemory()) / mb + "";
-		String var2 = (state.getReservedMemory() - state.getUsedMemory()) / mb + "";
-		String var3 = state.getReservedMemory() / mb + "";
-		String var4 = state.getMaxMemory() / mb + "";
+        RamStatistic state = BungeeUtil.getInstance().ramStatistiks.getLastState();
+        String var1 = (state.getUsedMemory()) / mb + "";
+        String var2 = (state.getReservedMemory() - state.getUsedMemory()) / mb + "";
+        String var3 = state.getReservedMemory() / mb + "";
+        String var4 = state.getMaxMemory() / mb + "";
 
-		int var5 = 5;
-		var1 = format(var1, var5);
-		var2 = format(var2, var5);
-		var3 = format(var3, var5);
-		var4 = format(var4, var5);
+        int var5 = 5;
+        var1 = format(var1, var5);
+        var2 = format(var2, var5);
+        var3 = format(var3, var5);
+        var4 = format(var4, var5);
 
-		int diff = 0;
-		if (state.getPreviousStatistic(10, TimeUnit.SECONDS) != null)
-			diff = (int) (((int) (state.getUsedMemory() / mb)) - ((int) (state.getPreviousStatistic(10, TimeUnit.SECONDS).getUsedMemory() / mb)));
-		String diffSpace = "";
-		for (int i = 0; i < ("(*" + Math.abs(diff) + ")").length(); i++)
-			diffSpace += " ";
-		List<String> lines = new ArrayList<>();
-		lines.add(ChatColorUtils.COLOR_CHAR + "7#####" + diffSpace.substring(0, diffSpace.length() / 2).replaceAll(" ", "#") + " " + ChatColorUtils.COLOR_CHAR + "6Heap utilization statistics [MB] " + ChatColorUtils.COLOR_CHAR + "7#####" + diffSpace.substring(0, diffSpace.length() / 2).replaceAll(" ", "#") + (diffSpace.length() % 2 != 0 ? "#" : ""));
-		lines.add(ChatColorUtils.COLOR_CHAR + "7#     " + ChatColorUtils.COLOR_CHAR + "aReserved Used Memory:      " + ChatColorUtils.COLOR_CHAR + "e" + var1 + "M " + ChatColorUtils.COLOR_CHAR + "7(" + (diff > 0 ? ChatColorUtils.COLOR_CHAR + "a+" : diff < 0 ? ChatColorUtils.COLOR_CHAR + "c-" : ChatColorUtils.COLOR_CHAR + "6") + Math.abs(diff) + ChatColorUtils.COLOR_CHAR + "7)   " + ChatColorUtils.COLOR_CHAR + "7#");
-		lines.add(ChatColorUtils.COLOR_CHAR + "7#     " + ChatColorUtils.COLOR_CHAR + "aReserved Free Memory:      " + ChatColorUtils.COLOR_CHAR + "e" + var2 + "M    " + diffSpace + ChatColorUtils.COLOR_CHAR + "7#");
-		lines.add(ChatColorUtils.COLOR_CHAR + "7#     " + ChatColorUtils.COLOR_CHAR + "aReserved Memory:           " + ChatColorUtils.COLOR_CHAR + "e" + var3 + "M    " + diffSpace + ChatColorUtils.COLOR_CHAR + "7#");
-		lines.add(ChatColorUtils.COLOR_CHAR + "7#     " + ChatColorUtils.COLOR_CHAR + "a-----------------------------" + format("", var5).replaceAll(" ", "-") + "   " + diffSpace + ChatColorUtils.COLOR_CHAR + "7#");
-		lines.add(ChatColorUtils.COLOR_CHAR + "7#     " + ChatColorUtils.COLOR_CHAR + "aAllowed Reservable Memory: " + ChatColorUtils.COLOR_CHAR + "e" + var4 + "M    " + diffSpace + ChatColorUtils.COLOR_CHAR + "7#");
-		lines.add(ChatColorUtils.COLOR_CHAR + "7############################################" + diffSpace.replaceAll(" ", "#"));
-		int h = 1;
-		int w = 0;
-		for (String m : lines)
-			if (ChatColor.stripColor(m).length() > w)
-				w = ChatColor.stripColor(m).length();
-		w = TerminalFactory.get().getWidth() - w + 1;
-		for (int i = 0; i < lines.size(); i++, h++) {
-			AnsiConsole.out.print("\033[" + h + ";" + w + "H" + AnsiColorFormater.getFormater().format(lines.get(i)));
-		}
-		int cw = 2 + BungeeCord.getInstance().getConsoleReader().getCursorBuffer().cursor; //2 = Promt = ' >'
-		AnsiConsole.out.print("\033[" + TerminalFactory.get().getHeight() + ";" + cw + "H");
-		AnsiConsole.out.flush();
-	}
+        int diff = 0;
+        if (state.getPreviousStatistic(10, TimeUnit.SECONDS) != null)
+            diff = (int) (((int) (state.getUsedMemory() / mb)) - ((int) (state.getPreviousStatistic(10, TimeUnit.SECONDS).getUsedMemory() / mb)));
+        String diffSpace = "";
+        for (int i = 0; i < ("(*" + Math.abs(diff) + ")").length(); i++)
+            diffSpace += " ";
+        List<String> lines = new ArrayList<>();
+        lines.add(ChatColorUtils.COLOR_CHAR + "7#####" + diffSpace.substring(0, diffSpace.length() / 2).replaceAll(" ", "#") + " " + ChatColorUtils.COLOR_CHAR + "6Heap utilization statistics [MB] " + ChatColorUtils.COLOR_CHAR + "7#####" + diffSpace.substring(0, diffSpace.length() / 2).replaceAll(" ", "#") + (diffSpace.length() % 2 != 0 ? "#" : ""));
+        lines.add(ChatColorUtils.COLOR_CHAR + "7#     " + ChatColorUtils.COLOR_CHAR + "aReserved Used Memory:      " + ChatColorUtils.COLOR_CHAR + "e" + var1 + "M " + ChatColorUtils.COLOR_CHAR + "7(" + (diff > 0 ? ChatColorUtils.COLOR_CHAR + "a+" : diff < 0 ? ChatColorUtils.COLOR_CHAR + "c-" : ChatColorUtils.COLOR_CHAR + "6") + Math.abs(diff) + ChatColorUtils.COLOR_CHAR + "7)   " + ChatColorUtils.COLOR_CHAR + "7#");
+        lines.add(ChatColorUtils.COLOR_CHAR + "7#     " + ChatColorUtils.COLOR_CHAR + "aReserved Free Memory:      " + ChatColorUtils.COLOR_CHAR + "e" + var2 + "M    " + diffSpace + ChatColorUtils.COLOR_CHAR + "7#");
+        lines.add(ChatColorUtils.COLOR_CHAR + "7#     " + ChatColorUtils.COLOR_CHAR + "aReserved Memory:           " + ChatColorUtils.COLOR_CHAR + "e" + var3 + "M    " + diffSpace + ChatColorUtils.COLOR_CHAR + "7#");
+        lines.add(ChatColorUtils.COLOR_CHAR + "7#     " + ChatColorUtils.COLOR_CHAR + "a-----------------------------" + format("", var5).replaceAll(" ", "-") + "   " + diffSpace + ChatColorUtils.COLOR_CHAR + "7#");
+        lines.add(ChatColorUtils.COLOR_CHAR + "7#     " + ChatColorUtils.COLOR_CHAR + "aAllowed Reservable Memory: " + ChatColorUtils.COLOR_CHAR + "e" + var4 + "M    " + diffSpace + ChatColorUtils.COLOR_CHAR + "7#");
+        lines.add(ChatColorUtils.COLOR_CHAR + "7############################################" + diffSpace.replaceAll(" ", "#"));
+        int h = 1;
+        int w = 0;
+        for (String m : lines)
+            if (ChatColor.stripColor(m).length() > w)
+                w = ChatColor.stripColor(m).length();
+        w = TerminalFactory.get().getWidth() - w + 1;
+        for (int i = 0; i < lines.size(); i++, h++) {
+            AnsiConsole.out.print("\033[" + h + ";" + w + "H" + AnsiColorFormater.getFormater().format(lines.get(i)));
+        }
+        int cw = 2 + BungeeCord.getInstance().getConsoleReader().getCursorBuffer().cursor; //2 = Promt = ' >'
+        AnsiConsole.out.print("\033[" + TerminalFactory.get().getHeight() + ";" + cw + "H");
+        AnsiConsole.out.flush();
+    }
 
-	private String format(String in, int space) {
-		while (in.length() < space) {
-			in = in + " ";
-		}
-		return in;
-	}
+    private String format(String in, int space) {
+        while (in.length() < space) {
+            in = in + " ";
+        }
+        return in;
+    }
 
-	@Override
-	public void onResize(int oldWidth, int oldHeight, int newWidth, int newHeight) {
-		TerminalListener.getInstance().repaintTerminal();
-		paint();
-	}
+    @Override
+    public void onResize(int oldWidth, int oldHeight, int newWidth, int newHeight) {
+        TerminalListener.getInstance().repaintTerminal();
+        paint();
+    }
 
-	@Override
-	public void onLinesPrinted() {
-		paint();
-	}
+    @Override
+    public void onLinesPrinted() {
+        paint();
+    }
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/bukkit/BukkitMain.java b/src/main/java/dev/wolveringer/BungeeUtil/bukkit/BukkitMain.java
index 8d985b5..16b7a18 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/bukkit/BukkitMain.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/bukkit/BukkitMain.java
@@ -12,6 +12,6 @@ public class BukkitMain extends JavaPlugin{
 
 }
 */
-public class BukkitMain  {
-	
+public class BukkitMain {
+
 }
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/configuration/Configuration.java b/src/main/java/dev/wolveringer/BungeeUtil/configuration/Configuration.java
index e402d44..23ed404 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/configuration/Configuration.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/configuration/Configuration.java
@@ -2,109 +2,115 @@ package dev.wolveringer.BungeeUtil.configuration;
 
 import java.io.File;
 import java.io.IOException;
-import java.util.ArrayList;
 import java.util.List;
 
 import dev.wolveringer.BungeeUtil.AsyncCatcher.AsyncCatcherMode;
 import dev.wolveringer.BungeeUtil.BungeeUtil;
 import dev.wolveringer.BungeeUtil.HandleErrorAction;
-import dev.wolveringer.BungeeUtil.Main;
 import dev.wolveringer.configuration.file.YamlConfiguration;
 import dev.wolveringer.strings.Messages;
-import net.md_5.bungee.BungeeCord;
 
 public class Configuration {
-	private static YamlConfiguration conf;
-	private static List<String> versionsFuture;
-	
-	public static YamlConfiguration getConfig() {
-		return conf;
-	}
-	
-	@SuppressWarnings("deprecation")
-	public static void init(){
-		conf = YamlConfiguration.loadConfiguration(new File(BungeeUtil.getPluginInstance().getDataFolder().getParentFile().getAbsolutePath()+"/BungeeUtil/"+Messages.getString("configuration.name")));
-		conf.setDefaults(YamlConfiguration.loadConfiguration(Configuration.class.getResourceAsStream("/"+Messages.getString("configuration.name"))));
-		conf.options().copyHeader(true);
-		conf.options().copyDefaults(true);
-		try{
-			conf.save(new File(BungeeUtil.getPluginInstance().getDataFolder().getParentFile().getAbsolutePath()+"/BungeeUtil/"+Messages.getString("configuration.name")));
-		}catch (IOException ex){
-			ex.printStackTrace();
-		}
-	}
-	
-	public static String getByteBuffType() {
-		return conf.getString("byteBuffType");
-	}
-	
-	public static boolean ramStatistics() {
-		return conf.getBoolean("debug.ram-statistics");
-	}
-	
-	public static boolean isTerminalColored(){
-		return conf.getBoolean("terminal.colored");
-	}
-	
-	public static boolean isTimingsActive(){
-		return conf.getBoolean(Messages.getString("configuration.timings"));
-	}
-	
-	public static int getLoadingBufferSize(){
-		return conf.getInt("loading.inject.buffer-size");
-	}
-
-	public static boolean isFastBoot(){
-		return conf.getBoolean("loading.fastboot");
-	}
-	
-	public static void setTimingsActive(boolean enabled) {
-		conf.set(Messages.getString("configuration.timings"), enabled);
-		try{
-			conf.save(new File(BungeeUtil.getPluginInstance().getDataFolder().getParentFile().getAbsolutePath()+"/BungeeUtil/"+Messages.getString("configuration.name")));
-		}catch (IOException ex){
-			ex.printStackTrace();
-		}
-	}
-	public static boolean isUpdaterActive(){
-		return conf.getBoolean(Messages.getString("configuration.updater"));
-	}
-	public static String getLastVersion(){
-		return conf.getString("lastVersion"); 
-	}
-	public static void setLastVersion(String oldVerstion){
-		if(oldVerstion == null){
-			conf.set("lastVersion", null);
-		}
-		else
-			conf.set("lastVersion", oldVerstion);
-		try {
-			conf.save(new File(BungeeUtil.getPluginInstance().getDataFolder().getParentFile().getAbsolutePath()+"/BungeeUtil/"+Messages.getString("configuration.name")));
-		} catch (IOException e) {
-		}
-	}
-	public static AsyncCatcherMode getAsyncMode(){
-		if(conf.getBoolean("async-catcher.enabled"))
-			return AsyncCatcherMode.valueOf(conf.getString("async-catcher.mode"));
-		else
-			return AsyncCatcherMode.DISABLED;
-	}
-	public static boolean isGCEnabled(){
-		return conf.getBoolean("system.gc.enabled");
-	}
-	public static boolean isDebugEnabled(){
-		return conf.getBoolean("debug.messages");
-	}
-	public static boolean isSyncInventoryClickActive(){
-		return conf.getBoolean("inventory.synchandle");
-	}
-	public static boolean isScoreboardhandleEnabled(){
-		return conf.getBoolean("utils.scoreboard");
-	}
-	public static boolean isBossBarhandleEnabled(){
-		return conf.getBoolean("utils.bossbar");
-	}
-	public static HandleErrorAction getHandleExceptionAction(){
-		return HandleErrorAction.valueOf(conf.getString("network.exception"));
-	}
+    private static YamlConfiguration conf;
+    private static List<String> versionsFuture;
+
+    public static YamlConfiguration getConfig() {
+        return conf;
+    }
+
+    @SuppressWarnings("deprecation")
+    public static void init() {
+        conf = YamlConfiguration.loadConfiguration(new File(BungeeUtil.getPluginInstance().getDataFolder().getParentFile().getAbsolutePath() + "/BungeeUtil/" + Messages.getString("configuration.name")));
+        conf.setDefaults(YamlConfiguration.loadConfiguration(Configuration.class.getResourceAsStream("/" + Messages.getString("configuration.name"))));
+        conf.options().copyHeader(true);
+        conf.options().copyDefaults(true);
+        try {
+            conf.save(new File(BungeeUtil.getPluginInstance().getDataFolder().getParentFile().getAbsolutePath() + "/BungeeUtil/" + Messages.getString("configuration.name")));
+        } catch (IOException ex) {
+            ex.printStackTrace();
+        }
+    }
+
+    public static String getByteBuffType() {
+        return conf.getString("byteBuffType");
+    }
+
+    public static boolean ramStatistics() {
+        return conf.getBoolean("debug.ram-statistics");
+    }
+
+    public static boolean isTerminalColored() {
+        return conf.getBoolean("terminal.colored");
+    }
+
+    public static boolean isTimingsActive() {
+        return conf.getBoolean(Messages.getString("configuration.timings"));
+    }
+
+    public static void setTimingsActive(boolean enabled) {
+        conf.set(Messages.getString("configuration.timings"), enabled);
+        try {
+            conf.save(new File(BungeeUtil.getPluginInstance().getDataFolder().getParentFile().getAbsolutePath() + "/BungeeUtil/" + Messages.getString("configuration.name")));
+        } catch (IOException ex) {
+            ex.printStackTrace();
+        }
+    }
+
+    public static int getLoadingBufferSize() {
+        return conf.getInt("loading.inject.buffer-size");
+    }
+
+    public static boolean isFastBoot() {
+        return conf.getBoolean("loading.fastboot");
+    }
+
+    public static boolean isUpdaterActive() {
+        return conf.getBoolean(Messages.getString("configuration.updater"));
+    }
+
+    public static String getLastVersion() {
+        return conf.getString("lastVersion");
+    }
+
+    public static void setLastVersion(String oldVerstion) {
+        if (oldVerstion == null) {
+            conf.set("lastVersion", null);
+        } else
+            conf.set("lastVersion", oldVerstion);
+        try {
+            conf.save(new File(BungeeUtil.getPluginInstance().getDataFolder().getParentFile().getAbsolutePath() + "/BungeeUtil/" + Messages.getString("configuration.name")));
+        } catch (IOException e) {
+        }
+    }
+
+    public static AsyncCatcherMode getAsyncMode() {
+        if (conf.getBoolean("async-catcher.enabled"))
+            return AsyncCatcherMode.valueOf(conf.getString("async-catcher.mode"));
+        else
+            return AsyncCatcherMode.DISABLED;
+    }
+
+    public static boolean isGCEnabled() {
+        return conf.getBoolean("system.gc.enabled");
+    }
+
+    public static boolean isDebugEnabled() {
+        return conf.getBoolean("debug.messages");
+    }
+
+    public static boolean isSyncInventoryClickActive() {
+        return conf.getBoolean("inventory.synchandle");
+    }
+
+    public static boolean isScoreboardhandleEnabled() {
+        return conf.getBoolean("utils.scoreboard");
+    }
+
+    public static boolean isBossBarhandleEnabled() {
+        return conf.getBoolean("utils.bossbar");
+    }
+
+    public static HandleErrorAction getHandleExceptionAction() {
+        return HandleErrorAction.valueOf(conf.getString("network.exception"));
+    }
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/exception/ExceptionUtils.java b/src/main/java/dev/wolveringer/BungeeUtil/exception/ExceptionUtils.java
index 3939e87..fc9ba7d 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/exception/ExceptionUtils.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/exception/ExceptionUtils.java
@@ -4,118 +4,122 @@ import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
 
-import com.mysql.jdbc.Util;
-
 import dev.wolveringer.util.UtilReflection;
 
 public class ExceptionUtils {
-	private static final String class_name;
-
-	static{
-		class_name = ExceptionUtils.class.getName();
-	}
-
-	public static StackTraceElement[] replaceStackTraceElement(StackTraceElement[] in, StackTraceElement old_stack, StackTraceElement new_stack) {
-		List<StackTraceElement> arraylist_new_stack = new ArrayList<StackTraceElement>();
-		for(StackTraceElement e : in){
-			if(e.getClassName() == old_stack.getClassName())
-				if(e.getMethodName() == old_stack.getMethodName())
-					if(e.getFileName() == old_stack.getFileName())
-						if(new_stack != null)
-							arraylist_new_stack.add(new_stack);
-						else
-							continue;
-			arraylist_new_stack.add(e);
-		}
-		return arraylist_new_stack.toArray(new StackTraceElement[arraylist_new_stack.size()]);
-	}
-
-	public static StackTraceElement[] replaceCurruntStackTraceElement(StackTraceElement[] in) {
-		return replaceStackTraceElement(in, getCurruntMethodeStackTraceElement(), null);
-	}
-
-	public static StackTraceElement getCurruntMethodeStackTraceElement() {
-		StackTraceElement[] _currunt = Thread.currentThread().getStackTrace();
-		for(StackTraceElement e : _currunt)
-			if(e != null && !e.getClassName().equals(class_name) && !e.getMethodName().equalsIgnoreCase("getStackTrace"))
-				return e;
-		return null;
-	}
-
-	public static StackTraceElement getCallerStackTraceElement() {
-		StackTraceElement[] _currunt = Thread.currentThread().getStackTrace();
-		for(int i = 0;i<_currunt.length;i++){
-			StackTraceElement e = _currunt[i];
-			if(e != null && !e.getClassName().equals(class_name) && !e.getMethodName().equalsIgnoreCase("getStackTrace")){
-				if(i+1<_currunt.length){
-					return null;
-				}
-				else
-					return _currunt[i+1];
-			}
-		}
-		return null;
-	}
-	
-	public static Throwable replaceCurruntStackTraceElement(Throwable in) {
-		return replaceStackTraceElement(in, getCurruntMethodeStackTraceElement(), null);
-	}
-
-	public static Throwable replaceStackTraceElement(Throwable in, StackTraceElement old_stack, StackTraceElement new_stack) {
-		List<StackTraceElement> arraylist_new_stack = new ArrayList<StackTraceElement>();
-		for(StackTraceElement e : in.getStackTrace()){
-			if(e.getClassName() == old_stack.getClassName())
-				if(e.getMethodName() == old_stack.getMethodName())
-					if(e.getFileName() == old_stack.getFileName())
-						if(new_stack != null)
-							arraylist_new_stack.add(new_stack);
-						else
-							continue;
-			arraylist_new_stack.add(e);
-		}
-		in.setStackTrace(arraylist_new_stack.toArray(new StackTraceElement[arraylist_new_stack.size()]));
-		return in;
-	}
-	
-	public static int getIndexOf(StackTraceElement[] in,StackTraceElement e){
-		for(int i = 0;i < in.length;i++){
-			StackTraceElement stackTraceElement = in[i];
-			if(e.getClassName() == stackTraceElement.getClassName())
-				if(e.getMethodName() == stackTraceElement.getMethodName())
-					if(e.getFileName() == stackTraceElement.getFileName())
-						return i;
-		}
-		return -1;
-	}
-	public static int getIndexOf(Throwable ex,StackTraceElement e){
-		return getIndexOf(ex.getStackTrace(), e);
-	}
-	public static int getCurrentMethodeIndex(StackTraceElement[] in){
-		return getIndexOf(in, getCurruntMethodeStackTraceElement());
-	}
-	public static int getCurrentMethodeIndex(Throwable ex){
-		return getIndexOf(ex, getCurruntMethodeStackTraceElement());
-	}
-	public static StackTraceElement[] deleteDownward(StackTraceElement[] ex,int index){
-		return Arrays.copyOf(ex, index);
-	}
-	public static StackTraceElement[] deleteUpward(StackTraceElement[] ex,int index){
-		return Arrays.copyOfRange(ex, index, ex.length);
-	}
-	public static Throwable setExceptionMessage(Throwable t,String message){
-		try{
-			UtilReflection.getField(Throwable.class, "detailMessage").set(t, message);
-		}catch(Exception e){
-			e.printStackTrace();
-		}
-		return t;
-	}
-	public static RuntimeException createRuntimeException(Throwable t){
-		if(t instanceof RuntimeException)
-			return (RuntimeException) t;
-		RuntimeException ex = new RuntimeException(t.getMessage());
-		ex.setStackTrace(t.getStackTrace());
-		UtilReflection.setField(RuntimeException.class, "cause", t.getCause() == null ? ex : t.getCause());
-		return ex;
-	}
+    private static final String class_name;
+
+    static {
+        class_name = ExceptionUtils.class.getName();
+    }
+
+    public static StackTraceElement[] replaceStackTraceElement(StackTraceElement[] in, StackTraceElement old_stack, StackTraceElement new_stack) {
+        List<StackTraceElement> arraylist_new_stack = new ArrayList<StackTraceElement>();
+        for (StackTraceElement e : in) {
+            if (e.getClassName() == old_stack.getClassName())
+                if (e.getMethodName() == old_stack.getMethodName())
+                    if (e.getFileName() == old_stack.getFileName())
+                        if (new_stack != null)
+                            arraylist_new_stack.add(new_stack);
+                        else
+                            continue;
+            arraylist_new_stack.add(e);
+        }
+        return arraylist_new_stack.toArray(new StackTraceElement[arraylist_new_stack.size()]);
+    }
+
+    public static StackTraceElement[] replaceCurruntStackTraceElement(StackTraceElement[] in) {
+        return replaceStackTraceElement(in, getCurruntMethodeStackTraceElement(), null);
+    }
+
+    public static StackTraceElement getCurruntMethodeStackTraceElement() {
+        StackTraceElement[] _currunt = Thread.currentThread().getStackTrace();
+        for (StackTraceElement e : _currunt)
+            if (e != null && !e.getClassName().equals(class_name) && !e.getMethodName().equalsIgnoreCase("getStackTrace"))
+                return e;
+        return null;
+    }
+
+    public static StackTraceElement getCallerStackTraceElement() {
+        StackTraceElement[] _currunt = Thread.currentThread().getStackTrace();
+        for (int i = 0; i < _currunt.length; i++) {
+            StackTraceElement e = _currunt[i];
+            if (e != null && !e.getClassName().equals(class_name) && !e.getMethodName().equalsIgnoreCase("getStackTrace")) {
+                if (i + 1 < _currunt.length) {
+                    return null;
+                } else
+                    return _currunt[i + 1];
+            }
+        }
+        return null;
+    }
+
+    public static Throwable replaceCurruntStackTraceElement(Throwable in) {
+        return replaceStackTraceElement(in, getCurruntMethodeStackTraceElement(), null);
+    }
+
+    public static Throwable replaceStackTraceElement(Throwable in, StackTraceElement old_stack, StackTraceElement new_stack) {
+        List<StackTraceElement> arraylist_new_stack = new ArrayList<StackTraceElement>();
+        for (StackTraceElement e : in.getStackTrace()) {
+            if (e.getClassName() == old_stack.getClassName())
+                if (e.getMethodName() == old_stack.getMethodName())
+                    if (e.getFileName() == old_stack.getFileName())
+                        if (new_stack != null)
+                            arraylist_new_stack.add(new_stack);
+                        else
+                            continue;
+            arraylist_new_stack.add(e);
+        }
+        in.setStackTrace(arraylist_new_stack.toArray(new StackTraceElement[arraylist_new_stack.size()]));
+        return in;
+    }
+
+    public static int getIndexOf(StackTraceElement[] in, StackTraceElement e) {
+        for (int i = 0; i < in.length; i++) {
+            StackTraceElement stackTraceElement = in[i];
+            if (e.getClassName() == stackTraceElement.getClassName())
+                if (e.getMethodName() == stackTraceElement.getMethodName())
+                    if (e.getFileName() == stackTraceElement.getFileName())
+                        return i;
+        }
+        return -1;
+    }
+
+    public static int getIndexOf(Throwable ex, StackTraceElement e) {
+        return getIndexOf(ex.getStackTrace(), e);
+    }
+
+    public static int getCurrentMethodeIndex(StackTraceElement[] in) {
+        return getIndexOf(in, getCurruntMethodeStackTraceElement());
+    }
+
+    public static int getCurrentMethodeIndex(Throwable ex) {
+        return getIndexOf(ex, getCurruntMethodeStackTraceElement());
+    }
+
+    public static StackTraceElement[] deleteDownward(StackTraceElement[] ex, int index) {
+        return Arrays.copyOf(ex, index);
+    }
+
+    public static StackTraceElement[] deleteUpward(StackTraceElement[] ex, int index) {
+        return Arrays.copyOfRange(ex, index, ex.length);
+    }
+
+    public static Throwable setExceptionMessage(Throwable t, String message) {
+        try {
+            UtilReflection.getField(Throwable.class, "detailMessage").set(t, message);
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+        return t;
+    }
+
+    public static RuntimeException createRuntimeException(Throwable t) {
+        if (t instanceof RuntimeException)
+            return (RuntimeException) t;
+        RuntimeException ex = new RuntimeException(t.getMessage());
+        ex.setStackTrace(t.getStackTrace());
+        UtilReflection.setField(RuntimeException.class, "cause", t.getCause() == null ? ex : t.getCause());
+        return ex;
+    }
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/GameProfile.java b/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/GameProfile.java
index 0c93751..9a49784 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/GameProfile.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/GameProfile.java
@@ -3,49 +3,52 @@ package dev.wolveringer.BungeeUtil.gameprofile;
 import java.util.UUID;
 
 public class GameProfile {
-	private UUID id;
-	private String name;
-	private PropertyMap properties = new PropertyMap();
-	private boolean legacy;
-
-	public GameProfile(UUID id, String name) {
-		if((id == null) && ("".equalsIgnoreCase(name)||name==null))
-			throw new IllegalArgumentException("Name and ID cannot both be blank");
-		this.id = id;
-		this.name = name;
-	}
-
-	public UUID getId() {
-		return this.id;
-	}
-
-	public String getName() {
-		return this.name;
-	}
-
-	public PropertyMap getProperties() {
-		return this.properties;
-	}
-
-	public boolean isComplete() {
-		return (this.id != null) && getName().isEmpty();
-	}
-
-	@Override
-	public String toString() {
-		return "GameProfile [id=" + id + ", name=" + name + ", properties=" + properties + ", legacy=" + legacy + "]";
-	}
-
-	public boolean isLegacy() {
-		return this.legacy;
-	}
-	public void setName(String name) {
-		this.name = name;
-	}
-	public void setId(UUID id) {
-		this.id = id;
-	}
-	public void setProperties(PropertyMap properties) {
-		this.properties = properties;
-	}
+    private UUID id;
+    private String name;
+    private PropertyMap properties = new PropertyMap();
+    private boolean legacy;
+
+    public GameProfile(UUID id, String name) {
+        if ((id == null) && ("".equalsIgnoreCase(name) || name == null))
+            throw new IllegalArgumentException("Name and ID cannot both be blank");
+        this.id = id;
+        this.name = name;
+    }
+
+    public UUID getId() {
+        return this.id;
+    }
+
+    public void setId(UUID id) {
+        this.id = id;
+    }
+
+    public String getName() {
+        return this.name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+
+    public PropertyMap getProperties() {
+        return this.properties;
+    }
+
+    public void setProperties(PropertyMap properties) {
+        this.properties = properties;
+    }
+
+    public boolean isComplete() {
+        return (this.id != null) && getName().isEmpty();
+    }
+
+    @Override
+    public String toString() {
+        return "GameProfile [id=" + id + ", name=" + name + ", properties=" + properties + ", legacy=" + legacy + "]";
+    }
+
+    public boolean isLegacy() {
+        return this.legacy;
+    }
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/GameProfileSerializer.java b/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/GameProfileSerializer.java
index 8f14f9f..dd2a037 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/GameProfileSerializer.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/GameProfileSerializer.java
@@ -8,90 +8,90 @@ import dev.wolveringer.nbt.NBTTagCompound;
 import dev.wolveringer.nbt.NBTTagList;
 
 public class GameProfileSerializer {
-	@SuppressWarnings("rawtypes")
-	public static GameProfile deserialize(NBTTagCompound nbttagcompound) {
-		if(nbttagcompound == null)
-			return null;
-		String s = null;
-		String s1 = null;
-
-		if(nbttagcompound.hasKeyOfType("Name", 8)){
-			s = nbttagcompound.getString("Name");
-		}
-
-		if(nbttagcompound.hasKeyOfType("Id", 8)){
-			s1 = nbttagcompound.getString("Id");
-		}
-
-		UUID uuid;
-
-		try{
-			uuid = UUID.fromString(s1);
-		}catch (Throwable throwable){
-			uuid = null;
-		}
-		if(uuid == null && s==null)
-			return null;
-		GameProfile gameprofile = new GameProfile(uuid, s);
-
-		if(nbttagcompound.hasKeyOfType("Properties", 10)){
-			NBTTagCompound nbttagcompound1 = nbttagcompound.getCompound("Properties");
-			Iterator iterator = nbttagcompound1.dataKeyset().iterator();
-
-			while (iterator.hasNext()){
-				String s2 = (String) iterator.next();
-				NBTTagList nbttaglist = nbttagcompound1.getList(s2);
-
-				for(int i = 0;i < nbttaglist.size();++i){
-					NBTTagCompound nbttagcompound2 = nbttaglist.get(i);
-					String s3 = nbttagcompound2.getString("Value");
-
-					if(nbttagcompound2.hasKeyOfType("Signature", 8)){
-						gameprofile.getProperties().put(s2, new Property(s2, s3, nbttagcompound2.getString("Signature")));
-					}else{
-						gameprofile.getProperties().put(s2, new Property(s2, s3));
-					}
-				}
-			}
-		}
-
-		return gameprofile;
-	}
-
-	@SuppressWarnings("rawtypes")
-	public static NBTTagCompound serialize(NBTTagCompound nbttagcompound, GameProfile gameprofile) {
-		if(gameprofile == null)
-			return nbttagcompound;
-		if(gameprofile.getName() != null && !gameprofile.getName().isEmpty())
-			nbttagcompound.setString("Name", gameprofile.getName());
-		if(gameprofile.getId() != null)
-			nbttagcompound.setString("Id", gameprofile.getId().toString());
-
-		if(!gameprofile.getProperties().isEmpty()){
-			NBTTagCompound nbttagcompound1 = new NBTTagCompound();
-			Iterator iterator = gameprofile.getProperties().keySet().iterator();
-
-			while (iterator.hasNext()){
-				String s = (String) iterator.next();
-				NBTTagList nbttaglist = new NBTTagList();
-
-				NBTTagCompound nbttagcompound2;
-
-				for(Iterator iterator1 = gameprofile.getProperties().get(s).iterator();iterator1.hasNext();nbttaglist.add(nbttagcompound2)){
-					Property property = (Property) iterator1.next();
-
-					nbttagcompound2 = new NBTTagCompound();
-					nbttagcompound2.setString("Value", property.getValue());
-					if(property.hasSignature()){
-						nbttagcompound2.setString("Signature", property.getSignature());
-					}
-				}
-
-				nbttagcompound1.set(s, nbttaglist);
-			}
-
-			nbttagcompound.set("Properties", nbttagcompound1);
-		}
-		return nbttagcompound;
-	}
+    @SuppressWarnings("rawtypes")
+    public static GameProfile deserialize(NBTTagCompound nbttagcompound) {
+        if (nbttagcompound == null)
+            return null;
+        String s = null;
+        String s1 = null;
+
+        if (nbttagcompound.hasKeyOfType("Name", 8)) {
+            s = nbttagcompound.getString("Name");
+        }
+
+        if (nbttagcompound.hasKeyOfType("Id", 8)) {
+            s1 = nbttagcompound.getString("Id");
+        }
+
+        UUID uuid;
+
+        try {
+            uuid = UUID.fromString(s1);
+        } catch (Throwable throwable) {
+            uuid = null;
+        }
+        if (uuid == null && s == null)
+            return null;
+        GameProfile gameprofile = new GameProfile(uuid, s);
+
+        if (nbttagcompound.hasKeyOfType("Properties", 10)) {
+            NBTTagCompound nbttagcompound1 = nbttagcompound.getCompound("Properties");
+            Iterator iterator = nbttagcompound1.dataKeyset().iterator();
+
+            while (iterator.hasNext()) {
+                String s2 = (String) iterator.next();
+                NBTTagList nbttaglist = nbttagcompound1.getList(s2);
+
+                for (int i = 0; i < nbttaglist.size(); ++i) {
+                    NBTTagCompound nbttagcompound2 = nbttaglist.get(i);
+                    String s3 = nbttagcompound2.getString("Value");
+
+                    if (nbttagcompound2.hasKeyOfType("Signature", 8)) {
+                        gameprofile.getProperties().put(s2, new Property(s2, s3, nbttagcompound2.getString("Signature")));
+                    } else {
+                        gameprofile.getProperties().put(s2, new Property(s2, s3));
+                    }
+                }
+            }
+        }
+
+        return gameprofile;
+    }
+
+    @SuppressWarnings("rawtypes")
+    public static NBTTagCompound serialize(NBTTagCompound nbttagcompound, GameProfile gameprofile) {
+        if (gameprofile == null)
+            return nbttagcompound;
+        if (gameprofile.getName() != null && !gameprofile.getName().isEmpty())
+            nbttagcompound.setString("Name", gameprofile.getName());
+        if (gameprofile.getId() != null)
+            nbttagcompound.setString("Id", gameprofile.getId().toString());
+
+        if (!gameprofile.getProperties().isEmpty()) {
+            NBTTagCompound nbttagcompound1 = new NBTTagCompound();
+            Iterator iterator = gameprofile.getProperties().keySet().iterator();
+
+            while (iterator.hasNext()) {
+                String s = (String) iterator.next();
+                NBTTagList nbttaglist = new NBTTagList();
+
+                NBTTagCompound nbttagcompound2;
+
+                for (Iterator iterator1 = gameprofile.getProperties().get(s).iterator(); iterator1.hasNext(); nbttaglist.add(nbttagcompound2)) {
+                    Property property = (Property) iterator1.next();
+
+                    nbttagcompound2 = new NBTTagCompound();
+                    nbttagcompound2.setString("Value", property.getValue());
+                    if (property.hasSignature()) {
+                        nbttagcompound2.setString("Signature", property.getSignature());
+                    }
+                }
+
+                nbttagcompound1.set(s, nbttaglist);
+            }
+
+            nbttagcompound.set("Properties", nbttagcompound1);
+        }
+        return nbttagcompound;
+    }
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/PlayerInfoData.java b/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/PlayerInfoData.java
index d1874f5..55a1c0c 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/PlayerInfoData.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/PlayerInfoData.java
@@ -4,64 +4,65 @@ import dev.wolveringer.chat.ChatSerializer;
 import dev.wolveringer.chat.IChatBaseComponent;
 
 public class PlayerInfoData {
-	private int ping;
-	private int gamemode;
-	private GameProfile gameprofile;
-	private IChatBaseComponent name;
-	private String username;
-	
-	public PlayerInfoData(GameProfile gameprofile, int ping, int gamemode, IChatBaseComponent tab) {
-		this.gameprofile = gameprofile;
-		this.ping = ping;
-		this.gamemode = gamemode;
-		this.name = tab;
-		this.username = gameprofile.getName();
-	}
+    private int ping;
+    private int gamemode;
+    private GameProfile gameprofile;
+    private IChatBaseComponent name;
+    private String username;
 
-	public PlayerInfoData(GameProfile gameprofile, int ping, int gamemode2, String tab) {
-		this.gameprofile = gameprofile;
-		this.ping = ping;
-		this.gamemode = gamemode2;
-		this.username = tab;
-	}
+    public PlayerInfoData(GameProfile gameprofile, int ping, int gamemode, IChatBaseComponent tab) {
+        this.gameprofile = gameprofile;
+        this.ping = ping;
+        this.gamemode = gamemode;
+        this.name = tab;
+        this.username = gameprofile.getName();
+    }
 
-	public int getPing() {
-		return ping;
-	}
+    public PlayerInfoData(GameProfile gameprofile, int ping, int gamemode2, String tab) {
+        this.gameprofile = gameprofile;
+        this.ping = ping;
+        this.gamemode = gamemode2;
+        this.username = tab;
+    }
 
-	public int getGamemode() {
-		return gamemode;
-	}
+    public int getPing() {
+        return ping;
+    }
 
-	public GameProfile getGameprofile() {
-		return gameprofile;
-	}
+    public void setPing(int b) {
+        this.ping = b;
+    }
 
-	public IChatBaseComponent getName() {
-		return name;
-	}
-	
-	public void setPing(int b) {
-		this.ping = b;
-	}
+    public int getGamemode() {
+        return gamemode;
+    }
 
-	public void setGamemode(int gamemode) {
-		this.gamemode = gamemode;
-	}
+    public void setGamemode(int gamemode) {
+        this.gamemode = gamemode;
+    }
 
-	public void setGameprofile(GameProfile gameprofile) {
-		this.gameprofile = gameprofile;
-	}
+    public GameProfile getGameprofile() {
+        return gameprofile;
+    }
 
-	public void setName(IChatBaseComponent name) {
-		this.name = name;
-	}
+    public void setGameprofile(GameProfile gameprofile) {
+        this.gameprofile = gameprofile;
+    }
 
-	@Override
-	public String toString() {
-		return "PlayerInfoData [b=" + ping + ", gamemode=" + gamemode + ", gameprofile=" + gameprofile + ", name=" + ChatSerializer.toMessage(name) + "]";
-	}
-	public String getUsername() {
-		return username;
-	}
+    public IChatBaseComponent getName() {
+        return name;
+    }
+
+    public void setName(IChatBaseComponent name) {
+        this.name = name;
+    }
+
+    @Override
+    public String toString() {
+        return "PlayerInfoData [b=" + ping + ", gamemode=" + gamemode + ", gameprofile=" + gameprofile + ", name=" + ChatSerializer.toMessage(name) + "]";
+    }
+
+    public String getUsername() {
+        return username;
+    }
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/Property.java b/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/Property.java
index 0c5832d..84416ef 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/Property.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/Property.java
@@ -1,38 +1,38 @@
 package dev.wolveringer.BungeeUtil.gameprofile;
 
 public class Property {
-	private final String name;
-	private final String value;
-	private final String signature;
-
-	public Property(String value, String name) {
-		this(value, name, null);
-	}
-
-	public Property(String name, String value, String signature) {
-		this.name = name;
-		this.value = value;
-		this.signature = signature;
-	}
-
-	public String getName() {
-		return this.name;
-	}
-
-	public String getValue() {
-		return this.value;
-	}
-
-	public String getSignature() {
-		return this.signature;
-	}
-
-	public boolean hasSignature() {
-		return this.signature != null;
-	}
-
-	@Override
-	public String toString() {
-		return "Property@" + System.identityHashCode(this) + "[name=" + this.name + ", value=" + this.value + ", signature=" + this.signature + "]";
-	}
+    private final String name;
+    private final String value;
+    private final String signature;
+
+    public Property(String value, String name) {
+        this(value, name, null);
+    }
+
+    public Property(String name, String value, String signature) {
+        this.name = name;
+        this.value = value;
+        this.signature = signature;
+    }
+
+    public String getName() {
+        return this.name;
+    }
+
+    public String getValue() {
+        return this.value;
+    }
+
+    public String getSignature() {
+        return this.signature;
+    }
+
+    public boolean hasSignature() {
+        return this.signature != null;
+    }
+
+    @Override
+    public String toString() {
+        return "Property@" + System.identityHashCode(this) + "[name=" + this.name + ", value=" + this.value + ", signature=" + this.signature + "]";
+    }
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/PropertyMap.java b/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/PropertyMap.java
index 5dea4a2..e191da0 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/PropertyMap.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/PropertyMap.java
@@ -1,9 +1,5 @@
 package dev.wolveringer.BungeeUtil.gameprofile;
 
-import java.lang.reflect.Type;
-import java.util.Iterator;
-import java.util.Map;
-
 import com.google.common.collect.ForwardingMultimap;
 import com.google.common.collect.LinkedHashMultimap;
 import com.google.common.collect.Multimap;
@@ -16,68 +12,72 @@ import com.google.gson.JsonParseException;
 import com.google.gson.JsonSerializationContext;
 import com.google.gson.JsonSerializer;
 
+import java.lang.reflect.Type;
+import java.util.Iterator;
+import java.util.Map;
+
 public class PropertyMap extends ForwardingMultimap<String, Property> {
-	private final Multimap<String, Property> properties;
+    private final Multimap<String, Property> properties;
 
-	public PropertyMap() {
-		this.properties = LinkedHashMultimap.create();
-	}
+    public PropertyMap() {
+        this.properties = LinkedHashMultimap.create();
+    }
 
-	protected Multimap<String, Property> delegate() {
-		return this.properties;
-	}
+    protected Multimap<String, Property> delegate() {
+        return this.properties;
+    }
 
-	public static class Serializer implements JsonSerializer<PropertyMap>, JsonDeserializer<PropertyMap> {
-		@SuppressWarnings({ "rawtypes", "unchecked" })
-		public PropertyMap deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {
-			PropertyMap result = new PropertyMap();
-			Iterator i$;
-			Map.Entry<String, JsonElement> entry;
-			if((json instanceof JsonObject)){
-				JsonObject object = (JsonObject) json;
-				for(i$ = object.entrySet().iterator();i$.hasNext();){
-					entry = (Map.Entry) i$.next();
-					if((entry.getValue() instanceof JsonArray)){
-						for(JsonElement element : (JsonArray) entry.getValue()){
-							result.put(entry.getKey(), new Property((String) entry.getKey(), element.getAsString()));
-						}
-					}
-				}
-			}else if((json instanceof JsonArray)){
-				for(JsonElement element : (JsonArray) json){
-					if((element instanceof JsonObject)){
-						JsonObject object = (JsonObject) element;
-						String name = object.getAsJsonPrimitive("name").getAsString();
-						String value = object.getAsJsonPrimitive("value").getAsString();
-						if(object.has("signature")){
-							result.put(name, new Property(name, value, object.getAsJsonPrimitive("signature").getAsString()));
-						}else{
-							result.put(name, new Property(name, value));
-						}
-					}
-				}
-			}
-			return result;
-		}
+    @Override
+    public String toString() {
+        return "PropertyMap@" + System.identityHashCode(this) + "[properties=" + this.properties + "]";
+    }
 
-		public JsonElement serialize(PropertyMap src, Type typeOfSrc, JsonSerializationContext context) {
-			JsonArray result = new JsonArray();
-			for(Property property : src.values()){
-				JsonObject object = new JsonObject();
+    public static class Serializer implements JsonSerializer<PropertyMap>, JsonDeserializer<PropertyMap> {
+        @SuppressWarnings({"rawtypes", "unchecked"})
+        public PropertyMap deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {
+            PropertyMap result = new PropertyMap();
+            Iterator i$;
+            Map.Entry<String, JsonElement> entry;
+            if ((json instanceof JsonObject)) {
+                JsonObject object = (JsonObject) json;
+                for (i$ = object.entrySet().iterator(); i$.hasNext(); ) {
+                    entry = (Map.Entry) i$.next();
+                    if ((entry.getValue() instanceof JsonArray)) {
+                        for (JsonElement element : (JsonArray) entry.getValue()) {
+                            result.put(entry.getKey(), new Property((String) entry.getKey(), element.getAsString()));
+                        }
+                    }
+                }
+            } else if ((json instanceof JsonArray)) {
+                for (JsonElement element : (JsonArray) json) {
+                    if ((element instanceof JsonObject)) {
+                        JsonObject object = (JsonObject) element;
+                        String name = object.getAsJsonPrimitive("name").getAsString();
+                        String value = object.getAsJsonPrimitive("value").getAsString();
+                        if (object.has("signature")) {
+                            result.put(name, new Property(name, value, object.getAsJsonPrimitive("signature").getAsString()));
+                        } else {
+                            result.put(name, new Property(name, value));
+                        }
+                    }
+                }
+            }
+            return result;
+        }
 
-				object.addProperty("name", property.getName());
-				object.addProperty("value", property.getValue());
-				if(property.hasSignature()){
-					object.addProperty("signature", property.getSignature());
-				}
-				result.add(object);
-			}
-			return result;
-		}
-	}
+        public JsonElement serialize(PropertyMap src, Type typeOfSrc, JsonSerializationContext context) {
+            JsonArray result = new JsonArray();
+            for (Property property : src.values()) {
+                JsonObject object = new JsonObject();
 
-	@Override
-	public String toString() {
-		return "PropertyMap@" + System.identityHashCode(this) + "[properties=" + this.properties + "]";
-	}
+                object.addProperty("name", property.getName());
+                object.addProperty("value", property.getValue());
+                if (property.hasSignature()) {
+                    object.addProperty("signature", property.getSignature());
+                }
+                result.add(object);
+            }
+            return result;
+        }
+    }
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/Skin.java b/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/Skin.java
index 4d19fb4..e245e51 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/Skin.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/Skin.java
@@ -1,224 +1,222 @@
 package dev.wolveringer.BungeeUtil.gameprofile;
 
-import java.util.UUID;
-
 import org.json.JSONArray;
-import org.json.JSONML;
 import org.json.JSONObject;
 import org.yaml.snakeyaml.external.biz.base64Coder.Base64Coder;
 
+import java.util.UUID;
+
 public class Skin {
-	protected static Skin createEmptySkin() {
-		Skin s = new Skin();
-		s.name = "";
-		s.raw_value = "";
-		s.signature = "";
-		s.value = new JSONObject();
-		s.updateRaw();
-		return s;
-	}
-
-	private String name = "textures";
-	private String raw_value;
-	private String signature;
-	private boolean empty = false;
-
-	private JSONObject value;
-
-	private Skin() {
-		empty = true;
-	}
-
-	protected Skin(JSONObject raw_profile) {
-		try {
-			if (raw_profile.has("properties")) {
-				JSONArray properties = (JSONArray) raw_profile.get("properties");
-				for (int i = 0; i < properties.length(); i++) { //TODO size == 1 ?????
-					JSONObject property = (JSONObject) properties.get(i);
-					name = (String) property.get("name");
-					raw_value = (String) property.get("value");
-					signature = (String) property.get("signature");
-				}
-			}
-			if (raw_value != null)
-				value = new JSONObject(Base64Coder.decodeString(raw_value));
-			else
-				value = new JSONObject();
-			empty = false;
-		} catch (Exception e) {
-			e.printStackTrace();
-			empty = true;
-		}
-		
-	}
-
-	protected Skin(String rawValue, String signature) {
-		try {
-			if (rawValue == null || rawValue.equalsIgnoreCase("undefined") || Base64Coder.decodeString(rawValue) == null) {
-				rawValue = Base64Coder.encodeString("{}");
-			}
-		} catch (IllegalArgumentException ex) {
-			rawValue = Base64Coder.encodeString("{}");
-		}
-		this.raw_value = rawValue;
-		this.value = new JSONObject(Base64Coder.decodeString(raw_value));
-		if (!signature.equalsIgnoreCase("undefined"))
-			this.signature = signature;
-	}
-
-	public GameProfile applay(GameProfile g) {
-		if (g.getId() == null)
-			g.setId(getUUID());
-		if (g.getName() == null)
-			g.setName(getProfileName());
-		g.getProperties().clear();
-		g.getProperties().put(name, new Property(name, raw_value, isSignatureRequired() ? signature : null));
-		return g;
-	}
-
-	public String getSkinUrl() {
-		if (hasSkin())
-			return value.getJSONObject("textures").getJSONObject("SKIN").getString("url");
-		return null;
-	}
-
-	public void setSkin(String url) {
-		empty = false;
-		if (!value.has("textures"))
-			value.put("value", new JSONObject());
-		if (!value.getJSONObject("textures").has("SKIN"))
-			value.getJSONObject("textures").put("SKIN", new JSONObject());
-		value.getJSONObject("textures").getJSONObject("SKIN").put("url", url);
-		updateRaw();
-	}
-
-	public boolean hasSkin() {
-		return value.has("textures") && value.getJSONObject("textures").has("SKIN") && value.getJSONObject("textures").getJSONObject("SKIN").has("url");
-	}
-
-	public void setCape(String url) {
-		empty = false;
-		if (!value.has("textures"))
-			value.put("value", new JSONObject());
-		if (!value.getJSONObject("textures").has("CAPE"))
-			value.getJSONObject("textures").put("CAPE", new JSONObject());
-		value.getJSONObject("textures").getJSONObject("CAPE").put("url", url);
-		updateRaw();
-	}
-
-	public String getCapeUrl() {
-		if (hasCape())
-			return value.getJSONObject("textures").getJSONObject("CAPE").getString("url");
-		return null;
-	}
-
-	public boolean hasCape() {
-		return value.has("textures") && value.getJSONObject("textures").has("CAPE") && value.getJSONObject("textures").getJSONObject("CAPE").has("url");
-	}
-
-	public UUID getUUID() {
-		return UUID.fromString(value.getString("profileId").replaceFirst("([0-9a-fA-F]{8})([0-9a-fA-F]{4})([0-9a-fA-F]{4})([0-9a-fA-F]{4})([0-9a-fA-F]+)", "$1-$2-$3-$4-$5"));
-	}
-
-	public void setUUID(UUID id) {
-		empty = false;
-		value.put("profileId", id.toString().replaceAll("-", ""));
-		updateRaw();
-	}
-
-	public boolean hasUUID() {
-		return value.has("profileId");
-	}
-
-	public String getProfileName() {
-		if (!hasProfileName())
-			return "undef";
-		return value.getString("profileName");
-	}
-
-	public boolean hasProfileName() {
-		return value.has("profileName");
-	}
-
-	public void setProfileName(String name) {
-		empty = false;
-		value.put("profileName", name);
-		updateRaw();
-	}
-
-	public boolean isPublic() {
-		return value.getBoolean("isPublic");
-	}
-
-	public void setPublic(boolean b) {
-		empty = false;
-		value.put("isPublic", b);
-		updateRaw();
-	}
-
-	public boolean isEmpty() {
-		return empty;
-	}
-
-	private void updateRaw() {
-		raw_value = Base64Coder.encodeString(value.toString());
-	}
-
-	public GameProfile toGameProfile() {
-		try {
-			return applay(new GameProfile(getUUID(), getProfileName()));
-		} catch (Exception e) {
-			return null;
-		}
-	}
-
-	public void setSignatureRequired(boolean flag) {
-		empty = false;
-		value.put("signatureRequired", flag);
-		updateRaw();
-
-	}
-
-	public boolean isSignatureRequired() {
-		return value.has("signatureRequired") && value.getBoolean("signatureRequired");
-	}
-
-	public String getSignature() {
-		if (signature == null)
-			return "undefined";
-		return signature;
-	}
-
-	public void setSignature(String signature) {
-		this.signature = signature;
-		empty = false;
-	}
-
-	public void setRawData(String string) {
-		this.raw_value = string;
-		this.value = new JSONObject(Base64Coder.decodeString(raw_value));
-	}
-
-	public String getRawData() {
-		return raw_value;
-	}
-
-	public Skin clone() {
-		Skin _new = new Skin();
-		_new.empty = empty;
-		_new.name = name;
-		_new.raw_value = raw_value;
-		_new.signature = signature;
-		_new.value = value;
-		return _new;
-	}
-
-	public String getName() {
-		return name;
-	}
-
-	@Override
-	public String toString() {
-		return value.toString();
-	}
+    private String name = "textures";
+    private String raw_value;
+    private String signature;
+    private boolean empty = false;
+    private JSONObject value;
+
+    private Skin() {
+        empty = true;
+    }
+
+    protected Skin(JSONObject raw_profile) {
+        try {
+            if (raw_profile.has("properties")) {
+                JSONArray properties = (JSONArray) raw_profile.get("properties");
+                for (int i = 0; i < properties.length(); i++) { //TODO size == 1 ?????
+                    JSONObject property = (JSONObject) properties.get(i);
+                    name = (String) property.get("name");
+                    raw_value = (String) property.get("value");
+                    signature = (String) property.get("signature");
+                }
+            }
+            if (raw_value != null)
+                value = new JSONObject(Base64Coder.decodeString(raw_value));
+            else
+                value = new JSONObject();
+            empty = false;
+        } catch (Exception e) {
+            e.printStackTrace();
+            empty = true;
+        }
+
+    }
+
+    protected Skin(String rawValue, String signature) {
+        try {
+            if (rawValue == null || rawValue.equalsIgnoreCase("undefined") || Base64Coder.decodeString(rawValue) == null) {
+                rawValue = Base64Coder.encodeString("{}");
+            }
+        } catch (IllegalArgumentException ex) {
+            rawValue = Base64Coder.encodeString("{}");
+        }
+        this.raw_value = rawValue;
+        this.value = new JSONObject(Base64Coder.decodeString(raw_value));
+        if (!signature.equalsIgnoreCase("undefined"))
+            this.signature = signature;
+    }
+
+    protected static Skin createEmptySkin() {
+        Skin s = new Skin();
+        s.name = "";
+        s.raw_value = "";
+        s.signature = "";
+        s.value = new JSONObject();
+        s.updateRaw();
+        return s;
+    }
+
+    public GameProfile applay(GameProfile g) {
+        if (g.getId() == null)
+            g.setId(getUUID());
+        if (g.getName() == null)
+            g.setName(getProfileName());
+        g.getProperties().clear();
+        g.getProperties().put(name, new Property(name, raw_value, isSignatureRequired() ? signature : null));
+        return g;
+    }
+
+    public String getSkinUrl() {
+        if (hasSkin())
+            return value.getJSONObject("textures").getJSONObject("SKIN").getString("url");
+        return null;
+    }
+
+    public void setSkin(String url) {
+        empty = false;
+        if (!value.has("textures"))
+            value.put("value", new JSONObject());
+        if (!value.getJSONObject("textures").has("SKIN"))
+            value.getJSONObject("textures").put("SKIN", new JSONObject());
+        value.getJSONObject("textures").getJSONObject("SKIN").put("url", url);
+        updateRaw();
+    }
+
+    public boolean hasSkin() {
+        return value.has("textures") && value.getJSONObject("textures").has("SKIN") && value.getJSONObject("textures").getJSONObject("SKIN").has("url");
+    }
+
+    public void setCape(String url) {
+        empty = false;
+        if (!value.has("textures"))
+            value.put("value", new JSONObject());
+        if (!value.getJSONObject("textures").has("CAPE"))
+            value.getJSONObject("textures").put("CAPE", new JSONObject());
+        value.getJSONObject("textures").getJSONObject("CAPE").put("url", url);
+        updateRaw();
+    }
+
+    public String getCapeUrl() {
+        if (hasCape())
+            return value.getJSONObject("textures").getJSONObject("CAPE").getString("url");
+        return null;
+    }
+
+    public boolean hasCape() {
+        return value.has("textures") && value.getJSONObject("textures").has("CAPE") && value.getJSONObject("textures").getJSONObject("CAPE").has("url");
+    }
+
+    public UUID getUUID() {
+        return UUID.fromString(value.getString("profileId").replaceFirst("([0-9a-fA-F]{8})([0-9a-fA-F]{4})([0-9a-fA-F]{4})([0-9a-fA-F]{4})([0-9a-fA-F]+)", "$1-$2-$3-$4-$5"));
+    }
+
+    public void setUUID(UUID id) {
+        empty = false;
+        value.put("profileId", id.toString().replaceAll("-", ""));
+        updateRaw();
+    }
+
+    public boolean hasUUID() {
+        return value.has("profileId");
+    }
+
+    public String getProfileName() {
+        if (!hasProfileName())
+            return "undef";
+        return value.getString("profileName");
+    }
+
+    public void setProfileName(String name) {
+        empty = false;
+        value.put("profileName", name);
+        updateRaw();
+    }
+
+    public boolean hasProfileName() {
+        return value.has("profileName");
+    }
+
+    public boolean isPublic() {
+        return value.getBoolean("isPublic");
+    }
+
+    public void setPublic(boolean b) {
+        empty = false;
+        value.put("isPublic", b);
+        updateRaw();
+    }
+
+    public boolean isEmpty() {
+        return empty;
+    }
+
+    private void updateRaw() {
+        raw_value = Base64Coder.encodeString(value.toString());
+    }
+
+    public GameProfile toGameProfile() {
+        try {
+            return applay(new GameProfile(getUUID(), getProfileName()));
+        } catch (Exception e) {
+            return null;
+        }
+    }
+
+    public boolean isSignatureRequired() {
+        return value.has("signatureRequired") && value.getBoolean("signatureRequired");
+    }
+
+    public void setSignatureRequired(boolean flag) {
+        empty = false;
+        value.put("signatureRequired", flag);
+        updateRaw();
+
+    }
+
+    public String getSignature() {
+        if (signature == null)
+            return "undefined";
+        return signature;
+    }
+
+    public void setSignature(String signature) {
+        this.signature = signature;
+        empty = false;
+    }
+
+    public String getRawData() {
+        return raw_value;
+    }
+
+    public void setRawData(String string) {
+        this.raw_value = string;
+        this.value = new JSONObject(Base64Coder.decodeString(raw_value));
+    }
+
+    public Skin clone() {
+        Skin _new = new Skin();
+        _new.empty = empty;
+        _new.name = name;
+        _new.raw_value = raw_value;
+        _new.signature = signature;
+        _new.value = value;
+        return _new;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    @Override
+    public String toString() {
+        return value.toString();
+    }
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/SkinCache.java b/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/SkinCache.java
index d6cbf2a..3a6015e 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/SkinCache.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/SkinCache.java
@@ -1,92 +1,93 @@
 package dev.wolveringer.BungeeUtil.gameprofile;
 
-import java.io.IOException;
-import java.net.URL;
-import java.util.UUID;
-import java.util.concurrent.TimeUnit;
-import java.util.logging.Level;
+import com.google.common.cache.CacheBuilder;
+import com.google.common.cache.CacheLoader;
+import com.google.common.cache.LoadingCache;
 
 import net.md_5.bungee.BungeeCord;
 
 import org.json.JSONObject;
 
-import com.google.common.cache.CacheBuilder;
-import com.google.common.cache.CacheLoader;
-import com.google.common.cache.LoadingCache;
+import java.io.IOException;
+import java.net.URL;
+import java.util.UUID;
+import java.util.concurrent.TimeUnit;
+import java.util.logging.Level;
 
 import dev.wolveringer.BungeeUtil.BungeeUtil;
-import dev.wolveringer.BungeeUtil.Main;
 import dev.wolveringer.BungeeUtil.OperationCalback;
 
 public class SkinCache {
-	private static final String PROFILE_URL = "https://sessionserver.mojang.com/session/minecraft/profile/";
+    private static final String PROFILE_URL = "https://sessionserver.mojang.com/session/minecraft/profile/";
+
+    private static LoadingCache<UUID, Skin> profileCache = CacheBuilder.newBuilder().maximumSize(500).expireAfterWrite(4, TimeUnit.HOURS).build(new CacheLoader<UUID, Skin>() {
+        public Skin load(UUID name) throws Exception {
+            return loadSkin(name);
+        }
+
+        ;
+    });
+
+    @Deprecated
+    public static Skin getSkin(UUID uuid) {
+        if (uuid == null)
+            throw new IllegalArgumentException("UUID cant be null");
+        try {
+            return profileCache.get(uuid);
+        } catch (Exception e) {
+            BungeeCord.getInstance().getLogger().log(Level.WARNING, "Cant loading Skin for " + uuid + " (Reson: " + e.getMessage() + ")");
+            return Skin.createEmptySkin();
+        }
+    }
+
+    @SuppressWarnings("unchecked")
+    public static void getSkin(final UUID uuid, final OperationCalback<Skin>... c) {
+        BungeeCord.getInstance().getScheduler().runAsync(BungeeUtil.getPluginInstance(), new Runnable() {
+            @SuppressWarnings({"rawtypes"})
+            @Override
+            public void run() {
+                Skin s = getSkin(uuid);
+                for (OperationCalback t : c)
+                    t.done(s);
+            }
+        });
+    }
 
-	private static LoadingCache<UUID, Skin> profileCache = CacheBuilder.newBuilder().maximumSize(500).expireAfterWrite(4, TimeUnit.HOURS).build(new CacheLoader<UUID, Skin>() {
-		public Skin load(UUID name) throws Exception {
-			return loadSkin(name);
-		};
-	});
+    @Deprecated
+    public static Skin getSkin(String name) {
+        try {
+            return getSkin(UUIDFetcher.getUUIDOf(name));
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+        return Skin.createEmptySkin();
+    }
 
-	@Deprecated
-	public static Skin getSkin(UUID uuid) {
-		if(uuid == null)
-			throw new IllegalArgumentException("UUID cant be null");
-		try{
-			return profileCache.get(uuid);
-		}catch (Exception e){
-			BungeeCord.getInstance().getLogger().log(Level.WARNING, "Cant loading Skin for " + uuid + " (Reson: " + e.getMessage() + ")");
-			return Skin.createEmptySkin();
-		}
-	}
+    @SuppressWarnings("unchecked")
+    public static void getSkin(final String name, final OperationCalback<Skin>... c) {
+        BungeeCord.getInstance().getScheduler().runAsync(BungeeUtil.getPluginInstance(), new Runnable() {
+            @SuppressWarnings({"rawtypes"})
+            @Override
+            public void run() {
+                Skin s = getSkin(name);
+                for (OperationCalback t : c)
+                    t.done(s);
+            }
+        });
+    }
 
-	@SuppressWarnings("unchecked")
-	public static void getSkin(final UUID uuid, final OperationCalback<Skin>... c) {
-		BungeeCord.getInstance().getScheduler().runAsync(BungeeUtil.getPluginInstance(), new Runnable() {
-			@SuppressWarnings({ "rawtypes" })
-			@Override
-			public void run() {
-				Skin s = getSkin(uuid);
-				for(OperationCalback t : c)
-					t.done(s);
-			}
-		});
-	}
-	
-	@Deprecated
-	public static Skin getSkin(String name) {
-		try{
-			return getSkin(UUIDFetcher.getUUIDOf(name));
-		}catch (Exception e){
-			e.printStackTrace();
-		}
-		return Skin.createEmptySkin();
-	}
-	
-	@SuppressWarnings("unchecked")
-	public static void getSkin(final String name, final OperationCalback<Skin>... c) {
-		BungeeCord.getInstance().getScheduler().runAsync(BungeeUtil.getPluginInstance(), new Runnable() {
-			@SuppressWarnings({ "rawtypes" })
-			@Override
-			public void run() {
-				Skin s = getSkin(name);
-				for(OperationCalback t : c)
-					t.done(s);
-			}
-		});
-	}
+    private static Skin loadSkin(UUID uuid) throws IOException {
+        String s = new SkinRequest().performGetRequest(new URL(PROFILE_URL + uuid.toString().replace("-", "") + "?unsigned=false"));
+        if ("".equalsIgnoreCase(s) || s == null)
+            throw new IOException("Player skin not found (" + uuid + ")");
+        return new Skin(new JSONObject(s));
+    }
 
-	private static Skin loadSkin(UUID uuid) throws IOException {
-		String s = new SkinRequest().performGetRequest(new URL(PROFILE_URL + uuid.toString().replace("-", "") + "?unsigned=false"));
-		if("".equalsIgnoreCase(s) || s == null)
-			throw new IOException("Player skin not found (" + uuid + ")");
-		return new Skin(new JSONObject(s));
-	}
-	
-	public static void main(String[] args) {
-		Skin s = Skin.createEmptySkin();
-		s.setRawData("eyJ0ZXh0dXJlcyI6eyJTS0lOIjp7InVybCI6Imh0dHA6Ly90ZXh0dXJlcy5taW5lY3JhZnQubmV0L3RleHR1cmUvMjdiYmQwYjI5MTFjOTZiNWQ4N2IyZGY3NjY5MWE1MWI4YjEyYzZmZWZkNTIzMTQ2ZDhhYzVlZjFiOGVlIn19fQ==");
-		s.setSkin(SkinCache.getSkin("WolverinEN").getSkinUrl());
-		s.setUUID(UUID.randomUUID());
-		System.out.print(s.getRawData());
-	}
+    public static void main(String[] args) {
+        Skin s = Skin.createEmptySkin();
+        s.setRawData("eyJ0ZXh0dXJlcyI6eyJTS0lOIjp7InVybCI6Imh0dHA6Ly90ZXh0dXJlcy5taW5lY3JhZnQubmV0L3RleHR1cmUvMjdiYmQwYjI5MTFjOTZiNWQ4N2IyZGY3NjY5MWE1MWI4YjEyYzZmZWZkNTIzMTQ2ZDhhYzVlZjFiOGVlIn19fQ==");
+        s.setSkin(SkinCache.getSkin("WolverinEN").getSkinUrl());
+        s.setUUID(UUID.randomUUID());
+        System.out.print(s.getRawData());
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/SkinFactory.java b/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/SkinFactory.java
index 12cea60..4f3bf0e 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/SkinFactory.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/SkinFactory.java
@@ -1,122 +1,123 @@
 package dev.wolveringer.BungeeUtil.gameprofile;
 
-import java.io.IOException;
-import java.net.URL;
-import java.util.UUID;
-import java.util.concurrent.TimeUnit;
-import java.util.logging.Level;
+import com.google.common.cache.CacheBuilder;
+import com.google.common.cache.CacheLoader;
+import com.google.common.cache.LoadingCache;
 
 import net.md_5.bungee.BungeeCord;
 
 import org.json.JSONArray;
 import org.json.JSONObject;
 
-import com.google.common.cache.CacheBuilder;
-import com.google.common.cache.CacheLoader;
-import com.google.common.cache.LoadingCache;
+import java.io.IOException;
+import java.net.URL;
+import java.util.UUID;
+import java.util.concurrent.TimeUnit;
+import java.util.logging.Level;
 
 import dev.wolveringer.BungeeUtil.BungeeUtil;
-import dev.wolveringer.BungeeUtil.Main;
 import dev.wolveringer.BungeeUtil.OperationCalback;
 
 public class SkinFactory {
-	private static final String PROFILE_URL = "https://sessionserver.mojang.com/session/minecraft/profile/";
-
-	private static LoadingCache<UUID, Skin> profileCache = CacheBuilder.newBuilder().maximumSize(500).expireAfterWrite(4, TimeUnit.HOURS).build(new CacheLoader<UUID, Skin>() {
-		public Skin load(UUID name) throws Exception {
-			Skin skin = new SteveSkin();
-			try{
-				skin = loadSkin(name);
-			}catch(Exception e){
-				e.printStackTrace();
-			}
-			return skin;
-		};
-	});
-
-	@Deprecated
-	public static Skin getSkin(UUID uuid) {
-		if(uuid == null)
-			throw new IllegalArgumentException("UUID cant be null");
-		try{
-			Skin s = profileCache.get(uuid);
-			if(s instanceof SteveSkin){
-				profileCache.refresh(uuid);
-				s = profileCache.get(uuid);
-			}
-			return s.clone();
-		}catch (Exception e){
-			BungeeCord.getInstance().getLogger().log(Level.WARNING, "Cant loading Skin for " + uuid + " (Reson: " + e.getMessage() + ")");
-			return Skin.createEmptySkin();
-		}
-	}
-
-	@SuppressWarnings("unchecked")
-	public static void getSkin(final UUID uuid, final OperationCalback<Skin>... c) {
-		BungeeCord.getInstance().getScheduler().runAsync(BungeeUtil.getPluginInstance(), new Runnable() {
-			@SuppressWarnings({ "rawtypes" })
-			@Override
-			public void run() {
-				Skin s = getSkin(uuid);
-				for(OperationCalback t : c)
-					t.done(s);
-			}
-		});
-	}
-	
-	public static Skin createEmptySkin(){
-		return Skin.createEmptySkin();
-	}
-	
-	public static Skin createSkin(String rawValue,String signature){
-		JSONObject o = new JSONObject();
-		JSONArray props = new JSONArray();
-		JSONObject prop = new JSONObject();
-		prop.put("name", "textures");
-		prop.put("value", rawValue);
-		prop.put("signature", signature);
-		props.put(prop);
-		o.put("properties", props);
-		return new Skin(o);
-	}
-	
-	@Deprecated
-	public static Skin getSkin(String name) {
-		try{
-			return getSkin(UUIDFetcher.getUUIDOf(name));
-		}catch (Exception e){
-			e.printStackTrace();
-		}
-		return Skin.createEmptySkin();
-	}
-	
-	@SuppressWarnings("unchecked")
-	public static void getSkin(final String name, final OperationCalback<Skin>... c) {
-		BungeeCord.getInstance().getScheduler().runAsync(BungeeUtil.getPluginInstance(), new Runnable() {
-			@SuppressWarnings({ "rawtypes" })
-			@Override
-			public void run() {
-				Skin s = getSkin(name);
-				for(OperationCalback t : c)
-					t.done(s);
-			}
-		});
-	}
-
-	private static Skin loadSkin(UUID uuid) throws IOException {
-		String s = new SkinRequest().performGetRequest(new URL(PROFILE_URL + uuid.toString().replace("-", "") + "?unsigned=false"));
-		if("".equalsIgnoreCase(s) || s == null){
-			throw new NullPointerException("Player skin not found (" + uuid + ")");
-		}
-		return new Skin(new JSONObject(s));
-	}
-	
-	public static void main(String[] args) {
-		Skin s = Skin.createEmptySkin();
-		s.setRawData("eyJ0ZXh0dXJlcyI6eyJTS0lOIjp7InVybCI6Imh0dHA6Ly90ZXh0dXJlcy5taW5lY3JhZnQubmV0L3RleHR1cmUvMjdiYmQwYjI5MTFjOTZiNWQ4N2IyZGY3NjY5MWE1MWI4YjEyYzZmZWZkNTIzMTQ2ZDhhYzVlZjFiOGVlIn19fQ==");
-		s.setSkin(SkinFactory.getSkin("WolverinEN").getSkinUrl());
-		s.setUUID(UUID.randomUUID());
-		
-		System.out.print(s.getRawData());
-	}
+    private static final String PROFILE_URL = "https://sessionserver.mojang.com/session/minecraft/profile/";
+
+    private static LoadingCache<UUID, Skin> profileCache = CacheBuilder.newBuilder().maximumSize(500).expireAfterWrite(4, TimeUnit.HOURS).build(new CacheLoader<UUID, Skin>() {
+        public Skin load(UUID name) throws Exception {
+            Skin skin = new SteveSkin();
+            try {
+                skin = loadSkin(name);
+            } catch (Exception e) {
+                e.printStackTrace();
+            }
+            return skin;
+        }
+
+        ;
+    });
+
+    @Deprecated
+    public static Skin getSkin(UUID uuid) {
+        if (uuid == null)
+            throw new IllegalArgumentException("UUID cant be null");
+        try {
+            Skin s = profileCache.get(uuid);
+            if (s instanceof SteveSkin) {
+                profileCache.refresh(uuid);
+                s = profileCache.get(uuid);
+            }
+            return s.clone();
+        } catch (Exception e) {
+            BungeeCord.getInstance().getLogger().log(Level.WARNING, "Cant loading Skin for " + uuid + " (Reson: " + e.getMessage() + ")");
+            return Skin.createEmptySkin();
+        }
+    }
+
+    @SuppressWarnings("unchecked")
+    public static void getSkin(final UUID uuid, final OperationCalback<Skin>... c) {
+        BungeeCord.getInstance().getScheduler().runAsync(BungeeUtil.getPluginInstance(), new Runnable() {
+            @SuppressWarnings({"rawtypes"})
+            @Override
+            public void run() {
+                Skin s = getSkin(uuid);
+                for (OperationCalback t : c)
+                    t.done(s);
+            }
+        });
+    }
+
+    public static Skin createEmptySkin() {
+        return Skin.createEmptySkin();
+    }
+
+    public static Skin createSkin(String rawValue, String signature) {
+        JSONObject o = new JSONObject();
+        JSONArray props = new JSONArray();
+        JSONObject prop = new JSONObject();
+        prop.put("name", "textures");
+        prop.put("value", rawValue);
+        prop.put("signature", signature);
+        props.put(prop);
+        o.put("properties", props);
+        return new Skin(o);
+    }
+
+    @Deprecated
+    public static Skin getSkin(String name) {
+        try {
+            return getSkin(UUIDFetcher.getUUIDOf(name));
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+        return Skin.createEmptySkin();
+    }
+
+    @SuppressWarnings("unchecked")
+    public static void getSkin(final String name, final OperationCalback<Skin>... c) {
+        BungeeCord.getInstance().getScheduler().runAsync(BungeeUtil.getPluginInstance(), new Runnable() {
+            @SuppressWarnings({"rawtypes"})
+            @Override
+            public void run() {
+                Skin s = getSkin(name);
+                for (OperationCalback t : c)
+                    t.done(s);
+            }
+        });
+    }
+
+    private static Skin loadSkin(UUID uuid) throws IOException {
+        String s = new SkinRequest().performGetRequest(new URL(PROFILE_URL + uuid.toString().replace("-", "") + "?unsigned=false"));
+        if ("".equalsIgnoreCase(s) || s == null) {
+            throw new NullPointerException("Player skin not found (" + uuid + ")");
+        }
+        return new Skin(new JSONObject(s));
+    }
+
+    public static void main(String[] args) {
+        Skin s = Skin.createEmptySkin();
+        s.setRawData("eyJ0ZXh0dXJlcyI6eyJTS0lOIjp7InVybCI6Imh0dHA6Ly90ZXh0dXJlcy5taW5lY3JhZnQubmV0L3RleHR1cmUvMjdiYmQwYjI5MTFjOTZiNWQ4N2IyZGY3NjY5MWE1MWI4YjEyYzZmZWZkNTIzMTQ2ZDhhYzVlZjFiOGVlIn19fQ==");
+        s.setSkin(SkinFactory.getSkin("WolverinEN").getSkinUrl());
+        s.setUUID(UUID.randomUUID());
+
+        System.out.print(s.getRawData());
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/SkinRequest.java b/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/SkinRequest.java
index c21df04..0ec295b 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/SkinRequest.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/SkinRequest.java
@@ -1,46 +1,46 @@
 package dev.wolveringer.BungeeUtil.gameprofile;
 
+import com.google.common.base.Charsets;
+
+import org.apache.commons.io.IOUtils;
+
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.HttpURLConnection;
 import java.net.URL;
 
-import org.apache.commons.io.IOUtils;
-
-import com.google.common.base.Charsets;
-
 public class SkinRequest {
-	public String performGetRequest(URL url) throws IOException {
-		HttpURLConnection connection = createUrlConnection(url);
+    public String performGetRequest(URL url) throws IOException {
+        HttpURLConnection connection = createUrlConnection(url);
 
-		InputStream inputStream = null;
-		try{
-			inputStream = connection.getInputStream();
-			String result = IOUtils.toString(inputStream, Charsets.UTF_8);
-			return result;
-		}catch (IOException e){
-			IOUtils.closeQuietly(inputStream);
-			inputStream = connection.getErrorStream();
-			if(inputStream != null){
-				String result = IOUtils.toString(inputStream, Charsets.UTF_8);
-				return result;
-			}
-			throw e;
-		}finally{
-			IOUtils.closeQuietly(inputStream);
-		}
-	}
+        InputStream inputStream = null;
+        try {
+            inputStream = connection.getInputStream();
+            String result = IOUtils.toString(inputStream, Charsets.UTF_8);
+            return result;
+        } catch (IOException e) {
+            IOUtils.closeQuietly(inputStream);
+            inputStream = connection.getErrorStream();
+            if (inputStream != null) {
+                String result = IOUtils.toString(inputStream, Charsets.UTF_8);
+                return result;
+            }
+            throw e;
+        } finally {
+            IOUtils.closeQuietly(inputStream);
+        }
+    }
 
-	protected HttpURLConnection createUrlConnection(URL url) throws IOException {
-		HttpURLConnection connection = (HttpURLConnection) url.openConnection();
-		connection.setConnectTimeout(2000);
-		connection.setReadTimeout(2000);
-		connection.setUseCaches(false);
-		connection.setRequestMethod("GET");
-		connection.setDefaultUseCaches(false);
-		connection.addRequestProperty("User-Agent", "Mozilla/5.0");
-		connection.addRequestProperty("Cache-Control", "no-cache, no-store, must-revalidate");
-		connection.addRequestProperty("Pragma", "no-cache");
-		return connection;
-	}
+    protected HttpURLConnection createUrlConnection(URL url) throws IOException {
+        HttpURLConnection connection = (HttpURLConnection) url.openConnection();
+        connection.setConnectTimeout(2000);
+        connection.setReadTimeout(2000);
+        connection.setUseCaches(false);
+        connection.setRequestMethod("GET");
+        connection.setDefaultUseCaches(false);
+        connection.addRequestProperty("User-Agent", "Mozilla/5.0");
+        connection.addRequestProperty("Cache-Control", "no-cache, no-store, must-revalidate");
+        connection.addRequestProperty("Pragma", "no-cache");
+        return connection;
+    }
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/SteveSkin.java b/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/SteveSkin.java
index 5c4e1f0..74e8a01 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/SteveSkin.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/SteveSkin.java
@@ -1,100 +1,124 @@
 package dev.wolveringer.BungeeUtil.gameprofile;
 
+import org.json.JSONObject;
+
 import java.util.UUID;
 
-import org.json.JSONObject;
+public class SteveSkin extends Skin {
+
+    public SteveSkin() {
+        super(new JSONObject());
+    }
+
+    @Override
+    public GameProfile applay(GameProfile g) {
+        return g;
+    }
+
+    @Override
+    public String getCapeUrl() {
+        return "";
+    }
+
+    @Override
+    public String getProfileName() {
+        return "Steve";
+    }
+
+    @Override
+    public void setProfileName(String name) {
+    }
+
+    @Override
+    public String getRawData() {
+        return "undefined";
+    }
+
+    @Override
+    public void setRawData(String string) {
+    }
+
+    @Override
+    public String getSignature() {
+        return "undefined";
+    }
+
+    @Override
+    public void setSignature(String signature) {
+    }
+
+    @Override
+    public String getSkinUrl() {
+        return "";
+    }
+
+    @Override
+    public UUID getUUID() {
+        return UUID.nameUUIDFromBytes("Steve".getBytes());
+    }
+
+    @Override
+    public void setUUID(UUID id) {
+    }
+
+    @Override
+    public boolean hasSkin() {
+        return false;
+    }
+
+    @Override
+    public boolean hasCape() {
+        return false;
+    }
+
+    @Override
+    public boolean hasProfileName() {
+        return true;
+    }
+
+    @Override
+    public boolean hasUUID() {
+        return false;
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return true;
+    }
+
+    @Override
+    public boolean isPublic() {
+        return false;
+    }
+
+    @Override
+    public void setPublic(boolean b) {
+    }
+
+    @Override
+    public boolean isSignatureRequired() {
+        return false;
+    }
+
+    @Override
+    public void setSignatureRequired(boolean flag) {
+    }
+
+    @Override
+    public void setCape(String url) {
+    }
+
+    @Override
+    public void setSkin(String url) {
+    }
+
+    @Override
+    public GameProfile toGameProfile() {
+        return new GameProfile(getUUID(), getProfileName());
+    }
 
-public class SteveSkin extends Skin{
-
-	public SteveSkin() {
-		super(new JSONObject());
-	}
-	
-	@Override
-	public GameProfile applay(GameProfile g) {
-		return g;
-	}
-	
-	@Override
-	public String getCapeUrl() {
-		return "";
-	}
-	
-	@Override
-	public String getProfileName() {
-		return "Steve";
-	}
-
-	@Override
-	public String getRawData() {
-		return "undefined";
-	}
-	
-	@Override
-	public String getSignature() {
-		return "undefined";
-	}
-	
-	@Override
-	public String getSkinUrl() {
-		return "";
-	}
-	
-	@Override
-	public UUID getUUID() {
-		return UUID.nameUUIDFromBytes("Steve".getBytes());
-	}
-	
-	@Override
-	public boolean hasSkin() {
-		return false;
-	}
-	@Override
-	public boolean hasCape() {
-		return false;
-	}
-	@Override
-	public boolean hasProfileName() {
-		return true;
-	}
-	@Override
-	public boolean hasUUID() {
-		return false;
-	}
-	@Override
-	public boolean isEmpty() {
-		return true;
-	}
-	@Override
-	public boolean isPublic() {
-		return false;
-	}
-	@Override
-	public boolean isSignatureRequired() {
-		return false;
-	}
-	@Override
-	public void setCape(String url) {}
-	@Override
-	public void setProfileName(String name) {}
-	@Override
-	public void setPublic(boolean b) {}
-	@Override
-	public void setRawData(String string) {}
-	@Override
-	public void setSignature(String signature) {}
-	@Override
-	public void setSignatureRequired(boolean flag) {}
-	@Override
-	public void setSkin(String url) {}
-	@Override
-	public void setUUID(UUID id) {}
-	@Override
-	public GameProfile toGameProfile() {
-		return new GameProfile(getUUID(), getProfileName());
-	}
-	@Override
-	public String toString() {
-		return "Skin[Owner=Steve]";
-	}
+    @Override
+    public String toString() {
+        return "Skin[Owner=Steve]";
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/Test.java b/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/Test.java
index 9741c71..5fdd9a9 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/Test.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/Test.java
@@ -3,10 +3,10 @@ package dev.wolveringer.BungeeUtil.gameprofile;
 import java.util.UUID;
 
 public class Test {
-	public static void main(String[] args) throws Exception {
-		UUID uuid = UUIDFetcher.getUUIDOf("WolverinDEV");
-		System.out.println("UUID: "+uuid);
-		Skin skin = SkinCache.getSkin(uuid);
-		System.out.println(skin);
-	}
+    public static void main(String[] args) throws Exception {
+        UUID uuid = UUIDFetcher.getUUIDOf("WolverinDEV");
+        System.out.println("UUID: " + uuid);
+        Skin skin = SkinCache.getSkin(uuid);
+        System.out.println(skin);
+    }
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/UUIDFetcher.java b/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/UUIDFetcher.java
index 694eba2..5ba58f0 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/UUIDFetcher.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/gameprofile/UUIDFetcher.java
@@ -1,5 +1,15 @@
 package dev.wolveringer.BungeeUtil.gameprofile;
 
+import com.google.common.cache.CacheBuilder;
+import com.google.common.cache.CacheLoader;
+import com.google.common.cache.LoadingCache;
+import com.google.common.collect.ImmutableList;
+import com.google.gson.JsonArray;
+import com.google.gson.JsonObject;
+import com.google.gson.JsonParser;
+
+import org.json.JSONArray;
+
 import java.io.InputStreamReader;
 import java.io.OutputStream;
 import java.net.HttpURLConnection;
@@ -13,71 +23,37 @@ import java.util.UUID;
 import java.util.concurrent.Callable;
 import java.util.concurrent.TimeUnit;
 
-import org.json.JSONArray;
-
-import com.google.common.cache.CacheBuilder;
-import com.google.common.cache.CacheLoader;
-import com.google.common.cache.LoadingCache;
-import com.google.common.collect.ImmutableList;
-import com.google.gson.JsonArray;
-import com.google.gson.JsonObject;
-import com.google.gson.JsonParser;
-
 public class UUIDFetcher implements Callable<Map<String, UUID>> {
-	
-	private static LoadingCache<String, UUID> uuidCache = CacheBuilder.newBuilder().maximumSize(500).expireAfterWrite(4, TimeUnit.HOURS).build(new CacheLoader<String, UUID>() {
-		public UUID load(String name) throws Exception {
-			return new UUIDFetcher(Arrays.asList(name)).call().get(name);
-		};
-	});
-	
+
     private static final double PROFILES_PER_REQUEST = 100;
     private static final String PROFILE_URL = "https://api.mojang.com/profiles/minecraft";
+    private static LoadingCache<String, UUID> uuidCache = CacheBuilder.newBuilder().maximumSize(500).expireAfterWrite(4, TimeUnit.HOURS).build(new CacheLoader<String, UUID>() {
+        public UUID load(String name) throws Exception {
+            return new UUIDFetcher(Arrays.asList(name)).call().get(name);
+        }
+
+        ;
+    });
     private final JsonParser jsonParser = new JsonParser();
     private final List<String> names;
     private final boolean rateLimiting;
- 
+
     public UUIDFetcher(List<String> names, boolean rateLimiting) {
         this.names = ImmutableList.copyOf(names);
         this.rateLimiting = rateLimiting;
     }
- 
+
     public UUIDFetcher(List<String> names) {
         this(names, true);
     }
- 
-    public Map<String, UUID> call() throws Exception {
-        Map<String, UUID> uuidMap = new HashMap<String, UUID>();
-        int requests = (int) Math.ceil(names.size() / PROFILES_PER_REQUEST);
-        for (int i = 0; i < requests; i++) {
-            HttpURLConnection connection = createConnection();
-            JSONArray obj = new JSONArray();
-            for(String s : names.subList(i * 100, Math.min((i + 1) * 100, names.size())))
-            	obj.put(s);
-            String body = obj.toString();
-            writeBody(connection, body);
-            JsonArray array = (JsonArray) jsonParser.parse(new InputStreamReader(connection.getInputStream()));
-            for (Object profile : array) {
-            	JsonObject jsonProfile = (JsonObject) profile;
-                String id = (String) jsonProfile.get("id").getAsString();
-                String name = (String) jsonProfile.get("name").getAsString();
-                UUID uuid = UUIDFetcher.getUUID(id);
-                uuidMap.put(name, uuid);
-            }
-            if (rateLimiting && i != requests - 1) {
-                Thread.sleep(100L);
-            }
-        }
-        return uuidMap;
-    }
- 
+
     private static void writeBody(HttpURLConnection connection, String body) throws Exception {
         OutputStream stream = connection.getOutputStream();
         stream.write(body.getBytes());
         stream.flush();
         stream.close();
     }
- 
+
     private static HttpURLConnection createConnection() throws Exception {
         URL url = new URL(PROFILE_URL);
         HttpURLConnection connection = (HttpURLConnection) url.openConnection();
@@ -88,18 +64,18 @@ public class UUIDFetcher implements Callable<Map<String, UUID>> {
         connection.setDoOutput(true);
         return connection;
     }
- 
+
     private static UUID getUUID(String id) {
-        return UUID.fromString(id.substring(0, 8) + "-" + id.substring(8, 12) + "-" + id.substring(12, 16) + "-" + id.substring(16, 20) + "-" +id.substring(20, 32));
+        return UUID.fromString(id.substring(0, 8) + "-" + id.substring(8, 12) + "-" + id.substring(12, 16) + "-" + id.substring(16, 20) + "-" + id.substring(20, 32));
     }
- 
+
     public static byte[] toBytes(UUID uuid) {
         ByteBuffer byteBuffer = ByteBuffer.wrap(new byte[16]);
         byteBuffer.putLong(uuid.getMostSignificantBits());
         byteBuffer.putLong(uuid.getLeastSignificantBits());
         return byteBuffer.array();
     }
- 
+
     public static UUID fromBytes(byte[] array) {
         if (array.length != 16) {
             throw new IllegalArgumentException("Illegal byte array length: " + array.length);
@@ -109,8 +85,33 @@ public class UUIDFetcher implements Callable<Map<String, UUID>> {
         long leastSignificant = byteBuffer.getLong();
         return new UUID(mostSignificant, leastSignificant);
     }
- 
+
     public static UUID getUUIDOf(String name) throws Exception {
         return uuidCache.get(name);
     }
+
+    public Map<String, UUID> call() throws Exception {
+        Map<String, UUID> uuidMap = new HashMap<String, UUID>();
+        int requests = (int) Math.ceil(names.size() / PROFILES_PER_REQUEST);
+        for (int i = 0; i < requests; i++) {
+            HttpURLConnection connection = createConnection();
+            JSONArray obj = new JSONArray();
+            for (String s : names.subList(i * 100, Math.min((i + 1) * 100, names.size())))
+                obj.put(s);
+            String body = obj.toString();
+            writeBody(connection, body);
+            JsonArray array = (JsonArray) jsonParser.parse(new InputStreamReader(connection.getInputStream()));
+            for (Object profile : array) {
+                JsonObject jsonProfile = (JsonObject) profile;
+                String id = (String) jsonProfile.get("id").getAsString();
+                String name = (String) jsonProfile.get("name").getAsString();
+                UUID uuid = UUIDFetcher.getUUID(id);
+                uuidMap.put(name, uuid);
+            }
+            if (rateLimiting && i != requests - 1) {
+                Thread.sleep(100L);
+            }
+        }
+        return uuidMap;
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/injector/InjectFiles.java b/src/main/java/dev/wolveringer/BungeeUtil/injector/InjectFiles.java
index 6883ade..4428e6d 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/injector/InjectFiles.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/injector/InjectFiles.java
@@ -1,5 +1,11 @@
 package dev.wolveringer.BungeeUtil.injector;
 
+import javassist.ClassPool;
+import javassist.CtClass;
+
+import net.md_5.bungee.BungeeCord;
+import net.md_5.bungee.UserConnection;
+
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.DataOutputStream;
@@ -13,107 +19,102 @@ import java.util.zip.ZipEntry;
 import java.util.zip.ZipInputStream;
 import java.util.zip.ZipOutputStream;
 
-import javassist.ClassPool;
-import javassist.CtClass;
-import net.md_5.bungee.BungeeCord;
-import net.md_5.bungee.UserConnection;
 import dev.wolveringer.BungeeUtil.BungeeUtil;
-import dev.wolveringer.BungeeUtil.Main;
 import dev.wolveringer.BungeeUtil.configuration.Configuration;
 import dev.wolveringer.chat.ChatColor.ChatColorUtils;
 
 public class InjectFiles {
-	public static int inject() {
-		try{
-			int modifier = UserConnection.class.getModifiers();
+    public static int inject() {
+        try {
+            int modifier = UserConnection.class.getModifiers();
+
+            if (!Modifier.isFinal(modifier) && Modifier.isPublic(modifier)) {
+                return -1;
+            }
+            BungeeUtil.getInstance().setInformation("\u00A7aInjection BungeeUtils. Please wait.");
+            BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR + "aStarting BungeeUtil injection.");
+            BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR + "aSet modifiers for class UserConnection.class to \"public\"");
 
-			if(!Modifier.isFinal(modifier) && Modifier.isPublic(modifier)){
-				return -1;
-			}
-			BungeeUtil.getInstance().setInformation("\u00A7aInjection BungeeUtils. Please wait.");
-			BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR+"aStarting BungeeUtil injection.");
-			BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR+"aSet modifiers for class UserConnection.class to \"public\"");
+            String[] names = {"net.md_5.bungee.UserConnection.class"};
+            ClassPool cp = ClassPool.getDefault();
+            CtClass clazz = cp.getCtClass(UserConnection.class.getName());
+            clazz.setModifiers(Modifier.PUBLIC);
+            ByteArrayOutputStream bout;
+            DataOutputStream out = new DataOutputStream(bout = new ByteArrayOutputStream());
+            clazz.getClassFile().write(out);
+            InputStream[] streams = {new ByteArrayInputStream(bout.toByteArray())};
+            File bungee_file = new File(BungeeCord.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath());
+            updateZipFile(bungee_file, names, streams);
+            return 1;
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+        return 0;
+    }
 
-			String[] names = { "net.md_5.bungee.UserConnection.class" };
-			ClassPool cp = ClassPool.getDefault();
-			CtClass clazz = cp.getCtClass(UserConnection.class.getName());
-			clazz.setModifiers(Modifier.PUBLIC);
-			ByteArrayOutputStream bout;
-			DataOutputStream out = new DataOutputStream(bout = new ByteArrayOutputStream());
-			clazz.getClassFile().write(out);
-			InputStream[] streams = { new ByteArrayInputStream(bout.toByteArray()) };
-			File bungee_file = new File(BungeeCord.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath());
-			updateZipFile(bungee_file, names, streams);
-			return 1;
-		}catch (Exception e){
-			e.printStackTrace();
-		}
-		return 0;
-	}
-	
-	public static boolean isInjected(){
-		return !Modifier.isFinal(UserConnection.class.getModifiers()) && Modifier.isPublic(UserConnection.class.getModifiers());
-	}
+    public static boolean isInjected() {
+        return !Modifier.isFinal(UserConnection.class.getModifiers()) && Modifier.isPublic(UserConnection.class.getModifiers());
+    }
 
-	private static void updateZipFile(File zipFile, String[] names, InputStream[] ins) throws IOException {
-		File tempFile = File.createTempFile(zipFile.getName(), null);
-		if(!tempFile.delete())
-			BungeeUtil.getInstance().sendMessage("Warn: Cant delte temp file.");
-		if(tempFile.exists())
-			BungeeUtil.getInstance().sendMessage("Warn: Temp target file alredy exist!");
-		if(!zipFile.exists())
-			throw new RuntimeException("Could not rename the file " + zipFile.getAbsolutePath() + " to " + tempFile.getAbsolutePath()+" (Src. not found!)");
-		int renameOk = zipFile.renameTo(tempFile)?1:0;
-		if(renameOk==0){
-			tempFile = new File(zipFile.toString()+".copy");
-			com.google.common.io.Files.copy(zipFile, tempFile);
-			renameOk = 2;
-			if(zipFile.delete()){
-				BungeeUtil.getInstance().sendMessage("Warn: Src file cant delete.");
-				renameOk = -1;
-			}
-		}
-		if(renameOk == 0)
-			throw new RuntimeException("Could not rename the file " + zipFile.getAbsolutePath() + " to " + tempFile.getAbsolutePath()+" (Directory read only? (Temp:[R:"+(tempFile.canRead()?1:0)+";W:"+(tempFile.canWrite()?1:0)+",D:"+(tempFile.canExecute()?1:0)+"],Src:[R:"+(zipFile.canRead()?1:0)+";W:"+(zipFile.canWrite()?1:0)+",D:"+(zipFile.canExecute()?1:0)+"]))");
-		if(renameOk != 1)
-			BungeeUtil.getInstance().sendMessage("Warn: Cant create temp file. Use .copy file");
-		byte[] buf = new byte[Configuration.getLoadingBufferSize()];
-		BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR+"aBuffer size: "+ChatColorUtils.COLOR_CHAR+"e"+buf.length);
-		ZipInputStream zin = new ZipInputStream(new FileInputStream(tempFile));
-		ZipOutputStream out = new ZipOutputStream(new FileOutputStream(zipFile));
+    private static void updateZipFile(File zipFile, String[] names, InputStream[] ins) throws IOException {
+        File tempFile = File.createTempFile(zipFile.getName(), null);
+        if (!tempFile.delete())
+            BungeeUtil.getInstance().sendMessage("Warn: Cant delte temp file.");
+        if (tempFile.exists())
+            BungeeUtil.getInstance().sendMessage("Warn: Temp target file alredy exist!");
+        if (!zipFile.exists())
+            throw new RuntimeException("Could not rename the file " + zipFile.getAbsolutePath() + " to " + tempFile.getAbsolutePath() + " (Src. not found!)");
+        int renameOk = zipFile.renameTo(tempFile) ? 1 : 0;
+        if (renameOk == 0) {
+            tempFile = new File(zipFile.toString() + ".copy");
+            com.google.common.io.Files.copy(zipFile, tempFile);
+            renameOk = 2;
+            if (zipFile.delete()) {
+                BungeeUtil.getInstance().sendMessage("Warn: Src file cant delete.");
+                renameOk = -1;
+            }
+        }
+        if (renameOk == 0)
+            throw new RuntimeException("Could not rename the file " + zipFile.getAbsolutePath() + " to " + tempFile.getAbsolutePath() + " (Directory read only? (Temp:[R:" + (tempFile.canRead() ? 1 : 0) + ";W:" + (tempFile.canWrite() ? 1 : 0) + ",D:" + (tempFile.canExecute() ? 1 : 0) + "],Src:[R:" + (zipFile.canRead() ? 1 : 0) + ";W:" + (zipFile.canWrite() ? 1 : 0) + ",D:" + (zipFile.canExecute() ? 1 : 0) + "]))");
+        if (renameOk != 1)
+            BungeeUtil.getInstance().sendMessage("Warn: Cant create temp file. Use .copy file");
+        byte[] buf = new byte[Configuration.getLoadingBufferSize()];
+        BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR + "aBuffer size: " + ChatColorUtils.COLOR_CHAR + "e" + buf.length);
+        ZipInputStream zin = new ZipInputStream(new FileInputStream(tempFile));
+        ZipOutputStream out = new ZipOutputStream(new FileOutputStream(zipFile));
 
-		ZipEntry entry = zin.getNextEntry();
-		while (entry != null){
-			String path_name = entry.getName().replaceAll("/", "\\.");
-			boolean notReplace = true;
-			for(String f : names)
-				if(f.equals(path_name)){
-					notReplace = false;
-					break;
-				}
-			if(notReplace){
-				out.putNextEntry(new ZipEntry(entry.getName()));
-				int len;
-				while ((len = zin.read(buf)) > 0)
-					out.write(buf, 0, len);
-			}
-			entry = zin.getNextEntry();
-		}
-		zin.close();
-		for(int i = 0;i < names.length;i++){
-			InputStream in = ins[i];
-			int index = names[i].lastIndexOf('.');
-			out.putNextEntry(new ZipEntry(names[i].substring(0, index).replaceAll("\\.", "/") + names[i].substring(index)));
-			int len;
-			while ((len = in.read(buf)) > 0)
-				out.write(buf, 0, len);
-			out.closeEntry();
-			in.close();
-		}
-		out.close();
-		tempFile.delete();
-		if(renameOk == -1){
-			System.exit(-1);
-		}
-	}
+        ZipEntry entry = zin.getNextEntry();
+        while (entry != null) {
+            String path_name = entry.getName().replaceAll("/", "\\.");
+            boolean notReplace = true;
+            for (String f : names)
+                if (f.equals(path_name)) {
+                    notReplace = false;
+                    break;
+                }
+            if (notReplace) {
+                out.putNextEntry(new ZipEntry(entry.getName()));
+                int len;
+                while ((len = zin.read(buf)) > 0)
+                    out.write(buf, 0, len);
+            }
+            entry = zin.getNextEntry();
+        }
+        zin.close();
+        for (int i = 0; i < names.length; i++) {
+            InputStream in = ins[i];
+            int index = names[i].lastIndexOf('.');
+            out.putNextEntry(new ZipEntry(names[i].substring(0, index).replaceAll("\\.", "/") + names[i].substring(index)));
+            int len;
+            while ((len = in.read(buf)) > 0)
+                out.write(buf, 0, len);
+            out.closeEntry();
+            in.close();
+        }
+        out.close();
+        tempFile.delete();
+        if (renameOk == -1) {
+            System.exit(-1);
+        }
+    }
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/item/ClickListener.java b/src/main/java/dev/wolveringer/BungeeUtil/item/ClickListener.java
index 329d132..1f9de9e 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/item/ClickListener.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/item/ClickListener.java
@@ -3,5 +3,5 @@ package dev.wolveringer.BungeeUtil.item;
 import dev.wolveringer.BungeeUtil.item.ItemStack.Click;
 
 public interface ClickListener {
-	public void click(Click click);
+    public void click(Click click);
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/item/Item.java b/src/main/java/dev/wolveringer/BungeeUtil/item/Item.java
index eadc289..6a1680f 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/item/Item.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/item/Item.java
@@ -10,407 +10,386 @@ import dev.wolveringer.BungeeUtil.item.itemmeta.MetaFactory;
 import dev.wolveringer.configuration.serialization.ConfigurationSerializable;
 import dev.wolveringer.nbt.NBTTagCompound;
 
-public class Item{
-	/**
-	 * Required method for configuration serialization
-	 *
-	 * @param args
-	 *            map to deserialize
-	 * @return deserialized item stack
-	 * @see ConfigurationSerializable
-	 */
-	public static Item deserialize(Map<String, Object> args) {
-		Material type = Material.getMaterial((String) args.get("type"));
-		short damage = 0;
-		int amount = 1;
-
-		if(args.containsKey("damage")){
-			damage = ((Number) args.get("damage")).shortValue();
-		}
-
-		if(args.containsKey("amount")){
-			amount = (Integer) args.get("amount");
-		}
-
-		Item result = new Item(type, amount, damage);
-
-		if(args.containsKey("meta")){ // We cannot and will not have meta when enchantments (pre-ItemMeta) exist
-			Object raw = args.get("meta");
-			if(raw instanceof ItemMeta){
-				result.setTag(((ItemMeta) raw).getTag());
-			}
-		}
-
-		return result;
-	}
-
-	@SuppressWarnings("deprecation")
-	private static Material getType0(int id) {
-		Material material = Material.getMaterial(id);
-		return material == null ? Material.AIR : material;
-	}
-
-	private int amount = 0;
-	private MaterialData data = null;
-	private short durability = 0;
-	private ItemMeta meta;
-	private NBTTagCompound tag;
-	private int type = 0;
-
-	/**
-	 * Defaults stack size to 1, with no extra data
-	 *
-	 * @param type
-	 *            item material id
-	 * @deprecated Magic value
-	 */
-	@Deprecated
-	public Item(final int type) {
-		this(type, 1);
-	}
-
-	/**
-	 * An item stack with no extra data
-	 *
-	 * @param type
-	 *            item material id
-	 * @param amount
-	 *            stack size
-	 * @deprecated Magic value
-	 */
-	@Deprecated
-	public Item(final int type, final int amount) {
-		this(type, amount, (short) 0);
-	}
-
-	/**
-	 * An item stack with the specified damage / durability
-	 *
-	 * @param type
-	 *            item material id
-	 * @param amount
-	 *            stack size
-	 * @param damage
-	 *            durability / damage
-	 * @deprecated Magic value
-	 */
-	@Deprecated
-	public Item(final int type, final int amount, final short damage) {
-		this.type = type;
-		this.amount = amount;
-		this.durability = damage;
-		this.meta = MetaFactory.getItemMeta(this);
-	}
-
-	/**
-	 * @deprecated this method uses an ambiguous data byte object
-	 */
-	@Deprecated
-	public Item(final int type, final int amount, final short damage, final Byte data) {
-		this.type = type;
-		this.amount = amount;
-		this.durability = damage;
-		if(data != null){
-			createData(data);
-			this.durability = data;
-		}
-		this.meta = MetaFactory.getItemMeta(this);
-	}
-
-	/**
-	 * Creates a new item stack derived from the specified stack
-	 *
-	 * @param stack
-	 *            the stack to copy
-	 * @throws IllegalArgumentException
-	 *             if the specified stack is null or
-	 *             returns an item meta not created by the item factory
-	 */
-	public Item(final Item stack) throws IllegalArgumentException {
-		this.type = stack.getTypeId();
-		this.amount = stack.getAmount();
-		this.durability = stack.getDurability();
-		this.data = stack.getData();
-		this.tag = stack.tag;
-		this.meta = getItemMeta();
-	}
-
-	/**
-	 * Defaults stack size to 1, with no extra data
-	 *
-	 * @param type
-	 *            item material
-	 */
-	public Item(final Material type) {
-		this(type, 1);
-	}
-
-	/**
-	 * An item stack with no extra data
-	 *
-	 * @param type
-	 *            item material
-	 * @param amount
-	 *            stack size
-	 */
-	@SuppressWarnings("deprecation")
-	public Item(final Material type, final int amount) {
-		this(type.getId(), amount);
-	}
-
-	/**
-	 * An item stack with the specified damage / durabiltiy
-	 *
-	 * @param type
-	 *            item material
-	 * @param amount
-	 *            stack size
-	 * @param damage
-	 *            durability / damage
-	 */
-	@SuppressWarnings("deprecation")
-	public Item(final Material type, final int amount, final short damage) {
-		this((type == null ? Material.AIR : type).getId(), amount, damage);
-	}
-
-	/**
-	 * @deprecated this method uses an ambiguous data byte object
-	 */
-	@Deprecated
-	public Item(final Material type, final int amount, final short damage, final Byte data) {
-		this(type.getId(), amount, damage, data);
-	}
-
-	@SuppressWarnings("deprecation")
-	private void createData(final byte data) {
-		Material mat = Material.getMaterial(type);
-		if(mat == null){
-			this.data = new MaterialData(type, data);
-		}else{
-			this.data = new MaterialData(data);
-		}
-	}
-
-	@Override
-	public boolean equals(Object obj) {
-		if(this == obj){
-			return true;
-		}
-		if(!(obj instanceof Item)){
-			return false;
-		}
-
-		Item stack = (Item) obj;
-		return getAmount() == stack.getAmount() && isSimilar(stack);
-	}
-
-	/**
-	 * Gets the amount of items in this stack
-	 *
-	 * @return Amount of items in this stick
-	 */
-	public int getAmount() {
-		return amount;
-	}
-
-	/**
-	 * Gets the MaterialData for this stack of items
-	 *
-	 * @return MaterialData for this item
-	 */
-	public MaterialData getData() {
-		Material mat = getType();
-		if(data == null && mat != null){
-			data = new MaterialData(this.getDurability());
-		}
-
-		return data;
-	}
-
-	/**
-	 * Gets the durability of this item
-	 *
-	 * @return Durability of this item
-	 */
-	public short getDurability() {
-		return durability;
-	}
-
-	/**
-	 * Get a copy of this ItemStack's {@link ItemMeta}.
-	 *
-	 * @return a copy of the current ItemStack's ItemData
-	 */
-	public ItemMeta getItemMeta() {
-		return this.meta == null ? this.meta = MetaFactory.getItemMeta(this) : this.meta;
-	}
-
-	/**
-	 * Get the maximum stacksize for the material hold in this ItemStack.
-	 * (Returns -1 if it has no idea)
-	 *
-	 * @return The maximum you can stack this material to.
-	 */
-	public int getMaxStackSize() {
-		Material material = getType();
-		if(material != null){
-			return material.getMaxStackSize();
-		}
-		return -1;
-	}
-
-	public NBTTagCompound getTag() {
-		return tag;
-	}
-
-	/**
-	 * Gets the type of this item
-	 *
-	 * @return Type of the items in this stack
-	 */
-	public Material getType() {
-		return getType0(getTypeId());
-	}
-
-	/**
-	 * Gets the type id of this item
-	 *
-	 * @return Type Id of the items in this stack
-	 * @deprecated Magic value
-	 */
-	@Deprecated
-	public int getTypeId() {
-		return type;
-	}
-
-	@Override
-	public final int hashCode() {
-		int hash = 1;
-
-		hash = hash * 31 + getTypeId();
-		hash = hash * 31 + getAmount();
-		hash = hash * 31 + (getDurability() & 0xffff);
-		hash = hash * 31 + (hasItemMeta() ? meta == null ? getItemMeta().hashCode() : meta.hashCode() : 0);
-
-		return hash;
-	}
-
-	/**
-	 * Checks to see if any meta data has been defined.
-	 *
-	 * @return Returns true if some meta data has been set for this item
-	 */
-	public boolean hasItemMeta() {
-		return !MetaFactory.equals(meta, null);
-	}
-
-	/**
-	 * This method is the same as equals, but does not consider stack size
-	 * (amount).
-	 *
-	 * @param stack
-	 *            the item stack to compare to
-	 * @return true if the two stacks are equal, ignoring the amount
-	 */
-	public boolean isSimilar(Item stack) {
-		if(stack == null){
-			return false;
-		}
-		if(stack == this){
-			return true;
-		}
-		return getTypeId() == stack.getTypeId() && getDurability() == stack.getDurability() && MetaFactory.equals(getItemMeta(), stack.getItemMeta());
-	}
-
-	public Map<String, Object> serialize() {
-		Map<String, Object> result = new LinkedHashMap<String, Object>();
-
-		result.put("type", getType().name());
-
-		if(getDurability() != 0){
-			result.put("damage", getDurability());
-		}
-
-		if(getAmount() != 1){
-			result.put("amount", getAmount());
-		}
-
-		ItemMeta meta = getItemMeta();
-		if(!MetaFactory.equals(meta, null)){
-			result.put("meta", meta);
-		}
-		return result;
-	}
-
-	/**
-	 * Sets the amount of items in this stack
-	 *
-	 * @param amount
-	 *            New amount of items in this stack
-	 */
-	public void setAmount(int amount) {
-		this.amount = amount;
-	}
-
-	/**
-	 * Sets the MaterialData for this stack of items
-	 *
-	 * @param data
-	 *            New MaterialData for this item
-	 */
-	public void setData(MaterialData data) {
-		getType();
-		this.data = data;
-	}
-
-	/**
-	 * Sets the durability of this item
-	 *
-	 * @param durability
-	 *            Durability of this item
-	 */
-	public void setDurability(final short durability) {
-		this.durability = durability;
-	}
-
-	public void setTag(NBTTagCompound b) {
-		this.tag = b;
-	}
-
-	/**
-	 * Sets the type of this item
-	 * <p>
-	 * Note that in doing so you will reset the MaterialData for this stack
-	 *
-	 * @param type
-	 *            New type to set the items in this stack to
-	 */
-	@SuppressWarnings("deprecation")
-	public void setType(Material type) {
-		setTypeId(type.getId());
-	}
-
-	/**
-	 * Sets the type id of this item
-	 * <p>
-	 * Note that in doing so you will reset the MaterialData for this stack
-	 *
-	 * @param type
-	 *            New type id to set the items in this stack to
-	 * @deprecated Magic value
-	 */
-	@Deprecated
-	public void setTypeId(int type) {
-		this.type = type;
-		createData((byte) 0);
-	}
-
-	@Override
-	public String toString() {
-		return "Item@" + System.identityHashCode(this) + "[amount=" + amount + ", data=" + data + ", durability=" + durability + ", meta=" + meta + ", tag=" + tag + ", type=" + type + "]";
-	}
-
-	public boolean hasTag() {
-		return meta==null||meta.hasTag();
-	}
+public class Item {
+    private int amount = 0;
+    private MaterialData data = null;
+    private short durability = 0;
+    private ItemMeta meta;
+    private NBTTagCompound tag;
+    private int type = 0;
+
+    /**
+     * Defaults stack size to 1, with no extra data
+     *
+     * @param type item material id
+     * @deprecated Magic value
+     */
+    @Deprecated
+    public Item(final int type) {
+        this(type, 1);
+    }
+
+    /**
+     * An item stack with no extra data
+     *
+     * @param type   item material id
+     * @param amount stack size
+     * @deprecated Magic value
+     */
+    @Deprecated
+    public Item(final int type, final int amount) {
+        this(type, amount, (short) 0);
+    }
+
+    /**
+     * An item stack with the specified damage / durability
+     *
+     * @param type   item material id
+     * @param amount stack size
+     * @param damage durability / damage
+     * @deprecated Magic value
+     */
+    @Deprecated
+    public Item(final int type, final int amount, final short damage) {
+        this.type = type;
+        this.amount = amount;
+        this.durability = damage;
+        this.meta = MetaFactory.getItemMeta(this);
+    }
+
+    /**
+     * @deprecated this method uses an ambiguous data byte object
+     */
+    @Deprecated
+    public Item(final int type, final int amount, final short damage, final Byte data) {
+        this.type = type;
+        this.amount = amount;
+        this.durability = damage;
+        if (data != null) {
+            createData(data);
+            this.durability = data;
+        }
+        this.meta = MetaFactory.getItemMeta(this);
+    }
+
+    /**
+     * Creates a new item stack derived from the specified stack
+     *
+     * @param stack the stack to copy
+     * @throws IllegalArgumentException if the specified stack is null or returns an item meta not
+     *                                  created by the item factory
+     */
+    public Item(final Item stack) throws IllegalArgumentException {
+        this.type = stack.getTypeId();
+        this.amount = stack.getAmount();
+        this.durability = stack.getDurability();
+        this.data = stack.getData();
+        this.tag = stack.tag;
+        this.meta = getItemMeta();
+    }
+
+    /**
+     * Defaults stack size to 1, with no extra data
+     *
+     * @param type item material
+     */
+    public Item(final Material type) {
+        this(type, 1);
+    }
+
+    /**
+     * An item stack with no extra data
+     *
+     * @param type   item material
+     * @param amount stack size
+     */
+    @SuppressWarnings("deprecation")
+    public Item(final Material type, final int amount) {
+        this(type.getId(), amount);
+    }
+
+    /**
+     * An item stack with the specified damage / durabiltiy
+     *
+     * @param type   item material
+     * @param amount stack size
+     * @param damage durability / damage
+     */
+    @SuppressWarnings("deprecation")
+    public Item(final Material type, final int amount, final short damage) {
+        this((type == null ? Material.AIR : type).getId(), amount, damage);
+    }
+
+    /**
+     * @deprecated this method uses an ambiguous data byte object
+     */
+    @Deprecated
+    public Item(final Material type, final int amount, final short damage, final Byte data) {
+        this(type.getId(), amount, damage, data);
+    }
+
+    /**
+     * Required method for configuration serialization
+     *
+     * @param args map to deserialize
+     * @return deserialized item stack
+     * @see ConfigurationSerializable
+     */
+    public static Item deserialize(Map<String, Object> args) {
+        Material type = Material.getMaterial((String) args.get("type"));
+        short damage = 0;
+        int amount = 1;
+
+        if (args.containsKey("damage")) {
+            damage = ((Number) args.get("damage")).shortValue();
+        }
+
+        if (args.containsKey("amount")) {
+            amount = (Integer) args.get("amount");
+        }
+
+        Item result = new Item(type, amount, damage);
+
+        if (args.containsKey("meta")) { // We cannot and will not have meta when enchantments (pre-ItemMeta) exist
+            Object raw = args.get("meta");
+            if (raw instanceof ItemMeta) {
+                result.setTag(((ItemMeta) raw).getTag());
+            }
+        }
+
+        return result;
+    }
+
+    @SuppressWarnings("deprecation")
+    private static Material getType0(int id) {
+        Material material = Material.getMaterial(id);
+        return material == null ? Material.AIR : material;
+    }
+
+    @SuppressWarnings("deprecation")
+    private void createData(final byte data) {
+        Material mat = Material.getMaterial(type);
+        if (mat == null) {
+            this.data = new MaterialData(type, data);
+        } else {
+            this.data = new MaterialData(data);
+        }
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj) {
+            return true;
+        }
+        if (!(obj instanceof Item)) {
+            return false;
+        }
+
+        Item stack = (Item) obj;
+        return getAmount() == stack.getAmount() && isSimilar(stack);
+    }
+
+    /**
+     * Gets the amount of items in this stack
+     *
+     * @return Amount of items in this stick
+     */
+    public int getAmount() {
+        return amount;
+    }
+
+    /**
+     * Sets the amount of items in this stack
+     *
+     * @param amount New amount of items in this stack
+     */
+    public void setAmount(int amount) {
+        this.amount = amount;
+    }
+
+    /**
+     * Gets the MaterialData for this stack of items
+     *
+     * @return MaterialData for this item
+     */
+    public MaterialData getData() {
+        Material mat = getType();
+        if (data == null && mat != null) {
+            data = new MaterialData(this.getDurability());
+        }
+
+        return data;
+    }
+
+    /**
+     * Sets the MaterialData for this stack of items
+     *
+     * @param data New MaterialData for this item
+     */
+    public void setData(MaterialData data) {
+        getType();
+        this.data = data;
+    }
+
+    /**
+     * Gets the durability of this item
+     *
+     * @return Durability of this item
+     */
+    public short getDurability() {
+        return durability;
+    }
+
+    /**
+     * Sets the durability of this item
+     *
+     * @param durability Durability of this item
+     */
+    public void setDurability(final short durability) {
+        this.durability = durability;
+    }
+
+    /**
+     * Get a copy of this ItemStack's {@link ItemMeta}.
+     *
+     * @return a copy of the current ItemStack's ItemData
+     */
+    public ItemMeta getItemMeta() {
+        return this.meta == null ? this.meta = MetaFactory.getItemMeta(this) : this.meta;
+    }
+
+    /**
+     * Get the maximum stacksize for the material hold in this ItemStack.
+     * (Returns -1 if it has no idea)
+     *
+     * @return The maximum you can stack this material to.
+     */
+    public int getMaxStackSize() {
+        Material material = getType();
+        if (material != null) {
+            return material.getMaxStackSize();
+        }
+        return -1;
+    }
+
+    public NBTTagCompound getTag() {
+        return tag;
+    }
+
+    public void setTag(NBTTagCompound b) {
+        this.tag = b;
+    }
+
+    /**
+     * Gets the type of this item
+     *
+     * @return Type of the items in this stack
+     */
+    public Material getType() {
+        return getType0(getTypeId());
+    }
+
+    /**
+     * Sets the type of this item
+     * <p>
+     * Note that in doing so you will reset the MaterialData for this stack
+     *
+     * @param type New type to set the items in this stack to
+     */
+    @SuppressWarnings("deprecation")
+    public void setType(Material type) {
+        setTypeId(type.getId());
+    }
+
+    /**
+     * Gets the type id of this item
+     *
+     * @return Type Id of the items in this stack
+     * @deprecated Magic value
+     */
+    @Deprecated
+    public int getTypeId() {
+        return type;
+    }
+
+    /**
+     * Sets the type id of this item
+     * <p>
+     * Note that in doing so you will reset the MaterialData for this stack
+     *
+     * @param type New type id to set the items in this stack to
+     * @deprecated Magic value
+     */
+    @Deprecated
+    public void setTypeId(int type) {
+        this.type = type;
+        createData((byte) 0);
+    }
+
+    @Override
+    public final int hashCode() {
+        int hash = 1;
+
+        hash = hash * 31 + getTypeId();
+        hash = hash * 31 + getAmount();
+        hash = hash * 31 + (getDurability() & 0xffff);
+        hash = hash * 31 + (hasItemMeta() ? meta == null ? getItemMeta().hashCode() : meta.hashCode() : 0);
+
+        return hash;
+    }
+
+    /**
+     * Checks to see if any meta data has been defined.
+     *
+     * @return Returns true if some meta data has been set for this item
+     */
+    public boolean hasItemMeta() {
+        return !MetaFactory.equals(meta, null);
+    }
+
+    /**
+     * This method is the same as equals, but does not consider stack size
+     * (amount).
+     *
+     * @param stack the item stack to compare to
+     * @return true if the two stacks are equal, ignoring the amount
+     */
+    public boolean isSimilar(Item stack) {
+        if (stack == null) {
+            return false;
+        }
+        if (stack == this) {
+            return true;
+        }
+        return getTypeId() == stack.getTypeId() && getDurability() == stack.getDurability() && MetaFactory.equals(getItemMeta(), stack.getItemMeta());
+    }
+
+    public Map<String, Object> serialize() {
+        Map<String, Object> result = new LinkedHashMap<String, Object>();
+
+        result.put("type", getType().name());
+
+        if (getDurability() != 0) {
+            result.put("damage", getDurability());
+        }
+
+        if (getAmount() != 1) {
+            result.put("amount", getAmount());
+        }
+
+        ItemMeta meta = getItemMeta();
+        if (!MetaFactory.equals(meta, null)) {
+            result.put("meta", meta);
+        }
+        return result;
+    }
+
+    @Override
+    public String toString() {
+        return "Item@" + System.identityHashCode(this) + "[amount=" + amount + ", data=" + data + ", durability=" + durability + ", meta=" + meta + ", tag=" + tag + ", type=" + type + "]";
+    }
+
+    public boolean hasTag() {
+        return meta == null || meta.hasTag();
+    }
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/item/ItemBuilder.java b/src/main/java/dev/wolveringer/BungeeUtil/item/ItemBuilder.java
index 668bc39..f64116e 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/item/ItemBuilder.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/item/ItemBuilder.java
@@ -3,133 +3,131 @@ package dev.wolveringer.BungeeUtil.item;
 import java.util.ArrayList;
 
 import dev.wolveringer.BungeeUtil.Material;
-import dev.wolveringer.BungeeUtil.item.Item;
-import dev.wolveringer.BungeeUtil.item.ItemStack;
 import dev.wolveringer.BungeeUtil.item.ItemStack.Click;
 
 public class ItemBuilder {
-	public static ItemBuilder create() {
-		return new ItemBuilder();
-	}
-
-	public static ItemBuilder create(Material m) {
-		return create(m.getId());
-	}
-
-	public static ItemBuilder create(int id) {
-		return new ItemBuilder(id);
-	}
-
-	public static ItemBuilder create(Item handle) {
-		return new ItemBuilder(handle);
-	}
-
-	private int id;
-	private int sid = -1;
-	private int amouth = -1;
-	private String name;
-	private ArrayList<String> lore = new ArrayList<>();
-	private boolean glow;
-	private ClickListener listener;
-	private Item handle;
-
-	public ItemBuilder(int id) {
-		this.id = id;
-	}
-
-	public ItemBuilder(Item handle) {
-		this.handle = new Item(handle); //Copy
-	}
-
-	public ItemBuilder() {
-	}
-
-	public ItemBuilder name(String name) {
-		this.name = name;
-		return this;
-	}
-
-	public ItemBuilder lore(String lore) {
-		this.lore.add(lore);
-		return this;
-	}
-
-	public ItemBuilder glow() {
-		this.glow = true;
-		return this;
-	}
-
-	public ItemBuilder glow(boolean flag) {
-		this.glow = flag;
-		return this;
-	}
-
-	public ItemBuilder durbility(int short_) {
-		this.sid = short_;
-		return this;
-	}
-
-	public ItemBuilder amount(int n) {
-		this.amouth = n;
-		return this;
-	}
-
-	public ItemBuilder listener(ClickListener run) {
-		this.listener = run;
-		return this;
-	}
-	
-	public ItemBuilder listener(final Runnable run) {
-		this.listener = new ClickListener() {
-			@Override
-			public void click(Click click) {
-				run.run();				
-			}
-		};
-		return this;
-	}
-
-	public ItemBuilder id(int id) {
-		this.id = id;
-		return this;
-	}
-
-	public ItemBuilder material(Material m) {
-		this.id = m.getId();
-		return this;
-	}
-
-	public Item build() {
-		Item i;
-		if (handle != null) {
-			if (id != 0)
-				handle.setTypeId(id);
-			if (sid != -1)
-				handle.setDurability((short) sid);
-			if(amouth != -1)
-				handle.setAmount(amouth);
-			i = handle;
-		} else
-			i = new Item(id, amouth == -1 ? 1 : amouth, (short) (sid == -1 ? 0 : sid));
-		if (listener != null) {
-			i = new ItemStack(i) {
-				@Override
-				public void click(Click c) {
-					listener.click(c);
-				}
-			};
-		}
-		if (name != null)
-			i.getItemMeta().setDisplayName(name);
-		if (!lore.isEmpty())
-			i.getItemMeta().setLore(lore);
-		if (glow)
-			i.getItemMeta().setGlow(true);
-		return i;
-	}
-
-	public ItemBuilder clearLore() {
-		lore.clear();
-		return this;
-	}
+    private int id;
+    private int sid = -1;
+    private int amouth = -1;
+    private String name;
+    private ArrayList<String> lore = new ArrayList<>();
+    private boolean glow;
+    private ClickListener listener;
+    private Item handle;
+
+    public ItemBuilder(int id) {
+        this.id = id;
+    }
+
+    public ItemBuilder(Item handle) {
+        this.handle = new Item(handle); //Copy
+    }
+
+    public ItemBuilder() {
+    }
+
+    public static ItemBuilder create() {
+        return new ItemBuilder();
+    }
+
+    public static ItemBuilder create(Material m) {
+        return create(m.getId());
+    }
+
+    public static ItemBuilder create(int id) {
+        return new ItemBuilder(id);
+    }
+
+    public static ItemBuilder create(Item handle) {
+        return new ItemBuilder(handle);
+    }
+
+    public ItemBuilder name(String name) {
+        this.name = name;
+        return this;
+    }
+
+    public ItemBuilder lore(String lore) {
+        this.lore.add(lore);
+        return this;
+    }
+
+    public ItemBuilder glow() {
+        this.glow = true;
+        return this;
+    }
+
+    public ItemBuilder glow(boolean flag) {
+        this.glow = flag;
+        return this;
+    }
+
+    public ItemBuilder durbility(int short_) {
+        this.sid = short_;
+        return this;
+    }
+
+    public ItemBuilder amount(int n) {
+        this.amouth = n;
+        return this;
+    }
+
+    public ItemBuilder listener(ClickListener run) {
+        this.listener = run;
+        return this;
+    }
+
+    public ItemBuilder listener(final Runnable run) {
+        this.listener = new ClickListener() {
+            @Override
+            public void click(Click click) {
+                run.run();
+            }
+        };
+        return this;
+    }
+
+    public ItemBuilder id(int id) {
+        this.id = id;
+        return this;
+    }
+
+    public ItemBuilder material(Material m) {
+        this.id = m.getId();
+        return this;
+    }
+
+    public Item build() {
+        Item i;
+        if (handle != null) {
+            if (id != 0)
+                handle.setTypeId(id);
+            if (sid != -1)
+                handle.setDurability((short) sid);
+            if (amouth != -1)
+                handle.setAmount(amouth);
+            i = handle;
+        } else
+            i = new Item(id, amouth == -1 ? 1 : amouth, (short) (sid == -1 ? 0 : sid));
+        if (listener != null) {
+            i = new ItemStack(i) {
+                @Override
+                public void click(Click c) {
+                    listener.click(c);
+                }
+            };
+        }
+        if (name != null)
+            i.getItemMeta().setDisplayName(name);
+        if (!lore.isEmpty())
+            i.getItemMeta().setLore(lore);
+        if (glow)
+            i.getItemMeta().setGlow(true);
+        return i;
+    }
+
+    public ItemBuilder clearLore() {
+        lore.clear();
+        return this;
+    }
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/item/ItemStack.java b/src/main/java/dev/wolveringer/BungeeUtil/item/ItemStack.java
index cd38a92..131382b 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/item/ItemStack.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/item/ItemStack.java
@@ -6,79 +6,79 @@ import dev.wolveringer.api.inventory.Inventory;
 
 public abstract class ItemStack extends Item {
 
-	public ItemStack(Item stack) throws IllegalArgumentException {
-		super(stack);
-	}
-
-	public ItemStack(Material type) {
-		super(type);
-	}
-
-	public ItemStack(Material type, int amount) {
-		super(type, amount);
-	}
-
-	public ItemStack(Material type, int amount, short damage) {
-		super(type, amount, damage);
-	}
-
-	@SuppressWarnings("deprecation")
-	public ItemStack(int type, int amount, short damage) {
-		super(type, amount, damage);
-	}
-
-	public abstract void click(Click click);
-
-	public static class Click {
-		private Player player;
-		private int slot;
-		private Inventory inventory;
-		private int mode;
-		private boolean cancel = true;
-		private Item item;
-		private boolean sync;
-		
-		public Click(Player p, int slot, Inventory inv,Item ci, int mode,boolean sync) {
-			this.player = p;
-			this.slot = slot;
-			this.inventory = inv;
-			this.mode = mode;
-			this.item = ci;
-			this.sync = sync;
-		}
-
-		public Player getPlayer() {
-			return player;
-		}
-
-		public int getSlot() {
-			return slot;
-		}
-
-		public Inventory getInventory() {
-			return inventory;
-		}
-
-		public int getMode() {
-			return mode;
-		}
-		
-		public Item getItem() {
-			return item;
-		}
-		
-		@Deprecated
-		public void setCancelled(boolean b) {
-			this.cancel = b;
-		}
-
-		@Deprecated
-		public boolean isCancelled() {
-			return cancel;
-		}
-		
-		public boolean isSyncHandle() {
-			return sync;
-		}
-	}
+    public ItemStack(Item stack) throws IllegalArgumentException {
+        super(stack);
+    }
+
+    public ItemStack(Material type) {
+        super(type);
+    }
+
+    public ItemStack(Material type, int amount) {
+        super(type, amount);
+    }
+
+    public ItemStack(Material type, int amount, short damage) {
+        super(type, amount, damage);
+    }
+
+    @SuppressWarnings("deprecation")
+    public ItemStack(int type, int amount, short damage) {
+        super(type, amount, damage);
+    }
+
+    public abstract void click(Click click);
+
+    public static class Click {
+        private Player player;
+        private int slot;
+        private Inventory inventory;
+        private int mode;
+        private boolean cancel = true;
+        private Item item;
+        private boolean sync;
+
+        public Click(Player p, int slot, Inventory inv, Item ci, int mode, boolean sync) {
+            this.player = p;
+            this.slot = slot;
+            this.inventory = inv;
+            this.mode = mode;
+            this.item = ci;
+            this.sync = sync;
+        }
+
+        public Player getPlayer() {
+            return player;
+        }
+
+        public int getSlot() {
+            return slot;
+        }
+
+        public Inventory getInventory() {
+            return inventory;
+        }
+
+        public int getMode() {
+            return mode;
+        }
+
+        public Item getItem() {
+            return item;
+        }
+
+        @Deprecated
+        public boolean isCancelled() {
+            return cancel;
+        }
+
+        @Deprecated
+        public void setCancelled(boolean b) {
+            this.cancel = b;
+        }
+
+        public boolean isSyncHandle() {
+            return sync;
+        }
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/item/MultiClickItemStack.java b/src/main/java/dev/wolveringer/BungeeUtil/item/MultiClickItemStack.java
index e79bd28..a86caf7 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/item/MultiClickItemStack.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/item/MultiClickItemStack.java
@@ -4,38 +4,40 @@ import java.util.ArrayList;
 
 import dev.wolveringer.BungeeUtil.Material;
 
-public class MultiClickItemStack extends ItemStack{
-	private ArrayList<ClickListener> listener = new ArrayList<>();
-	public MultiClickItemStack(int type, int amount, short damage) {
-		super(type, amount, damage);
-	}
-
-	public MultiClickItemStack(Item stack) throws IllegalArgumentException {
-		super(stack);
-	}
-
-	public MultiClickItemStack(Material type, int amount, short damage) {
-		super(type, amount, damage);
-	}
-
-	public MultiClickItemStack(Material type, int amount) {
-		super(type, amount);
-	}
-
-	public MultiClickItemStack(Material type) {
-		super(type);
-	}
-	
-	public void addClickListener(ClickListener listener){
-		this.listener.add(listener);
-	}
-	public void removeListener(ClickListener listener){
-		this.listener.remove(listener);
-	}
-	
-	@Override
-	public void click(Click p) {
-		for(ClickListener c : listener)
-			c.click(p);
-	}
+public class MultiClickItemStack extends ItemStack {
+    private ArrayList<ClickListener> listener = new ArrayList<>();
+
+    public MultiClickItemStack(int type, int amount, short damage) {
+        super(type, amount, damage);
+    }
+
+    public MultiClickItemStack(Item stack) throws IllegalArgumentException {
+        super(stack);
+    }
+
+    public MultiClickItemStack(Material type, int amount, short damage) {
+        super(type, amount, damage);
+    }
+
+    public MultiClickItemStack(Material type, int amount) {
+        super(type, amount);
+    }
+
+    public MultiClickItemStack(Material type) {
+        super(type);
+    }
+
+    public void addClickListener(ClickListener listener) {
+        this.listener.add(listener);
+    }
+
+    public void removeListener(ClickListener listener) {
+        this.listener.remove(listener);
+    }
+
+    @Override
+    public void click(Click p) {
+        for (ClickListener c : listener)
+            c.click(p);
+    }
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/item/SyncHandle.java b/src/main/java/dev/wolveringer/BungeeUtil/item/SyncHandle.java
index e73fc12..e2f1c8d 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/item/SyncHandle.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/item/SyncHandle.java
@@ -7,4 +7,5 @@ import java.lang.annotation.Target;
 
 @Target(ElementType.METHOD)
 @Retention(RetentionPolicy.RUNTIME)
-public @interface SyncHandle {}
+public @interface SyncHandle {
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/item/Test.java b/src/main/java/dev/wolveringer/BungeeUtil/item/Test.java
index 6d0614b..905cc9c 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/item/Test.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/item/Test.java
@@ -4,11 +4,14 @@ import dev.wolveringer.BungeeUtil.Material;
 import dev.wolveringer.BungeeUtil.item.itemmeta.CraftItemMeta;
 
 public class Test {
-	public static void main(String[] args) {
-		ItemStack is = new ItemStack(Material.STONE){
-			@SyncHandle
-			public void click(Click click) {};
-		};
-		System.out.println(((CraftItemMeta)is.getItemMeta()).isClickSync());
-	}
+    public static void main(String[] args) {
+        ItemStack is = new ItemStack(Material.STONE) {
+            @SyncHandle
+            public void click(Click click) {
+            }
+
+            ;
+        };
+        System.out.println(((CraftItemMeta) is.getItemMeta()).isClickSync());
+    }
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/item/itemmeta/CraftItemMeta.java b/src/main/java/dev/wolveringer/BungeeUtil/item/itemmeta/CraftItemMeta.java
index 39589f8..bd90664 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/item/itemmeta/CraftItemMeta.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/item/itemmeta/CraftItemMeta.java
@@ -1,17 +1,14 @@
 package dev.wolveringer.BungeeUtil.item.itemmeta;
 
-import java.lang.annotation.Annotation;
 import java.lang.reflect.Method;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.List;
 
 import dev.wolveringer.BungeeUtil.BungeeUtil;
-import dev.wolveringer.BungeeUtil.Main;
 import dev.wolveringer.BungeeUtil.item.Item;
 import dev.wolveringer.BungeeUtil.item.ItemStack;
-import dev.wolveringer.BungeeUtil.item.SyncHandle;
 import dev.wolveringer.BungeeUtil.item.ItemStack.Click;
+import dev.wolveringer.BungeeUtil.item.SyncHandle;
 import dev.wolveringer.api.inventory.Inventory;
 import dev.wolveringer.nbt.NBTTagCompound;
 import dev.wolveringer.nbt.NBTTagList;
@@ -19,160 +16,161 @@ import dev.wolveringer.nbt.NBTTagString;
 import dev.wolveringer.util.UtilReflection;
 
 public class CraftItemMeta implements ItemMeta {
-	protected Item item;
-	protected ArrayList<MetaListener> listener = new ArrayList<MetaListener>();
-	private int sync = -1;
-	
-	public CraftItemMeta(Item i) {
-		this.item = i;
-	}
-
-	@Override
-	public String getDisplayName() {
-		if (!getTag().hasKey("display"))
-			getTag().set("display", new NBTTagCompound());
-		return hasDisplayName() ? getTag().getCompound("display").getString("Name") : "";
-	}
-
-	@Override
-	public List<String> getLore() {
-		if (!hasLore())
-			return new ArrayList<String>();
-		List<String> l = new ArrayList<>();
-		NBTTagList x = getTag().getCompound("display").getList("Lore");
-		for (int y = 0; y < x.size(); y++)
-			l.add(x.getString(y));
-		return l;
-	}
-
-	@Override
-	public boolean hasDisplayName() {
-		return getTag() != null && getTag().hasKey("display") && getTag().getCompound("display").hasKey("Name");
-	}
-
-	@Override
-	public boolean hasLore() {
-		return getTag() != null && getTag().hasKey("display") && getTag().getCompound("display").hasKey("Lore");
-	}
-
-	@Override
-	public void setDisplayName(String name) {
-		if (!getTag().hasKey("display"))
-			getTag().set("display", new NBTTagCompound());
-		getTag().getCompound("display").set("Name", new NBTTagString(name));
-		fireUpdate();
-	}
-
-	@Override
-	public void setGlow(boolean b) {
-		if (b) {
-			if (!getTag().hasKey("ench"))
-				getTag().set("ench", new NBTTagList());
-		} else if (!b) {
-			if (getTag().hasKey("ench"))
-				getTag().remove("ench");
-		}
-		fireUpdate();
-	}
-
-	@Override
-	public boolean hasGlow() {
-		return getTag() != null && getTag().hasKey("ench");
-	}
-
-	@Override
-	public void setLore(List<String> lore) {
-		if (!getTag().hasKey("display"))
-			getTag().set("display", new NBTTagCompound());
-		NBTTagList l = new NBTTagList();
-		for (String s : lore)
-			l.add(new NBTTagString(s));
-		getTag().getCompound("display").set("Lore", l);
-		fireUpdate();
-	}
-
-	@Override
-	public boolean hasTag() {
-		return getTag() != null && !getTag().isEmpty();
-	}
-
-	public NBTTagCompound getTag() {
-		if (item.getTag() == null)
-			item.setTag(new NBTTagCompound());
-		return item.getTag();
-	}
-
-	protected void fireUpdate() {
-		for (StackTraceElement e : Thread.currentThread().getStackTrace())
-			if (e.getClassName().contains(Inventory.class.getCanonicalName() + "$2")
-					&& e.getMethodName().equalsIgnoreCase("onUpdate")) // recall
-																		// in
-																		// update
-				return;
-		if (listener.size() != 0){
-			try{
-			for (MetaListener l : new ArrayList<>(listener))
-				if (l != null)
-					l.onUpdate(item);
-			}catch(NegativeArraySizeException e){
-				System.out.println("NegativeArraySizeException from ArrayList?! I'm crazy! size()->"+listener.size());
-			}
-		}
-	}
-
-	public void addMetaListener(MetaListener listener) {
-		this.listener.add(listener);
-	}
-
-	public void removeMetaListener(MetaListener listener) {
-		this.listener.remove(listener);
-	}
-
-	public boolean isClickSync(){
-		if(sync == -1){
-			if(!(item instanceof ItemStack))
-				sync = 0;
-			ItemStack is = (ItemStack) item;
-			try{
-				Method m = UtilReflection.getMethod(is.getClass(), "click", Click.class);
-				sync = m.isAnnotationPresent(SyncHandle.class) ? 1 : 0;
-				BungeeUtil.getInstance().debug((sync == 1 ? "Sync-":"Ansync-")+"Click handeling for "+m.getDeclaringClass().getName()+"#"+m.getName());
-			}catch(Exception e){
-				BungeeUtil.getInstance().debug(e, "Exception while try to detect sync handeling....");
-			}
-		}
-		return sync == 1;
-	}
-	
-	@Override
-	public String toString() {
-		return "CraftItemMeta@" + System.identityHashCode(this) + "[listener=" + listener + "]";
-	}
-
-	@Override
-	public int hashCode() {
-		final int prime = 31;
-		int result = 1;
-		result = prime * result + ((item == null) ? 0 : item.hashCode());
-		return result;
-	}
-
-	@Override
-	public boolean equals(Object obj) {
-		if (this == obj)
-			return true;
-		if (obj == null)
-			return false;
-		if (getClass() != obj.getClass())
-			return false;
-		CraftItemMeta other = (CraftItemMeta) obj;
-		if (item == null) {
-			if (other.item != null)
-				return false;
-		} else if (!item.getTag().equals(other.item.getTag()))
-			return false;
-		return true;
-	}
-
-	protected void build() {}
+    protected Item item;
+    protected ArrayList<MetaListener> listener = new ArrayList<MetaListener>();
+    private int sync = -1;
+
+    public CraftItemMeta(Item i) {
+        this.item = i;
+    }
+
+    @Override
+    public String getDisplayName() {
+        if (!getTag().hasKey("display"))
+            getTag().set("display", new NBTTagCompound());
+        return hasDisplayName() ? getTag().getCompound("display").getString("Name") : "";
+    }
+
+    @Override
+    public void setDisplayName(String name) {
+        if (!getTag().hasKey("display"))
+            getTag().set("display", new NBTTagCompound());
+        getTag().getCompound("display").set("Name", new NBTTagString(name));
+        fireUpdate();
+    }
+
+    @Override
+    public List<String> getLore() {
+        if (!hasLore())
+            return new ArrayList<String>();
+        List<String> l = new ArrayList<>();
+        NBTTagList x = getTag().getCompound("display").getList("Lore");
+        for (int y = 0; y < x.size(); y++)
+            l.add(x.getString(y));
+        return l;
+    }
+
+    @Override
+    public void setLore(List<String> lore) {
+        if (!getTag().hasKey("display"))
+            getTag().set("display", new NBTTagCompound());
+        NBTTagList l = new NBTTagList();
+        for (String s : lore)
+            l.add(new NBTTagString(s));
+        getTag().getCompound("display").set("Lore", l);
+        fireUpdate();
+    }
+
+    @Override
+    public boolean hasDisplayName() {
+        return getTag() != null && getTag().hasKey("display") && getTag().getCompound("display").hasKey("Name");
+    }
+
+    @Override
+    public boolean hasLore() {
+        return getTag() != null && getTag().hasKey("display") && getTag().getCompound("display").hasKey("Lore");
+    }
+
+    @Override
+    public void setGlow(boolean b) {
+        if (b) {
+            if (!getTag().hasKey("ench"))
+                getTag().set("ench", new NBTTagList());
+        } else if (!b) {
+            if (getTag().hasKey("ench"))
+                getTag().remove("ench");
+        }
+        fireUpdate();
+    }
+
+    @Override
+    public boolean hasGlow() {
+        return getTag() != null && getTag().hasKey("ench");
+    }
+
+    @Override
+    public boolean hasTag() {
+        return getTag() != null && !getTag().isEmpty();
+    }
+
+    public NBTTagCompound getTag() {
+        if (item.getTag() == null)
+            item.setTag(new NBTTagCompound());
+        return item.getTag();
+    }
+
+    protected void fireUpdate() {
+        for (StackTraceElement e : Thread.currentThread().getStackTrace())
+            if (e.getClassName().contains(Inventory.class.getCanonicalName() + "$2")
+                    && e.getMethodName().equalsIgnoreCase("onUpdate")) // recall
+                // in
+                // update
+                return;
+        if (listener.size() != 0) {
+            try {
+                for (MetaListener l : new ArrayList<>(listener))
+                    if (l != null)
+                        l.onUpdate(item);
+            } catch (NegativeArraySizeException e) {
+                System.out.println("NegativeArraySizeException from ArrayList?! I'm crazy! size()->" + listener.size());
+            }
+        }
+    }
+
+    public void addMetaListener(MetaListener listener) {
+        this.listener.add(listener);
+    }
+
+    public void removeMetaListener(MetaListener listener) {
+        this.listener.remove(listener);
+    }
+
+    public boolean isClickSync() {
+        if (sync == -1) {
+            if (!(item instanceof ItemStack))
+                sync = 0;
+            ItemStack is = (ItemStack) item;
+            try {
+                Method m = UtilReflection.getMethod(is.getClass(), "click", Click.class);
+                sync = m.isAnnotationPresent(SyncHandle.class) ? 1 : 0;
+                BungeeUtil.getInstance().debug((sync == 1 ? "Sync-" : "Ansync-") + "Click handeling for " + m.getDeclaringClass().getName() + "#" + m.getName());
+            } catch (Exception e) {
+                BungeeUtil.getInstance().debug(e, "Exception while try to detect sync handeling....");
+            }
+        }
+        return sync == 1;
+    }
+
+    @Override
+    public String toString() {
+        return "CraftItemMeta@" + System.identityHashCode(this) + "[listener=" + listener + "]";
+    }
+
+    @Override
+    public int hashCode() {
+        final int prime = 31;
+        int result = 1;
+        result = prime * result + ((item == null) ? 0 : item.hashCode());
+        return result;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj)
+            return true;
+        if (obj == null)
+            return false;
+        if (getClass() != obj.getClass())
+            return false;
+        CraftItemMeta other = (CraftItemMeta) obj;
+        if (item == null) {
+            if (other.item != null)
+                return false;
+        } else if (!item.getTag().equals(other.item.getTag()))
+            return false;
+        return true;
+    }
+
+    protected void build() {
+    }
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/item/itemmeta/ItemMeta.java b/src/main/java/dev/wolveringer/BungeeUtil/item/itemmeta/ItemMeta.java
index 1132cdb..0ac7243 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/item/itemmeta/ItemMeta.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/item/itemmeta/ItemMeta.java
@@ -12,63 +12,61 @@ import dev.wolveringer.nbt.NBTTagCompound;
  */
 public interface ItemMeta extends Cloneable {
 
-	/**
-	 * Gets the display name that is set.
-	 * <p>
-	 * Plugins should check that hasDisplayName() returns <code>true</code>
-	 * before calling this method.
-	 *
-	 * @return the display name that is set
-	 */
-	String getDisplayName();
+    /**
+     * Gets the display name that is set.
+     * <p>
+     * Plugins should check that hasDisplayName() returns <code>true</code>
+     * before calling this method.
+     *
+     * @return the display name that is set
+     */
+    String getDisplayName();
 
-	/**
-	 * Gets the lore that is set.
-	 * <p>
-	 * Plugins should check if hasLore() returns <code>true</code> before
-	 * calling this method.
-	 * 
-	 * @return a list of lore that is set
-	 */
-	List<String> getLore();
+    /**
+     * Sets the display name.
+     *
+     * @param name the name to set
+     */
+    void setDisplayName(String name);
 
-	/**
-	 * Checks for existence of a display name.
-	 *
-	 * @return true if this has a display name
-	 */
-	boolean hasDisplayName();
+    /**
+     * Gets the lore that is set.
+     * <p>
+     * Plugins should check if hasLore() returns <code>true</code> before
+     * calling this method.
+     *
+     * @return a list of lore that is set
+     */
+    List<String> getLore();
 
-	/**
-	 * Checks for existence of lore.
-	 *
-	 * @return true if this has lore
-	 */
-	boolean hasLore();
+    /**
+     * Sets the lore for this item.
+     * Removes lore when given null.
+     *
+     * @param lore the lore that will be set
+     */
+    void setLore(List<String> lore);
 
-	/**
-	 * Sets the display name.
-	 *
-	 * @param name
-	 *            the name to set
-	 */
-	void setDisplayName(String name);
+    /**
+     * Checks for existence of a display name.
+     *
+     * @return true if this has a display name
+     */
+    boolean hasDisplayName();
 
-	void setGlow(boolean b);
+    /**
+     * Checks for existence of lore.
+     *
+     * @return true if this has lore
+     */
+    boolean hasLore();
 
-	/**
-	 * Sets the lore for this item.
-	 * Removes lore when given null.
-	 *
-	 * @param lore
-	 *            the lore that will be set
-	 */
-	void setLore(List<String> lore);
+    void setGlow(boolean b);
 
-	boolean hasTag();
+    boolean hasTag();
 
-	boolean hasGlow();
+    boolean hasGlow();
+
+    NBTTagCompound getTag();
 
-	NBTTagCompound getTag();
-	
 }
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/item/itemmeta/MetaFactory.java b/src/main/java/dev/wolveringer/BungeeUtil/item/itemmeta/MetaFactory.java
index ddb29f1..4e2a57d 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/item/itemmeta/MetaFactory.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/item/itemmeta/MetaFactory.java
@@ -1,99 +1,104 @@
 package dev.wolveringer.BungeeUtil.item.itemmeta;
 
+import javassist.util.proxy.MethodHandler;
+import javassist.util.proxy.ProxyFactory;
+
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.util.ArrayList;
 import java.util.HashMap;
 
-import javassist.util.proxy.MethodHandler;
-import javassist.util.proxy.ProxyFactory;
 import dev.wolveringer.BungeeUtil.item.Item;
 
-@SuppressWarnings({ "deprecation", "rawtypes" })
+@SuppressWarnings({"deprecation", "rawtypes"})
 public class MetaFactory {
-	private static ItemMetaProxy proxy = new ItemMetaProxy();
-	public static boolean equals(ItemMeta meta, Object object) {
-		if(object == null && meta == null)
-			return true;
-		else if(object == null || meta == null){
-			return false;
-		}else if(!(object instanceof ItemMeta)){
-			return false;
-		}
-		ItemMeta im = (ItemMeta) object;
-		if(!im.getLore().equals(meta.getLore())){
-			return false;
-		}
-		if(!im.getDisplayName().equalsIgnoreCase(meta.getDisplayName())){
-			return false;
-		}
-		return true;
-	}
+    private static ItemMetaProxy proxy = new ItemMetaProxy();
 
-	public static ItemMeta getItemMeta(Item item) {
-		/*
-		switch (item.getType()) {
+    public static boolean equals(ItemMeta meta, Object object) {
+        if (object == null && meta == null)
+            return true;
+        else if (object == null || meta == null) {
+            return false;
+        } else if (!(object instanceof ItemMeta)) {
+            return false;
+        }
+        ItemMeta im = (ItemMeta) object;
+        if (!im.getLore().equals(meta.getLore())) {
+            return false;
+        }
+        if (!im.getDisplayName().equalsIgnoreCase(meta.getDisplayName())) {
+            return false;
+        }
+        return true;
+    }
+
+    public static ItemMeta getItemMeta(Item item) {
+        /*
+        switch (item.getType()) {
 			case SKULL_ITEM:
 				return createProxyInstance(SkullMeta.class,item);
 			default:
 				return createProxyInstance(CraftItemMeta.class,item);
 		}
 		*/
-		switch (item.getType()) {
-			case SKULL_ITEM:
-				return new SkullMeta(item);
-			default:
-				return new CraftItemMeta(item);
-		}
-	}
+        switch (item.getType()) {
+            case SKULL_ITEM:
+                return new SkullMeta(item);
+            default:
+                return new CraftItemMeta(item);
+        }
+    }
 
-	protected static ItemMeta createProxyInstance(Class c,Item item) {
-		ProxyFactory factor = new ProxyFactory();
-		factor.setSuperclass(c);
-		factor.setHandler(proxy);
-		try{
-			return (ItemMeta) factor.create(new Class[]{Item.class}, new Object[]{item});
-		}catch (NoSuchMethodException | IllegalArgumentException | InstantiationException | IllegalAccessException | InvocationTargetException e){
-			e.printStackTrace();
-		}
-		return new CraftItemMeta(item);
-	}
+    protected static ItemMeta createProxyInstance(Class c, Item item) {
+        ProxyFactory factor = new ProxyFactory();
+        factor.setSuperclass(c);
+        factor.setHandler(proxy);
+        try {
+            return (ItemMeta) factor.create(new Class[]{Item.class}, new Object[]{item});
+        } catch (NoSuchMethodException | IllegalArgumentException | InstantiationException | IllegalAccessException | InvocationTargetException e) {
+            e.printStackTrace();
+        }
+        return new CraftItemMeta(item);
+    }
 
-	protected static class ItemMetaProxy implements MethodHandler {
-		@SuppressWarnings("serial")
-		private static HashMap<Class, ArrayList<String>> whitelist = new HashMap<Class, ArrayList<String>>(){
-			public java.util.ArrayList<String> get(Object key) {
-				if(super.get(key) == null)
-					super.put((Class) key, new ArrayList<String>());
-				return super.get(key);
-			}
-		};
-		public static void addWhiteList(Class clazz,String methode){
-			whitelist.get(clazz).add(methode);
-		}
-		@Override
-		public Object invoke(Object self, Method thisMethod, Method proceed, Object[] args) throws Throwable {
-			if(self instanceof CraftItemMeta){
-				if(thisMethod.getName().startsWith("set")){
-					for(Class c : whitelist.keySet())
-						if(isInstance(self, c))
-							if(whitelist.get(c).contains(thisMethod.getName()))
-								return proceed.invoke(self, args);
-					Object resulut = proceed.invoke(self, args); //? null
-					self.getClass().getDeclaredMethod("build").invoke(self);
-					((CraftItemMeta)self).fireUpdate();
-					return resulut;
-				}
-			}
-			return proceed.invoke(self, args);
-		}
-		private boolean isInstance(Object base,Class of){
-			try{
-				of.cast(base);
-				return true;
-			}catch(Exception e){
-				return false;
-			}
-		}
-	}
+    protected static class ItemMetaProxy implements MethodHandler {
+        @SuppressWarnings("serial")
+        private static HashMap<Class, ArrayList<String>> whitelist = new HashMap<Class, ArrayList<String>>() {
+            public java.util.ArrayList<String> get(Object key) {
+                if (super.get(key) == null)
+                    super.put((Class) key, new ArrayList<String>());
+                return super.get(key);
+            }
+        };
+
+        public static void addWhiteList(Class clazz, String methode) {
+            whitelist.get(clazz).add(methode);
+        }
+
+        @Override
+        public Object invoke(Object self, Method thisMethod, Method proceed, Object[] args) throws Throwable {
+            if (self instanceof CraftItemMeta) {
+                if (thisMethod.getName().startsWith("set")) {
+                    for (Class c : whitelist.keySet())
+                        if (isInstance(self, c))
+                            if (whitelist.get(c).contains(thisMethod.getName()))
+                                return proceed.invoke(self, args);
+                    Object resulut = proceed.invoke(self, args); //? null
+                    self.getClass().getDeclaredMethod("build").invoke(self);
+                    ((CraftItemMeta) self).fireUpdate();
+                    return resulut;
+                }
+            }
+            return proceed.invoke(self, args);
+        }
+
+        private boolean isInstance(Object base, Class of) {
+            try {
+                of.cast(base);
+                return true;
+            } catch (Exception e) {
+                return false;
+            }
+        }
+    }
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/item/itemmeta/MetaListener.java b/src/main/java/dev/wolveringer/BungeeUtil/item/itemmeta/MetaListener.java
index f7c639a..4b478f7 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/item/itemmeta/MetaListener.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/item/itemmeta/MetaListener.java
@@ -3,5 +3,5 @@ package dev.wolveringer.BungeeUtil.item.itemmeta;
 import dev.wolveringer.BungeeUtil.item.Item;
 
 public interface MetaListener {
-	public void onUpdate(Item is);
+    public void onUpdate(Item is);
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/item/itemmeta/SkullMeta.java b/src/main/java/dev/wolveringer/BungeeUtil/item/itemmeta/SkullMeta.java
index 5eccb76..cd0ff12 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/item/itemmeta/SkullMeta.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/item/itemmeta/SkullMeta.java
@@ -1,10 +1,10 @@
 package dev.wolveringer.BungeeUtil.item.itemmeta;
 
+import net.md_5.bungee.BungeeCord;
+
 import java.util.UUID;
 
-import net.md_5.bungee.BungeeCord;
 import dev.wolveringer.BungeeUtil.BungeeUtil;
-import dev.wolveringer.BungeeUtil.Main;
 import dev.wolveringer.BungeeUtil.OperationCalback;
 import dev.wolveringer.BungeeUtil.gameprofile.GameProfile;
 import dev.wolveringer.BungeeUtil.gameprofile.GameProfileSerializer;
@@ -16,108 +16,110 @@ import dev.wolveringer.nbt.NBTTagCompound;
 
 public class SkullMeta extends CraftItemMeta {
 
-	static{
-		MetaFactory.ItemMetaProxy.addWhiteList(SkullMeta.class, "setSkin");
-	}
-
-	GameProfile p = new GameProfile(UUID.randomUUID(), "");
-	UUID owner;
-
-	public SkullMeta(Item i) {
-		super(i);
-		if(getTag().hasKey("SkullOwner"))
-			p = GameProfileSerializer.deserialize(getTag().getCompound("SkullOwner"));
-	}
-
-	@SuppressWarnings("unchecked")
-	public void setSkin(UUID owner) {
-		this.owner = owner;
-		if(p == null)
-			p = new GameProfile(owner, "");
-		p.setId(owner);
-		SkinFactory.getSkin(owner, new OperationCalback<Skin>() {
-			public void done(Skin response) {
-				setSkin(response);
-			};
-		});
-		build();
-	}
-
-	public void setSkin(final String owner) {
-		BungeeCord.getInstance().getScheduler().runAsync(BungeeUtil.getPluginInstance(), new Runnable() {
-			@Override
-			public void run() {
-				try{
-					setSkin(UUIDFetcher.getUUIDOf(owner));
-				}catch (Exception e){
-					e.printStackTrace();
-				}
-			}
-		});
-	}
-
-	public void setSkin(Skin s) {
-		s.applay(p);
-		p.setName(p.getName().equalsIgnoreCase("") ? s.getProfileName() : p.getName());
-		build();
-	}
-
-	public void setSkullOwner(String name) {
-		if(p == null)
-			p = new GameProfile(UUID.randomUUID(), name);
-		p.setName(name);
-		build();
-	}
-
-	public GameProfile getProfile() {
-		return p;
-	}
-
-	public void setProfile(GameProfile p) {
-		this.p = p;
-		build();
-	}
-
-	@Override
-	protected void build() {
-		if(p != null)
-			getTag().set("SkullOwner", GameProfileSerializer.serialize(new NBTTagCompound(), p));
-		fireUpdate();
-	}
-
-	@Override
-	public String toString() {
-		return "SkullMeta@" + System.identityHashCode(this) + "[p=" + p + ", owner=" + owner + "]";
-	}
-
-	@Override
-	public int hashCode() {
-		final int prime = 31;
-		int result = super.hashCode();
-		result = prime * result + ((owner == null) ? 0 : owner.hashCode());
-		result = prime * result + ((p == null) ? 0 : p.hashCode());
-		return result;
-	}
-
-	@Override
-	public boolean equals(Object obj) {
-		if(this == obj)
-			return true;
-		if(!super.equals(obj))
-			return false;
-		if(getClass() != obj.getClass())
-			return false;
-		SkullMeta other = (SkullMeta) obj;
-		if(owner == null){
-			if(other.owner != null)
-				return false;
-		}else if(!owner.equals(other.owner))
-			return false;
-		if(p == null){
-			if(other.p != null)
-				return false;
-		}else if(!p.equals(other.p))
-			return false;
-		return super.equals(obj);
-	}
+    static {
+        MetaFactory.ItemMetaProxy.addWhiteList(SkullMeta.class, "setSkin");
+    }
+
+    GameProfile p = new GameProfile(UUID.randomUUID(), "");
+    UUID owner;
+
+    public SkullMeta(Item i) {
+        super(i);
+        if (getTag().hasKey("SkullOwner"))
+            p = GameProfileSerializer.deserialize(getTag().getCompound("SkullOwner"));
+    }
+
+    @SuppressWarnings("unchecked")
+    public void setSkin(UUID owner) {
+        this.owner = owner;
+        if (p == null)
+            p = new GameProfile(owner, "");
+        p.setId(owner);
+        SkinFactory.getSkin(owner, new OperationCalback<Skin>() {
+            public void done(Skin response) {
+                setSkin(response);
+            }
+
+            ;
+        });
+        build();
+    }
+
+    public void setSkin(final String owner) {
+        BungeeCord.getInstance().getScheduler().runAsync(BungeeUtil.getPluginInstance(), new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    setSkin(UUIDFetcher.getUUIDOf(owner));
+                } catch (Exception e) {
+                    e.printStackTrace();
+                }
+            }
+        });
+    }
+
+    public void setSkin(Skin s) {
+        s.applay(p);
+        p.setName(p.getName().equalsIgnoreCase("") ? s.getProfileName() : p.getName());
+        build();
+    }
+
+    public void setSkullOwner(String name) {
+        if (p == null)
+            p = new GameProfile(UUID.randomUUID(), name);
+        p.setName(name);
+        build();
+    }
+
+    public GameProfile getProfile() {
+        return p;
+    }
+
+    public void setProfile(GameProfile p) {
+        this.p = p;
+        build();
+    }
+
+    @Override
+    protected void build() {
+        if (p != null)
+            getTag().set("SkullOwner", GameProfileSerializer.serialize(new NBTTagCompound(), p));
+        fireUpdate();
+    }
+
+    @Override
+    public String toString() {
+        return "SkullMeta@" + System.identityHashCode(this) + "[p=" + p + ", owner=" + owner + "]";
+    }
+
+    @Override
+    public int hashCode() {
+        final int prime = 31;
+        int result = super.hashCode();
+        result = prime * result + ((owner == null) ? 0 : owner.hashCode());
+        result = prime * result + ((p == null) ? 0 : p.hashCode());
+        return result;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj)
+            return true;
+        if (!super.equals(obj))
+            return false;
+        if (getClass() != obj.getClass())
+            return false;
+        SkullMeta other = (SkullMeta) obj;
+        if (owner == null) {
+            if (other.owner != null)
+                return false;
+        } else if (!owner.equals(other.owner))
+            return false;
+        if (p == null) {
+            if (other.p != null)
+                return false;
+        } else if (!p.equals(other.p))
+            return false;
+        return super.equals(obj);
+    }
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/Abstract/PacketAbstract.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/Abstract/PacketAbstract.java
index be7804d..0781121 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/packets/Abstract/PacketAbstract.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/Abstract/PacketAbstract.java
@@ -4,20 +4,22 @@ import dev.wolveringer.BungeeUtil.packets.Packet;
 import dev.wolveringer.packet.PacketDataSerializer;
 
 @SuppressWarnings("deprecation")
-public abstract class PacketAbstract extends Packet{
-	private byte[] b;
-	
-	public PacketAbstract(int id) {
-		super(id);
-	}
-	
-	public PacketAbstract() {}
-	
-	public void readUnusedBytes(PacketDataSerializer s){
-		b = new byte[s.readableBytes()];
-		s.readBytes(b);
-	}
-	public void writeUnusedBytes(PacketDataSerializer s){
-		s.writeBytes(b);
-	}
+public abstract class PacketAbstract extends Packet {
+    private byte[] b;
+
+    public PacketAbstract(int id) {
+        super(id);
+    }
+
+    public PacketAbstract() {
+    }
+
+    public void readUnusedBytes(PacketDataSerializer s) {
+        b = new byte[s.readableBytes()];
+        s.readBytes(b);
+    }
+
+    public void writeUnusedBytes(PacketDataSerializer s) {
+        s.writeBytes(b);
+    }
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/Abstract/PacketPlayIn.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/Abstract/PacketPlayIn.java
index 04e0867..02b4532 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/packets/Abstract/PacketPlayIn.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/Abstract/PacketPlayIn.java
@@ -1,3 +1,4 @@
 package dev.wolveringer.BungeeUtil.packets.Abstract;
 
-public interface PacketPlayIn {}
+public interface PacketPlayIn {
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/Abstract/PacketPlayOut.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/Abstract/PacketPlayOut.java
index a404aef..3c711a3 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/packets/Abstract/PacketPlayOut.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/Abstract/PacketPlayOut.java
@@ -1,3 +1,4 @@
 package dev.wolveringer.BungeeUtil.packets.Abstract;
 
-public interface PacketPlayOut {}
+public interface PacketPlayOut {
+}
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/Abstract/PacketPlayOutEntityAbstract.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/Abstract/PacketPlayOutEntityAbstract.java
index 9056f83..9182ed8 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/packets/Abstract/PacketPlayOutEntityAbstract.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/Abstract/PacketPlayOutEntityAbstract.java
@@ -5,34 +5,35 @@ import dev.wolveringer.packet.PacketDataSerializer;
 
 public class PacketPlayOutEntityAbstract extends PacketAbstract {
 
-	private int id;
-
-	public PacketPlayOutEntityAbstract() {}
-	
-	public PacketPlayOutEntityAbstract(int id) {
-		super(id);
-	}
-
-	@Override
-	public void read(PacketDataSerializer s) {
-		id = getVersion().getBigVersion() == BigClientVersion.v1_8 ? s.readVarInt() : s.readInt();
-		readUnusedBytes(s);
-	}
-
-	@Override
-	public void write(PacketDataSerializer s) {
-		if(getVersion().getBigVersion() == BigClientVersion.v1_8)
-			s.writeVarInt(id);
-		else
-			s.writeInt(id);
-		writeUnusedBytes(s);
-	}
-
-	public int getId() {
-		return id;
-	}
-
-	public void setId(int id) {
-		this.id = id;
-	}
+    private int id;
+
+    public PacketPlayOutEntityAbstract() {
+    }
+
+    public PacketPlayOutEntityAbstract(int id) {
+        super(id);
+    }
+
+    @Override
+    public void read(PacketDataSerializer s) {
+        id = getVersion().getBigVersion() == BigClientVersion.v1_8 ? s.readVarInt() : s.readInt();
+        readUnusedBytes(s);
+    }
+
+    @Override
+    public void write(PacketDataSerializer s) {
+        if (getVersion().getBigVersion() == BigClientVersion.v1_8)
+            s.writeVarInt(id);
+        else
+            s.writeInt(id);
+        writeUnusedBytes(s);
+    }
+
+    public int getId() {
+        return id;
+    }
+
+    public void setId(int id) {
+        this.id = id;
+    }
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/Abstract/PacketPlayXXXHeldItemSlot.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/Abstract/PacketPlayXXXHeldItemSlot.java
index 29c4b21..b6c30be 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/packets/Abstract/PacketPlayXXXHeldItemSlot.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/Abstract/PacketPlayXXXHeldItemSlot.java
@@ -2,21 +2,24 @@ package dev.wolveringer.BungeeUtil.packets.Abstract;
 
 import dev.wolveringer.BungeeUtil.packets.Packet;
 
-public abstract class PacketPlayXXXHeldItemSlot extends Packet{
-	private int slot;
-	
-	public PacketPlayXXXHeldItemSlot(byte id) {
-		super(id);
-		
-	}
-	public PacketPlayXXXHeldItemSlot(int i) {
-		super(i);
-		
-	}
-	public int getSlot() {
-		return slot;
-	}
-	public void setSlot(int slot) {
-		this.slot = slot;
-	}
+public abstract class PacketPlayXXXHeldItemSlot extends Packet {
+    private int slot;
+
+    public PacketPlayXXXHeldItemSlot(byte id) {
+        super(id);
+
+    }
+
+    public PacketPlayXXXHeldItemSlot(int i) {
+        super(i);
+
+    }
+
+    public int getSlot() {
+        return slot;
+    }
+
+    public void setSlot(int slot) {
+        this.slot = slot;
+    }
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/AbstractPacketCreator.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/AbstractPacketCreator.java
index ccb1e6c..44a858f 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/packets/AbstractPacketCreator.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/AbstractPacketCreator.java
@@ -1,8 +1,9 @@
 package dev.wolveringer.BungeeUtil.packets;
 
-import io.netty.buffer.ByteBuf;
+import net.md_5.bungee.api.ChatColor;
+import net.md_5.bungee.protocol.Protocol;
+import net.md_5.bungee.protocol.ProtocolConstants.Direction;
 
-import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -12,183 +13,182 @@ import java.util.HashMap;
 import java.util.List;
 import java.util.Map.Entry;
 
-import net.md_5.bungee.api.ChatColor;
-import net.md_5.bungee.protocol.Protocol;
-import net.md_5.bungee.protocol.ProtocolConstants.Direction;
-import dev.wolveringer.BungeeUtil.ClientVersion.ProtocollVersion;
-import dev.wolveringer.BungeeUtil.packets.Packet.ProtocollId;
 import dev.wolveringer.BungeeUtil.BungeeUtil;
+import dev.wolveringer.BungeeUtil.ClientVersion.ProtocollVersion;
 import dev.wolveringer.BungeeUtil.CostumPrintStream;
 import dev.wolveringer.BungeeUtil.Player;
+import dev.wolveringer.BungeeUtil.packets.Packet.ProtocollId;
 import dev.wolveringer.chat.ChatColor.ChatColorUtils;
 import dev.wolveringer.string.ColoredChar;
 import dev.wolveringer.terminal.table.TerminalTable;
 import dev.wolveringer.terminal.table.TerminalTable.Align;
 import dev.wolveringer.terminal.table.TerminalTable.TerminalColumn;
 import dev.wolveringer.terminal.table.TerminalTable.TerminalRow;
+import io.netty.buffer.ByteBuf;
 
 public abstract class AbstractPacketCreator {
-	public int calculate(ProtocollVersion version, Protocol p, Direction d, Integer id) {
-		int x = ((version.ordinal() & 0xFF) << 16) | ((p.ordinal() & 0x0F) << 12) | ((d.ordinal() & 0x0F) << 8) | (id & 0xFF);
-		return x;
-	}
-
-	public ProtocollVersion getPacketVersion(int base) {
-		return ProtocollVersion.values()[((int) (base >> 16)) & 0xFF];
-	}
-
-	public int getPacketId(int base) {
-		return base & 0xFF;
-	}
-
-	public Protocol getProtocoll(int base) {
-		return Protocol.values()[((int) (base >> 12)) & 0x0F];
-	}
-
-	public Direction getDirection(int base) {
-		int size = ((int) (base >> 8)) & 0x0F;
-		if (Direction.values().length < size)
-			return Direction.TO_SERVER;
-		return Direction.values()[size];
-	}
-
-	public Packet getPacket(ProtocollVersion version, Protocol s, Direction d, ByteBuf x, Player p) {
-		if (x.readableBytes() < 1)
-			return null;
-		x.markReaderIndex().markWriterIndex();
-		Packet y = getPacket0(version, s, d, (int) x.readUnsignedByte(), x, p); // faster
-		x.resetReaderIndex().resetWriterIndex();
-		return y;
-	}
-
-	public void listPackets(CostumPrintStream out) {
-		HashMap<ProtocollVersion, HashMap<Direction, HashMap<Integer, Class<? extends Packet>>>> packets = new HashMap<ProtocollVersion, HashMap<Direction, HashMap<Integer, Class<? extends Packet>>>>();
-		for (ProtocollVersion c : ProtocollVersion.values()) {
-			if (!c.isSupported())
-				continue;
-			packets.put(c, new HashMap<Direction, HashMap<Integer, Class<? extends Packet>>>());
-			for (Direction d : Direction.values())
-				packets.get(c).put(d, new HashMap<Integer, Class<? extends Packet>>());
-		}
-
-		for (Class<? extends Packet> packet : getRegisteredPackets()) {
-			for (ProtocollVersion version : packets.keySet()) {
-				int compressed = getPacketId(version, packet);
-				if (getPacketId(compressed) != 0xFF)
-					packets.get(version).get(getDirection(compressed)).put(getPacketId(compressed), packet);
-			}
-		}
-
-		HashMap<ProtocollVersion, Integer> rowMapping = new HashMap<>();
-		List<TerminalColumn> columns = new ArrayList<>();
-		columns.add(new TerminalColumn("\u00A7eName", Align.RIGHT));
-		columns.add(new TerminalColumn("\u00A7eDirection", Align.CENTER));
-		List<ProtocollVersion> versions = Arrays.asList(ProtocollVersion.values());
-		Collections.sort(versions, new Comparator<ProtocollVersion>() {
-			@Override
-			public int compare(ProtocollVersion o1, ProtocollVersion o2) {
-				return Integer.compare(o1.getProtocollVersion(), o2.getProtocollVersion());
-			}
-		});
-		for (ProtocollVersion version : versions) {
-			if (version == ProtocollVersion.Unsupported)
-				continue;
-			rowMapping.put(version, columns.size());
-			columns.add(new TerminalColumn("\u00A7e" + version.name(), Align.CENTER));
-		}
-		TerminalTable table = new TerminalTable(columns.toArray(new TerminalColumn[0]));
-
-		HashMap<Class<? extends Packet>, String[]> packetRow = new HashMap<Class<? extends Packet>, String[]>();
-		for (Entry<ProtocollVersion, HashMap<Direction, HashMap<Integer, Class<? extends Packet>>>> protocolls : packets.entrySet()) {
-			for (Entry<Direction, HashMap<Integer, Class<? extends Packet>>> directions : protocolls.getValue().entrySet()) {
-				List<Entry<Integer, Class<? extends Packet>>> packetIds = new ArrayList<>(directions.getValue().entrySet());
-				Collections.sort(packetIds, new Comparator<Entry<Integer, Class<? extends Packet>>>() {
-					@Override
-					public int compare(Entry<Integer, Class<? extends Packet>> o1, Entry<Integer, Class<? extends Packet>> o2) {
-						return Integer.compare(o1.getKey(), o1.getKey());
-					}
-				});
-
-				for (Entry<Integer, Class<? extends Packet>> packet : packetIds) {
-					if (!packetRow.containsKey(packet.getValue())) {
-						String[] ids = new String[columns.size()];
-						Arrays.fill(ids, 2, ids.length, "\u00A76nan");
-						packetRow.put(packet.getValue(), ids);
-					}
-					String packetIdHex = "\u00A7c0x" + (Integer.toHexString(packet.getKey()).length() == 1 ? "0" : "") + Integer.toHexString(packet.getKey()).toUpperCase();
-					packetRow.get(packet.getValue())[rowMapping.get(protocolls.getKey())] = packetIdHex;
-					if (packetRow.get(packet.getValue())[0] == null) {
-						packetRow.get(packet.getValue())[0] = "\u00A76" + packet.getValue().getName().replaceAll(packet.getValue().getName().split("\\.")[packet.getValue().getName().split("\\.").length - 1], ChatColorUtils.COLOR_CHAR + "b" + packet.getValue().getName().split("\\.")[packet.getValue().getName().split("\\.").length - 1]);
-					}
-					if (packetRow.get(packet.getValue())[1] == null) {
-						packetRow.get(packet.getValue())[1] = "\u00A7a" + directions.getKey().name();
-					}
-				}
-			}
-		}
-
-		for (String[] row : packetRow.values())
-			table.addRow(row);
-		table.setRowSeperator(new TerminalTable.RowSeperator() {
-			@Override
-			public ColoredChar getSeperator(TerminalRow row, int rowIndex, int columnFrom, int columnTo) {
-				if(columnFrom < 2)
-					return new ColoredChar("|");
-				String oldPacketIds = row.getColumns()[columnFrom].get(rowIndex);
-				String newPacketIds = row.getColumns()[columnTo].get(rowIndex);
-				if(oldPacketIds.equalsIgnoreCase("\u00A76nan"))
-					oldPacketIds = "0x-1";
-				if(newPacketIds.equalsIgnoreCase("\u00A76nan"))
-					newPacketIds = "0x-1";
-				BigInteger oldPacketId = new BigInteger(ChatColor.stripColor(oldPacketIds).substring(2),16);
-				BigInteger newPacketId = new BigInteger(ChatColor.stripColor(newPacketIds).substring(2),16);
-				switch (oldPacketId.compareTo(newPacketId)) {
-				case -1:
-					return new ColoredChar("\u00A7a");
-				case 0:
-					return new ColoredChar("\u00A77|");
-				case 1:
-					return new ColoredChar("\u00A7a");
-				default:
-					break;
-				}
-				return new ColoredChar("\u00A75X");
-			}
-			@Override
-			public ColoredChar getDefaultSeperator() {
-				return new ColoredChar("\u00A77|");
-			}
-		});
-		
-		for (String line : table.buildLines())
-			out.println(line);
-	}
-
-	public void listPackets() {
-		listPackets(new CostumPrintStream() {
-			@Override
-			public void println(String s) {
-				BungeeUtil.getInstance().sendMessage(s);
-			}
-
-			@Override
-			public void print(String s) {
-				BungeeUtil.getInstance().sendMessage(s);
-			}
-		});
-	}
-
-	public abstract Packet getPacket0(ProtocollVersion version, Protocol protocol, Direction d, Integer id, ByteBuf b, Player p);
-
-	public abstract int loadPacket(ProtocollVersion version, Protocol p, Direction d, Integer id, Class<? extends Packet> clazz);
-
-	public abstract void registerPacket(Protocol p, Direction d, Class<? extends Packet> clazz, ProtocollId... ids);
-
-	public abstract void unregisterPacket(ProtocollVersion version, Protocol p, Direction d, Integer id);
-
-	public abstract int countPackets();
-
-	public abstract int getPacketId(ProtocollVersion version, Class<? extends Packet> clazz);
-
-	public abstract List<Class<? extends Packet>> getRegisteredPackets();
+    public int calculate(ProtocollVersion version, Protocol p, Direction d, Integer id) {
+        int x = ((version.ordinal() & 0xFF) << 16) | ((p.ordinal() & 0x0F) << 12) | ((d.ordinal() & 0x0F) << 8) | (id & 0xFF);
+        return x;
+    }
+
+    public ProtocollVersion getPacketVersion(int base) {
+        return ProtocollVersion.values()[((int) (base >> 16)) & 0xFF];
+    }
+
+    public int getPacketId(int base) {
+        return base & 0xFF;
+    }
+
+    public Protocol getProtocoll(int base) {
+        return Protocol.values()[((int) (base >> 12)) & 0x0F];
+    }
+
+    public Direction getDirection(int base) {
+        int size = ((int) (base >> 8)) & 0x0F;
+        if (Direction.values().length < size)
+            return Direction.TO_SERVER;
+        return Direction.values()[size];
+    }
+
+    public Packet getPacket(ProtocollVersion version, Protocol s, Direction d, ByteBuf x, Player p) {
+        if (x.readableBytes() < 1)
+            return null;
+        x.markReaderIndex().markWriterIndex();
+        Packet y = getPacket0(version, s, d, (int) x.readUnsignedByte(), x, p); // faster
+        x.resetReaderIndex().resetWriterIndex();
+        return y;
+    }
+
+    public void listPackets(CostumPrintStream out) {
+        HashMap<ProtocollVersion, HashMap<Direction, HashMap<Integer, Class<? extends Packet>>>> packets = new HashMap<ProtocollVersion, HashMap<Direction, HashMap<Integer, Class<? extends Packet>>>>();
+        for (ProtocollVersion c : ProtocollVersion.values()) {
+            if (!c.isSupported())
+                continue;
+            packets.put(c, new HashMap<Direction, HashMap<Integer, Class<? extends Packet>>>());
+            for (Direction d : Direction.values())
+                packets.get(c).put(d, new HashMap<Integer, Class<? extends Packet>>());
+        }
+
+        for (Class<? extends Packet> packet : getRegisteredPackets()) {
+            for (ProtocollVersion version : packets.keySet()) {
+                int compressed = getPacketId(version, packet);
+                if (getPacketId(compressed) != 0xFF)
+                    packets.get(version).get(getDirection(compressed)).put(getPacketId(compressed), packet);
+            }
+        }
+
+        HashMap<ProtocollVersion, Integer> rowMapping = new HashMap<>();
+        List<TerminalColumn> columns = new ArrayList<>();
+        columns.add(new TerminalColumn("\u00A7eName", Align.RIGHT));
+        columns.add(new TerminalColumn("\u00A7eDirection", Align.CENTER));
+        List<ProtocollVersion> versions = Arrays.asList(ProtocollVersion.values());
+        Collections.sort(versions, new Comparator<ProtocollVersion>() {
+            @Override
+            public int compare(ProtocollVersion o1, ProtocollVersion o2) {
+                return Integer.compare(o1.getProtocollVersion(), o2.getProtocollVersion());
+            }
+        });
+        for (ProtocollVersion version : versions) {
+            if (version == ProtocollVersion.Unsupported)
+                continue;
+            rowMapping.put(version, columns.size());
+            columns.add(new TerminalColumn("\u00A7e" + version.name(), Align.CENTER));
+        }
+        TerminalTable table = new TerminalTable(columns.toArray(new TerminalColumn[0]));
+
+        HashMap<Class<? extends Packet>, String[]> packetRow = new HashMap<Class<? extends Packet>, String[]>();
+        for (Entry<ProtocollVersion, HashMap<Direction, HashMap<Integer, Class<? extends Packet>>>> protocolls : packets.entrySet()) {
+            for (Entry<Direction, HashMap<Integer, Class<? extends Packet>>> directions : protocolls.getValue().entrySet()) {
+                List<Entry<Integer, Class<? extends Packet>>> packetIds = new ArrayList<>(directions.getValue().entrySet());
+                Collections.sort(packetIds, new Comparator<Entry<Integer, Class<? extends Packet>>>() {
+                    @Override
+                    public int compare(Entry<Integer, Class<? extends Packet>> o1, Entry<Integer, Class<? extends Packet>> o2) {
+                        return Integer.compare(o1.getKey(), o1.getKey());
+                    }
+                });
+
+                for (Entry<Integer, Class<? extends Packet>> packet : packetIds) {
+                    if (!packetRow.containsKey(packet.getValue())) {
+                        String[] ids = new String[columns.size()];
+                        Arrays.fill(ids, 2, ids.length, "\u00A76nan");
+                        packetRow.put(packet.getValue(), ids);
+                    }
+                    String packetIdHex = "\u00A7c0x" + (Integer.toHexString(packet.getKey()).length() == 1 ? "0" : "") + Integer.toHexString(packet.getKey()).toUpperCase();
+                    packetRow.get(packet.getValue())[rowMapping.get(protocolls.getKey())] = packetIdHex;
+                    if (packetRow.get(packet.getValue())[0] == null) {
+                        packetRow.get(packet.getValue())[0] = "\u00A76" + packet.getValue().getName().replaceAll(packet.getValue().getName().split("\\.")[packet.getValue().getName().split("\\.").length - 1], ChatColorUtils.COLOR_CHAR + "b" + packet.getValue().getName().split("\\.")[packet.getValue().getName().split("\\.").length - 1]);
+                    }
+                    if (packetRow.get(packet.getValue())[1] == null) {
+                        packetRow.get(packet.getValue())[1] = "\u00A7a" + directions.getKey().name();
+                    }
+                }
+            }
+        }
+
+        for (String[] row : packetRow.values())
+            table.addRow(row);
+        table.setRowSeperator(new TerminalTable.RowSeperator() {
+            @Override
+            public ColoredChar getSeperator(TerminalRow row, int rowIndex, int columnFrom, int columnTo) {
+                if (columnFrom < 2)
+                    return new ColoredChar("|");
+                String oldPacketIds = row.getColumns()[columnFrom].get(rowIndex);
+                String newPacketIds = row.getColumns()[columnTo].get(rowIndex);
+                if (oldPacketIds.equalsIgnoreCase("\u00A76nan"))
+                    oldPacketIds = "0x-1";
+                if (newPacketIds.equalsIgnoreCase("\u00A76nan"))
+                    newPacketIds = "0x-1";
+                BigInteger oldPacketId = new BigInteger(ChatColor.stripColor(oldPacketIds).substring(2), 16);
+                BigInteger newPacketId = new BigInteger(ChatColor.stripColor(newPacketIds).substring(2), 16);
+                switch (oldPacketId.compareTo(newPacketId)) {
+                    case -1:
+                        return new ColoredChar("\u00A7a");
+                    case 0:
+                        return new ColoredChar("\u00A77|");
+                    case 1:
+                        return new ColoredChar("\u00A7a");
+                    default:
+                        break;
+                }
+                return new ColoredChar("\u00A75X");
+            }
+
+            @Override
+            public ColoredChar getDefaultSeperator() {
+                return new ColoredChar("\u00A77|");
+            }
+        });
+
+        for (String line : table.buildLines())
+            out.println(line);
+    }
+
+    public void listPackets() {
+        listPackets(new CostumPrintStream() {
+            @Override
+            public void println(String s) {
+                BungeeUtil.getInstance().sendMessage(s);
+            }
+
+            @Override
+            public void print(String s) {
+                BungeeUtil.getInstance().sendMessage(s);
+            }
+        });
+    }
+
+    public abstract Packet getPacket0(ProtocollVersion version, Protocol protocol, Direction d, Integer id, ByteBuf b, Player p);
+
+    public abstract int loadPacket(ProtocollVersion version, Protocol p, Direction d, Integer id, Class<? extends Packet> clazz);
+
+    public abstract void registerPacket(Protocol p, Direction d, Class<? extends Packet> clazz, ProtocollId... ids);
+
+    public abstract void unregisterPacket(ProtocollVersion version, Protocol p, Direction d, Integer id);
+
+    public abstract int countPackets();
+
+    public abstract int getPacketId(ProtocollVersion version, Class<? extends Packet> clazz);
+
+    public abstract List<Class<? extends Packet>> getRegisteredPackets();
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/BetaPacket.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/BetaPacket.java
index e332f04..4553a48 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/packets/BetaPacket.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/BetaPacket.java
@@ -1,34 +1,37 @@
 package dev.wolveringer.BungeeUtil.packets;
 
-import io.netty.buffer.ByteBuf;
-
 import javax.naming.OperationNotSupportedException;
 
 import dev.wolveringer.BungeeUtil.ClientVersion;
 import dev.wolveringer.BungeeUtil.DebugProperties;
+import io.netty.buffer.ByteBuf;
+
+public abstract class BetaPacket extends Packet {
+
+    public BetaPacket() {
+    }
+
+    public BetaPacket(byte id) {
+        super(id);
+
+    }
+
+    public BetaPacket(int i) {
+        super(i);
+
+    }
+
+    @Override
+    protected Packet load(ByteBuf b, ClientVersion version) {
+        if (!DebugProperties.PACKET_DEVELOPMENT)
+            throw new RuntimeException(new OperationNotSupportedException("Packet is stille under development!"));
+        return super.load(b, version);
+    }
 
-public abstract class BetaPacket extends Packet{
-	
-	public BetaPacket() {}
-	
-	public BetaPacket(byte id) {
-		super(id);
-		
-	}
-	public BetaPacket(int i) {
-		super(i);
-		
-	}
-	@Override
-	protected Packet load(ByteBuf b,ClientVersion version) {
-		if(!DebugProperties.PACKET_DEVELOPMENT)
-			throw new RuntimeException(new OperationNotSupportedException("Packet is stille under development!"));
-		return super.load(b,version);
-	}
-	@Override
-	public ByteBuf getByteBuf(ClientVersion version) {
-		if(!DebugProperties.PACKET_DEVELOPMENT)
-			throw new RuntimeException(new OperationNotSupportedException("Packet is stille under development!"));
-		return super.getByteBuf(version);
-	}
+    @Override
+    public ByteBuf getByteBuf(ClientVersion version) {
+        if (!DebugProperties.PACKET_DEVELOPMENT)
+            throw new RuntimeException(new OperationNotSupportedException("Packet is stille under development!"));
+        return super.getByteBuf(version);
+    }
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/NormalPacketCreator.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/NormalPacketCreator.java
index 7780a59..058b170 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/packets/NormalPacketCreator.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/NormalPacketCreator.java
@@ -1,5 +1,8 @@
 package dev.wolveringer.BungeeUtil.packets;
 
+import net.md_5.bungee.protocol.Protocol;
+import net.md_5.bungee.protocol.ProtocolConstants.Direction;
+
 import java.lang.instrument.ClassFileTransformer;
 import java.lang.instrument.IllegalClassFormatException;
 import java.lang.reflect.Constructor;
@@ -12,144 +15,135 @@ import java.util.List;
 import dev.wolveringer.BungeeUtil.BungeeUtil;
 import dev.wolveringer.BungeeUtil.ClientVersion;
 import dev.wolveringer.BungeeUtil.ClientVersion.ProtocollVersion;
-import dev.wolveringer.BungeeUtil.exception.ExceptionUtils;
-import dev.wolveringer.BungeeUtil.Main;
 import dev.wolveringer.BungeeUtil.Player;
+import dev.wolveringer.BungeeUtil.exception.ExceptionUtils;
 import dev.wolveringer.BungeeUtil.packets.Packet.ProtocollId;
 import dev.wolveringer.packet.PacketDataSerializer;
 import io.netty.buffer.ByteBuf;
 import lombok.AllArgsConstructor;
 import lombok.Getter;
-import net.md_5.bungee.protocol.Protocol;
-import net.md_5.bungee.protocol.ProtocolConstants.Direction;
 
 public class NormalPacketCreator extends AbstractPacketCreator {
-	@AllArgsConstructor
-	@Getter
-	private static class PacketHolder {
-		private Constructor<? extends Packet> constuctor;
+    private PacketHolder[] packetsId = new PacketHolder[((ProtocollVersion.values().length & 0x0F) << 16) | ((Protocol.values().length & 0x0F) << 12) | ((Direction.values().length & 0x0F) << 8) | 0xFF]; // Calculate max packet compressed id. (0xFF = Max ID)
+    @SuppressWarnings("unchecked")
+    private HashMap<Class<? extends Packet>, Integer>[] classToId = new HashMap[ProtocollVersion.values().length];
+    private List<Class<? extends Packet>> registerPackets = new ArrayList<>();
+    private boolean packetListChanged = true;
 
-		public Packet newInstance() throws InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
-			return constuctor.newInstance();
-		}
-	}
-	
-	private PacketHolder[] packetsId = new PacketHolder[((ProtocollVersion.values().length & 0x0F) << 16) | ((Protocol.values().length & 0x0F) << 12) | ((Direction.values().length & 0x0F) << 8) | 0xFF]; // Calculate max packet compressed id. (0xFF = Max ID)
-	@SuppressWarnings("unchecked")
-	private HashMap<Class<? extends Packet>, Integer>[] classToId = new HashMap[ProtocollVersion.values().length];
-	
-	private List<Class<? extends Packet>> registerPackets = new ArrayList<>();
-	private boolean packetListChanged = true;
-	
-	public NormalPacketCreator() {
-		for(int i = 0;i<classToId.length;i++)
-			classToId[i] = new HashMap<>();
-	}
-	
-	@SuppressWarnings("unchecked")
-	public int getPacketId(ProtocollVersion version,Class<? extends Packet> clazz) {
-		if(version == ProtocollVersion.Unsupported){
-			throw new NullPointerException("Unsupported version!");
-		}
-		if (!clazz.getName().endsWith("$-1")) while (clazz.getName().contains("$")) {
-			clazz = (Class<? extends Packet>) clazz.getSuperclass();
-		}
-		if (!classToId[version.ordinal()].containsKey(clazz)) //throw new NullPointerException("Packet " + clazz.getName() + " not loadet.");
-			if(version.getBasedVersion().getProtocollVersion() != version)
-				return getPacketId(version.getBasedVersion().getProtocollVersion(),clazz);
-			else
-				return -1;
-		return   classToId[version.ordinal()].get(clazz);
-	}
-	
-	public List<Class<? extends Packet>> getRegisteredPackets() {
-		if (packetListChanged) {
-			registerPackets.clear();
-			for (int i = 0; i < packetsId.length; i++) {
-				if(packetsId[i] == null)
-					continue;
-				Constructor<? extends Packet> constructor = packetsId[i].getConstuctor();
-				if (constructor == null) continue;
-				registerPackets.add(constructor.getDeclaringClass());
-			}
-			packetListChanged = false;
-		}
-		return registerPackets;
-	}
-	
-	public Packet getPacket0(ProtocollVersion version,Protocol protocol, Direction d, Integer id, ByteBuf b, Player p) {
-		int compressed = calculate(version,protocol, d, id);
-		PacketHolder cons = null;
-		if ((cons = packetsId[compressed]) == null) {
-			if(version.getBasedVersion().getProtocollVersion() == version){ //Fallback (based version) (1.8-1.9)
-				return null;
-			}
-			else{
-				return getPacket0(version.getBasedVersion().getProtocollVersion(), protocol, d, id, b, p);
-			}
-		}
-		if(cons.getConstuctor() == null)
-			return null;
-		try {
-			Packet packet = cons.newInstance();
-			if (p == null || p.getVersion() == null){
-				BungeeUtil.getInstance().debug("Version of '"+(p == null ? "<Null client>" : p.getName())+"' is undefined");
-				return packet.setcompressedId(compressed).load(b, ClientVersion.UnderknownVersion);
-			}
-			else return packet.setcompressedId(compressed).load(b, p.getVersion());
-		}
-		catch (Exception e) {
-			throw ExceptionUtils.createRuntimeException(ExceptionUtils.setExceptionMessage(e, "Packet error (Version: " + (p == null ? "unknown" : p.getVersion()) + ", Readed version: "+version+", Class: " + (cons == null || cons.getConstuctor() == null ? "null" : cons.getConstuctor().getDeclaringClass().getName()) + ", Id: 0x"+Integer.toHexString(id).toUpperCase()+") -> "+e.getMessage()));
-		}
-	}
-	
-	public Packet getPacket1(ProtocollVersion version,ProtocollVersion orginalVersion,Protocol protocol, Direction d, Integer id, ByteBuf b, Player p) {
-		return null;
-	}
-	
-	public int loadPacket(ProtocollVersion version,Protocol p, Direction d, Integer id, Class<? extends Packet> clazz) {
-		//clazz = getPacketWithDefaultConstructor(clazz);
-		int compressedId = calculate(version,p, d, id);
-		classToId[version.ordinal()].put(clazz, compressedId);
-		return compressedId;
-	}
-	
-	
-	public void registerPacket(Protocol p, Direction d, Class<? extends Packet> clazz, ProtocollId... ids) {
-		//clazz = getPacketWithDefaultConstructor(clazz);
-		try {
-			for(ProtocollId id : ids)
-				if(id != null && id.isValid()){
-					packetsId[loadPacket(id.getVersion(),p, d, id.getId(), clazz)] = new PacketHolder(clazz == null ? null : (Constructor<? extends Packet>) clazz.getConstructor());
-					/*
-					if(id.getVersion().getBasedVersion().getProtocollVersion() != id.getVersion()){
+    public NormalPacketCreator() {
+        for (int i = 0; i < classToId.length; i++)
+            classToId[i] = new HashMap<>();
+    }
+
+    @SuppressWarnings("unchecked")
+    public int getPacketId(ProtocollVersion version, Class<? extends Packet> clazz) {
+        if (version == ProtocollVersion.Unsupported) {
+            throw new NullPointerException("Unsupported version!");
+        }
+        if (!clazz.getName().endsWith("$-1")) while (clazz.getName().contains("$")) {
+            clazz = (Class<? extends Packet>) clazz.getSuperclass();
+        }
+        if (!classToId[version.ordinal()].containsKey(clazz)) //throw new NullPointerException("Packet " + clazz.getName() + " not loadet.");
+            if (version.getBasedVersion().getProtocollVersion() != version)
+                return getPacketId(version.getBasedVersion().getProtocollVersion(), clazz);
+            else
+                return -1;
+        return classToId[version.ordinal()].get(clazz);
+    }
+
+    public List<Class<? extends Packet>> getRegisteredPackets() {
+        if (packetListChanged) {
+            registerPackets.clear();
+            for (int i = 0; i < packetsId.length; i++) {
+                if (packetsId[i] == null)
+                    continue;
+                Constructor<? extends Packet> constructor = packetsId[i].getConstuctor();
+                if (constructor == null) continue;
+                registerPackets.add(constructor.getDeclaringClass());
+            }
+            packetListChanged = false;
+        }
+        return registerPackets;
+    }
+
+    public Packet getPacket0(ProtocollVersion version, Protocol protocol, Direction d, Integer id, ByteBuf b, Player p) {
+        int compressed = calculate(version, protocol, d, id);
+        PacketHolder cons = null;
+        if ((cons = packetsId[compressed]) == null) {
+            if (version.getBasedVersion().getProtocollVersion() == version) { //Fallback (based version) (1.8-1.9)
+                return null;
+            } else {
+                return getPacket0(version.getBasedVersion().getProtocollVersion(), protocol, d, id, b, p);
+            }
+        }
+        if (cons.getConstuctor() == null)
+            return null;
+        try {
+            Packet packet = cons.newInstance();
+            if (p == null || p.getVersion() == null) {
+                BungeeUtil.getInstance().debug("Version of '" + (p == null ? "<Null client>" : p.getName()) + "' is undefined");
+                return packet.setcompressedId(compressed).load(b, ClientVersion.UnderknownVersion);
+            } else return packet.setcompressedId(compressed).load(b, p.getVersion());
+        } catch (Exception e) {
+            throw ExceptionUtils.createRuntimeException(ExceptionUtils.setExceptionMessage(e, "Packet error (Version: " + (p == null ? "unknown" : p.getVersion()) + ", Readed version: " + version + ", Class: " + (cons == null || cons.getConstuctor() == null ? "null" : cons.getConstuctor().getDeclaringClass().getName()) + ", Id: 0x" + Integer.toHexString(id).toUpperCase() + ") -> " + e.getMessage()));
+        }
+    }
+
+    public Packet getPacket1(ProtocollVersion version, ProtocollVersion orginalVersion, Protocol protocol, Direction d, Integer id, ByteBuf b, Player p) {
+        return null;
+    }
+
+    public int loadPacket(ProtocollVersion version, Protocol p, Direction d, Integer id, Class<? extends Packet> clazz) {
+        //clazz = getPacketWithDefaultConstructor(clazz);
+        int compressedId = calculate(version, p, d, id);
+        classToId[version.ordinal()].put(clazz, compressedId);
+        return compressedId;
+    }
+
+    public void registerPacket(Protocol p, Direction d, Class<? extends Packet> clazz, ProtocollId... ids) {
+        //clazz = getPacketWithDefaultConstructor(clazz);
+        try {
+            for (ProtocollId id : ids)
+                if (id != null && id.isValid()) {
+                    packetsId[loadPacket(id.getVersion(), p, d, id.getId(), clazz)] = new PacketHolder(clazz == null ? null : (Constructor<? extends Packet>) clazz.getConstructor());
+                    /*
+                    if(id.getVersion().getBasedVersion().getProtocollVersion() != id.getVersion()){
 						int cid = loadPacket(id.getVersion().getBasedVersion().getProtocollVersion(),p, d, id.getId(), clazz);
 						if(packetsId[cid] == null)
 							packetsId[cid] = new PacketHolder(null);
 					}
 					*/
-				}
-		}
-		catch (NoSuchMethodException | SecurityException ex) {
-			System.out.println(clazz);
-			ex.printStackTrace();
-		}
-		packetListChanged = true;
-	}
-	
-	public void unregisterPacket(ProtocollVersion version,Protocol p, Direction d, Integer id) {
-		packetsId[calculate(version,p, d, id)] = null;
-		packetListChanged = true;
-	}
-	
-	public int countPackets() {
-		return getRegisteredPackets().size();
-	}
-	
-	/**
-	 * Try to create a default constructor.....
-	 */
-	/*
+                }
+        } catch (NoSuchMethodException | SecurityException ex) {
+            System.out.println(clazz);
+            ex.printStackTrace();
+        }
+        packetListChanged = true;
+    }
+
+    public void unregisterPacket(ProtocollVersion version, Protocol p, Direction d, Integer id) {
+        packetsId[calculate(version, p, d, id)] = null;
+        packetListChanged = true;
+    }
+
+    public int countPackets() {
+        return getRegisteredPackets().size();
+    }
+
+    @AllArgsConstructor
+    @Getter
+    private static class PacketHolder {
+        private Constructor<? extends Packet> constuctor;
+
+        public Packet newInstance() throws InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
+            return constuctor.newInstance();
+        }
+    }
+
+    /**
+     * Try to create a default constructor.....
+     */
+    /*
 	
 	@SuppressWarnings({ "unchecked", "deprecation" })
 	private static Class<? extends Packet> getPacketWithDefaultConstructor(final Class<? extends Packet> in) {
@@ -243,38 +237,46 @@ public class NormalPacketCreator extends AbstractPacketCreator {
 	*/
 }
 
-class TestPacket extends Packet{
-	String test = "undefined";
-	
-	public TestPacket(String test) {
-		this.test = test;
-	}
-	
-	@Override
-	public void read(PacketDataSerializer s) {
-		
-	}
+class TestPacket extends Packet {
+    String test = "undefined";
 
-	@Override
-	public void write(PacketDataSerializer s) {
-		
-	}
-	public String getTest() {
-		return test;
-	}
+    public TestPacket(String test) {
+        this.test = test;
+    }
+
+    @Override
+    public void read(PacketDataSerializer s) {
+
+    }
+
+    @Override
+    public void write(PacketDataSerializer s) {
+
+    }
+
+    public String getTest() {
+        return test;
+    }
 }
+
 class DemoTransformer implements ClassFileTransformer {
-    /** The internal form class name of the class to transform */
+    /**
+     * The internal form class name of the class to transform
+     */
     protected String className;
-    /** The class loader of the class */
+    /**
+     * The class loader of the class
+     */
     protected ClassLoader classLoader;
     private byte[] newData;
+
     /**
      * Creates a new DemoTransformer
-     * @param className The binary class name of the class to transform
+     *
+     * @param className   The binary class name of the class to transform
      * @param classLoader The class loader of the class
      */
-    public DemoTransformer(String className, ClassLoader classLoader,byte[] newData) {
+    public DemoTransformer(String className, ClassLoader classLoader, byte[] newData) {
         this.className = className.replace('.', '/');
         this.classLoader = classLoader;
         this.newData = newData;
@@ -282,14 +284,16 @@ class DemoTransformer implements ClassFileTransformer {
 
     /**
      * {@inheritDoc}
-     * @see java.lang.instrument.ClassFileTransformer#transform(java.lang.ClassLoader, java.lang.String, java.lang.Class, java.security.ProtectionDomain, byte[])
+     *
+     * @see java.lang.instrument.ClassFileTransformer#transform(java.lang.ClassLoader,
+     * java.lang.String, java.lang.Class, java.security.ProtectionDomain, byte[])
      */
     @Override
     public byte[] transform(ClassLoader loader, String className,
-            Class<?> classBeingRedefined, ProtectionDomain protectionDomain,
-            byte[] classfileBuffer) throws IllegalClassFormatException {
-        if(className.equals(this.className) && loader.equals(classLoader)) {
-        	System.out.println("Redefining");
+                            Class<?> classBeingRedefined, ProtectionDomain protectionDomain,
+                            byte[] classfileBuffer) throws IllegalClassFormatException {
+        if (className.equals(this.className) && loader.equals(classLoader)) {
+            System.out.println("Redefining");
             return newData;
         }
         return classfileBuffer;
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/Packet.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/Packet.java
index 2d9a0cd..465515d 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/packets/Packet.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/Packet.java
@@ -1,13 +1,11 @@
 package dev.wolveringer.BungeeUtil.packets;
 
-import io.netty.buffer.ByteBuf;
-import lombok.Getter;
+import net.md_5.bungee.protocol.Protocol;
+import net.md_5.bungee.protocol.ProtocolConstants.Direction;
 
 import java.util.List;
 import java.util.concurrent.atomic.AtomicLong;
 
-import net.md_5.bungee.protocol.Protocol;
-import net.md_5.bungee.protocol.ProtocolConstants.Direction;
 import dev.wolveringer.BungeeUtil.ClientVersion;
 import dev.wolveringer.BungeeUtil.ClientVersion.BigClientVersion;
 import dev.wolveringer.BungeeUtil.ClientVersion.ProtocollVersion;
@@ -16,277 +14,280 @@ import dev.wolveringer.BungeeUtil.Player;
 import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
 import dev.wolveringer.packet.ByteBuffCreator;
 import dev.wolveringer.packet.PacketDataSerializer;
+import io.netty.buffer.ByteBuf;
+import lombok.Getter;
 
 public abstract class Packet {
-	@Getter
-	public static class ProtocollId {
-		private ProtocollVersion version;
-		private int id;
-		
-		public ProtocollId(ProtocollVersion version, int id) {
-			this.version = version;
-			this.id = id;
-		}
-		
-		public ProtocollId(BigClientVersion version, int id) {
-			this.version = version.getProtocollVersion();
-			this.id = id;
-		}
-		
-		public boolean isValid() {
-			return id >= 0 && version != null && version != ProtocollVersion.Unsupported;
-		}
-		
-		@Override
-		public String toString() {
-			return "ProtocollId [version=" + version + ", id=" + Integer.toHexString(id) + "]";
-		}
-	}
-	
-	public static final AtomicLong classInstances = new AtomicLong();
-	
-	private static AbstractPacketCreator creator;
-	
-	public static AbstractPacketCreator getCreator() {
-		if (creator == null) {
-			creator = new NormalPacketCreator();
-		}
-		return creator;
-	}
-	
-	static {
-		registerPacket(Protocol.LOGIN, Direction.TO_CLIENT, PacketLoginDisconnect.class, new ProtocollId(BigClientVersion.v1_8, 0x00), new ProtocollId(BigClientVersion.v1_9, 0x00), new ProtocollId(BigClientVersion.v1_10, 0x00));
-		
-		registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutChat.class, new ProtocollId(BigClientVersion.v1_8, 0x02), new ProtocollId(BigClientVersion.v1_9, 0x0F), new ProtocollId(BigClientVersion.v1_10, 0x0F)); // ->0x0F
-		registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutPlayerListHeaderFooter.class, new ProtocollId(BigClientVersion.v1_8, 0x47), new ProtocollId(BigClientVersion.v1_9, 0x48), new ProtocollId(ProtocollVersion.v1_9_4, 0x47), new ProtocollId(BigClientVersion.v1_10, 0x47));// ->0x48
-		registerPacket(Protocol.GAME, Direction.TO_CLIENT, null, new ProtocollId(ProtocollVersion.v1_9_4, 0x48));
-		
-		registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutPosition.class, new ProtocollId(BigClientVersion.v1_8, 0x08), new ProtocollId(BigClientVersion.v1_9, 0x2E), new ProtocollId(BigClientVersion.v1_10, 0x2E)); // Changed -> 0x2E
-		
-		registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutEntityTeleport.class, new ProtocollId(BigClientVersion.v1_8, 0x18), new ProtocollId(BigClientVersion.v1_9, 0x4A), new ProtocollId(ProtocollVersion.v1_9_4, 0x49), new ProtocollId(BigClientVersion.v1_10, 0x49)); // Changed -> 0x2E | 1.9.4 other id!
-		registerPacket(Protocol.GAME, Direction.TO_CLIENT, null, new ProtocollId(ProtocollVersion.v1_9_4, 0x4A));
-		
-		registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutEntityHeadRotation.class, new ProtocollId(BigClientVersion.v1_8, 0x19), new ProtocollId(BigClientVersion.v1_9, 0x34), new ProtocollId(BigClientVersion.v1_10, 0x34));
-		
-		registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutTransaction.class, new ProtocollId(BigClientVersion.v1_8, 0x32), new ProtocollId(BigClientVersion.v1_9, 0x11), new ProtocollId(BigClientVersion.v1_10, 0x11)); // -> 0x11
-		registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutCloseWindow.class, new ProtocollId(BigClientVersion.v1_8, 0x2E), new ProtocollId(BigClientVersion.v1_9, 0x12), new ProtocollId(BigClientVersion.v1_10, 0x12));// -> 0x12
-		registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutOpenWindow.class, new ProtocollId(BigClientVersion.v1_8, 0x2D), new ProtocollId(BigClientVersion.v1_9, 0x13), new ProtocollId(BigClientVersion.v1_10, 0x13)); // -> 0x13
-		registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutWindowItems.class, new ProtocollId(BigClientVersion.v1_8, 0x30), new ProtocollId(BigClientVersion.v1_9, 0x14), new ProtocollId(BigClientVersion.v1_10, 0x14));// -> 0x14
-		registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutWindowData.class, new ProtocollId(BigClientVersion.v1_8, 0x31), new ProtocollId(BigClientVersion.v1_9, 0x15), new ProtocollId(BigClientVersion.v1_10, 0x15));// -> 0x15
-		registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutSetSlot.class, new ProtocollId(BigClientVersion.v1_8, 0x2F), new ProtocollId(BigClientVersion.v1_9, 0x16), new ProtocollId(BigClientVersion.v1_10, 0x16)); // -> 0x16
-		
-		registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutPluginMessage.class, new ProtocollId(BigClientVersion.v1_8, 0x3F), new ProtocollId(BigClientVersion.v1_9, 0x18), new ProtocollId(BigClientVersion.v1_10, 0x18));
-		
-		registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutEntityEquipment.class, new ProtocollId(BigClientVersion.v1_8, 0x04), new ProtocollId(BigClientVersion.v1_9, 0x3C), new ProtocollId(BigClientVersion.v1_10, 0x3C)); // Chaned
-		
-		registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutWorldParticles.class, new ProtocollId(BigClientVersion.v1_8, 0x2A), new ProtocollId(BigClientVersion.v1_9, 0x22), new ProtocollId(BigClientVersion.v1_10, 0x22));
-		
-		registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutDisconnect.class, new ProtocollId(BigClientVersion.v1_8, 0x40), new ProtocollId(BigClientVersion.v1_9, 0x1A), new ProtocollId(BigClientVersion.v1_10, 0x1A)); // 0x1A
-		
-		registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutScoreboardTeam.class, new ProtocollId(BigClientVersion.v1_8, 0x3E), new ProtocollId(BigClientVersion.v1_9, 0x41), new ProtocollId(BigClientVersion.v1_10, 0x41)); // -> 0x41
-		registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutScoreboardDisplayObjective.class, new ProtocollId(BigClientVersion.v1_8, 0x3D), new ProtocollId(BigClientVersion.v1_9, 0x38), new ProtocollId(BigClientVersion.v1_10, 0x38));// -> 0x38
-		registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutScoreboardObjective.class, new ProtocollId(BigClientVersion.v1_8, 0x3B), new ProtocollId(BigClientVersion.v1_9, 0x3F), new ProtocollId(BigClientVersion.v1_10, 0x3F)); // -> 0x3F
-		registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutScoreboardScore.class, new ProtocollId(BigClientVersion.v1_8, 0x3C), new ProtocollId(BigClientVersion.v1_9, 0x42), new ProtocollId(BigClientVersion.v1_10, 0x42)); // -> 0x42
-		
-		registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutStatistic.class, new ProtocollId(BigClientVersion.v1_8, 0x37), new ProtocollId(BigClientVersion.v1_9, 0x07), new ProtocollId(BigClientVersion.v1_10, 0x07)); // -> 0x07
-		registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutEntityDestroy.class, new ProtocollId(BigClientVersion.v1_8, 0x13), new ProtocollId(BigClientVersion.v1_9, 0x30), new ProtocollId(BigClientVersion.v1_10, 0x30));// -> 0x30
-		registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutEntityEffect.class, new ProtocollId(BigClientVersion.v1_8, 0x1D), new ProtocollId(BigClientVersion.v1_9, 0x4C), new ProtocollId(ProtocollVersion.v1_9_4, 0x4B), new ProtocollId(BigClientVersion.v1_10, 0x4B));// Changed ->
-		registerPacket(Protocol.GAME, Direction.TO_CLIENT, null, new ProtocollId(ProtocollVersion.v1_9_4, 0x4C));
-		
-		registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutRemoveEntityEffect.class, new ProtocollId(BigClientVersion.v1_8, 0x1E), new ProtocollId(BigClientVersion.v1_9, 0x31), new ProtocollId(BigClientVersion.v1_10, 0x31));
-		registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutGameStateChange.class, new ProtocollId(BigClientVersion.v1_8, 0x2B), new ProtocollId(BigClientVersion.v1_9, 0x1E), new ProtocollId(BigClientVersion.v1_10, 0x1E));// -> 0x31
-		
-		registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutPlayerInfo.class, new ProtocollId(BigClientVersion.v1_8, 0x38), new ProtocollId(BigClientVersion.v1_9, 0x2D), new ProtocollId(BigClientVersion.v1_10, 0x2D));// -> 0x2D
-		
-		registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutHeldItemSlot.class, new ProtocollId(BigClientVersion.v1_8, 0x09), new ProtocollId(BigClientVersion.v1_9, 0x37), new ProtocollId(BigClientVersion.v1_10, 0x37));// -> 0x37
-		registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutUpdateSign.class, new ProtocollId(BigClientVersion.v1_8, 0x33)); // 1.9 -> TitleEntityNBTData ;)
-		
-		registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutBossBar.class, new ProtocollId(BigClientVersion.v1_9, 0x0C), new ProtocollId(BigClientVersion.v1_10, 0x0C)); // Only 1.9 :) Best Bar-Update Ever!
-		
-		registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutNamedSoundEffect.class, new ProtocollId(BigClientVersion.v1_8, 0x29), new ProtocollId(BigClientVersion.v1_9, 0x19), new ProtocollId(ProtocollVersion.v1_9_4, 0x19), new ProtocollId(BigClientVersion.v1_10, 0x19)); // Changed
-		//registerPacket(Protocol.GAME, Direction.TO_CLIENT, null, new ProtocollId(ProtocollVersion.v1_9_4, 0x19));
-		
-		registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutNamedEntitySpawn.class, new ProtocollId(BigClientVersion.v1_8, 0x0C), new ProtocollId(BigClientVersion.v1_9, 0x05), new ProtocollId(BigClientVersion.v1_10, 0x05));
-		registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutTitle.class, new ProtocollId(BigClientVersion.v1_8, 0x45), new ProtocollId(BigClientVersion.v1_9, 0x45), new ProtocollId(BigClientVersion.v1_10, 0x45));
-		// registerPacket(Protocol.GAME, Direction.TO_CLIENT, 0x21, PacketPlayOutMapChunk.class, new ProtocollId(BigClientVersion.v1_8, 0x00), new ProtocollId(BigClientVersion.v1_9, 0x00), new ProtocollId(BigClientVersion.v1_10, 0x00); //TODO Chunk Serelizer (Premium bungee src)
-		// registerPacket(Protocol.GAME, Direction.TO_CLIENT, 0x26, PacketPlayOutMapChunkBulk.class, new ProtocollId(BigClientVersion.v1_8, 0x00), new ProtocollId(BigClientVersion.v1_9, 0x00), new ProtocollId(BigClientVersion.v1_10, 0x00); //TODO Chunk Serelizer (Premium bungee src)
-		
-		registerPacket(Protocol.GAME, Direction.TO_SERVER, PacketPlayInClientState.class, new ProtocollId(BigClientVersion.v1_8, 0x16), new ProtocollId(BigClientVersion.v1_9, 0x03), new ProtocollId(BigClientVersion.v1_10, 0x03)); // Changed
-		//
-		registerPacket(Protocol.GAME, Direction.TO_SERVER, PacketPlayInPluginMessage.class,new ProtocollId(BigClientVersion.v1_8, 0x17),  new ProtocollId(BigClientVersion.v1_9, 0x09), new ProtocollId(BigClientVersion.v1_10, 0x09));
-		
-		registerPacket(Protocol.GAME, Direction.TO_SERVER, PacketPlayInChat.class, new ProtocollId(BigClientVersion.v1_8, 0x01), new ProtocollId(BigClientVersion.v1_9, 0x02), new ProtocollId(BigClientVersion.v1_10, 0x02)); // -> 0x02
-		registerPacket(Protocol.GAME, Direction.TO_SERVER, PacketPlayInUseEntity.class, new ProtocollId(BigClientVersion.v1_8, 0x02), new ProtocollId(BigClientVersion.v1_9, 0x0A), new ProtocollId(BigClientVersion.v1_10, 0x0A)); // -> changed
-		registerPacket(Protocol.GAME, Direction.TO_SERVER, PacketPlayInHeldItemSlot.class, new ProtocollId(BigClientVersion.v1_8, 0x09), new ProtocollId(BigClientVersion.v1_9, 0x17), new ProtocollId(BigClientVersion.v1_10, 0x17));// -> 0x17
-		
-		registerPacket(Protocol.GAME, Direction.TO_SERVER, PacketPlayInPosition.class, new ProtocollId(BigClientVersion.v1_8, 0x04), new ProtocollId(BigClientVersion.v1_9, 0x0C), new ProtocollId(BigClientVersion.v1_10, 0x0C));// -> 0x0C
-		registerPacket(Protocol.GAME, Direction.TO_SERVER, PacketPlayInPositionLook.class, new ProtocollId(BigClientVersion.v1_8, 0x06), new ProtocollId(BigClientVersion.v1_9, 0x0D), new ProtocollId(BigClientVersion.v1_10, 0x0D));// -> 0x0D
-		registerPacket(Protocol.GAME, Direction.TO_SERVER, PacketPlayInLook.class, new ProtocollId(BigClientVersion.v1_8, 0x05), new ProtocollId(BigClientVersion.v1_9, 0x0E), new ProtocollId(BigClientVersion.v1_10, 0x0E));// -> 0x0E
-		
-		registerPacket(Protocol.GAME, Direction.TO_SERVER, PacketPlayInWindowClick.class, new ProtocollId(BigClientVersion.v1_8, 0x0E), new ProtocollId(BigClientVersion.v1_9, 0x07), new ProtocollId(BigClientVersion.v1_10, 0x07)); // 0x07
-		registerPacket(Protocol.GAME, Direction.TO_SERVER, PacketPlayInCloseWindow.class, new ProtocollId(BigClientVersion.v1_8, 0x0D), new ProtocollId(BigClientVersion.v1_9, 0x08), new ProtocollId(BigClientVersion.v1_10, 0x08)); // 0x08
-		registerPacket(Protocol.GAME, Direction.TO_SERVER, PacketPlayInBlockDig.class, new ProtocollId(BigClientVersion.v1_8, 0x07), new ProtocollId(BigClientVersion.v1_9, 0x13), new ProtocollId(BigClientVersion.v1_10, 0x13)); // 0x13
-		
-		registerPacket(Protocol.GAME, Direction.TO_SERVER, PacketPlayInArmAnimation.class, new ProtocollId(BigClientVersion.v1_8, 0x0A), new ProtocollId(BigClientVersion.v1_9, 0x1A), new ProtocollId(BigClientVersion.v1_10, 0x1A));
-		registerPacket(Protocol.GAME, Direction.TO_SERVER, PacketPlayInBlockPlace.class, new ProtocollId(BigClientVersion.v1_8, 0x08), new ProtocollId(BigClientVersion.v1_9, 0x1C), new ProtocollId(BigClientVersion.v1_10, 0x1C));
-		// TODO Make it working! registerPacket(Protocol.GAME, Direction.TO_SERVER, 0x12, PacketPlayInUpdateSign.class, new ProtocollId(BigClientVersion.v1_8, 0x00), new ProtocollId(BigClientVersion.v1_9, 0x00), new ProtocollId(BigClientVersion.v1_10, 0x00); //Changed from ChatComponent to String
-	}
-	
-	public static int calculate(ProtocollVersion version, Protocol p, Direction d, Integer id) {
-		return getCreator().calculate(version, p, d, id);
-	}
-	
-	public static int getPacketId(int base) {
-		return getCreator().getPacketId(base);
-	}
-	
-	public static Protocol getProtocoll(int base) {
-		return getCreator().getProtocoll(base);
-	}
-	
-	public static Direction getDirection(int base) {
-		return getCreator().getDirection(base);
-	}
-	
-	public static Packet getPacket(ProtocollVersion version, Protocol s, Direction d, ByteBuf b, Player p) {
-		return getCreator().getPacket(version, s, d, b, p);
-	}
-	
-	public static void listPackets(CostumPrintStream out) {
-		getCreator().listPackets(out);
-	}
-	
-	public static void listPackets() {
-		getCreator().listPackets();
-	}
-	
-	public static int loadPacket(ProtocollVersion version, Protocol p, Direction d, Integer id, Class<? extends Packet> clazz) {
-		return getCreator().loadPacket(version, p, d, id, clazz);
-	}
-	
-	@Deprecated
-	public static void registerPacket(Protocol p, Direction d, Integer v1_8_id, Integer v1_9_id, Class<? extends Packet> clazz) {
-		if (v1_8_id == null && v1_9_id == null) throw new RuntimeException("All packet ids are null!");
-		if (v1_8_id == null) v1_8_id = -1;
-		if (v1_9_id == null) v1_9_id = -1;
-		registerPacket(p, d, clazz, new ProtocollId(BigClientVersion.v1_8, v1_8_id), new ProtocollId(BigClientVersion.v1_9, v1_9_id));
-	}
-	
-	public static void registerPacket(Protocol p, Direction d, Class<? extends Packet> clazz, ProtocollId... ids) {
-		getCreator().registerPacket(p, d, clazz, ids);
-	}
-	
-	public static void unregisterPacket(ProtocollVersion version, Protocol p, Direction d, Integer id) {
-		getCreator().unregisterPacket(version, p, d, id);
-	}
-	
-	public static int countPackets() {
-		return getCreator().countPackets();
-	}
-	
-	public static int getPacketId(ProtocollVersion version, Class<? extends Packet> clazz) {
-		return getCreator().getPacketId(version, clazz);
-	}
-	
-	public static List<Class<? extends Packet>> getRegisteredPackets() {
-		return getCreator().getRegisteredPackets();
-	}
-	
+    public static final AtomicLong classInstances = new AtomicLong();
+    private static AbstractPacketCreator creator;
+
+    static {
+        registerPacket(Protocol.LOGIN, Direction.TO_CLIENT, PacketLoginDisconnect.class, new ProtocollId(BigClientVersion.v1_8, 0x00), new ProtocollId(BigClientVersion.v1_9, 0x00), new ProtocollId(BigClientVersion.v1_10, 0x00));
+
+        registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutChat.class, new ProtocollId(BigClientVersion.v1_8, 0x02), new ProtocollId(BigClientVersion.v1_9, 0x0F), new ProtocollId(BigClientVersion.v1_10, 0x0F)); // ->0x0F
+        registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutPlayerListHeaderFooter.class, new ProtocollId(BigClientVersion.v1_8, 0x47), new ProtocollId(BigClientVersion.v1_9, 0x48), new ProtocollId(ProtocollVersion.v1_9_4, 0x47), new ProtocollId(BigClientVersion.v1_10, 0x47));// ->0x48
+        registerPacket(Protocol.GAME, Direction.TO_CLIENT, null, new ProtocollId(ProtocollVersion.v1_9_4, 0x48));
+
+        registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutPosition.class, new ProtocollId(BigClientVersion.v1_8, 0x08), new ProtocollId(BigClientVersion.v1_9, 0x2E), new ProtocollId(BigClientVersion.v1_10, 0x2E)); // Changed -> 0x2E
+
+        registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutEntityTeleport.class, new ProtocollId(BigClientVersion.v1_8, 0x18), new ProtocollId(BigClientVersion.v1_9, 0x4A), new ProtocollId(ProtocollVersion.v1_9_4, 0x49), new ProtocollId(BigClientVersion.v1_10, 0x49)); // Changed -> 0x2E | 1.9.4 other id!
+        registerPacket(Protocol.GAME, Direction.TO_CLIENT, null, new ProtocollId(ProtocollVersion.v1_9_4, 0x4A));
+
+        registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutEntityHeadRotation.class, new ProtocollId(BigClientVersion.v1_8, 0x19), new ProtocollId(BigClientVersion.v1_9, 0x34), new ProtocollId(BigClientVersion.v1_10, 0x34));
+
+        registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutTransaction.class, new ProtocollId(BigClientVersion.v1_8, 0x32), new ProtocollId(BigClientVersion.v1_9, 0x11), new ProtocollId(BigClientVersion.v1_10, 0x11)); // -> 0x11
+        registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutCloseWindow.class, new ProtocollId(BigClientVersion.v1_8, 0x2E), new ProtocollId(BigClientVersion.v1_9, 0x12), new ProtocollId(BigClientVersion.v1_10, 0x12));// -> 0x12
+        registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutOpenWindow.class, new ProtocollId(BigClientVersion.v1_8, 0x2D), new ProtocollId(BigClientVersion.v1_9, 0x13), new ProtocollId(BigClientVersion.v1_10, 0x13)); // -> 0x13
+        registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutWindowItems.class, new ProtocollId(BigClientVersion.v1_8, 0x30), new ProtocollId(BigClientVersion.v1_9, 0x14), new ProtocollId(BigClientVersion.v1_10, 0x14));// -> 0x14
+        registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutWindowData.class, new ProtocollId(BigClientVersion.v1_8, 0x31), new ProtocollId(BigClientVersion.v1_9, 0x15), new ProtocollId(BigClientVersion.v1_10, 0x15));// -> 0x15
+        registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutSetSlot.class, new ProtocollId(BigClientVersion.v1_8, 0x2F), new ProtocollId(BigClientVersion.v1_9, 0x16), new ProtocollId(BigClientVersion.v1_10, 0x16)); // -> 0x16
+
+        registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutPluginMessage.class, new ProtocollId(BigClientVersion.v1_8, 0x3F), new ProtocollId(BigClientVersion.v1_9, 0x18), new ProtocollId(BigClientVersion.v1_10, 0x18));
+
+        registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutEntityEquipment.class, new ProtocollId(BigClientVersion.v1_8, 0x04), new ProtocollId(BigClientVersion.v1_9, 0x3C), new ProtocollId(BigClientVersion.v1_10, 0x3C)); // Chaned
+
+        registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutWorldParticles.class, new ProtocollId(BigClientVersion.v1_8, 0x2A), new ProtocollId(BigClientVersion.v1_9, 0x22), new ProtocollId(BigClientVersion.v1_10, 0x22));
+
+        registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutDisconnect.class, new ProtocollId(BigClientVersion.v1_8, 0x40), new ProtocollId(BigClientVersion.v1_9, 0x1A), new ProtocollId(BigClientVersion.v1_10, 0x1A)); // 0x1A
+
+        registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutScoreboardTeam.class, new ProtocollId(BigClientVersion.v1_8, 0x3E), new ProtocollId(BigClientVersion.v1_9, 0x41), new ProtocollId(BigClientVersion.v1_10, 0x41)); // -> 0x41
+        registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutScoreboardDisplayObjective.class, new ProtocollId(BigClientVersion.v1_8, 0x3D), new ProtocollId(BigClientVersion.v1_9, 0x38), new ProtocollId(BigClientVersion.v1_10, 0x38));// -> 0x38
+        registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutScoreboardObjective.class, new ProtocollId(BigClientVersion.v1_8, 0x3B), new ProtocollId(BigClientVersion.v1_9, 0x3F), new ProtocollId(BigClientVersion.v1_10, 0x3F)); // -> 0x3F
+        registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutScoreboardScore.class, new ProtocollId(BigClientVersion.v1_8, 0x3C), new ProtocollId(BigClientVersion.v1_9, 0x42), new ProtocollId(BigClientVersion.v1_10, 0x42)); // -> 0x42
+
+        registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutStatistic.class, new ProtocollId(BigClientVersion.v1_8, 0x37), new ProtocollId(BigClientVersion.v1_9, 0x07), new ProtocollId(BigClientVersion.v1_10, 0x07)); // -> 0x07
+        registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutEntityDestroy.class, new ProtocollId(BigClientVersion.v1_8, 0x13), new ProtocollId(BigClientVersion.v1_9, 0x30), new ProtocollId(BigClientVersion.v1_10, 0x30));// -> 0x30
+        registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutEntityEffect.class, new ProtocollId(BigClientVersion.v1_8, 0x1D), new ProtocollId(BigClientVersion.v1_9, 0x4C), new ProtocollId(ProtocollVersion.v1_9_4, 0x4B), new ProtocollId(BigClientVersion.v1_10, 0x4B));// Changed ->
+        registerPacket(Protocol.GAME, Direction.TO_CLIENT, null, new ProtocollId(ProtocollVersion.v1_9_4, 0x4C));
+
+        registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutRemoveEntityEffect.class, new ProtocollId(BigClientVersion.v1_8, 0x1E), new ProtocollId(BigClientVersion.v1_9, 0x31), new ProtocollId(BigClientVersion.v1_10, 0x31));
+        registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutGameStateChange.class, new ProtocollId(BigClientVersion.v1_8, 0x2B), new ProtocollId(BigClientVersion.v1_9, 0x1E), new ProtocollId(BigClientVersion.v1_10, 0x1E));// -> 0x31
+
+        registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutPlayerInfo.class, new ProtocollId(BigClientVersion.v1_8, 0x38), new ProtocollId(BigClientVersion.v1_9, 0x2D), new ProtocollId(BigClientVersion.v1_10, 0x2D));// -> 0x2D
+
+        registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutHeldItemSlot.class, new ProtocollId(BigClientVersion.v1_8, 0x09), new ProtocollId(BigClientVersion.v1_9, 0x37), new ProtocollId(BigClientVersion.v1_10, 0x37));// -> 0x37
+        registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutUpdateSign.class, new ProtocollId(BigClientVersion.v1_8, 0x33)); // 1.9 -> TitleEntityNBTData ;)
+
+        registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutBossBar.class, new ProtocollId(BigClientVersion.v1_9, 0x0C), new ProtocollId(BigClientVersion.v1_10, 0x0C)); // Only 1.9 :) Best Bar-Update Ever!
+
+        registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutNamedSoundEffect.class, new ProtocollId(BigClientVersion.v1_8, 0x29), new ProtocollId(BigClientVersion.v1_9, 0x19), new ProtocollId(ProtocollVersion.v1_9_4, 0x19), new ProtocollId(BigClientVersion.v1_10, 0x19)); // Changed
+        //registerPacket(Protocol.GAME, Direction.TO_CLIENT, null, new ProtocollId(ProtocollVersion.v1_9_4, 0x19));
+
+        registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutNamedEntitySpawn.class, new ProtocollId(BigClientVersion.v1_8, 0x0C), new ProtocollId(BigClientVersion.v1_9, 0x05), new ProtocollId(BigClientVersion.v1_10, 0x05));
+        registerPacket(Protocol.GAME, Direction.TO_CLIENT, PacketPlayOutTitle.class, new ProtocollId(BigClientVersion.v1_8, 0x45), new ProtocollId(BigClientVersion.v1_9, 0x45), new ProtocollId(BigClientVersion.v1_10, 0x45));
+        // registerPacket(Protocol.GAME, Direction.TO_CLIENT, 0x21, PacketPlayOutMapChunk.class, new ProtocollId(BigClientVersion.v1_8, 0x00), new ProtocollId(BigClientVersion.v1_9, 0x00), new ProtocollId(BigClientVersion.v1_10, 0x00); //TODO Chunk Serelizer (Premium bungee src)
+        // registerPacket(Protocol.GAME, Direction.TO_CLIENT, 0x26, PacketPlayOutMapChunkBulk.class, new ProtocollId(BigClientVersion.v1_8, 0x00), new ProtocollId(BigClientVersion.v1_9, 0x00), new ProtocollId(BigClientVersion.v1_10, 0x00); //TODO Chunk Serelizer (Premium bungee src)
+
+        registerPacket(Protocol.GAME, Direction.TO_SERVER, PacketPlayInClientState.class, new ProtocollId(BigClientVersion.v1_8, 0x16), new ProtocollId(BigClientVersion.v1_9, 0x03), new ProtocollId(BigClientVersion.v1_10, 0x03)); // Changed
+        //
+        registerPacket(Protocol.GAME, Direction.TO_SERVER, PacketPlayInPluginMessage.class, new ProtocollId(BigClientVersion.v1_8, 0x17), new ProtocollId(BigClientVersion.v1_9, 0x09), new ProtocollId(BigClientVersion.v1_10, 0x09));
+
+        registerPacket(Protocol.GAME, Direction.TO_SERVER, PacketPlayInChat.class, new ProtocollId(BigClientVersion.v1_8, 0x01), new ProtocollId(BigClientVersion.v1_9, 0x02), new ProtocollId(BigClientVersion.v1_10, 0x02)); // -> 0x02
+        registerPacket(Protocol.GAME, Direction.TO_SERVER, PacketPlayInUseEntity.class, new ProtocollId(BigClientVersion.v1_8, 0x02), new ProtocollId(BigClientVersion.v1_9, 0x0A), new ProtocollId(BigClientVersion.v1_10, 0x0A)); // -> changed
+        registerPacket(Protocol.GAME, Direction.TO_SERVER, PacketPlayInHeldItemSlot.class, new ProtocollId(BigClientVersion.v1_8, 0x09), new ProtocollId(BigClientVersion.v1_9, 0x17), new ProtocollId(BigClientVersion.v1_10, 0x17));// -> 0x17
+
+        registerPacket(Protocol.GAME, Direction.TO_SERVER, PacketPlayInPosition.class, new ProtocollId(BigClientVersion.v1_8, 0x04), new ProtocollId(BigClientVersion.v1_9, 0x0C), new ProtocollId(BigClientVersion.v1_10, 0x0C));// -> 0x0C
+        registerPacket(Protocol.GAME, Direction.TO_SERVER, PacketPlayInPositionLook.class, new ProtocollId(BigClientVersion.v1_8, 0x06), new ProtocollId(BigClientVersion.v1_9, 0x0D), new ProtocollId(BigClientVersion.v1_10, 0x0D));// -> 0x0D
+        registerPacket(Protocol.GAME, Direction.TO_SERVER, PacketPlayInLook.class, new ProtocollId(BigClientVersion.v1_8, 0x05), new ProtocollId(BigClientVersion.v1_9, 0x0E), new ProtocollId(BigClientVersion.v1_10, 0x0E));// -> 0x0E
+
+        registerPacket(Protocol.GAME, Direction.TO_SERVER, PacketPlayInWindowClick.class, new ProtocollId(BigClientVersion.v1_8, 0x0E), new ProtocollId(BigClientVersion.v1_9, 0x07), new ProtocollId(BigClientVersion.v1_10, 0x07)); // 0x07
+        registerPacket(Protocol.GAME, Direction.TO_SERVER, PacketPlayInCloseWindow.class, new ProtocollId(BigClientVersion.v1_8, 0x0D), new ProtocollId(BigClientVersion.v1_9, 0x08), new ProtocollId(BigClientVersion.v1_10, 0x08)); // 0x08
+        registerPacket(Protocol.GAME, Direction.TO_SERVER, PacketPlayInBlockDig.class, new ProtocollId(BigClientVersion.v1_8, 0x07), new ProtocollId(BigClientVersion.v1_9, 0x13), new ProtocollId(BigClientVersion.v1_10, 0x13)); // 0x13
+
+        registerPacket(Protocol.GAME, Direction.TO_SERVER, PacketPlayInArmAnimation.class, new ProtocollId(BigClientVersion.v1_8, 0x0A), new ProtocollId(BigClientVersion.v1_9, 0x1A), new ProtocollId(BigClientVersion.v1_10, 0x1A));
+        registerPacket(Protocol.GAME, Direction.TO_SERVER, PacketPlayInBlockPlace.class, new ProtocollId(BigClientVersion.v1_8, 0x08), new ProtocollId(BigClientVersion.v1_9, 0x1C), new ProtocollId(BigClientVersion.v1_10, 0x1C));
+        // TODO Make it working! registerPacket(Protocol.GAME, Direction.TO_SERVER, 0x12, PacketPlayInUpdateSign.class, new ProtocollId(BigClientVersion.v1_8, 0x00), new ProtocollId(BigClientVersion.v1_9, 0x00), new ProtocollId(BigClientVersion.v1_10, 0x00); //Changed from ChatComponent to String
+    }
+
+    private int compressedId = -1;
+    private transient ClientVersion version = ClientVersion.UnderknownVersion;
+    private ClientVersion readedVersion = ClientVersion.UnderknownVersion;
+    private ClientVersion writtenVersion = ClientVersion.UnderknownVersion;
+
+    public Packet() {
+        classInstances.addAndGet(1);
+    }
+
+    public Packet(int id) {
+        this();
+    }
+
+    public Packet(byte id) {
+        this();
+    }
+
+    public static AbstractPacketCreator getCreator() {
+        if (creator == null) {
+            creator = new NormalPacketCreator();
+        }
+        return creator;
+    }
+
+    public static int calculate(ProtocollVersion version, Protocol p, Direction d, Integer id) {
+        return getCreator().calculate(version, p, d, id);
+    }
+
+    public static int getPacketId(int base) {
+        return getCreator().getPacketId(base);
+    }
+
+    public static Protocol getProtocoll(int base) {
+        return getCreator().getProtocoll(base);
+    }
+
+    public static Direction getDirection(int base) {
+        return getCreator().getDirection(base);
+    }
+
+    public static Packet getPacket(ProtocollVersion version, Protocol s, Direction d, ByteBuf b, Player p) {
+        return getCreator().getPacket(version, s, d, b, p);
+    }
+
+    public static void listPackets(CostumPrintStream out) {
+        getCreator().listPackets(out);
+    }
+
+    public static void listPackets() {
+        getCreator().listPackets();
+    }
+
+    public static int loadPacket(ProtocollVersion version, Protocol p, Direction d, Integer id, Class<? extends Packet> clazz) {
+        return getCreator().loadPacket(version, p, d, id, clazz);
+    }
+
 	/*
 	 * -------------------------------------------------------------------------
 	 * ------------------------------
 	 */
-	
-	private int compressedId = -1;
-	private transient ClientVersion version = ClientVersion.UnderknownVersion;
-	private ClientVersion readedVersion = ClientVersion.UnderknownVersion;
-	private ClientVersion writtenVersion = ClientVersion.UnderknownVersion;
-	
-	protected Packet setcompressedId(int id) {
-		this.compressedId = id;
-		return this;
-	}
-	
-	public Packet() {
-		classInstances.addAndGet(1);
-	}
-	
-	public Packet(int id) {
-		this();
-	}
-	
-	public Packet(byte id) {
-		this();
-	}
-	
-	public Protocol getProtocol() {
-		if (compressedId == -1) compressedId = getPacketId(version.getProtocollVersion(), this.getClass());
-		return getProtocoll(compressedId);
-	}
-	
-	public ByteBuf getByteBuf(ClientVersion version) {
-		this.version = version;
-		compressedId = getPacketId(version.getProtocollVersion(), this.getClass());
-		return writeToByteBuff(null, version);
-	}
-	
-	public ByteBuf writeToByteBuff(ByteBuf buf, ClientVersion version) {
-		if(getPacketId(compressedId) < 0)
-			throw new RuntimeException("Unexpected packet id ("+getPacketId(compressedId) +")");
-		PacketDataSerializer s;
-		if (buf == null) {
-			buf = ByteBuffCreator.createByteBuff();
-		}
-		if (buf instanceof PacketDataSerializer) {
-			s = (PacketDataSerializer) buf;
-		}
-		else {
-			s = PacketDataSerializer.create(getPacketId(compressedId), version, buf);
-		}
-		this.version = (writtenVersion = version);
-		this.write(s);
-		this.version = ClientVersion.UnderknownVersion;
-		return s;
-	}
-	
-	protected Packet load(ByteBuf b, ClientVersion version) {
-		this.version = (readedVersion = version);
-		read(PacketDataSerializer.create(b, version));
-		this.version = ClientVersion.UnderknownVersion;
-		if (b.readableBytes() != 0) throw new RuntimeException("Did not read all bytes from packet (" + this.getClass().getName() + ")");
-		return this;
-	}
-	
-	public abstract void read(PacketDataSerializer s);
-	
-	public void sendPacket(Player p) {
-		if (this instanceof PacketPlayOut) p.sendPacket((PacketPlayOut) this);
-		else throw new IllegalStateException("PacketPlayIn cant send to player");
-	}
-	
-	public abstract void write(PacketDataSerializer s);
-	
-	@Deprecated
-	protected BigClientVersion getBigVersion() {
-		return version.getBigVersion();
-	}
-	
-	public ClientVersion getReadedVersion() {
-		return readedVersion;
-	}
-	
-	public ClientVersion getWrittenVersion() {
-		return writtenVersion;
-	}
-	
-	@Deprecated
-	protected ClientVersion getVersion() {
-		return version;
-	}
-	
-	@Override
-	protected void finalize() throws Throwable {
-		compressedId = -1;
-		classInstances.addAndGet(-1);
-	}
+
+    @Deprecated
+    public static void registerPacket(Protocol p, Direction d, Integer v1_8_id, Integer v1_9_id, Class<? extends Packet> clazz) {
+        if (v1_8_id == null && v1_9_id == null)
+            throw new RuntimeException("All packet ids are null!");
+        if (v1_8_id == null) v1_8_id = -1;
+        if (v1_9_id == null) v1_9_id = -1;
+        registerPacket(p, d, clazz, new ProtocollId(BigClientVersion.v1_8, v1_8_id), new ProtocollId(BigClientVersion.v1_9, v1_9_id));
+    }
+
+    public static void registerPacket(Protocol p, Direction d, Class<? extends Packet> clazz, ProtocollId... ids) {
+        getCreator().registerPacket(p, d, clazz, ids);
+    }
+
+    public static void unregisterPacket(ProtocollVersion version, Protocol p, Direction d, Integer id) {
+        getCreator().unregisterPacket(version, p, d, id);
+    }
+
+    public static int countPackets() {
+        return getCreator().countPackets();
+    }
+
+    public static int getPacketId(ProtocollVersion version, Class<? extends Packet> clazz) {
+        return getCreator().getPacketId(version, clazz);
+    }
+
+    public static List<Class<? extends Packet>> getRegisteredPackets() {
+        return getCreator().getRegisteredPackets();
+    }
+
+    protected Packet setcompressedId(int id) {
+        this.compressedId = id;
+        return this;
+    }
+
+    public Protocol getProtocol() {
+        if (compressedId == -1)
+            compressedId = getPacketId(version.getProtocollVersion(), this.getClass());
+        return getProtocoll(compressedId);
+    }
+
+    public ByteBuf getByteBuf(ClientVersion version) {
+        this.version = version;
+        compressedId = getPacketId(version.getProtocollVersion(), this.getClass());
+        return writeToByteBuff(null, version);
+    }
+
+    public ByteBuf writeToByteBuff(ByteBuf buf, ClientVersion version) {
+        if (getPacketId(compressedId) < 0)
+            throw new RuntimeException("Unexpected packet id (" + getPacketId(compressedId) + ")");
+        PacketDataSerializer s;
+        if (buf == null) {
+            buf = ByteBuffCreator.createByteBuff();
+        }
+        if (buf instanceof PacketDataSerializer) {
+            s = (PacketDataSerializer) buf;
+        } else {
+            s = PacketDataSerializer.create(getPacketId(compressedId), version, buf);
+        }
+        this.version = (writtenVersion = version);
+        this.write(s);
+        this.version = ClientVersion.UnderknownVersion;
+        return s;
+    }
+
+    protected Packet load(ByteBuf b, ClientVersion version) {
+        this.version = (readedVersion = version);
+        read(PacketDataSerializer.create(b, version));
+        this.version = ClientVersion.UnderknownVersion;
+        if (b.readableBytes() != 0)
+            throw new RuntimeException("Did not read all bytes from packet (" + this.getClass().getName() + ")");
+        return this;
+    }
+
+    public abstract void read(PacketDataSerializer s);
+
+    public void sendPacket(Player p) {
+        if (this instanceof PacketPlayOut) p.sendPacket((PacketPlayOut) this);
+        else throw new IllegalStateException("PacketPlayIn cant send to player");
+    }
+
+    public abstract void write(PacketDataSerializer s);
+
+    @Deprecated
+    protected BigClientVersion getBigVersion() {
+        return version.getBigVersion();
+    }
+
+    public ClientVersion getReadedVersion() {
+        return readedVersion;
+    }
+
+    public ClientVersion getWrittenVersion() {
+        return writtenVersion;
+    }
+
+    @Deprecated
+    protected ClientVersion getVersion() {
+        return version;
+    }
+
+    @Override
+    protected void finalize() throws Throwable {
+        compressedId = -1;
+        classInstances.addAndGet(-1);
+    }
+
+    @Getter
+    public static class ProtocollId {
+        private ProtocollVersion version;
+        private int id;
+
+        public ProtocollId(ProtocollVersion version, int id) {
+            this.version = version;
+            this.id = id;
+        }
+
+        public ProtocollId(BigClientVersion version, int id) {
+            this.version = version.getProtocollVersion();
+            this.id = id;
+        }
+
+        public boolean isValid() {
+            return id >= 0 && version != null && version != ProtocollVersion.Unsupported;
+        }
+
+        @Override
+        public String toString() {
+            return "ProtocollId [version=" + version + ", id=" + Integer.toHexString(id) + "]";
+        }
+    }
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketLoginDisconnect.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketLoginDisconnect.java
index 31831c5..f05cdad 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketLoginDisconnect.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketLoginDisconnect.java
@@ -6,31 +6,31 @@ import dev.wolveringer.packet.PacketDataSerializer;
 import dev.wolveringer.util.ByteString;
 
 public class PacketLoginDisconnect extends Packet {
-	private ByteString reson;
+    private ByteString reson;
 
-	public PacketLoginDisconnect(String reson) {
-		this.reson = new ByteString(reson);
-	}
+    public PacketLoginDisconnect(String reson) {
+        this.reson = new ByteString(reson);
+    }
 
-	public PacketLoginDisconnect() {
-		super(-1);
-	}
+    public PacketLoginDisconnect() {
+        super(-1);
+    }
 
-	@Override
-	public void read(PacketDataSerializer s) {
-		reson = s.readStringBytes();
-	}
+    @Override
+    public void read(PacketDataSerializer s) {
+        reson = s.readStringBytes();
+    }
 
-	@Override
-	public void write(PacketDataSerializer s) {
-		s.write(reson);
-	}
+    @Override
+    public void write(PacketDataSerializer s) {
+        s.write(reson);
+    }
 
-	public IChatBaseComponent getReson() {
-		return ChatSerializer.fromJSON(reson.getString());
-	}
+    public IChatBaseComponent getReson() {
+        return ChatSerializer.fromJSON(reson.getString());
+    }
 
-	public void setReson(IChatBaseComponent reson) {
-		this.reson = new ByteString(ChatSerializer.toJSONString(reson));
-	}
+    public void setReson(IChatBaseComponent reson) {
+        this.reson = new ByteString(ChatSerializer.toJSONString(reson));
+    }
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInArmAnimation.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInArmAnimation.java
index b43716f..5d38f6d 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInArmAnimation.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInArmAnimation.java
@@ -1,45 +1,44 @@
 package dev.wolveringer.BungeeUtil.packets;
 
-import dev.wolveringer.BungeeUtil.HandType;
 import dev.wolveringer.BungeeUtil.ClientVersion.BigClientVersion;
+import dev.wolveringer.BungeeUtil.HandType;
 import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayIn;
 import dev.wolveringer.packet.PacketDataSerializer;
 
 public class PacketPlayInArmAnimation extends Packet implements PacketPlayIn {
-	private int id;
-	private int type;
+    private int id;
+    private int type;
+
+    public PacketPlayInArmAnimation() {
+        super(0x0A);
+    }
+
+    @Override
+    public void read(PacketDataSerializer s) {
+        if (getBigVersion() == BigClientVersion.v1_7) {
+            this.id = s.readInt();
+            this.type = s.readByte();
+        } else if (getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10)
+            this.type = s.readVarInt();
+        else
+            this.type = 0;
+    }
 
-	public PacketPlayInArmAnimation() {
-		super(0x0A);
-	}
-	
-	@Override
-	public void read(PacketDataSerializer s) {
-		if(getBigVersion() == BigClientVersion.v1_7){
-			this.id = s.readInt();
-			this.type = s.readByte();
-		}else if(getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10)
-			this.type = s.readVarInt();
-		else
-			this.type = 0;
-	}
+    @Override
+    public void write(PacketDataSerializer s) {
+        if (getBigVersion() == BigClientVersion.v1_7) {
+            s.writeInt(id);
+            s.writeByte(type);
+        } else if (getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10)
+            s.writeVarInt(type);
+    }
 
-	@Override
-	public void write(PacketDataSerializer s) {
-		if(getBigVersion() == BigClientVersion.v1_7){
-			s.writeInt(id);
-			s.writeByte(type);
-		}
-		else if(getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10)
-			s.writeVarInt(type);
-	}
-	
-	public HandType getArmType() {
-		return HandType.values()[type];
-	}
+    public HandType getArmType() {
+        return HandType.values()[type];
+    }
 
-	@Override
-	public String toString() {
-		return "PacketPlayInArmAnimation [id=" + id + ", type=" + type + "]";
-	}
+    @Override
+    public String toString() {
+        return "PacketPlayInArmAnimation [id=" + id + ", type=" + type + "]";
+    }
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInBlockDig.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInBlockDig.java
index d57d602..46d706c 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInBlockDig.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInBlockDig.java
@@ -6,71 +6,72 @@ import dev.wolveringer.api.position.BlockPosition;
 import dev.wolveringer.packet.PacketDataSerializer;
 
 public class PacketPlayInBlockDig extends Packet implements PacketPlayIn {
-	public static enum State {
-		START_DIGGING,
-		END_DIGGING,
-		FINISH_DIGGING,
-		DROP_ITEMSTACK,
-		DROP_ITEM,
-		SHOT_ARROW,
-		SWARM_HAND;
-	}
-	private State state;
-	private BlockPosition loc;
-	private int face;
-	
-	public PacketPlayInBlockDig() {
-		super(0x07);
-	}
-	
-	@Override
-	public void read(PacketDataSerializer s) {
-		if (getVersion().getVersion() <= ClientVersion.v1_8_0.getVersion()) {
-			state = State.values()[s.readByte()];
-		} else {
-			state = State.values()[s.readVarInt()];
-		}
-		loc = s.readBlockPosition();
-		face = s.readUnsignedByte();
-	}
-	
-	@Override
-	public void write(PacketDataSerializer s) {
-		if (getVersion().getVersion() <= ClientVersion.v1_8_0.getVersion()) {
-			s.writeByte(state.ordinal());
-		} else {
-			s.writeVarInt(state.ordinal());
-		}
-		s.writeBlockPosition(loc);
-		s.writeByte(face);
-	}
+    private State state;
+    private BlockPosition loc;
+    private int face;
 
-	public State getState() {
-		return state;
-	}
+    public PacketPlayInBlockDig() {
+        super(0x07);
+    }
 
-	public void setState(State state) {
-		this.state = state;
-	}
+    @Override
+    public void read(PacketDataSerializer s) {
+        if (getVersion().getVersion() <= ClientVersion.v1_8_0.getVersion()) {
+            state = State.values()[s.readByte()];
+        } else {
+            state = State.values()[s.readVarInt()];
+        }
+        loc = s.readBlockPosition();
+        face = s.readUnsignedByte();
+    }
 
-	public BlockPosition getLocation() {
-		return loc;
-	}
+    @Override
+    public void write(PacketDataSerializer s) {
+        if (getVersion().getVersion() <= ClientVersion.v1_8_0.getVersion()) {
+            s.writeByte(state.ordinal());
+        } else {
+            s.writeVarInt(state.ordinal());
+        }
+        s.writeBlockPosition(loc);
+        s.writeByte(face);
+    }
 
-	public void setLocation(BlockPosition loc) {
-		this.loc = loc;
-	}
+    public State getState() {
+        return state;
+    }
 
-	public int getFace() {
-		return face;
-	}
+    public void setState(State state) {
+        this.state = state;
+    }
 
-	public void setFace(int face) {
-		this.face = face;
-	}
+    public BlockPosition getLocation() {
+        return loc;
+    }
 
-	@Override
-	public String toString() {
-		return "PacketPlayInBlockDig [state=" + state + ", loc=" + loc + ", face=" + face + "]";
-	}
+    public void setLocation(BlockPosition loc) {
+        this.loc = loc;
+    }
+
+    public int getFace() {
+        return face;
+    }
+
+    public void setFace(int face) {
+        this.face = face;
+    }
+
+    @Override
+    public String toString() {
+        return "PacketPlayInBlockDig [state=" + state + ", loc=" + loc + ", face=" + face + "]";
+    }
+
+    public static enum State {
+        START_DIGGING,
+        END_DIGGING,
+        FINISH_DIGGING,
+        DROP_ITEMSTACK,
+        DROP_ITEM,
+        SHOT_ARROW,
+        SWARM_HAND;
+    }
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInBlockPlace.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInBlockPlace.java
index 5f1245b..d2efad6 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInBlockPlace.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInBlockPlace.java
@@ -1,7 +1,7 @@
 package dev.wolveringer.BungeeUtil.packets;
 
-import dev.wolveringer.BungeeUtil.HandType;
 import dev.wolveringer.BungeeUtil.ClientVersion.BigClientVersion;
+import dev.wolveringer.BungeeUtil.HandType;
 import dev.wolveringer.BungeeUtil.item.Item;
 import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayIn;
 import dev.wolveringer.api.position.BlockPosition;
@@ -9,85 +9,86 @@ import dev.wolveringer.api.position.Vector3f;
 import dev.wolveringer.packet.PacketDataSerializer;
 
 public class PacketPlayInBlockPlace extends Packet implements PacketPlayIn {
-	private BlockPosition loc;
-	private int face;
-	private int hand = 0;
-	private Item item;
-	private Vector3f cursorPosition;
-
-	public PacketPlayInBlockPlace() {}
-
-	@Override
-	public void read(PacketDataSerializer s) {
-		loc = s.readBlockPosition();
-		face = (getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10) ? s.readVarInt() : s.readUnsignedByte();
-		if(getBigVersion() == BigClientVersion.v1_9  || getBigVersion() == BigClientVersion.v1_10)
-			hand = s.readVarInt();
-		if(face == 255)
-			loc.setY(255);
-		if(getBigVersion() == BigClientVersion.v1_8)
-			item = s.readItem();
-		cursorPosition = new Vector3f((float) s.readUnsignedByte() / 16.0F, (float) s.readUnsignedByte() / 16.0F, (float) s.readUnsignedByte() / 16.0F);
-	}
-
-	@Override
-	public void write(PacketDataSerializer s) {
-		s.writeBlockPosition(loc);
-		if(getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10)
-			s.writeVarInt(face);
-		else
-			s.writeByte(face);
-		if(getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10)
-			s.writeVarInt(hand);
-		if(getBigVersion() == BigClientVersion.v1_8)
-			s.writeItem(item);
-		s.writeByte((int) (cursorPosition.getX() * 16.0F));
-		s.writeByte((int) (cursorPosition.getY() * 16.0F));
-		s.writeByte((int) (cursorPosition.getZ() * 16.0F));
-	}
-
-	public HandType getHand() {
-		return HandType.values()[hand];
-	}
-	
-	public void setHand(HandType hand) {
-		this.hand = hand.ordinal();
-	}
-	
-	@Override
-	public String toString() {
-		return "PacketPlayInBlockPlace [loc=" + loc + ", face=" + face + ", item=" + item + ", cursorPosition=" + cursorPosition + "]";
-	}
-
-	public BlockPosition getLoc() {
-		return loc;
-	}
-
-	public void setLoc(BlockPosition loc) {
-		this.loc = loc;
-	}
-
-	public int getFace() {
-		return face;
-	}
-
-	public void setFace(int face) {
-		this.face = face;
-	}
-
-	public Item getItem() {
-		return item;
-	}
-
-	public void setItem(Item item) {
-		this.item = item;
-	}
-
-	public Vector3f getCursorPosition() {
-		return cursorPosition;
-	}
-
-	public void setCursorPosition(Vector3f cursorPosition) {
-		this.cursorPosition = cursorPosition;
-	}
+    private BlockPosition loc;
+    private int face;
+    private int hand = 0;
+    private Item item;
+    private Vector3f cursorPosition;
+
+    public PacketPlayInBlockPlace() {
+    }
+
+    @Override
+    public void read(PacketDataSerializer s) {
+        loc = s.readBlockPosition();
+        face = (getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10) ? s.readVarInt() : s.readUnsignedByte();
+        if (getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10)
+            hand = s.readVarInt();
+        if (face == 255)
+            loc.setY(255);
+        if (getBigVersion() == BigClientVersion.v1_8)
+            item = s.readItem();
+        cursorPosition = new Vector3f((float) s.readUnsignedByte() / 16.0F, (float) s.readUnsignedByte() / 16.0F, (float) s.readUnsignedByte() / 16.0F);
+    }
+
+    @Override
+    public void write(PacketDataSerializer s) {
+        s.writeBlockPosition(loc);
+        if (getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10)
+            s.writeVarInt(face);
+        else
+            s.writeByte(face);
+        if (getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10)
+            s.writeVarInt(hand);
+        if (getBigVersion() == BigClientVersion.v1_8)
+            s.writeItem(item);
+        s.writeByte((int) (cursorPosition.getX() * 16.0F));
+        s.writeByte((int) (cursorPosition.getY() * 16.0F));
+        s.writeByte((int) (cursorPosition.getZ() * 16.0F));
+    }
+
+    public HandType getHand() {
+        return HandType.values()[hand];
+    }
+
+    public void setHand(HandType hand) {
+        this.hand = hand.ordinal();
+    }
+
+    @Override
+    public String toString() {
+        return "PacketPlayInBlockPlace [loc=" + loc + ", face=" + face + ", item=" + item + ", cursorPosition=" + cursorPosition + "]";
+    }
+
+    public BlockPosition getLoc() {
+        return loc;
+    }
+
+    public void setLoc(BlockPosition loc) {
+        this.loc = loc;
+    }
+
+    public int getFace() {
+        return face;
+    }
+
+    public void setFace(int face) {
+        this.face = face;
+    }
+
+    public Item getItem() {
+        return item;
+    }
+
+    public void setItem(Item item) {
+        this.item = item;
+    }
+
+    public Vector3f getCursorPosition() {
+        return cursorPosition;
+    }
+
+    public void setCursorPosition(Vector3f cursorPosition) {
+        this.cursorPosition = cursorPosition;
+    }
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInChat.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInChat.java
index f5f80d8..ba1a1e7 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInChat.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInChat.java
@@ -4,36 +4,36 @@ import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayIn;
 import dev.wolveringer.packet.PacketDataSerializer;
 
 public class PacketPlayInChat extends Packet implements PacketPlayIn {
-	String msg;
-
-	//public PacketPlayInChat() {
-	//	super((byte) 0x01);
-	//}
-	
-	public PacketPlayInChat() {
-		super();
-	}
-
-	public PacketPlayInChat(String c) {
-		super((byte) 0x01);
-		this.msg = c;
-	}
-
-	public String getMessage() {
-		return msg;
-	}
-
-	@Override
-	public void read(PacketDataSerializer s) {
-		msg = s.readString(-1);
-	}
-
-	public void setMessage(String c) {
-		this.msg = c;
-	}
-
-	@Override
-	public void write(PacketDataSerializer s) {
-		s.writeString(msg);
-	}
+    String msg;
+
+    //public PacketPlayInChat() {
+    //	super((byte) 0x01);
+    //}
+
+    public PacketPlayInChat() {
+        super();
+    }
+
+    public PacketPlayInChat(String c) {
+        super((byte) 0x01);
+        this.msg = c;
+    }
+
+    public String getMessage() {
+        return msg;
+    }
+
+    public void setMessage(String c) {
+        this.msg = c;
+    }
+
+    @Override
+    public void read(PacketDataSerializer s) {
+        msg = s.readString(-1);
+    }
+
+    @Override
+    public void write(PacketDataSerializer s) {
+        s.writeString(msg);
+    }
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInClientState.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInClientState.java
index fdbf0e4..71e8f71 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInClientState.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInClientState.java
@@ -3,24 +3,29 @@ package dev.wolveringer.BungeeUtil.packets;
 import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
 import dev.wolveringer.packet.PacketDataSerializer;
 
-public class PacketPlayInClientState extends Packet implements PacketPlayOut{
-	private int state;
-	public PacketPlayInClientState() {
-		super(0x16);
-	}
-	public PacketPlayInClientState(int state) {
-		super(0x16);
-		this.state = state;
-	}
-	@Override
-	public void read(PacketDataSerializer serelizer) {
-		state = serelizer.readVarInt();
-	}
-	@Override
-	public void write(PacketDataSerializer serelizer) {
-		serelizer.writeVarInt(state);
-	}
-	public int getState() {
-		return state;
-	}
+public class PacketPlayInClientState extends Packet implements PacketPlayOut {
+    private int state;
+
+    public PacketPlayInClientState() {
+        super(0x16);
+    }
+
+    public PacketPlayInClientState(int state) {
+        super(0x16);
+        this.state = state;
+    }
+
+    @Override
+    public void read(PacketDataSerializer serelizer) {
+        state = serelizer.readVarInt();
+    }
+
+    @Override
+    public void write(PacketDataSerializer serelizer) {
+        serelizer.writeVarInt(state);
+    }
+
+    public int getState() {
+        return state;
+    }
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInCloseWindow.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInCloseWindow.java
index 8a613da..bb0d817 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInCloseWindow.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInCloseWindow.java
@@ -5,27 +5,27 @@ import dev.wolveringer.packet.PacketDataSerializer;
 
 public class PacketPlayInCloseWindow extends Packet implements PacketPlayIn {
 
-	private int window;
+    private int window;
 
-	public PacketPlayInCloseWindow() {
-		super(0x0D);
-	}
+    public PacketPlayInCloseWindow() {
+        super(0x0D);
+    }
 
-	public int getWindow() {
-		return window;
-	}
+    public int getWindow() {
+        return window;
+    }
 
-	@Override
-	public void read(PacketDataSerializer packetdataserializer) {
-		this.window = packetdataserializer.readByte();
-	}
+    public void setWindow(int window) {
+        this.window = window;
+    }
 
-	public void setWindow(int window) {
-		this.window = window;
-	}
+    @Override
+    public void read(PacketDataSerializer packetdataserializer) {
+        this.window = packetdataserializer.readByte();
+    }
 
-	@Override
-	public void write(PacketDataSerializer packetdataserializer) {
-		packetdataserializer.writeByte(this.window);
-	}
+    @Override
+    public void write(PacketDataSerializer packetdataserializer) {
+        packetdataserializer.writeByte(this.window);
+    }
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInFlying.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInFlying.java
index e9085bd..2906494 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInFlying.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInFlying.java
@@ -5,65 +5,65 @@ import dev.wolveringer.api.position.Location;
 import dev.wolveringer.packet.PacketDataSerializer;
 
 public class PacketPlayInFlying extends Packet implements PacketPlayIn {
-	protected boolean onground;
-	protected boolean hasLook = false;
-	protected boolean hasPos = false;
-	protected Location loc = new Location(0, 0, 0);
-	protected double stance;
+    protected boolean onground;
+    protected boolean hasLook = false;
+    protected boolean hasPos = false;
+    protected Location loc = new Location(0, 0, 0);
+    protected double stance;
 
-	public PacketPlayInFlying() {
-		super(-1);
-	}
+    public PacketPlayInFlying() {
+        super(-1);
+    }
 
-	public PacketPlayInFlying(int i) {
-		super(i);
-	}
+    public PacketPlayInFlying(int i) {
+        super(i);
+    }
 
-	public void setLocation(Location loc) {
-		if(loc.getYaw() != 0 || loc.getPitch() != 0)
-			hasLook = true;
-		if(loc.getX() != 0 && loc.getY() != 0 && loc.getZ() != 0)
-			hasPos = true;
-		this.loc = loc;
-	}
+    public Location getLocation() {
+        return loc.clone();
+    }
 
-	public Location getLocation() {
-		return loc.clone();
-	}
+    public void setLocation(Location loc) {
+        if (loc.getYaw() != 0 || loc.getPitch() != 0)
+            hasLook = true;
+        if (loc.getX() != 0 && loc.getY() != 0 && loc.getZ() != 0)
+            hasPos = true;
+        this.loc = loc;
+    }
 
-	public boolean hasLook() {
-		return this.hasLook;
-	}
+    public boolean hasLook() {
+        return this.hasLook;
+    }
 
-	public boolean hasPos() {
-		return this.hasPos;
-	}
+    public boolean hasPos() {
+        return this.hasPos;
+    }
 
-	public boolean onGound() {
-		return this.onground;
-	}
+    public boolean onGound() {
+        return this.onground;
+    }
 
-	@Override
-	public void read(PacketDataSerializer s) {
-		this.onground = s.readUnsignedByte() != 0;
-	}
+    @Override
+    public void read(PacketDataSerializer s) {
+        this.onground = s.readUnsignedByte() != 0;
+    }
 
-	public double stance() {
-		return this.stance;
-	}
+    public double stance() {
+        return this.stance;
+    }
 
-	@Override
-	public void write(PacketDataSerializer s) {
-		s.writeByte(this.onground ? 1 : 0);
-	}
+    @Override
+    public void write(PacketDataSerializer s) {
+        s.writeByte(this.onground ? 1 : 0);
+    }
 
-	protected void setOnground(boolean flag) {
-		this.onground = flag;
-	}
+    protected void setOnground(boolean flag) {
+        this.onground = flag;
+    }
+
+    @Override
+    public String toString() {
+        return "PacketPlayInFlying [onground=" + onground + ", hasLook=" + hasLook + ", hasPos=" + hasPos + ", loc=" + loc + ", stance=" + stance + "]";
+    }
 
-	@Override
-	public String toString() {
-		return "PacketPlayInFlying [onground=" + onground + ", hasLook=" + hasLook + ", hasPos=" + hasPos + ", loc=" + loc + ", stance=" + stance + "]";
-	}
-	
 }
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInHeldItemSlot.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInHeldItemSlot.java
index 35f54a4..01c1053 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInHeldItemSlot.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInHeldItemSlot.java
@@ -4,22 +4,23 @@ import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayIn;
 import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayXXXHeldItemSlot;
 import dev.wolveringer.packet.PacketDataSerializer;
 
-public class PacketPlayInHeldItemSlot extends PacketPlayXXXHeldItemSlot implements PacketPlayIn{
-	public PacketPlayInHeldItemSlot() {
-		super(0x09);
-	}
-	
-	public PacketPlayInHeldItemSlot(int slot) {
-		this();
-		setSlot(slot);
-	}
+public class PacketPlayInHeldItemSlot extends PacketPlayXXXHeldItemSlot implements PacketPlayIn {
+    public PacketPlayInHeldItemSlot() {
+        super(0x09);
+    }
 
-	@Override
-	public void read(PacketDataSerializer s) {
-		setSlot(s.readShort());
-	}
-	@Override
-	public void write(PacketDataSerializer s) {
-		s.writeShort(getSlot());
-	}
+    public PacketPlayInHeldItemSlot(int slot) {
+        this();
+        setSlot(slot);
+    }
+
+    @Override
+    public void read(PacketDataSerializer s) {
+        setSlot(s.readShort());
+    }
+
+    @Override
+    public void write(PacketDataSerializer s) {
+        s.writeShort(getSlot());
+    }
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInLook.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInLook.java
index 6c0e297..dd3ef05 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInLook.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInLook.java
@@ -4,19 +4,21 @@ import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayIn;
 import dev.wolveringer.api.position.Location;
 import dev.wolveringer.packet.PacketDataSerializer;
 
-public class PacketPlayInLook extends PacketPlayInFlying implements PacketPlayIn{
-	public PacketPlayInLook() {
-		super(0x05);
-	}
-	@Override
-	public void read(PacketDataSerializer s) {
-		super.setLocation(new Location(0, 0, 0,s.readFloat(),s.readFloat()));
-		super.read(s);
-	}
-	@Override
-	public void write(PacketDataSerializer s) {
-		s.writeFloat(super.getLocation().getYaw());
-		s.writeFloat(super.getLocation().getPitch());
-		super.write(s);
-	}
+public class PacketPlayInLook extends PacketPlayInFlying implements PacketPlayIn {
+    public PacketPlayInLook() {
+        super(0x05);
+    }
+
+    @Override
+    public void read(PacketDataSerializer s) {
+        super.setLocation(new Location(0, 0, 0, s.readFloat(), s.readFloat()));
+        super.read(s);
+    }
+
+    @Override
+    public void write(PacketDataSerializer s) {
+        s.writeFloat(super.getLocation().getYaw());
+        s.writeFloat(super.getLocation().getPitch());
+        super.write(s);
+    }
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInPluginMessage.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInPluginMessage.java
index 2115f27..f1bc8a2 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInPluginMessage.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInPluginMessage.java
@@ -1,86 +1,90 @@
 package dev.wolveringer.BungeeUtil.packets;
 
+import org.jsoup.helper.Validate;
+
 import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayIn;
 import dev.wolveringer.packet.PacketDataSerializer;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufInputStream;
 import io.netty.buffer.ByteBufOutputStream;
-import io.netty.buffer.Unpooled;
 import lombok.NoArgsConstructor;
-import org.jsoup.helper.Validate;
 
 @SuppressWarnings("Duplicates")
 @NoArgsConstructor
-public class PacketPlayInPluginMessage extends Packet implements PacketPlayIn{
-	private String channel;
-	private ByteBuf data;
-	private ByteBufOutputStream os;
-	private ByteBufInputStream is;
+public class PacketPlayInPluginMessage extends Packet implements PacketPlayIn {
+    private String channel;
+    private ByteBuf data;
+    private ByteBufOutputStream os;
+    private ByteBufInputStream is;
 //	private int length = -1;
 
-	@Override
-	public void read(PacketDataSerializer s) {
-		int readerIndex = s.readerIndex();
-		try{
-			channel = s.readString(-1);
-			readerIndex = s.readerIndex();
-			if(s.readableBytes() + s.readerIndex() != s.writerIndex()){
-				System.out.println("Incorrect length: "+(s.readableBytes() + s.readerIndex()+" - "+s.writerIndex()));
-			}
-		}catch(Exception e){
-			channel = null;
-			e.printStackTrace();
-			s.readerIndex(readerIndex);
-		}
-		Validate.isTrue(s.readableBytes() == s.writerIndex() - s.readerIndex(), "bytebuf has drunk: " + s.readableBytes() + " " + (s.writerIndex() - s.readerIndex()));
+    @Override
+    public void read(PacketDataSerializer s) {
+        int readerIndex = s.readerIndex();
+        try {
+            channel = s.readString(-1);
+            readerIndex = s.readerIndex();
+            if (s.readableBytes() + s.readerIndex() != s.writerIndex()) {
+                System.out.println("Incorrect length: " + (s.readableBytes() + s.readerIndex() + " - " + s.writerIndex()));
+            }
+        } catch (Exception e) {
+            channel = null;
+            e.printStackTrace();
+            s.readerIndex(readerIndex);
+        }
+        Validate.isTrue(s.readableBytes() == s.writerIndex() - s.readerIndex(), "bytebuf has drunk: " + s.readableBytes() + " " + (s.writerIndex() - s.readerIndex()));
 //		length = s.readableBytes();
-		data = s.readBytes(s.readableBytes());
+        data = s.readBytes(s.readableBytes());
 //		data = Unpooled.buffer(length);
 //		s.readBytes(data, length);
-	}
+    }
+
+    @Override
+    public void write(PacketDataSerializer s) {
+        if (channel != null)
+            s.writeString(channel);
+        try {
+            data.readerIndex(0);
+            int length = data.readableBytes();
+            s.ensureWritable(length, true);
+            s.writeBytes(data, length);
+            data.release();
+        } catch (Exception e) {
+            throw e;
+        }
+    }
+
+    public String getChannel() {
+        return channel;
+    }
+
+    public void setChannel(String channel) {
+        this.channel = channel;
+    }
+
+    public ByteBufInputStream getCopiedByteBufInputStream() {
+        return new ByteBufInputStream(data.copy());
+    }
+
+    public ByteBuf getCopiedbyteBuff() {
+        return data.copy();
+    }
+
+    public ByteBufInputStream getByteBufInputStream() {
+        if (is == null)
+            is = new ByteBufInputStream(data);
+        return is;
+    }
+
+    public ByteBufOutputStream getByteBufOutputStream() {
+        if (os == null)
+            os = new ByteBufOutputStream(data);
+        return os;
+    }
 
-	@Override
-	public void write(PacketDataSerializer s) {
-		if(channel != null)
-			s.writeString(channel);
-		try{
-			data.readerIndex(0);
-			int length = data.readableBytes();
-			s.ensureWritable(length, true);
-			s.writeBytes(data, length);
-			data.release();
-		}catch(Exception e){
-			throw e;
-		}
-	}
-	
-	public String getChannel() {
-		return channel;
-	}
-	public void setChannel(String channel) {
-		this.channel = channel;
-	}
-	public ByteBufInputStream getCopiedByteBufInputStream(){
-		return new ByteBufInputStream(data.copy());
-	}
-	
-	public ByteBuf getCopiedbyteBuff(){
-		return data.copy();
-	}
-	
-	public ByteBufInputStream getByteBufInputStream(){
-		if(is == null)
-			is = new ByteBufInputStream(data);
-		return is;
-	}
-	public ByteBufOutputStream getByteBufOutputStream(){
-		if(os == null)
-			os = new ByteBufOutputStream(data);
-		return os;
-	}
-	public void setData(ByteBuf data) {
-		this.data = data;
-		this.os = null;
-		this.is = null;
-	}
+    public void setData(ByteBuf data) {
+        this.data = data;
+        this.os = null;
+        this.is = null;
+    }
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInPosition.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInPosition.java
index 5ed1fa0..6a117d8 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInPosition.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInPosition.java
@@ -6,31 +6,32 @@ import dev.wolveringer.packet.PacketDataSerializer;
 
 public class PacketPlayInPosition extends PacketPlayInFlying {
 
-	public PacketPlayInPosition() {
-		super(0x05);
-	}
-	public PacketPlayInPosition(int id) {
-		super(id);
-	}
+    public PacketPlayInPosition() {
+        super(0x05);
+    }
 
-	@Override
-	public void read(PacketDataSerializer packetdataserializer) {
-		Double x = packetdataserializer.readDouble();
-		Double y = packetdataserializer.readDouble();
-		if(getVersion().getBigVersion() == BigClientVersion.v1_7)
-			this.stance = packetdataserializer.readDouble();
-		Double z = packetdataserializer.readDouble();
-		setLocation(new Location(x, y, z));
-		super.read(packetdataserializer);
-	}
+    public PacketPlayInPosition(int id) {
+        super(id);
+    }
 
-	@Override
-	public void write(PacketDataSerializer packetdataserializer) {
-		packetdataserializer.writeDouble(getLocation().getX());
-		packetdataserializer.writeDouble(getLocation().getY());
-		if(getVersion().getBigVersion() == BigClientVersion.v1_7)
-			packetdataserializer.writeDouble(this.stance);
-		packetdataserializer.writeDouble(getLocation().getZ());
-		super.write(packetdataserializer);
-	}
+    @Override
+    public void read(PacketDataSerializer packetdataserializer) {
+        Double x = packetdataserializer.readDouble();
+        Double y = packetdataserializer.readDouble();
+        if (getVersion().getBigVersion() == BigClientVersion.v1_7)
+            this.stance = packetdataserializer.readDouble();
+        Double z = packetdataserializer.readDouble();
+        setLocation(new Location(x, y, z));
+        super.read(packetdataserializer);
+    }
+
+    @Override
+    public void write(PacketDataSerializer packetdataserializer) {
+        packetdataserializer.writeDouble(getLocation().getX());
+        packetdataserializer.writeDouble(getLocation().getY());
+        if (getVersion().getBigVersion() == BigClientVersion.v1_7)
+            packetdataserializer.writeDouble(this.stance);
+        packetdataserializer.writeDouble(getLocation().getZ());
+        super.write(packetdataserializer);
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInPositionLook.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInPositionLook.java
index 56f9625..8fabaff 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInPositionLook.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInPositionLook.java
@@ -5,35 +5,36 @@ import dev.wolveringer.api.position.Location;
 import dev.wolveringer.packet.PacketDataSerializer;
 
 public class PacketPlayInPositionLook extends PacketPlayInPosition {
-	
-	public PacketPlayInPositionLook() {}
-	
-	@Override
-	public void read(PacketDataSerializer s) {
-		Double x = s.readDouble();
-		Double y = s.readDouble();
-		if(getVersion().getBigVersion() == BigClientVersion.v1_7)
-			this.stance = s.readDouble();
-		Double z = s.readDouble();
-		setLocation(new Location(x, y, z,s.readFloat(),s.readFloat()));
-		setOnground(s.readByte()==1);
-	}
 
-	@Override
-	public void write(PacketDataSerializer packetdataserializer) {
-		packetdataserializer.writeDouble(getLocation().getX());
-		packetdataserializer.writeDouble(getLocation().getY());
-		if(getVersion().getBigVersion() == BigClientVersion.v1_7)
-			packetdataserializer.writeDouble(this.stance);
-		packetdataserializer.writeDouble(getLocation().getZ());
-		packetdataserializer.writeFloat(getLocation().getYaw());
-		packetdataserializer.writeFloat(getLocation().getPitch());
-		packetdataserializer.writeByte(onGound()?1:0);
-	}
+    public PacketPlayInPositionLook() {
+    }
 
-	@Override
-	public String toString() {
-		return "PacketPlayInPositionLook [onground=" + onground + ", hasLook=" + hasLook + ", hasPos=" + hasPos + ", loc=" + loc + ", stance=" + stance + "]";
-	}
+    @Override
+    public void read(PacketDataSerializer s) {
+        Double x = s.readDouble();
+        Double y = s.readDouble();
+        if (getVersion().getBigVersion() == BigClientVersion.v1_7)
+            this.stance = s.readDouble();
+        Double z = s.readDouble();
+        setLocation(new Location(x, y, z, s.readFloat(), s.readFloat()));
+        setOnground(s.readByte() == 1);
+    }
+
+    @Override
+    public void write(PacketDataSerializer packetdataserializer) {
+        packetdataserializer.writeDouble(getLocation().getX());
+        packetdataserializer.writeDouble(getLocation().getY());
+        if (getVersion().getBigVersion() == BigClientVersion.v1_7)
+            packetdataserializer.writeDouble(this.stance);
+        packetdataserializer.writeDouble(getLocation().getZ());
+        packetdataserializer.writeFloat(getLocation().getYaw());
+        packetdataserializer.writeFloat(getLocation().getPitch());
+        packetdataserializer.writeByte(onGound() ? 1 : 0);
+    }
+
+    @Override
+    public String toString() {
+        return "PacketPlayInPositionLook [onground=" + onground + ", hasLook=" + hasLook + ", hasPos=" + hasPos + ", loc=" + loc + ", stance=" + stance + "]";
+    }
 
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInUpdateSign.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInUpdateSign.java
index c8c3bd0..517f33e 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInUpdateSign.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInUpdateSign.java
@@ -6,41 +6,44 @@ import dev.wolveringer.chat.IChatBaseComponent;
 import dev.wolveringer.packet.PacketDataSerializer;
 
 public class PacketPlayInUpdateSign extends Packet implements PacketPlayIn {
-	private BlockPosition loc;
-	private IChatBaseComponent comps[] = new IChatBaseComponent[4];
-	
-	public PacketPlayInUpdateSign() {
-		// TODO Auto-generated constructor stub
-	}
-	
-	@Override
-	public void read(PacketDataSerializer s) {
-		loc = s.readBlockPosition();
-		comps[0] = s.readRawString();
-		comps[1] = s.readRawString();
-		comps[2] = s.readRawString();
-		comps[3] = s.readRawString();
-	}
-	
-	@Override
-	public void write(PacketDataSerializer s) {
-		s.writeBlockPosition(loc);
-		s.writeRawString(comps[0]);
-		s.writeRawString(comps[1]);
-		s.writeRawString(comps[2]);
-		s.writeRawString(comps[3]);
-	}
-	
-	public void setLines(IChatBaseComponent[] comps) {
-		this.comps = comps;
-	}
-	public void setLocation(BlockPosition loc) {
-		this.loc = loc;
-	}
-	public BlockPosition getLoc() {
-		return loc;
-	}
-	public IChatBaseComponent[] getComps() {
-		return comps;
-	}
+    private BlockPosition loc;
+    private IChatBaseComponent comps[] = new IChatBaseComponent[4];
+
+    public PacketPlayInUpdateSign() {
+        // TODO Auto-generated constructor stub
+    }
+
+    @Override
+    public void read(PacketDataSerializer s) {
+        loc = s.readBlockPosition();
+        comps[0] = s.readRawString();
+        comps[1] = s.readRawString();
+        comps[2] = s.readRawString();
+        comps[3] = s.readRawString();
+    }
+
+    @Override
+    public void write(PacketDataSerializer s) {
+        s.writeBlockPosition(loc);
+        s.writeRawString(comps[0]);
+        s.writeRawString(comps[1]);
+        s.writeRawString(comps[2]);
+        s.writeRawString(comps[3]);
+    }
+
+    public void setLines(IChatBaseComponent[] comps) {
+        this.comps = comps;
+    }
+
+    public void setLocation(BlockPosition loc) {
+        this.loc = loc;
+    }
+
+    public BlockPosition getLoc() {
+        return loc;
+    }
+
+    public IChatBaseComponent[] getComps() {
+        return comps;
+    }
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInUseEntity.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInUseEntity.java
index ec8df4a..2afc780 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInUseEntity.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInUseEntity.java
@@ -6,84 +6,87 @@ import dev.wolveringer.api.position.Vector3f;
 import dev.wolveringer.packet.PacketDataSerializer;
 
 public class PacketPlayInUseEntity extends Packet implements PacketPlayIn {
-	public static enum Action {
-		INTERACT,
-		ATTACK,
-		INTERACT_AT;
-	}
-	
-	private int target;
-	private Action action;
-	private Vector3f location;
-	private int hand = 0;
-	
-	public PacketPlayInUseEntity() {
-		super(0x02);
-	}
-	
-	@Override
-	public void read(PacketDataSerializer s) {
-		target = getBigVersion() == BigClientVersion.v1_7 ? s.readInt() : s.readVarInt();
-		action = Action.values()[getBigVersion() == BigClientVersion.v1_7 ? s.readByte() : s.readVarInt()];
-		if ((getBigVersion() == BigClientVersion.v1_8 || getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10) && action == Action.INTERACT_AT) location = new Vector3f(s.readFloat(), s.readFloat(), s.readFloat());
-		if ((getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10) && action != Action.ATTACK) hand = s.readVarInt();
-	}
-	
-	@Override
-	public void write(PacketDataSerializer s) {
-		if (getBigVersion() == BigClientVersion.v1_7) {
-			s.writeInt(target);
-			s.writeByte(action.ordinal());
-		}
-		else if (getBigVersion() == BigClientVersion.v1_8 || getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10) {
-			s.writeVarInt(target);
-			s.writeVarInt(action.ordinal());
-			if (action == Action.INTERACT_AT) {
-				s.writeFloat(location.getX());
-				s.writeFloat(location.getY());
-				s.writeFloat(location.getZ());
-			}
-			if ((getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10) && action != Action.ATTACK) s.writeVarInt(hand);
-		}
-	}
-	
-	public Action getAction() {
-		return action;
-	}
-	
-	public void setAction(Action action) {
-		this.action = action;
-	}
-	
-	public int getTarget() {
-		return target;
-	}
-	
-	public void setTarget(int target) {
-		this.target = target;
-	}
-	
-	public Vector3f getLocation() {
-		return location;
-	}
-	
-	public void setLocation(Vector3f location) {
-		this.location = location;
-	}
-	
-	public int getHand() {
-		return hand;
-	}
-	
-	public void setHand(int hand) {
-		this.hand = hand;
-	}
-	/**
-	 *  
-	 */
-
-	@Override
-	public String toString() {
-		return "PacketPlayInUseEntity [target=" + target + ", action=" + action + ", location=" + location + ", hand=" + hand + "]";
-	}
+    private int target;
+    private Action action;
+    private Vector3f location;
+    private int hand = 0;
+
+    public PacketPlayInUseEntity() {
+        super(0x02);
+    }
+
+    @Override
+    public void read(PacketDataSerializer s) {
+        target = getBigVersion() == BigClientVersion.v1_7 ? s.readInt() : s.readVarInt();
+        action = Action.values()[getBigVersion() == BigClientVersion.v1_7 ? s.readByte() : s.readVarInt()];
+        if ((getBigVersion() == BigClientVersion.v1_8 || getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10) && action == Action.INTERACT_AT)
+            location = new Vector3f(s.readFloat(), s.readFloat(), s.readFloat());
+        if ((getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10) && action != Action.ATTACK)
+            hand = s.readVarInt();
+    }
+
+    @Override
+    public void write(PacketDataSerializer s) {
+        if (getBigVersion() == BigClientVersion.v1_7) {
+            s.writeInt(target);
+            s.writeByte(action.ordinal());
+        } else if (getBigVersion() == BigClientVersion.v1_8 || getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10) {
+            s.writeVarInt(target);
+            s.writeVarInt(action.ordinal());
+            if (action == Action.INTERACT_AT) {
+                s.writeFloat(location.getX());
+                s.writeFloat(location.getY());
+                s.writeFloat(location.getZ());
+            }
+            if ((getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10) && action != Action.ATTACK)
+                s.writeVarInt(hand);
+        }
+    }
+
+    public Action getAction() {
+        return action;
+    }
+
+    public void setAction(Action action) {
+        this.action = action;
+    }
+
+    public int getTarget() {
+        return target;
+    }
+
+    public void setTarget(int target) {
+        this.target = target;
+    }
+
+    public Vector3f getLocation() {
+        return location;
+    }
+
+    public void setLocation(Vector3f location) {
+        this.location = location;
+    }
+
+    public int getHand() {
+        return hand;
+    }
+
+    public void setHand(int hand) {
+        this.hand = hand;
+    }
+
+    /**
+     *
+     */
+
+    @Override
+    public String toString() {
+        return "PacketPlayInUseEntity [target=" + target + ", action=" + action + ", location=" + location + ", hand=" + hand + "]";
+    }
+
+    public static enum Action {
+        INTERACT,
+        ATTACK,
+        INTERACT_AT;
+    }
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInWindowClick.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInWindowClick.java
index 04f57d3..4722c6a 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInWindowClick.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayInWindowClick.java
@@ -6,146 +6,142 @@ import dev.wolveringer.packet.PacketDataSerializer;
 
 public class PacketPlayInWindowClick extends Packet implements PacketPlayIn {
 
-	public static class Mode {
-		private static int getInt(int mode, int button) {
-			return (mode << 4) + button;
-		}
-
-		private static int getMode(int mode) {
-			return mode >> 4;
-		}
-
-		public static boolean isNormalClick(int mode) {
-			return getMode(mode) == 0 || getMode(mode) == 3 || getMode(mode) == 6;
-		}
-
-		public static boolean isShiftClick(int mode) {
-			return getMode(mode) == 1;
-		}
-
-		public static boolean isKey(int mode) {
-			return getMode(mode) == 2;
-		}
-
-		public static boolean inDrop(int mode) {
-			return getMode(mode) == 4;
-		}
-
-		public static boolean isDrag(int mode) {
-			return getMode(mode) == 5;
-		}
-
-		//public static final class Normal {
-			public static final int NORMAL_LEFT_CLICK = getInt(0, 0);
-			public static final int NORMAL_RIGHT_CLICK = getInt(0, 1);
-			public static final int NORMAL_MIDDLE_CLICK = getInt(3, 2);
-			public static final int NORMAL_DOUBLE_CLICK = getInt(6, 0);
-		//}
-
-		//public static final class Shift {
-			public static final int SHIFT_LEFT_CLICK = getInt(1, 0);
-			public static final int SHIFT_RIGHT_CLICK = getInt(1, 1);
-		//}
-
-		//public static final class Key {
-			public static final int KEY_1 = getInt(2, 0);
-			public static final int KEY_2 = getInt(2, 1);
-			public static final int KEY_3 = getInt(2, 2);
-			public static final int KEY_4 = getInt(2, 3);
-			public static final int KEY_5 = getInt(2, 4);
-			public static final int KEY_6 = getInt(2, 5);
-			public static final int KEY_7 = getInt(2, 6);
-			public static final int KEY_8 = getInt(2, 7);
-			public static final int KEY_9 = getInt(2, 8);
-		//}
-
-		//public static final class Drop {
-			public static final int DROP_ITEM = getInt(4, 0);
-			public static final int DROP_ITEM_STACK = getInt(4, 1);
-		//}
-
-		//public static final class Drag {
-			public static final int DRAG_START_LEFT = getInt(5, 0);
-			public static final int DRAG_ADD_LEFT = getInt(5, 1);
-			public static final int DRAG_END_LEFT = getInt(5, 2);
-			public static final int DRAG_START_RIGHT = getInt(5, 4);
-			public static final int DRAG_ADD_RIGHT = getInt(5, 5);
-			public static final int DRAG_END_RIGHT = getInt(5, 6);
-		//}
-	}
-
-	private short actionNumber;
-	private Item item;
-	private int mode = 0;
-	private int slot;
-	private int window;
-
-	public PacketPlayInWindowClick() {
-		super(0x0E);
-	}
-
-	@Override
-	public String toString() {
-		return "PacketPlayInWindowClick [actionNumber=" + actionNumber + ", item=" + item + ", shift=" + mode + ", slot=" + slot + ", window=" + window + "]";
-	}
-
-	public short getActionNumber() {
-		return actionNumber;
-	}
-
-	public Item getItem() {
-		return item;
-	}
-
-	public int getMode() {
-		return mode;
-	}
-
-	public int getSlot() {
-		return slot;
-	}
-
-	public int getWindow() {
-		return window;
-	}
-
-	@Override
-	public void read(PacketDataSerializer s) {
-		this.window = s.readByte();
-		this.slot = s.readShort();
-		this.mode += s.readByte();
-		this.actionNumber = s.readShort();
-		this.mode += s.readByte() << 4;
-		this.item = s.readItem();
-	}
-
-	public void setActionNumber(short actionNumber) {
-		this.actionNumber = actionNumber;
-	}
-
-	public void setItem(Item item) {
-		this.item = item;
-	}
-
-	public void setMode(int mode) {
-		this.mode = mode;
-	}
-
-	public void setSlot(int slot) {
-		this.slot = slot;
-	}
-
-	public void setWindow(int window) {
-		this.window = window;
-	}
-
-	@Override
-	public void write(PacketDataSerializer s) {
-		s.writeByte(this.window);
-		s.writeShort(this.slot);
-		s.writeByte(this.mode & 0x0F);
-		s.writeShort(this.actionNumber);
-		s.writeByte(this.mode >> 4);
-		s.writeItem(this.item);
-	}
+    private short actionNumber;
+    private Item item;
+    private int mode = 0;
+    private int slot;
+    private int window;
+
+    public PacketPlayInWindowClick() {
+        super(0x0E);
+    }
+
+    @Override
+    public String toString() {
+        return "PacketPlayInWindowClick [actionNumber=" + actionNumber + ", item=" + item + ", shift=" + mode + ", slot=" + slot + ", window=" + window + "]";
+    }
+
+    public short getActionNumber() {
+        return actionNumber;
+    }
+
+    public void setActionNumber(short actionNumber) {
+        this.actionNumber = actionNumber;
+    }
+
+    public Item getItem() {
+        return item;
+    }
+
+    public void setItem(Item item) {
+        this.item = item;
+    }
+
+    public int getMode() {
+        return mode;
+    }
+
+    public void setMode(int mode) {
+        this.mode = mode;
+    }
+
+    public int getSlot() {
+        return slot;
+    }
+
+    public void setSlot(int slot) {
+        this.slot = slot;
+    }
+
+    public int getWindow() {
+        return window;
+    }
+
+    public void setWindow(int window) {
+        this.window = window;
+    }
+
+    @Override
+    public void read(PacketDataSerializer s) {
+        this.window = s.readByte();
+        this.slot = s.readShort();
+        this.mode += s.readByte();
+        this.actionNumber = s.readShort();
+        this.mode += s.readByte() << 4;
+        this.item = s.readItem();
+    }
+
+    @Override
+    public void write(PacketDataSerializer s) {
+        s.writeByte(this.window);
+        s.writeShort(this.slot);
+        s.writeByte(this.mode & 0x0F);
+        s.writeShort(this.actionNumber);
+        s.writeByte(this.mode >> 4);
+        s.writeItem(this.item);
+    }
+
+    public static class Mode {
+        //public static final class Normal {
+        public static final int NORMAL_LEFT_CLICK = getInt(0, 0);
+        public static final int NORMAL_RIGHT_CLICK = getInt(0, 1);
+        public static final int NORMAL_MIDDLE_CLICK = getInt(3, 2);
+        public static final int NORMAL_DOUBLE_CLICK = getInt(6, 0);
+        //public static final class Shift {
+        public static final int SHIFT_LEFT_CLICK = getInt(1, 0);
+        public static final int SHIFT_RIGHT_CLICK = getInt(1, 1);
+        //public static final class Key {
+        public static final int KEY_1 = getInt(2, 0);
+        public static final int KEY_2 = getInt(2, 1);
+        public static final int KEY_3 = getInt(2, 2);
+        public static final int KEY_4 = getInt(2, 3);
+        public static final int KEY_5 = getInt(2, 4);
+        //}
+        public static final int KEY_6 = getInt(2, 5);
+        public static final int KEY_7 = getInt(2, 6);
+        //}
+        public static final int KEY_8 = getInt(2, 7);
+        public static final int KEY_9 = getInt(2, 8);
+        //public static final class Drop {
+        public static final int DROP_ITEM = getInt(4, 0);
+        public static final int DROP_ITEM_STACK = getInt(4, 1);
+        //public static final class Drag {
+        public static final int DRAG_START_LEFT = getInt(5, 0);
+        public static final int DRAG_ADD_LEFT = getInt(5, 1);
+        public static final int DRAG_END_LEFT = getInt(5, 2);
+        public static final int DRAG_START_RIGHT = getInt(5, 4);
+        public static final int DRAG_ADD_RIGHT = getInt(5, 5);
+        //}
+        public static final int DRAG_END_RIGHT = getInt(5, 6);
+
+        private static int getInt(int mode, int button) {
+            return (mode << 4) + button;
+        }
+        //}
+
+        private static int getMode(int mode) {
+            return mode >> 4;
+        }
+
+        public static boolean isNormalClick(int mode) {
+            return getMode(mode) == 0 || getMode(mode) == 3 || getMode(mode) == 6;
+        }
+
+        public static boolean isShiftClick(int mode) {
+            return getMode(mode) == 1;
+        }
+
+        public static boolean isKey(int mode) {
+            return getMode(mode) == 2;
+        }
+
+        public static boolean inDrop(int mode) {
+            return getMode(mode) == 4;
+        }
+
+        public static boolean isDrag(int mode) {
+            return getMode(mode) == 5;
+        }
+        //}
+    }
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutBossBar.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutBossBar.java
index 2f019fc..b4c3375 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutBossBar.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutBossBar.java
@@ -7,176 +7,180 @@ import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
 import dev.wolveringer.chat.IChatBaseComponent;
 import dev.wolveringer.packet.PacketDataSerializer;
 
-public class PacketPlayOutBossBar extends Packet implements PacketPlayOut{
-	public static enum Action {
-		CREATE,
-		DELETE,
-		UPDATE_HEALTH,
-		UPDATE_TITLE,
-		UPDATE_STYLE,
-		UPDATE_FLAGS;
-		
-		private Action() {}
-	}
-	public static enum BarColor {
-		PING,
-		BLUE,
-		RED,
-		GREEN,
-		YELLOW,
-		PURPLE,
-		WHITE;
-		
-		private BarColor() {}
-	}
-	public static enum BarDivision {
-		NO_DIVISION,
-		SIX_DIVISIONS,
-		TEN_DIVISIONS,
-		TWELF_DIVISIONS,
-		TWENTY_DIVISIONS;
-	}
-	private UUID barId;
-	private Action action;
-	
-	private IChatBaseComponent title;
-	private float health;
-	private BarColor color;
-	private BarDivision division;
-	private short flags;
-	
-	@SuppressWarnings("incomplete-switch")
-	@Override
-	public void read(PacketDataSerializer s) {
-		if(getBigVersion() == BigClientVersion.v1_8)
-			throw new RuntimeException("BossBar packet is 1.9-1.10 only!");
-		barId = s.readUUID();
-		int action = s.readVarInt();
-		if(action >= Action.values().length){
-			System.out.println("Boss bar wrong..... BarId: "+barId);
-			System.out.println("Avariable data: "+s.readableBytes());
-			s.skipBytes(s.readableBytes());
-		}
-		this.action = Action.values()[action];
-		switch (this.action) {
-			case CREATE:
-				title = s.readRawString();
-				health = s.readFloat();
-				color = BarColor.values()[s.readVarInt()];
-				division = BarDivision.values()[s.readVarInt()];
-				flags = s.readUnsignedByte();
-				break;
-			case UPDATE_HEALTH:
-				health = s.readFloat();
-				break;
-			case UPDATE_TITLE:
-				title = s.readRawString();
-				break;
-			case UPDATE_STYLE:
-				color = BarColor.values()[s.readVarInt()];
-				division = BarDivision.values()[s.readVarInt()];
-				break;
-			case UPDATE_FLAGS:
-				flags = s.readUnsignedByte();
-				break;
-		}
-	}
-
-	@Override
-	public void write(PacketDataSerializer s) {
-		if(getBigVersion() == BigClientVersion.v1_8)
-			throw new RuntimeException("BossBar packet is 1.9-1.10 only!");
-		s.writeUUID(barId);
-		s.writeVarInt(action.ordinal());
-		switch (action) {
-			case CREATE:
-				s.writeRawString(title);
-				s.writeFloat(health);
-				s.writeVarInt(color.ordinal());
-				s.writeVarInt(division.ordinal());
-				s.writeByte(flags);
-				break;
-			case UPDATE_HEALTH:
-				s.writeFloat(health);
-				break;
-			case UPDATE_TITLE:
-				s.writeRawString(title);
-				break;
-			case UPDATE_STYLE:
-				s.writeVarInt(color.ordinal());
-				s.writeVarInt(division.ordinal());
-				break;
-			case UPDATE_FLAGS:
-				s.writeByte(flags);
-				break;
-		}
-	}
-
-	public UUID getBarId() {
-		return barId;
-	}
-
-	public PacketPlayOutBossBar setBarId(UUID barId) {
-		this.barId = barId;
-		return this;
-	}
-
-	public Action getAction() {
-		return action;
-	}
-
-	public PacketPlayOutBossBar setAction(Action action) {
-		this.action = action;
-		return this;
-	}
-
-	public IChatBaseComponent getTitle() {
-		return title;
-	}
-
-	public PacketPlayOutBossBar setTitle(IChatBaseComponent title) {
-		this.title = title;
-		return this;
-	}
-
-	public float getHealth() {
-		return health;
-	}
-
-	public PacketPlayOutBossBar setHealth(float health) {
-		this.health = health;
-		return this;
-	}
-
-	public BarColor getColor() {
-		return color;
-	}
-
-	public PacketPlayOutBossBar setColor(BarColor color) {
-		this.color = color;
-		return this;
-	}
-
-	public BarDivision getDivision() {
-		return division;
-	}
-
-	public PacketPlayOutBossBar setDivision(BarDivision division) {
-		this.division = division;
-		return this;
-	}
-
-	public short getFlags() {
-		return flags;
-	}
-
-	public PacketPlayOutBossBar setFlags(short flags) {
-		this.flags = flags;
-		return this;
-	}
-
-	@Override
-	public String toString() {
-		return "PacketPlayOutBossBar [barId=" + barId + ", action=" + action + ", title=" + title + ", health=" + health + ", color=" + color + ", division=" + division + ", flags=" + flags + "]";
-	}
+public class PacketPlayOutBossBar extends Packet implements PacketPlayOut {
+    private UUID barId;
+    private Action action;
+    private IChatBaseComponent title;
+    private float health;
+    private BarColor color;
+    private BarDivision division;
+    private short flags;
+
+    @SuppressWarnings("incomplete-switch")
+    @Override
+    public void read(PacketDataSerializer s) {
+        if (getBigVersion() == BigClientVersion.v1_8)
+            throw new RuntimeException("BossBar packet is 1.9-1.10 only!");
+        barId = s.readUUID();
+        int action = s.readVarInt();
+        if (action >= Action.values().length) {
+            System.out.println("Boss bar wrong..... BarId: " + barId);
+            System.out.println("Avariable data: " + s.readableBytes());
+            s.skipBytes(s.readableBytes());
+        }
+        this.action = Action.values()[action];
+        switch (this.action) {
+            case CREATE:
+                title = s.readRawString();
+                health = s.readFloat();
+                color = BarColor.values()[s.readVarInt()];
+                division = BarDivision.values()[s.readVarInt()];
+                flags = s.readUnsignedByte();
+                break;
+            case UPDATE_HEALTH:
+                health = s.readFloat();
+                break;
+            case UPDATE_TITLE:
+                title = s.readRawString();
+                break;
+            case UPDATE_STYLE:
+                color = BarColor.values()[s.readVarInt()];
+                division = BarDivision.values()[s.readVarInt()];
+                break;
+            case UPDATE_FLAGS:
+                flags = s.readUnsignedByte();
+                break;
+        }
+    }
+
+    @Override
+    public void write(PacketDataSerializer s) {
+        if (getBigVersion() == BigClientVersion.v1_8)
+            throw new RuntimeException("BossBar packet is 1.9-1.10 only!");
+        s.writeUUID(barId);
+        s.writeVarInt(action.ordinal());
+        switch (action) {
+            case CREATE:
+                s.writeRawString(title);
+                s.writeFloat(health);
+                s.writeVarInt(color.ordinal());
+                s.writeVarInt(division.ordinal());
+                s.writeByte(flags);
+                break;
+            case UPDATE_HEALTH:
+                s.writeFloat(health);
+                break;
+            case UPDATE_TITLE:
+                s.writeRawString(title);
+                break;
+            case UPDATE_STYLE:
+                s.writeVarInt(color.ordinal());
+                s.writeVarInt(division.ordinal());
+                break;
+            case UPDATE_FLAGS:
+                s.writeByte(flags);
+                break;
+        }
+    }
+
+    public UUID getBarId() {
+        return barId;
+    }
+
+    public PacketPlayOutBossBar setBarId(UUID barId) {
+        this.barId = barId;
+        return this;
+    }
+
+    public Action getAction() {
+        return action;
+    }
+
+    public PacketPlayOutBossBar setAction(Action action) {
+        this.action = action;
+        return this;
+    }
+
+    public IChatBaseComponent getTitle() {
+        return title;
+    }
+
+    public PacketPlayOutBossBar setTitle(IChatBaseComponent title) {
+        this.title = title;
+        return this;
+    }
+
+    public float getHealth() {
+        return health;
+    }
+
+    public PacketPlayOutBossBar setHealth(float health) {
+        this.health = health;
+        return this;
+    }
+
+    public BarColor getColor() {
+        return color;
+    }
+
+    public PacketPlayOutBossBar setColor(BarColor color) {
+        this.color = color;
+        return this;
+    }
+
+    public BarDivision getDivision() {
+        return division;
+    }
+
+    public PacketPlayOutBossBar setDivision(BarDivision division) {
+        this.division = division;
+        return this;
+    }
+
+    public short getFlags() {
+        return flags;
+    }
+
+    public PacketPlayOutBossBar setFlags(short flags) {
+        this.flags = flags;
+        return this;
+    }
+
+    @Override
+    public String toString() {
+        return "PacketPlayOutBossBar [barId=" + barId + ", action=" + action + ", title=" + title + ", health=" + health + ", color=" + color + ", division=" + division + ", flags=" + flags + "]";
+    }
+
+    public static enum Action {
+        CREATE,
+        DELETE,
+        UPDATE_HEALTH,
+        UPDATE_TITLE,
+        UPDATE_STYLE,
+        UPDATE_FLAGS;
+
+        private Action() {
+        }
+    }
+
+    public static enum BarColor {
+        PING,
+        BLUE,
+        RED,
+        GREEN,
+        YELLOW,
+        PURPLE,
+        WHITE;
+
+        private BarColor() {
+        }
+    }
+
+    public static enum BarDivision {
+        NO_DIVISION,
+        SIX_DIVISIONS,
+        TEN_DIVISIONS,
+        TWELF_DIVISIONS,
+        TWENTY_DIVISIONS;
+    }
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutChat.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutChat.java
index 8e5f957..1c33c47 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutChat.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutChat.java
@@ -9,53 +9,53 @@ import dev.wolveringer.util.ByteString;
 
 public class PacketPlayOutChat extends BetaPacket implements PacketPlayOut {
 
-	private byte modus = 0;
-	private ByteString data;
-
-	public PacketPlayOutChat() {
-		super(0x02);
-	}
-
-	public PacketPlayOutChat(IChatBaseComponent msg) {
-		super(0x02);
-		data = new ByteString(ChatSerializer.toJSONString(msg));
-	}
-
-	public IChatBaseComponent getMessage() {
-		return ChatSerializer.fromJSON(data.getString());
-	}
-
-	public void setModus(byte modus) {
-		this.modus = modus;
-	}
-
-	public byte getModus() {
-		return modus;
-	}
-
-	@Override
-	public void read(PacketDataSerializer s) {
-		data = s.readStringBytes();
-		if(getVersion().getBigVersion() == BigClientVersion.v1_8 || getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10)
-			modus = s.readByte();
-	}
-
-	public void setMessage(IChatBaseComponent c) {
-		this.data = new ByteString(ChatSerializer.toJSONString(c));
-	}
-
-	@Override
-	public void write(PacketDataSerializer s) {
-		s.writeStringBytes(data);
-		if(getVersion().getBigVersion() == BigClientVersion.v1_8 || getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10)
-			s.writeByte(modus);
-	}
-
-	public void setRawMessage(byte[] raw) {
-		this.data = new ByteString(raw);
-	}
-
-	public byte[] getRawMessage() {
-		return this.data.getBytes();
-	}
+    private byte modus = 0;
+    private ByteString data;
+
+    public PacketPlayOutChat() {
+        super(0x02);
+    }
+
+    public PacketPlayOutChat(IChatBaseComponent msg) {
+        super(0x02);
+        data = new ByteString(ChatSerializer.toJSONString(msg));
+    }
+
+    public IChatBaseComponent getMessage() {
+        return ChatSerializer.fromJSON(data.getString());
+    }
+
+    public void setMessage(IChatBaseComponent c) {
+        this.data = new ByteString(ChatSerializer.toJSONString(c));
+    }
+
+    public byte getModus() {
+        return modus;
+    }
+
+    public void setModus(byte modus) {
+        this.modus = modus;
+    }
+
+    @Override
+    public void read(PacketDataSerializer s) {
+        data = s.readStringBytes();
+        if (getVersion().getBigVersion() == BigClientVersion.v1_8 || getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10)
+            modus = s.readByte();
+    }
+
+    @Override
+    public void write(PacketDataSerializer s) {
+        s.writeStringBytes(data);
+        if (getVersion().getBigVersion() == BigClientVersion.v1_8 || getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10)
+            s.writeByte(modus);
+    }
+
+    public byte[] getRawMessage() {
+        return this.data.getBytes();
+    }
+
+    public void setRawMessage(byte[] raw) {
+        this.data = new ByteString(raw);
+    }
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutCloseWindow.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutCloseWindow.java
index d3ebaf0..2741371 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutCloseWindow.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutCloseWindow.java
@@ -3,34 +3,34 @@ package dev.wolveringer.BungeeUtil.packets;
 import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
 import dev.wolveringer.packet.PacketDataSerializer;
 
-public class PacketPlayOutCloseWindow extends Packet implements PacketPlayOut{
+public class PacketPlayOutCloseWindow extends Packet implements PacketPlayOut {
 
-	private int window;
+    private int window;
 
-	public PacketPlayOutCloseWindow() {
-		super(0x2E);
-	}
+    public PacketPlayOutCloseWindow() {
+        super(0x2E);
+    }
 
-	public PacketPlayOutCloseWindow(int window) {
-		super(0x2E);
-		this.window = window;
-	}
+    public PacketPlayOutCloseWindow(int window) {
+        super(0x2E);
+        this.window = window;
+    }
 
-	public int getWindow() {
-		return window;
-	}
+    public int getWindow() {
+        return window;
+    }
 
-	@Override
-	public void read(PacketDataSerializer s) {
-		this.window = s.readUnsignedByte();
-	}
+    public void setWindow(int window) {
+        this.window = window;
+    }
 
-	public void setWindow(int window) {
-		this.window = window;
-	}
+    @Override
+    public void read(PacketDataSerializer s) {
+        this.window = s.readUnsignedByte();
+    }
 
-	@Override
-	public void write(PacketDataSerializer s) {
-		s.writeByte(this.window);
-	}
+    @Override
+    public void write(PacketDataSerializer s) {
+        s.writeByte(this.window);
+    }
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutDisconnect.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutDisconnect.java
index 958e1f3..280e682 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutDisconnect.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutDisconnect.java
@@ -5,29 +5,29 @@ import dev.wolveringer.chat.ChatSerializer;
 import dev.wolveringer.chat.IChatBaseComponent;
 import dev.wolveringer.packet.PacketDataSerializer;
 
-public class PacketPlayOutDisconnect extends Packet implements PacketPlayOut{
-
-	private String c;
-	
-	public PacketPlayOutDisconnect() {
-	}
-	
-	public PacketPlayOutDisconnect(IChatBaseComponent c) {
-		this.c = ChatSerializer.toJSONString(c);
-	}
-	
-	@Override
-	public void read(PacketDataSerializer s) {
-		c = s.readString(-1);
-	}
-
-	@Override
-	public void write(PacketDataSerializer s) {
-		s.writeString(c);
-	}
-	
-	public IChatBaseComponent getMessage(){
-		return ChatSerializer.fromJSON(c);
-	}
-	
+public class PacketPlayOutDisconnect extends Packet implements PacketPlayOut {
+
+    private String c;
+
+    public PacketPlayOutDisconnect() {
+    }
+
+    public PacketPlayOutDisconnect(IChatBaseComponent c) {
+        this.c = ChatSerializer.toJSONString(c);
+    }
+
+    @Override
+    public void read(PacketDataSerializer s) {
+        c = s.readString(-1);
+    }
+
+    @Override
+    public void write(PacketDataSerializer s) {
+        s.writeString(c);
+    }
+
+    public IChatBaseComponent getMessage() {
+        return ChatSerializer.fromJSON(c);
+    }
+
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutEntityDestroy.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutEntityDestroy.java
index 344f0b5..2fa725d 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutEntityDestroy.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutEntityDestroy.java
@@ -4,43 +4,44 @@ import dev.wolveringer.BungeeUtil.ClientVersion.BigClientVersion;
 import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
 import dev.wolveringer.packet.PacketDataSerializer;
 
-public class PacketPlayOutEntityDestroy extends Packet implements PacketPlayOut{
-	private int[] entitys;
-
-	public PacketPlayOutEntityDestroy() {
-	}
-
-	public PacketPlayOutEntityDestroy(int... paramVarArgs) {
-		this.entitys = paramVarArgs;
-	}
-
-	public void read(PacketDataSerializer paramPacketDataSerializer) {
-		this.entitys = new int[getVersion().getBigVersion() == BigClientVersion.v1_7?paramPacketDataSerializer.readByte():paramPacketDataSerializer.readVarInt()];
-		for(int i = 0;i < this.entitys.length;i++){
-			if(getVersion().getBigVersion() == BigClientVersion.v1_7)
-				this.entitys[i] = paramPacketDataSerializer.readInt();
-			else
-				this.entitys[i] = paramPacketDataSerializer.readVarInt();
-		}
-	}
-
-	public void write(PacketDataSerializer paramPacketDataSerializer) {
-		if(getVersion().getBigVersion() == BigClientVersion.v1_7)
-			paramPacketDataSerializer.writeByte(this.entitys.length);
-		else
-			paramPacketDataSerializer.writeVarInt(this.entitys.length);
-		for(int i = 0;i < this.entitys.length;i++){
-			if(getVersion().getBigVersion() == BigClientVersion.v1_7)
-				paramPacketDataSerializer.writeInt(this.entitys[i]);
-			else
-				paramPacketDataSerializer.writeVarInt(this.entitys[i]);
-		}
-	}
-	
-	public int[] getEntitys() {
-		return entitys;
-	}
-	public void setEntitys(int[] entitys) {
-		this.entitys = entitys;
-	}
+public class PacketPlayOutEntityDestroy extends Packet implements PacketPlayOut {
+    private int[] entitys;
+
+    public PacketPlayOutEntityDestroy() {
+    }
+
+    public PacketPlayOutEntityDestroy(int... paramVarArgs) {
+        this.entitys = paramVarArgs;
+    }
+
+    public void read(PacketDataSerializer paramPacketDataSerializer) {
+        this.entitys = new int[getVersion().getBigVersion() == BigClientVersion.v1_7 ? paramPacketDataSerializer.readByte() : paramPacketDataSerializer.readVarInt()];
+        for (int i = 0; i < this.entitys.length; i++) {
+            if (getVersion().getBigVersion() == BigClientVersion.v1_7)
+                this.entitys[i] = paramPacketDataSerializer.readInt();
+            else
+                this.entitys[i] = paramPacketDataSerializer.readVarInt();
+        }
+    }
+
+    public void write(PacketDataSerializer paramPacketDataSerializer) {
+        if (getVersion().getBigVersion() == BigClientVersion.v1_7)
+            paramPacketDataSerializer.writeByte(this.entitys.length);
+        else
+            paramPacketDataSerializer.writeVarInt(this.entitys.length);
+        for (int i = 0; i < this.entitys.length; i++) {
+            if (getVersion().getBigVersion() == BigClientVersion.v1_7)
+                paramPacketDataSerializer.writeInt(this.entitys[i]);
+            else
+                paramPacketDataSerializer.writeVarInt(this.entitys[i]);
+        }
+    }
+
+    public int[] getEntitys() {
+        return entitys;
+    }
+
+    public void setEntitys(int[] entitys) {
+        this.entitys = entitys;
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutEntityEffect.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutEntityEffect.java
index 7c98d7c..1ef919e 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutEntityEffect.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutEntityEffect.java
@@ -5,55 +5,55 @@ import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
 import dev.wolveringer.packet.PacketDataSerializer;
 
 public class PacketPlayOutEntityEffect extends Packet implements PacketPlayOut {
-	
-	int entity;
-	int effect;
-	int amplifier;
-	int duration;
-	boolean hidden = false;
-	
-	public PacketPlayOutEntityEffect(int entity, int effect, int amplifier, int duration, boolean hidden) {
-		this();
-		this.entity = entity;
-		this.effect = effect;
-		this.amplifier = amplifier;
-		this.duration = duration;
-		this.hidden = hidden;
-	}
-	
-	public PacketPlayOutEntityEffect() {
-		super(0x1D);
-	}
-	
-	@Override
-	public void read(PacketDataSerializer s) {
-		entity = getVersion().getBigVersion() == BigClientVersion.v1_7 ? s.readInt() : s.readVarInt();
-		effect = s.readByte();
-		amplifier = s.readByte();
-		duration = getVersion().getBigVersion() == BigClientVersion.v1_7 ? s.readShort() : s.readVarInt();
-		hidden = getVersion().getBigVersion() == BigClientVersion.v1_8 ? s.readBoolean() : (getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10) ? s.readByte() == 1 : false;
-	}
-	
-	public void write(PacketDataSerializer s) {
-		if (getVersion().getBigVersion() == BigClientVersion.v1_8 || getVersion().getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10) {
-			s.writeVarInt(entity);
-			s.writeByte(effect);
-			s.writeByte(amplifier);
-			s.writeVarInt(duration);
-			if (getBigVersion() == BigClientVersion.v1_8) s.writeBoolean(hidden);
-			else if (getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10) s.writeByte(hidden == true ? 1 : 0);
-		}
-		else if (getVersion().getBigVersion() == BigClientVersion.v1_7) {
-			s.writeInt(entity);
-			s.writeByte(effect);
-			s.writeByte(amplifier);
-			s.writeShort(duration);
-		}
-	}
-	
-	@Override
-	public String toString() {
-		return "PacketPlayOutEntityEffect [entity=" + entity + ", effect=" + effect + ", amplifier=" + amplifier + ", duration=" + duration + ", hidden=" + hidden + "]";
-	}
-	
+
+    int entity;
+    int effect;
+    int amplifier;
+    int duration;
+    boolean hidden = false;
+
+    public PacketPlayOutEntityEffect(int entity, int effect, int amplifier, int duration, boolean hidden) {
+        this();
+        this.entity = entity;
+        this.effect = effect;
+        this.amplifier = amplifier;
+        this.duration = duration;
+        this.hidden = hidden;
+    }
+
+    public PacketPlayOutEntityEffect() {
+        super(0x1D);
+    }
+
+    @Override
+    public void read(PacketDataSerializer s) {
+        entity = getVersion().getBigVersion() == BigClientVersion.v1_7 ? s.readInt() : s.readVarInt();
+        effect = s.readByte();
+        amplifier = s.readByte();
+        duration = getVersion().getBigVersion() == BigClientVersion.v1_7 ? s.readShort() : s.readVarInt();
+        hidden = getVersion().getBigVersion() == BigClientVersion.v1_8 ? s.readBoolean() : (getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10) ? s.readByte() == 1 : false;
+    }
+
+    public void write(PacketDataSerializer s) {
+        if (getVersion().getBigVersion() == BigClientVersion.v1_8 || getVersion().getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10) {
+            s.writeVarInt(entity);
+            s.writeByte(effect);
+            s.writeByte(amplifier);
+            s.writeVarInt(duration);
+            if (getBigVersion() == BigClientVersion.v1_8) s.writeBoolean(hidden);
+            else if (getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10)
+                s.writeByte(hidden == true ? 1 : 0);
+        } else if (getVersion().getBigVersion() == BigClientVersion.v1_7) {
+            s.writeInt(entity);
+            s.writeByte(effect);
+            s.writeByte(amplifier);
+            s.writeShort(duration);
+        }
+    }
+
+    @Override
+    public String toString() {
+        return "PacketPlayOutEntityEffect [entity=" + entity + ", effect=" + effect + ", amplifier=" + amplifier + ", duration=" + duration + ", hidden=" + hidden + "]";
+    }
+
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutEntityEquipment.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutEntityEquipment.java
index 1af5bf9..15d05de 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutEntityEquipment.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutEntityEquipment.java
@@ -5,70 +5,72 @@ import dev.wolveringer.BungeeUtil.item.Item;
 import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
 import dev.wolveringer.packet.PacketDataSerializer;
 
-public class PacketPlayOutEntityEquipment extends Packet implements PacketPlayOut{
-	public static enum Slot {
-		MAIN_HAND,
-		OFF_HAND,
-		BOOTS,
-		LEGGINS,
-		CHESTPLATE,
-		HEMELT;
-		
-		private Slot() {}
-	}
-	private int eid;
-	private Item item;
-	private Slot slot;
+public class PacketPlayOutEntityEquipment extends Packet implements PacketPlayOut {
+    private int eid;
+    private Item item;
+    private Slot slot;
 
-	public PacketPlayOutEntityEquipment() {
-		super(0x04);
-	}
+    public PacketPlayOutEntityEquipment() {
+        super(0x04);
+    }
 
-	
-	public PacketPlayOutEntityEquipment(int eid, Item item, Slot slot) {
-		this();
-		this.eid = eid;
-		this.item = item;
-		this.slot = slot;
-	}
+    public PacketPlayOutEntityEquipment(int eid, Item item, Slot slot) {
+        this();
+        this.eid = eid;
+        this.item = item;
+        this.slot = slot;
+    }
 
+    @Override
+    public void read(PacketDataSerializer s) {
+        eid = s.readVarInt();
+        slot = Slot.values()[(getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10) ? s.readVarInt() : s.readShort()];
+        item = s.readItem();
+    }
 
+    @Override
+    public void write(PacketDataSerializer s) {
+        s.writeVarInt(eid);
+        if (getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10)
+            s.writeVarInt(slot.ordinal());
+        else
+            s.writeShort(slot.ordinal());
+        s.writeItem(item);
+    }
 
-	@Override
-	public void read(PacketDataSerializer s) {
-		eid = s.readVarInt();
-		slot = Slot.values()[(getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10) ? s.readVarInt() : s.readShort()];
-		item= s.readItem();
-	}
+    public int getEntityId() {
+        return eid;
+    }
 
-	@Override
-	public void write(PacketDataSerializer s) {
-		s.writeVarInt(eid);
-		if(getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10)
-			s.writeVarInt(slot.ordinal());
-		else
-			s.writeShort(slot.ordinal());
-		s.writeItem(item);
-	}
+    public void setEntityId(int eid) {
+        this.eid = eid;
+    }
 
-	
-	public int getEntityId() {
-		return eid;
-	}
-	public Item getItem() {
-		return item;
-	}
-	public Slot getSlot() {
-		return slot;
-	}
-	
-	public void setEntityId(int eid) {
-		this.eid = eid;
-	}
-	public void setItem(Item item) {
-		this.item = item;
-	}
-	public void setSlot(Slot slot) {
-		this.slot = slot;
-	}
+    public Item getItem() {
+        return item;
+    }
+
+    public void setItem(Item item) {
+        this.item = item;
+    }
+
+    public Slot getSlot() {
+        return slot;
+    }
+
+    public void setSlot(Slot slot) {
+        this.slot = slot;
+    }
+
+    public static enum Slot {
+        MAIN_HAND,
+        OFF_HAND,
+        BOOTS,
+        LEGGINS,
+        CHESTPLATE,
+        HEMELT;
+
+        private Slot() {
+        }
+    }
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutEntityHeadRotation.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutEntityHeadRotation.java
index ed1ac4c..e662cd5 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutEntityHeadRotation.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutEntityHeadRotation.java
@@ -1,40 +1,39 @@
 package dev.wolveringer.BungeeUtil.packets;
 
-import java.util.Random;
-
 import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
 import dev.wolveringer.packet.PacketDataSerializer;
 import dev.wolveringer.util.MathUtil;
 
-public class PacketPlayOutEntityHeadRotation extends Packet implements PacketPlayOut{
-	private int entityId;
-	private byte pitch;
-	
-	public PacketPlayOutEntityHeadRotation() {}
-	
-	public PacketPlayOutEntityHeadRotation(int entityId, float pitch) {
-		this.entityId = entityId;
-		this.pitch = (byte)((int)(MathUtil.pitchNormalizer(pitch) * 256.0F / 360.0F));
-	}
-
-
-
-	@Override
-	public void read(PacketDataSerializer s) {
-		entityId = s.readVarInt();
-		pitch = s.readByte();
-	}
-
-	@Override
-	public void write(PacketDataSerializer s) {
-		s.writeVarInt(entityId);
-		s.writeByte(pitch);
-	}
-	
-	public int getEntityId() {
-		return entityId;
-	}
-	public float getPitch() {
-		return pitch / 256.0F * 360.0F;
-	}
+public class PacketPlayOutEntityHeadRotation extends Packet implements PacketPlayOut {
+    private int entityId;
+    private byte pitch;
+
+    public PacketPlayOutEntityHeadRotation() {
+    }
+
+    public PacketPlayOutEntityHeadRotation(int entityId, float pitch) {
+        this.entityId = entityId;
+        this.pitch = (byte) ((int) (MathUtil.pitchNormalizer(pitch) * 256.0F / 360.0F));
+    }
+
+
+    @Override
+    public void read(PacketDataSerializer s) {
+        entityId = s.readVarInt();
+        pitch = s.readByte();
+    }
+
+    @Override
+    public void write(PacketDataSerializer s) {
+        s.writeVarInt(entityId);
+        s.writeByte(pitch);
+    }
+
+    public int getEntityId() {
+        return entityId;
+    }
+
+    public float getPitch() {
+        return pitch / 256.0F * 360.0F;
+    }
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutEntityMetadata.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutEntityMetadata.java
index 31606bf..b06f8ca 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutEntityMetadata.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutEntityMetadata.java
@@ -5,36 +5,36 @@ import dev.wolveringer.api.datawatcher.DataWatcher;
 import dev.wolveringer.packet.PacketDataSerializer;
 
 public class PacketPlayOutEntityMetadata extends Packet implements PacketPlayOut {
-	private int id;
-	private DataWatcher meta;
-
-	public PacketPlayOutEntityMetadata() {
-		super(0x1C);
-	}
-
-	public PacketPlayOutEntityMetadata(int id, DataWatcher datawatcher) {
-		this();
-		this.id = id;
-		this.meta = datawatcher;
-	}
-
-	public void read(PacketDataSerializer packetdataserializer) {
-		this.id = packetdataserializer.readInt();
-		this.meta = DataWatcher.createDataWatcher(getBigVersion(),packetdataserializer);
-	}
-
-	public void write(PacketDataSerializer packetdataserializer) {
-		if(getVersion().getVersion() < 16){
-			packetdataserializer.writeInt(this.id);
-		}else{
-			packetdataserializer.writeVarInt(this.id);
-		}
-		meta.write(packetdataserializer);
-	}
-
-	@Override
-	public String toString() {
-		return "PacketPlayOutEntityMetadata@" + System.identityHashCode(this) + "[id=" + id + ", meta=" + meta + "]";
-	}
-	
+    private int id;
+    private DataWatcher meta;
+
+    public PacketPlayOutEntityMetadata() {
+        super(0x1C);
+    }
+
+    public PacketPlayOutEntityMetadata(int id, DataWatcher datawatcher) {
+        this();
+        this.id = id;
+        this.meta = datawatcher;
+    }
+
+    public void read(PacketDataSerializer packetdataserializer) {
+        this.id = packetdataserializer.readInt();
+        this.meta = DataWatcher.createDataWatcher(getBigVersion(), packetdataserializer);
+    }
+
+    public void write(PacketDataSerializer packetdataserializer) {
+        if (getVersion().getVersion() < 16) {
+            packetdataserializer.writeInt(this.id);
+        } else {
+            packetdataserializer.writeVarInt(this.id);
+        }
+        meta.write(packetdataserializer);
+    }
+
+    @Override
+    public String toString() {
+        return "PacketPlayOutEntityMetadata@" + System.identityHashCode(this) + "[id=" + id + ", meta=" + meta + "]";
+    }
+
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutEntityProperties.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutEntityProperties.java
index d92ad7c..0f081fe 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutEntityProperties.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutEntityProperties.java
@@ -3,153 +3,171 @@ package dev.wolveringer.BungeeUtil.packets;
 import java.util.ArrayList;
 import java.util.UUID;
 
-import dev.wolveringer.BungeeUtil.packets.PacketPlayOutEntityProperties.EntityProperty.EntityPropertyModifier;
 import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
+import dev.wolveringer.BungeeUtil.packets.PacketPlayOutEntityProperties.EntityProperty.EntityPropertyModifier;
 import dev.wolveringer.packet.PacketDataSerializer;
 
-public class PacketPlayOutEntityProperties extends Packet implements PacketPlayOut{
-	public static class EntityProperty {
-		public static class EntityPropertyModifier{
-			private UUID uuid;
-			private double amount;
-			private byte operation;
-			
-			public EntityPropertyModifier(UUID uuid, double amount, byte operation) {
-				this.uuid = uuid;
-				this.amount = amount;
-				this.operation = operation;
-			}
-			
-			public double getAmount() {
-				return amount;
-			}
-			public byte getOperation() {
-				return operation;
-			}
-			public UUID getUUID() {
-				return uuid;
-			}
-
-			public void setAmount(double amount) {
-				this.amount = amount;
-			}
-			public void setOperation(byte operation) {
-				this.operation = operation;
-			}
-			public void setUUID(UUID uuid) {
-				this.uuid = uuid;
-			}
-			
-			@Override
-			public int hashCode() {
-				final int prime = 31;
-				int result = 1;
-				long temp;
-				temp = Double.doubleToLongBits(amount);
-				result = prime * result + (int) (temp ^ (temp >>> 32));
-				result = prime * result + operation;
-				result = prime * result + ((uuid == null) ? 0 : uuid.hashCode());
-				return result;
-			}
-
-			@Override
-			public boolean equals(Object obj) {
-				if (this == obj) return true;
-				if (obj == null) return false;
-				if (getClass() != obj.getClass()) return false;
-				EntityPropertyModifier other = (EntityPropertyModifier) obj;
-				if (Double.doubleToLongBits(amount) != Double.doubleToLongBits(other.amount)) return false;
-				if (operation != other.operation) return false;
-				if (uuid == null) {
-					if (other.uuid != null) return false;
-				}
-				else if (!uuid.equals(other.uuid)) return false;
-				return true;
-			}
-		}
-		private String name;
-		private double value;
-		private ArrayList<EntityPropertyModifier> modifiers = new ArrayList<>();
-		
-		public EntityProperty(String name,double value) {
-			this.name = name;
-			this.value = value;
-		}
-		
-		public String getName() {
-			return name;
-		}
-		public void setName(String name) {
-			this.name = name;
-		}
-		public double getValue() {
-			return value;
-		}
-		public void setValue(double value) {
-			this.value = value;
-		}
-		public ArrayList<EntityPropertyModifier> getModifiers() {
-			return modifiers;
-		}
-		public void addModifier(EntityPropertyModifier mod){
-			modifiers.add(mod);
-		}
-		public void removeModifier(EntityPropertyModifier mod){
-			modifiers.add(mod);
-		}
-	}
-	int entity;
-	ArrayList<EntityProperty> properties = new ArrayList<>();
-	
-	public PacketPlayOutEntityProperties() {
-		super(0x20);
-	}
-	
-	@Override
-	public void write(PacketDataSerializer s) {
-		s.writeVarInt(entity);
-		s.writeInt(properties.size());
-		for(EntityProperty prop : properties){
-			s.writeString(prop.getName());
-			s.writeDouble(prop.getValue());
-			s.writeVarInt(prop.getModifiers().size());
-			for(EntityPropertyModifier mod : prop.getModifiers()){
-				s.writeUUID(mod.getUUID());
-				s.writeDouble(mod.getAmount());
-				s.writeByte(mod.getOperation());
-			}
-		}
-	}
-	@Override
-	public void read(PacketDataSerializer s) {
-		entity = s.readVarInt();
-		int pSize = s.readInt();
-		for(int i = 0;i<pSize;i++){
-			EntityProperty prop = new EntityProperty(s.readString(-1), s.readDouble());
-			int mSize = s.readVarInt();
-			if(mSize > 0)
-				for(int j = 0;j<mSize;j++)
-					prop.addModifier(new EntityPropertyModifier(s.readUUID(), s.readDouble(), s.readByte()));
-			properties.add(prop);
-		}
-	}
-	public ArrayList<EntityProperty> getProperties() {
-		return properties;
-	}
-	public PacketPlayOutEntityProperties setProperties(ArrayList<EntityProperty> properties) {
-		this.properties = properties;
-		return this;
-	}
-	public int getEntityID() {
-		return entity;
-	}
-	public PacketPlayOutEntityProperties setEntityID(int entity) {
-		this.entity = entity;
-		return this;
-	}
-	public PacketPlayOutEntityProperties addProperty(EntityProperty prop){
-		properties.add(prop);
-		return this;
-	}
-	
+public class PacketPlayOutEntityProperties extends Packet implements PacketPlayOut {
+    int entity;
+    ArrayList<EntityProperty> properties = new ArrayList<>();
+
+    public PacketPlayOutEntityProperties() {
+        super(0x20);
+    }
+
+    @Override
+    public void write(PacketDataSerializer s) {
+        s.writeVarInt(entity);
+        s.writeInt(properties.size());
+        for (EntityProperty prop : properties) {
+            s.writeString(prop.getName());
+            s.writeDouble(prop.getValue());
+            s.writeVarInt(prop.getModifiers().size());
+            for (EntityPropertyModifier mod : prop.getModifiers()) {
+                s.writeUUID(mod.getUUID());
+                s.writeDouble(mod.getAmount());
+                s.writeByte(mod.getOperation());
+            }
+        }
+    }
+
+    @Override
+    public void read(PacketDataSerializer s) {
+        entity = s.readVarInt();
+        int pSize = s.readInt();
+        for (int i = 0; i < pSize; i++) {
+            EntityProperty prop = new EntityProperty(s.readString(-1), s.readDouble());
+            int mSize = s.readVarInt();
+            if (mSize > 0)
+                for (int j = 0; j < mSize; j++)
+                    prop.addModifier(new EntityPropertyModifier(s.readUUID(), s.readDouble(), s.readByte()));
+            properties.add(prop);
+        }
+    }
+
+    public ArrayList<EntityProperty> getProperties() {
+        return properties;
+    }
+
+    public PacketPlayOutEntityProperties setProperties(ArrayList<EntityProperty> properties) {
+        this.properties = properties;
+        return this;
+    }
+
+    public int getEntityID() {
+        return entity;
+    }
+
+    public PacketPlayOutEntityProperties setEntityID(int entity) {
+        this.entity = entity;
+        return this;
+    }
+
+    public PacketPlayOutEntityProperties addProperty(EntityProperty prop) {
+        properties.add(prop);
+        return this;
+    }
+
+    public static class EntityProperty {
+        private String name;
+        private double value;
+        private ArrayList<EntityPropertyModifier> modifiers = new ArrayList<>();
+
+        public EntityProperty(String name, double value) {
+            this.name = name;
+            this.value = value;
+        }
+
+        public String getName() {
+            return name;
+        }
+
+        public void setName(String name) {
+            this.name = name;
+        }
+
+        public double getValue() {
+            return value;
+        }
+
+        public void setValue(double value) {
+            this.value = value;
+        }
+
+        public ArrayList<EntityPropertyModifier> getModifiers() {
+            return modifiers;
+        }
+
+        public void addModifier(EntityPropertyModifier mod) {
+            modifiers.add(mod);
+        }
+
+        public void removeModifier(EntityPropertyModifier mod) {
+            modifiers.add(mod);
+        }
+
+        public static class EntityPropertyModifier {
+            private UUID uuid;
+            private double amount;
+            private byte operation;
+
+            public EntityPropertyModifier(UUID uuid, double amount, byte operation) {
+                this.uuid = uuid;
+                this.amount = amount;
+                this.operation = operation;
+            }
+
+            public double getAmount() {
+                return amount;
+            }
+
+            public void setAmount(double amount) {
+                this.amount = amount;
+            }
+
+            public byte getOperation() {
+                return operation;
+            }
+
+            public void setOperation(byte operation) {
+                this.operation = operation;
+            }
+
+            public UUID getUUID() {
+                return uuid;
+            }
+
+            public void setUUID(UUID uuid) {
+                this.uuid = uuid;
+            }
+
+            @Override
+            public int hashCode() {
+                final int prime = 31;
+                int result = 1;
+                long temp;
+                temp = Double.doubleToLongBits(amount);
+                result = prime * result + (int) (temp ^ (temp >>> 32));
+                result = prime * result + operation;
+                result = prime * result + ((uuid == null) ? 0 : uuid.hashCode());
+                return result;
+            }
+
+            @Override
+            public boolean equals(Object obj) {
+                if (this == obj) return true;
+                if (obj == null) return false;
+                if (getClass() != obj.getClass()) return false;
+                EntityPropertyModifier other = (EntityPropertyModifier) obj;
+                if (Double.doubleToLongBits(amount) != Double.doubleToLongBits(other.amount))
+                    return false;
+                if (operation != other.operation) return false;
+                if (uuid == null) {
+                    if (other.uuid != null) return false;
+                } else if (!uuid.equals(other.uuid)) return false;
+                return true;
+            }
+        }
+    }
+
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutEntityTeleport.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutEntityTeleport.java
index 971a389..b6e27a9 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutEntityTeleport.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutEntityTeleport.java
@@ -6,96 +6,94 @@ import dev.wolveringer.api.position.Location;
 import dev.wolveringer.packet.PacketDataSerializer;
 
 public class PacketPlayOutEntityTeleport extends Packet implements PacketPlayOut {
-	Location loc;
-	int id;
-	private boolean onGround;
-
-	public PacketPlayOutEntityTeleport() {
-		super(0x18);
-	}
-
-	public PacketPlayOutEntityTeleport(int id, Location loc) {
-		this();
-		this.loc = loc.clone();
-		this.id = id;
-	}
-
-	public PacketPlayOutEntityTeleport(int id, Location loc, boolean onGround) {
-		this(id, loc);
-		this.onGround = onGround;
-	}
-
-	public void read(PacketDataSerializer s) {
-		if(getVersion().getVersion() < 16)
-			id = s.readInt();
-		else
-			id = s.readVarInt();
-		if(getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10)
-			loc = new Location(s.readDouble(), s.readDouble(), s.readDouble(),((float)s.readByte())/ 256.0F * 360.0F,((float)s.readByte())/ 256.0F * 360.0F);
-		else
-			loc = new Location(s.readInt(), s.readInt(), s.readInt(), ((float)s.readByte())/ 256.0F * 360.0F,((float)s.readByte())/ 256.0F * 360.0F).dividide(32D);
-		if(getVersion().getVersion() >= 22){
-			onGround = s.readBoolean();
-		}
-	}
-
-	@Override
-	public void write(PacketDataSerializer s) {
-		if(getVersion().getVersion() < 16){
-			s.writeInt(id);
-		}else{
-			s.writeVarInt(id);
-		}
-		if(getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10){
-			s.writeDouble(loc.getX());
-			s.writeDouble(loc.getY());
-			s.writeDouble(loc.getZ());
-			
-			s.writeByte((int) (loc.getYaw() * 256.0F / 360.0F));
-			s.writeByte((int) (loc.getPitch() * 256.0F / 360.0F));
-		}
-		else
-		{
-			loc = loc.multiply(32D);
-			s.writeInt(loc.getBlockX());
-			s.writeInt(loc.getBlockY());
-			s.writeInt(loc.getBlockZ());
-
-			s.writeByte((int) (loc.getYaw() * 256.0F / 360.0F));
-			s.writeByte((int) (loc.getPitch() * 256.0F / 360.0F));
-		}
-		if(getVersion().getVersion() >= 22)
-			s.writeBoolean(this.onGround);
-	}
-
-	public Location getLocation() {
-		return loc.clone();
-	}
-
-	public void setLocation(Location loc) {
-		this.loc = loc.clone();
-	}
-
-	public int getId() {
-		return id;
-	}
-
-	public void setId(int id) {
-		this.id = id;
-	}
-
-	public boolean isOnGround() {
-		return onGround;
-	}
-
-	public void setOnGround(boolean onGround) {
-		this.onGround = onGround;
-	}
-	
-	public static void main(String[] args) {
-		float a = (int) (180F * 256.0F / 360.0F);
-		float b = (int) (a / 256.0F * 360.0F);
-		System.out.println("X: "+a+" Y: "+b);
-	}
+    Location loc;
+    int id;
+    private boolean onGround;
+
+    public PacketPlayOutEntityTeleport() {
+        super(0x18);
+    }
+
+    public PacketPlayOutEntityTeleport(int id, Location loc) {
+        this();
+        this.loc = loc.clone();
+        this.id = id;
+    }
+
+    public PacketPlayOutEntityTeleport(int id, Location loc, boolean onGround) {
+        this(id, loc);
+        this.onGround = onGround;
+    }
+
+    public static void main(String[] args) {
+        float a = (int) (180F * 256.0F / 360.0F);
+        float b = (int) (a / 256.0F * 360.0F);
+        System.out.println("X: " + a + " Y: " + b);
+    }
+
+    public void read(PacketDataSerializer s) {
+        if (getVersion().getVersion() < 16)
+            id = s.readInt();
+        else
+            id = s.readVarInt();
+        if (getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10)
+            loc = new Location(s.readDouble(), s.readDouble(), s.readDouble(), ((float) s.readByte()) / 256.0F * 360.0F, ((float) s.readByte()) / 256.0F * 360.0F);
+        else
+            loc = new Location(s.readInt(), s.readInt(), s.readInt(), ((float) s.readByte()) / 256.0F * 360.0F, ((float) s.readByte()) / 256.0F * 360.0F).dividide(32D);
+        if (getVersion().getVersion() >= 22) {
+            onGround = s.readBoolean();
+        }
+    }
+
+    @Override
+    public void write(PacketDataSerializer s) {
+        if (getVersion().getVersion() < 16) {
+            s.writeInt(id);
+        } else {
+            s.writeVarInt(id);
+        }
+        if (getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10) {
+            s.writeDouble(loc.getX());
+            s.writeDouble(loc.getY());
+            s.writeDouble(loc.getZ());
+
+            s.writeByte((int) (loc.getYaw() * 256.0F / 360.0F));
+            s.writeByte((int) (loc.getPitch() * 256.0F / 360.0F));
+        } else {
+            loc = loc.multiply(32D);
+            s.writeInt(loc.getBlockX());
+            s.writeInt(loc.getBlockY());
+            s.writeInt(loc.getBlockZ());
+
+            s.writeByte((int) (loc.getYaw() * 256.0F / 360.0F));
+            s.writeByte((int) (loc.getPitch() * 256.0F / 360.0F));
+        }
+        if (getVersion().getVersion() >= 22)
+            s.writeBoolean(this.onGround);
+    }
+
+    public Location getLocation() {
+        return loc.clone();
+    }
+
+    public void setLocation(Location loc) {
+        this.loc = loc.clone();
+    }
+
+    public int getId() {
+        return id;
+    }
+
+    public void setId(int id) {
+        this.id = id;
+    }
+
+    public boolean isOnGround() {
+        return onGround;
+    }
+
+    public void setOnGround(boolean onGround) {
+        this.onGround = onGround;
+    }
 
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutGameStateChange.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutGameStateChange.java
index 921ce86..14ca56d 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutGameStateChange.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutGameStateChange.java
@@ -3,42 +3,46 @@ package dev.wolveringer.BungeeUtil.packets;
 import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
 import dev.wolveringer.packet.PacketDataSerializer;
 
-public class PacketPlayOutGameStateChange extends Packet implements PacketPlayOut{
-	int state;
-	float value;
-	
-	
-	public PacketPlayOutGameStateChange(int state, float value) {
-		super(0x2B);
-		this.state = state;
-		this.value = value;
-	}
-	
-	public PacketPlayOutGameStateChange() {
-		super(0x2B);
-	}
-	
-	@Override
-	public void read(PacketDataSerializer s) {
-			state = s.readByte();
-			value = s.readFloat();
-	}
-	
-	@Override
-	public void write(PacketDataSerializer s) {
-			s.writeByte(state);
-			s.writeFloat(value);
-	}
-	public float getValue() {
-		return value;
-	}
-	public int getState() {
-		return state;
-	}
-	public void setState(int state) {
-		this.state = state;
-	}
-	public void setValue(float value) {
-		this.value = value;
-	}
+public class PacketPlayOutGameStateChange extends Packet implements PacketPlayOut {
+    int state;
+    float value;
+
+
+    public PacketPlayOutGameStateChange(int state, float value) {
+        super(0x2B);
+        this.state = state;
+        this.value = value;
+    }
+
+    public PacketPlayOutGameStateChange() {
+        super(0x2B);
+    }
+
+    @Override
+    public void read(PacketDataSerializer s) {
+        state = s.readByte();
+        value = s.readFloat();
+    }
+
+    @Override
+    public void write(PacketDataSerializer s) {
+        s.writeByte(state);
+        s.writeFloat(value);
+    }
+
+    public float getValue() {
+        return value;
+    }
+
+    public void setValue(float value) {
+        this.value = value;
+    }
+
+    public int getState() {
+        return state;
+    }
+
+    public void setState(int state) {
+        this.state = state;
+    }
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutHeldItemSlot.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutHeldItemSlot.java
index 3fe214b..ea907eb 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutHeldItemSlot.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutHeldItemSlot.java
@@ -5,21 +5,24 @@ import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayXXXHeldItemSlot;
 import dev.wolveringer.packet.PacketDataSerializer;
 
 
-public class PacketPlayOutHeldItemSlot extends PacketPlayXXXHeldItemSlot implements PacketPlayOut{
-	public PacketPlayOutHeldItemSlot() {
-		super(0x09);
-	}
-	
-	public PacketPlayOutHeldItemSlot(byte slot) {
-		this();
-		setSlot(slot);
-	}
+public class PacketPlayOutHeldItemSlot extends PacketPlayXXXHeldItemSlot implements PacketPlayOut {
+    public PacketPlayOutHeldItemSlot() {
+        super(0x09);
+    }
 
-	@Override
-	public void read(PacketDataSerializer s) {
-		setSlot(s.readByte());
-	}
-	public void write(PacketDataSerializer s) {
-		s.writeByte(getSlot());
-	};
+    public PacketPlayOutHeldItemSlot(byte slot) {
+        this();
+        setSlot(slot);
+    }
+
+    @Override
+    public void read(PacketDataSerializer s) {
+        setSlot(s.readByte());
+    }
+
+    public void write(PacketDataSerializer s) {
+        s.writeByte(getSlot());
+    }
+
+    ;
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutKeepAlive.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutKeepAlive.java
index d6a0036..31c8ac9 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutKeepAlive.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutKeepAlive.java
@@ -3,22 +3,29 @@ package dev.wolveringer.BungeeUtil.packets;
 import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
 import dev.wolveringer.packet.PacketDataSerializer;
 
-public class PacketPlayOutKeepAlive extends Packet implements PacketPlayOut{
-	int id;
-	public PacketPlayOutKeepAlive() {
-		super(0x00);
-	}
-	@Override
-	public void read(PacketDataSerializer s) {
-		id = s.readVarInt();
-	}
-	public void write(PacketDataSerializer s) {
-		s.writeVarInt(id);
-	};
-	public int getId() {
-		return id;
-	}
-	public void setId(int id) {
-		this.id = id;
-	}
+public class PacketPlayOutKeepAlive extends Packet implements PacketPlayOut {
+    int id;
+
+    public PacketPlayOutKeepAlive() {
+        super(0x00);
+    }
+
+    @Override
+    public void read(PacketDataSerializer s) {
+        id = s.readVarInt();
+    }
+
+    public void write(PacketDataSerializer s) {
+        s.writeVarInt(id);
+    }
+
+    ;
+
+    public int getId() {
+        return id;
+    }
+
+    public void setId(int id) {
+        this.id = id;
+    }
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutNamedEntitySpawn.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutNamedEntitySpawn.java
index fcaa0f4..5e828d7 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutNamedEntitySpawn.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutNamedEntitySpawn.java
@@ -1,160 +1,156 @@
 package dev.wolveringer.BungeeUtil.packets;
 
-import java.util.Iterator;
 import java.util.UUID;
 
 import dev.wolveringer.BungeeUtil.ClientVersion.BigClientVersion;
 import dev.wolveringer.BungeeUtil.gameprofile.GameProfile;
-import dev.wolveringer.BungeeUtil.gameprofile.Property;
 import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
 import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOutEntityAbstract;
 import dev.wolveringer.api.datawatcher.DataWatcher;
 import dev.wolveringer.api.position.Location;
 import dev.wolveringer.nbt.MathHelper;
 import dev.wolveringer.packet.PacketDataSerializer;
-import dev.wolveringer.packet.PacketDataSerializer_v1_7;
-
-public class PacketPlayOutNamedEntitySpawn extends PacketPlayOutEntityAbstract implements PacketPlayOut{
-	private GameProfile p = new GameProfile(UUID.randomUUID(), ""+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"cError: 201");
-	private UUID uuid;
-	private Location loc;
-	private byte yaw; // yaw / 256*360
-	private byte pitch; // pitch / 256*360
-	private int item_id;
-	private DataWatcher data;
-
-	public PacketPlayOutNamedEntitySpawn() {
-		super(0x0C);
-	}
-
-	public PacketPlayOutNamedEntitySpawn(int id, UUID uuid, Location loc, int hand, DataWatcher w) {
-		super(0x0C);
-		setId(id);
-		this.uuid = uuid;
-		this.loc = loc;
-		this.yaw = ((byte) (int) (loc.getYaw() * 256.0F / 360.0F));
-		this.pitch = ((byte) (int) (loc.getPitch() * 256.0F / 360.0F));
-		this.item_id = hand;
-		this.data = w;
-		this.p = new GameProfile(uuid, ""+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"cError:-202");
-	}
-
-	@SuppressWarnings("deprecation")
-	public PacketPlayOutNamedEntitySpawn(int id, GameProfile profile, Location loc, int hand, DataWatcher w) {
-		super(0x0C);
-		setId(id);
-		this.p = profile;
-		if(profile == null)
-			throw new NullPointerException("Profile cant be null");
-		this.uuid = profile.getId();
-		this.loc = loc;
-		this.yaw = ((byte) (int) (loc.getYaw() * 256.0F / 360.0F));
-		this.pitch = ((byte) (int) (loc.getPitch() * 256.0F / 360.0F));
-		this.item_id = hand;
-		this.data = w;
-	}
-
-	@SuppressWarnings("deprecation")
-	public PacketPlayOutNamedEntitySpawn(int id, UUID uuid, Location loc, GameProfile g, int hand, DataWatcher w) {
-		super(0x0C);
-		setId(id);
-		this.p = g;
-		this.uuid = uuid;
-		this.loc = loc;
-		this.yaw = ((byte) (int) (loc.getYaw() * 256.0F / 360.0F));
-		this.pitch = ((byte) (int) (loc.getPitch() * 256.0F / 360.0F));
-		this.item_id = hand;
-		this.data = w;
-	}
-
-	public void read(PacketDataSerializer paramPacketDataSerializer) {
-		setId(paramPacketDataSerializer.readVarInt());
-		this.uuid = paramPacketDataSerializer.readUUID();
-		if(getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10)
-			loc = new Location(paramPacketDataSerializer.readDouble(), paramPacketDataSerializer.readDouble(), paramPacketDataSerializer.readDouble());
-		else
-			loc = new Location(paramPacketDataSerializer.readInt()/32, paramPacketDataSerializer.readInt()/32, paramPacketDataSerializer.readInt()/32);
-		this.yaw = paramPacketDataSerializer.readByte();
-		this.pitch = paramPacketDataSerializer.readByte();
-		if(getBigVersion() == BigClientVersion.v1_8)
-			this.item_id = paramPacketDataSerializer.readShort();
-		this.data = DataWatcher.createDataWatcher(getBigVersion(),paramPacketDataSerializer);
-	}
-
-	@SuppressWarnings("rawtypes")
-	public void write(PacketDataSerializer paramPacketDataSerializer) {
-		paramPacketDataSerializer.writeVarInt(getId());
-			paramPacketDataSerializer.writeUUID(this.uuid);
-		if(getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10){
-			paramPacketDataSerializer.writeDouble(loc.getX());
-			paramPacketDataSerializer.writeDouble(loc.getY());
-			paramPacketDataSerializer.writeDouble(loc.getZ());
-		}
-		else
-		{
-			paramPacketDataSerializer.writeInt((int)MathHelper.floor(loc.getX() * 32.0D));
-			paramPacketDataSerializer.writeInt((int)MathHelper.floor(loc.getY() * 32.0D));
-			paramPacketDataSerializer.writeInt((int)MathHelper.floor(loc.getZ() * 32.0D));
-		}
-		paramPacketDataSerializer.writeByte(this.yaw);
-		paramPacketDataSerializer.writeByte(this.pitch);
-		if(getBigVersion() == BigClientVersion.v1_8)
-			paramPacketDataSerializer.writeShort(this.item_id);
-		this.data.write(paramPacketDataSerializer);
-	}
-
-	public DataWatcher getData() {
-		return data;
-	}
-
-	public GameProfile getGameProfile() {
-		return p;
-	}
-
-	public void setGameProfile(GameProfile p) {
-		this.p = p;
-	}
-
-	public UUID getUuid() {
-		return uuid;
-	}
-
-	public void setUuid(UUID uuid) {
-		this.uuid = uuid;
-	}
-
-	public Location getLocation() {
-		return loc;
-	}
-	public void setLocation(Location loc) {
-		this.loc = loc;
-	}
-
-	public int getItem_id() {
-		return item_id;
-	}
-
-	public void setItem_id(int item_id) {
-		this.item_id = item_id;
-	}
-
-	public void setData(DataWatcher data) {
-		this.data = data;
-	}
-	
-	public byte getYaw() {
-		return yaw;
-	}
-
-	public void setYaw(byte yaw) {
-		this.yaw = yaw;
-	}
-
-	public byte getPitch() {
-		return pitch;
-	}
-
-	public void setPitch(byte pitch) {
-		this.pitch = pitch;
-	}
+
+public class PacketPlayOutNamedEntitySpawn extends PacketPlayOutEntityAbstract implements PacketPlayOut {
+    private GameProfile p = new GameProfile(UUID.randomUUID(), "" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "cError: 201");
+    private UUID uuid;
+    private Location loc;
+    private byte yaw; // yaw / 256*360
+    private byte pitch; // pitch / 256*360
+    private int item_id;
+    private DataWatcher data;
+
+    public PacketPlayOutNamedEntitySpawn() {
+        super(0x0C);
+    }
+
+    public PacketPlayOutNamedEntitySpawn(int id, UUID uuid, Location loc, int hand, DataWatcher w) {
+        super(0x0C);
+        setId(id);
+        this.uuid = uuid;
+        this.loc = loc;
+        this.yaw = ((byte) (int) (loc.getYaw() * 256.0F / 360.0F));
+        this.pitch = ((byte) (int) (loc.getPitch() * 256.0F / 360.0F));
+        this.item_id = hand;
+        this.data = w;
+        this.p = new GameProfile(uuid, "" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "cError:-202");
+    }
+
+    @SuppressWarnings("deprecation")
+    public PacketPlayOutNamedEntitySpawn(int id, GameProfile profile, Location loc, int hand, DataWatcher w) {
+        super(0x0C);
+        setId(id);
+        this.p = profile;
+        if (profile == null)
+            throw new NullPointerException("Profile cant be null");
+        this.uuid = profile.getId();
+        this.loc = loc;
+        this.yaw = ((byte) (int) (loc.getYaw() * 256.0F / 360.0F));
+        this.pitch = ((byte) (int) (loc.getPitch() * 256.0F / 360.0F));
+        this.item_id = hand;
+        this.data = w;
+    }
+
+    @SuppressWarnings("deprecation")
+    public PacketPlayOutNamedEntitySpawn(int id, UUID uuid, Location loc, GameProfile g, int hand, DataWatcher w) {
+        super(0x0C);
+        setId(id);
+        this.p = g;
+        this.uuid = uuid;
+        this.loc = loc;
+        this.yaw = ((byte) (int) (loc.getYaw() * 256.0F / 360.0F));
+        this.pitch = ((byte) (int) (loc.getPitch() * 256.0F / 360.0F));
+        this.item_id = hand;
+        this.data = w;
+    }
+
+    public void read(PacketDataSerializer paramPacketDataSerializer) {
+        setId(paramPacketDataSerializer.readVarInt());
+        this.uuid = paramPacketDataSerializer.readUUID();
+        if (getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10)
+            loc = new Location(paramPacketDataSerializer.readDouble(), paramPacketDataSerializer.readDouble(), paramPacketDataSerializer.readDouble());
+        else
+            loc = new Location(paramPacketDataSerializer.readInt() / 32, paramPacketDataSerializer.readInt() / 32, paramPacketDataSerializer.readInt() / 32);
+        this.yaw = paramPacketDataSerializer.readByte();
+        this.pitch = paramPacketDataSerializer.readByte();
+        if (getBigVersion() == BigClientVersion.v1_8)
+            this.item_id = paramPacketDataSerializer.readShort();
+        this.data = DataWatcher.createDataWatcher(getBigVersion(), paramPacketDataSerializer);
+    }
+
+    @SuppressWarnings("rawtypes")
+    public void write(PacketDataSerializer paramPacketDataSerializer) {
+        paramPacketDataSerializer.writeVarInt(getId());
+        paramPacketDataSerializer.writeUUID(this.uuid);
+        if (getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10) {
+            paramPacketDataSerializer.writeDouble(loc.getX());
+            paramPacketDataSerializer.writeDouble(loc.getY());
+            paramPacketDataSerializer.writeDouble(loc.getZ());
+        } else {
+            paramPacketDataSerializer.writeInt((int) MathHelper.floor(loc.getX() * 32.0D));
+            paramPacketDataSerializer.writeInt((int) MathHelper.floor(loc.getY() * 32.0D));
+            paramPacketDataSerializer.writeInt((int) MathHelper.floor(loc.getZ() * 32.0D));
+        }
+        paramPacketDataSerializer.writeByte(this.yaw);
+        paramPacketDataSerializer.writeByte(this.pitch);
+        if (getBigVersion() == BigClientVersion.v1_8)
+            paramPacketDataSerializer.writeShort(this.item_id);
+        this.data.write(paramPacketDataSerializer);
+    }
+
+    public DataWatcher getData() {
+        return data;
+    }
+
+    public void setData(DataWatcher data) {
+        this.data = data;
+    }
+
+    public GameProfile getGameProfile() {
+        return p;
+    }
+
+    public void setGameProfile(GameProfile p) {
+        this.p = p;
+    }
+
+    public UUID getUuid() {
+        return uuid;
+    }
+
+    public void setUuid(UUID uuid) {
+        this.uuid = uuid;
+    }
+
+    public Location getLocation() {
+        return loc;
+    }
+
+    public void setLocation(Location loc) {
+        this.loc = loc;
+    }
+
+    public int getItem_id() {
+        return item_id;
+    }
+
+    public void setItem_id(int item_id) {
+        this.item_id = item_id;
+    }
+
+    public byte getYaw() {
+        return yaw;
+    }
+
+    public void setYaw(byte yaw) {
+        this.yaw = yaw;
+    }
+
+    public byte getPitch() {
+        return pitch;
+    }
+
+    public void setPitch(byte pitch) {
+        this.pitch = pitch;
+    }
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutNamedSoundEffect.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutNamedSoundEffect.java
index b70f89e..0a219c7 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutNamedSoundEffect.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutNamedSoundEffect.java
@@ -1,14 +1,11 @@
 package dev.wolveringer.BungeeUtil.packets;
 
 import dev.wolveringer.BungeeUtil.ClientVersion.BigClientVersion;
-import dev.wolveringer.BungeeUtil.ClientVersion.ProtocollVersion;
 import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
 import dev.wolveringer.api.position.Location;
-import dev.wolveringer.api.sound.SoundEffect;
 import dev.wolveringer.packet.PacketDataSerializer;
 import lombok.AllArgsConstructor;
 import lombok.Builder;
-import lombok.Data;
 import lombok.Getter;
 import lombok.Setter;
 import lombok.ToString;
@@ -19,55 +16,56 @@ import lombok.ToString;
 @Builder
 @AllArgsConstructor
 @ToString
-public class PacketPlayOutNamedSoundEffect extends Packet implements PacketPlayOut{
-	private float volume;
-	private float pitch;
-	private Location loc;
-	private String sound;
-	private int soundCategory;
-	
-	public PacketPlayOutNamedSoundEffect() {}
+public class PacketPlayOutNamedSoundEffect extends Packet implements PacketPlayOut {
+    private float volume;
+    private float pitch;
+    private Location loc;
+    private String sound;
+    private int soundCategory;
 
-	@Override
-	public void read(PacketDataSerializer s) {
-		if(getBigVersion().equals(BigClientVersion.v1_10) || getBigVersion().equals(BigClientVersion.v1_9)) {
-			sound = s.readString(-1);
-			soundCategory = s.readVarInt();
-			loc = new Location(s.readInt(), s.readInt(), s.readInt()).dividide(8D);
-			volume = s.readFloat();
-			pitch = getBigVersion() == BigClientVersion.v1_10 ? s.readFloat() : s.readUnsignedByte();
-		} else if(getBigVersion() == BigClientVersion.v1_8) {
-			sound = s.readString(-1);
-			loc = new Location(s.readInt(), s.readInt(), s.readInt()).dividide(8D);
-			volume = s.readFloat();
-			pitch = s.readUnsignedByte();
-		}
-	}
-	
-	@Override
-	public void write(PacketDataSerializer s) {
-		if(getBigVersion().equals(BigClientVersion.v1_10) || getBigVersion().equals(BigClientVersion.v1_9)){
-			s.writeString(sound);
-			s.writeVarInt(soundCategory);
-			loc.multiply(8D);
-			s.writeInt(loc.getBlockX());
-			s.writeInt(loc.getBlockY());
-			s.writeInt(loc.getBlockZ());
-			loc.dividide(8D);
-			s.writeFloat(volume);
-			if(getBigVersion() == BigClientVersion.v1_10)
-				s.writeFloat(pitch);
-			else
-				s.writeByte((int) pitch);
-		} else if(getBigVersion() == BigClientVersion.v1_8){
-			s.writeString(sound);
-			loc.multiply(8D);
-			s.writeInt(loc.getBlockX());
-			s.writeInt(loc.getBlockY());
-			s.writeInt(loc.getBlockZ());
-			loc.dividide(8D);
-			s.writeFloat(volume);
-			s.writeByte((int) pitch);
-		}
-	}
+    public PacketPlayOutNamedSoundEffect() {
+    }
+
+    @Override
+    public void read(PacketDataSerializer s) {
+        if (getBigVersion().equals(BigClientVersion.v1_10) || getBigVersion().equals(BigClientVersion.v1_9)) {
+            sound = s.readString(-1);
+            soundCategory = s.readVarInt();
+            loc = new Location(s.readInt(), s.readInt(), s.readInt()).dividide(8D);
+            volume = s.readFloat();
+            pitch = getBigVersion() == BigClientVersion.v1_10 ? s.readFloat() : s.readUnsignedByte();
+        } else if (getBigVersion() == BigClientVersion.v1_8) {
+            sound = s.readString(-1);
+            loc = new Location(s.readInt(), s.readInt(), s.readInt()).dividide(8D);
+            volume = s.readFloat();
+            pitch = s.readUnsignedByte();
+        }
+    }
+
+    @Override
+    public void write(PacketDataSerializer s) {
+        if (getBigVersion().equals(BigClientVersion.v1_10) || getBigVersion().equals(BigClientVersion.v1_9)) {
+            s.writeString(sound);
+            s.writeVarInt(soundCategory);
+            loc.multiply(8D);
+            s.writeInt(loc.getBlockX());
+            s.writeInt(loc.getBlockY());
+            s.writeInt(loc.getBlockZ());
+            loc.dividide(8D);
+            s.writeFloat(volume);
+            if (getBigVersion() == BigClientVersion.v1_10)
+                s.writeFloat(pitch);
+            else
+                s.writeByte((int) pitch);
+        } else if (getBigVersion() == BigClientVersion.v1_8) {
+            s.writeString(sound);
+            loc.multiply(8D);
+            s.writeInt(loc.getBlockX());
+            s.writeInt(loc.getBlockY());
+            s.writeInt(loc.getBlockZ());
+            loc.dividide(8D);
+            s.writeFloat(volume);
+            s.writeByte((int) pitch);
+        }
+    }
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutOpenWindow.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutOpenWindow.java
index 160f713..7728dbc 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutOpenWindow.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutOpenWindow.java
@@ -1,111 +1,110 @@
 package dev.wolveringer.BungeeUtil.packets;
 
-import dev.wolveringer.BungeeUtil.ClientVersion.BigClientVersion;
 import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
 import dev.wolveringer.packet.PacketDataSerializer;
 
 public class PacketPlayOutOpenWindow extends Packet implements PacketPlayOut {
-	private int horesID;
-	private boolean horse;
-	private int id;
-	private String name;
-	private int slots;
-	private String type;
-	public boolean UTF_8 = false;
-	
-	public PacketPlayOutOpenWindow() {
-		super(0x2D);
-	}
-	
-	public PacketPlayOutOpenWindow(int id, String type, String name, int slots, boolean ishorse) {
-		super(0x2D);
-		this.id = id;
-		this.type = type + "";
-		this.name = name;
-		this.slots = slots;
-		this.horse = ishorse;
-	}
-	
-	public PacketPlayOutOpenWindow(int id, String type, String name, int slots, int horse_id) {
-		this(id, type, name, slots, true);
-		this.horesID = horse_id;
-	}
-	
-	public int getHoresID() {
-		return horesID;
-	}
-	
-	public int getId() {
-		return id;
-	}
-	
-	public String getName() {
-		return name;
-	}
-	
-	public int getSlots() {
-		return slots;
-	}
-	
-	public String getType() {
-		return type;
-	}
-	
-	public boolean isHorse() {
-		return horse;
-	}
-	
-	@Override
-	public void read(PacketDataSerializer s) {
-		this.id = s.readUnsignedByte();
-		this.type = s.readString(32);
-		this.name = s.readString(-1);
-		this.slots = s.readUnsignedByte();
-		if (type.equalsIgnoreCase("EntityHorse")) this.horesID = s.readInt();
-	}
-	
-	public void setHoresID(int horesID) {
-		this.horesID = horesID;
-	}
-	
-	public void setHorse(boolean horse) {
-		this.horse = horse;
-	}
-	
-	public void setId(int id) {
-		this.id = id;
-	}
-	
-	public void setName(String name) {
-		this.name = name;
-	}
-	
-	public void setSlots(int slots) {
-		this.slots = slots;
-	}
-	
-	public void setType(String type) {
-		this.type = type;
-	}
-	
-	@Override
-	public void write(PacketDataSerializer s) {
-		s.writeByte(this.id);
-		s.writeString(this.type);
-		if (!name.startsWith("{")) {
-			if (!name.startsWith("\"")) name = "\"" + name + "\"";
-			name = "{\"translate\":" + name + "}";
-		}
-		s.writeString(this.name);
-		s.writeByte(this.slots);
-		if (this.type.equals("EntityHorse")) {
-			s.writeInt(this.horesID);
-		}
-	}
-	
-	@Override
-	public String toString() {
-		return "PacketPlayOutOpenWindow [horesID=" + horesID + ", horse=" + horse + ", id=" + id + ", name=" + name + ", slots=" + slots + ", type=" + type + "]";
-	}
-	
+    public boolean UTF_8 = false;
+    private int horesID;
+    private boolean horse;
+    private int id;
+    private String name;
+    private int slots;
+    private String type;
+
+    public PacketPlayOutOpenWindow() {
+        super(0x2D);
+    }
+
+    public PacketPlayOutOpenWindow(int id, String type, String name, int slots, boolean ishorse) {
+        super(0x2D);
+        this.id = id;
+        this.type = type + "";
+        this.name = name;
+        this.slots = slots;
+        this.horse = ishorse;
+    }
+
+    public PacketPlayOutOpenWindow(int id, String type, String name, int slots, int horse_id) {
+        this(id, type, name, slots, true);
+        this.horesID = horse_id;
+    }
+
+    public int getHoresID() {
+        return horesID;
+    }
+
+    public void setHoresID(int horesID) {
+        this.horesID = horesID;
+    }
+
+    public int getId() {
+        return id;
+    }
+
+    public void setId(int id) {
+        this.id = id;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+
+    public int getSlots() {
+        return slots;
+    }
+
+    public void setSlots(int slots) {
+        this.slots = slots;
+    }
+
+    public String getType() {
+        return type;
+    }
+
+    public void setType(String type) {
+        this.type = type;
+    }
+
+    public boolean isHorse() {
+        return horse;
+    }
+
+    public void setHorse(boolean horse) {
+        this.horse = horse;
+    }
+
+    @Override
+    public void read(PacketDataSerializer s) {
+        this.id = s.readUnsignedByte();
+        this.type = s.readString(32);
+        this.name = s.readString(-1);
+        this.slots = s.readUnsignedByte();
+        if (type.equalsIgnoreCase("EntityHorse")) this.horesID = s.readInt();
+    }
+
+    @Override
+    public void write(PacketDataSerializer s) {
+        s.writeByte(this.id);
+        s.writeString(this.type);
+        if (!name.startsWith("{")) {
+            if (!name.startsWith("\"")) name = "\"" + name + "\"";
+            name = "{\"translate\":" + name + "}";
+        }
+        s.writeString(this.name);
+        s.writeByte(this.slots);
+        if (this.type.equals("EntityHorse")) {
+            s.writeInt(this.horesID);
+        }
+    }
+
+    @Override
+    public String toString() {
+        return "PacketPlayOutOpenWindow [horesID=" + horesID + ", horse=" + horse + ", id=" + id + ", name=" + name + ", slots=" + slots + ", type=" + type + "]";
+    }
+
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutPlayerInfo.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutPlayerInfo.java
index e32063b..2e298cd 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutPlayerInfo.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutPlayerInfo.java
@@ -1,10 +1,9 @@
 package dev.wolveringer.BungeeUtil.packets;
 
-import java.util.List;
-
 import com.google.common.collect.Lists;
 
-import dev.wolveringer.BungeeUtil.ClientVersion.BigClientVersion;
+import java.util.List;
+
 import dev.wolveringer.BungeeUtil.gameprofile.GameProfile;
 import dev.wolveringer.BungeeUtil.gameprofile.PlayerInfoData;
 import dev.wolveringer.BungeeUtil.gameprofile.Property;
@@ -14,143 +13,141 @@ import dev.wolveringer.chat.IChatBaseComponent;
 import dev.wolveringer.packet.PacketDataSerializer;
 
 public class PacketPlayOutPlayerInfo extends Packet implements PacketPlayOut {
-	
-	public static enum EnumPlayerInfoAction {
-		ADD_PLAYER,
-		UPDATE_GAMEMODE,
-		UPDATE_PING,
-		UPDATE_DISPLAY_NAME,
-		REMOVE_PLAYER;
-	}
-	
-	private EnumPlayerInfoAction action;
-	private final List<PlayerInfoData> data = Lists.newArrayList();
-	
-	public boolean profile = true;
-	
-	public PacketPlayOutPlayerInfo() {
-		super(0x38);
-	}
-	
-	public PacketPlayOutPlayerInfo(EnumPlayerInfoAction paramEnumPlayerInfoAction, PlayerInfoData... player) {
-		super(0x38);
-		this.action = paramEnumPlayerInfoAction;
-		for (PlayerInfoData localEntityPlayer : player) {
-			this.data.add(localEntityPlayer);
-		}
-	}
-	
-	public void read(PacketDataSerializer s) {
-		this.action = ((EnumPlayerInfoAction) EnumPlayerInfoAction.values()[s.readVarInt()]);
-		int profiles = s.readVarInt();
-		for (int x = 0; x < profiles; x++) {
-			GameProfile gameporfile = null;
-			int ping = 0;
-			int gamemode = 0;
-			IChatBaseComponent nickname = null;
-			switch (this.action) {
-				case ADD_PLAYER:
-					gameporfile = new GameProfile(s.readUUID(), s.readString(-1));
-					int length = s.readVarInt();
-					for (int n = 0; n < length; n++) {
-						String key = s.readString(-1);
-						String value = s.readString(-1);
-						if (s.readBoolean()) {
-							gameporfile.getProperties().put(key, new Property(key, value, s.readString(-1)));
-						}
-						else {
-							gameporfile.getProperties().put(key, new Property(key, value));
-						}
-					}
-					gamemode = s.readVarInt();
-					ping = s.readVarInt();
-					if (s.readBoolean()) {
-						nickname = ChatSerializer.fromJSON(s.readString(-1));
-					}
-					break;
-				case UPDATE_GAMEMODE:
-					gameporfile = new GameProfile(s.readUUID(), null);
-					gamemode = s.readVarInt();
-					break;
-				case UPDATE_PING:
-					gameporfile = new GameProfile(s.readUUID(), null);
-					ping = s.readVarInt();
-					break;
-				case UPDATE_DISPLAY_NAME:
-					gameporfile = new GameProfile(s.readUUID(), null);
-					if (s.readBoolean()) nickname = s.readRawString();
-					break;
-				case REMOVE_PLAYER:
-					gameporfile = new GameProfile(s.readUUID(), null);
-			}
-			this.data.add(new PlayerInfoData(gameporfile, ping, gamemode, nickname));
-		}
-	}
-	
-	@SuppressWarnings("static-access")
-	public void write(PacketDataSerializer paramPacketDataSerializer) {
-		paramPacketDataSerializer.writeVarInt(this.action.ordinal());
-		paramPacketDataSerializer.writeVarInt(this.data.size());
-		for (PlayerInfoData localPlayerInfoData : this.data) {
-			switch ((this.action.ordinal() + 1)) {
-				case 1:
-					paramPacketDataSerializer.writeUUID(localPlayerInfoData.getGameprofile().getId()); // UUID
-					paramPacketDataSerializer.writeString(localPlayerInfoData.getGameprofile().getName()); // REAL NAME
-					
-					paramPacketDataSerializer.writeVarInt(localPlayerInfoData.getGameprofile().getProperties().size()); // PROPETY-SIZE
-					for (Property localProperty : localPlayerInfoData.getGameprofile().getProperties().values()) {
-						paramPacketDataSerializer.writeString(localProperty.getName()); // PROTETY NAME
-						paramPacketDataSerializer.writeString(localProperty.getValue()); // PROTETY VALUE
-						paramPacketDataSerializer.writeBoolean(localProperty.hasSignature());
-						if (localProperty.hasSignature()) paramPacketDataSerializer.writeString(localProperty.getSignature()); // PROTETY SIGNATURE
-					}
-					
-					paramPacketDataSerializer.writeVarInt(localPlayerInfoData.getGamemode()); // PROTETY GAMEMODE
-					paramPacketDataSerializer.writeVarInt(localPlayerInfoData.getPing());
-					paramPacketDataSerializer.writeBoolean(localPlayerInfoData.getName() != null);
-					if (localPlayerInfoData.getName() != null) {
-						paramPacketDataSerializer.writeRawString(localPlayerInfoData.getName());
-					}
-					break;
-				case 2:
-					paramPacketDataSerializer.writeUUID(localPlayerInfoData.getGameprofile().getId());
-					paramPacketDataSerializer.writeVarInt(localPlayerInfoData.getGamemode());
-					break;
-				case 3:
-					paramPacketDataSerializer.writeUUID(localPlayerInfoData.getGameprofile().getId());
-					paramPacketDataSerializer.writeVarInt(localPlayerInfoData.getPing());
-					break;
-				case 4:
-					paramPacketDataSerializer.writeUUID(localPlayerInfoData.getGameprofile().getId());
-					if (localPlayerInfoData.getName() == null) {
-						paramPacketDataSerializer.writeBoolean(false);
-					}
-					else {
-						paramPacketDataSerializer.writeBoolean(true);
-						paramPacketDataSerializer.writeRawString(localPlayerInfoData.getName());
-					}
-					break;
-				case 5:
-					paramPacketDataSerializer.writeUUID(localPlayerInfoData.getGameprofile().getId());
-			}
-		}
-	}
-	
-	public EnumPlayerInfoAction getAction() {
-		return action;
-	}
-	
-	public void setAction(EnumPlayerInfoAction action) {
-		this.action = action;
-	}
-	
-	public List<PlayerInfoData> getData() {
-		return data;
-	}
-	
-	@Override
-	public String toString() {
-		return "PacketPlayOutPlayerInfo [action=" + action + ", data=" + data + "]";
-	}
-	
+
+    private final List<PlayerInfoData> data = Lists.newArrayList();
+    public boolean profile = true;
+    private EnumPlayerInfoAction action;
+
+    public PacketPlayOutPlayerInfo() {
+        super(0x38);
+    }
+
+    public PacketPlayOutPlayerInfo(EnumPlayerInfoAction paramEnumPlayerInfoAction, PlayerInfoData... player) {
+        super(0x38);
+        this.action = paramEnumPlayerInfoAction;
+        for (PlayerInfoData localEntityPlayer : player) {
+            this.data.add(localEntityPlayer);
+        }
+    }
+
+    public void read(PacketDataSerializer s) {
+        this.action = ((EnumPlayerInfoAction) EnumPlayerInfoAction.values()[s.readVarInt()]);
+        int profiles = s.readVarInt();
+        for (int x = 0; x < profiles; x++) {
+            GameProfile gameporfile = null;
+            int ping = 0;
+            int gamemode = 0;
+            IChatBaseComponent nickname = null;
+            switch (this.action) {
+                case ADD_PLAYER:
+                    gameporfile = new GameProfile(s.readUUID(), s.readString(-1));
+                    int length = s.readVarInt();
+                    for (int n = 0; n < length; n++) {
+                        String key = s.readString(-1);
+                        String value = s.readString(-1);
+                        if (s.readBoolean()) {
+                            gameporfile.getProperties().put(key, new Property(key, value, s.readString(-1)));
+                        } else {
+                            gameporfile.getProperties().put(key, new Property(key, value));
+                        }
+                    }
+                    gamemode = s.readVarInt();
+                    ping = s.readVarInt();
+                    if (s.readBoolean()) {
+                        nickname = ChatSerializer.fromJSON(s.readString(-1));
+                    }
+                    break;
+                case UPDATE_GAMEMODE:
+                    gameporfile = new GameProfile(s.readUUID(), null);
+                    gamemode = s.readVarInt();
+                    break;
+                case UPDATE_PING:
+                    gameporfile = new GameProfile(s.readUUID(), null);
+                    ping = s.readVarInt();
+                    break;
+                case UPDATE_DISPLAY_NAME:
+                    gameporfile = new GameProfile(s.readUUID(), null);
+                    if (s.readBoolean()) nickname = s.readRawString();
+                    break;
+                case REMOVE_PLAYER:
+                    gameporfile = new GameProfile(s.readUUID(), null);
+            }
+            this.data.add(new PlayerInfoData(gameporfile, ping, gamemode, nickname));
+        }
+    }
+
+    @SuppressWarnings("static-access")
+    public void write(PacketDataSerializer paramPacketDataSerializer) {
+        paramPacketDataSerializer.writeVarInt(this.action.ordinal());
+        paramPacketDataSerializer.writeVarInt(this.data.size());
+        for (PlayerInfoData localPlayerInfoData : this.data) {
+            switch ((this.action.ordinal() + 1)) {
+                case 1:
+                    paramPacketDataSerializer.writeUUID(localPlayerInfoData.getGameprofile().getId()); // UUID
+                    paramPacketDataSerializer.writeString(localPlayerInfoData.getGameprofile().getName()); // REAL NAME
+
+                    paramPacketDataSerializer.writeVarInt(localPlayerInfoData.getGameprofile().getProperties().size()); // PROPETY-SIZE
+                    for (Property localProperty : localPlayerInfoData.getGameprofile().getProperties().values()) {
+                        paramPacketDataSerializer.writeString(localProperty.getName()); // PROTETY NAME
+                        paramPacketDataSerializer.writeString(localProperty.getValue()); // PROTETY VALUE
+                        paramPacketDataSerializer.writeBoolean(localProperty.hasSignature());
+                        if (localProperty.hasSignature())
+                            paramPacketDataSerializer.writeString(localProperty.getSignature()); // PROTETY SIGNATURE
+                    }
+
+                    paramPacketDataSerializer.writeVarInt(localPlayerInfoData.getGamemode()); // PROTETY GAMEMODE
+                    paramPacketDataSerializer.writeVarInt(localPlayerInfoData.getPing());
+                    paramPacketDataSerializer.writeBoolean(localPlayerInfoData.getName() != null);
+                    if (localPlayerInfoData.getName() != null) {
+                        paramPacketDataSerializer.writeRawString(localPlayerInfoData.getName());
+                    }
+                    break;
+                case 2:
+                    paramPacketDataSerializer.writeUUID(localPlayerInfoData.getGameprofile().getId());
+                    paramPacketDataSerializer.writeVarInt(localPlayerInfoData.getGamemode());
+                    break;
+                case 3:
+                    paramPacketDataSerializer.writeUUID(localPlayerInfoData.getGameprofile().getId());
+                    paramPacketDataSerializer.writeVarInt(localPlayerInfoData.getPing());
+                    break;
+                case 4:
+                    paramPacketDataSerializer.writeUUID(localPlayerInfoData.getGameprofile().getId());
+                    if (localPlayerInfoData.getName() == null) {
+                        paramPacketDataSerializer.writeBoolean(false);
+                    } else {
+                        paramPacketDataSerializer.writeBoolean(true);
+                        paramPacketDataSerializer.writeRawString(localPlayerInfoData.getName());
+                    }
+                    break;
+                case 5:
+                    paramPacketDataSerializer.writeUUID(localPlayerInfoData.getGameprofile().getId());
+            }
+        }
+    }
+
+    public EnumPlayerInfoAction getAction() {
+        return action;
+    }
+
+    public void setAction(EnumPlayerInfoAction action) {
+        this.action = action;
+    }
+
+    public List<PlayerInfoData> getData() {
+        return data;
+    }
+
+    @Override
+    public String toString() {
+        return "PacketPlayOutPlayerInfo [action=" + action + ", data=" + data + "]";
+    }
+
+    public static enum EnumPlayerInfoAction {
+        ADD_PLAYER,
+        UPDATE_GAMEMODE,
+        UPDATE_PING,
+        UPDATE_DISPLAY_NAME,
+        REMOVE_PLAYER;
+    }
+
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutPlayerListHeaderFooter.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutPlayerListHeaderFooter.java
index 35f8934..700ba04 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutPlayerListHeaderFooter.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutPlayerListHeaderFooter.java
@@ -7,46 +7,47 @@ import dev.wolveringer.packet.PacketDataSerializer;
 import dev.wolveringer.util.ByteString;
 
 public class PacketPlayOutPlayerListHeaderFooter extends Packet implements PacketPlayOut {
-	private ByteString header;
-	private ByteString footer;
-
-	public PacketPlayOutPlayerListHeaderFooter() {
-	}
-	
-	public PacketPlayOutPlayerListHeaderFooter(String header,String footer) {
-		setHeader(ChatSerializer.fromMessage(header));
-		setFooter(ChatSerializer.fromMessage(footer));
-	}
-	public PacketPlayOutPlayerListHeaderFooter(IChatBaseComponent header,IChatBaseComponent footer) {
-		setHeader(header);
-		setFooter(footer);
-	}
-
-	@Override
-	public void read(PacketDataSerializer s) {
-		header = s.readStringBytes();
-		footer = s.readStringBytes();
-	}
-
-	@Override
-	public void write(PacketDataSerializer s) {
-		s.writeStringBytes(header);
-		s.writeStringBytes(footer);
-	}
-
-	public IChatBaseComponent getHeader() {
-		return ChatSerializer.fromJSON(header.getString());
-	}
-
-	public IChatBaseComponent getFooter() {
-		return ChatSerializer.fromJSON(footer.getString());
-	}
-
-	public void setHeader(IChatBaseComponent header) {
-		this.header = new ByteString(ChatSerializer.toJSONString(header));
-	}
-
-	public void setFooter(IChatBaseComponent footer) {
-		this.footer = new ByteString(ChatSerializer.toJSONString(footer));
-	}
+    private ByteString header;
+    private ByteString footer;
+
+    public PacketPlayOutPlayerListHeaderFooter() {
+    }
+
+    public PacketPlayOutPlayerListHeaderFooter(String header, String footer) {
+        setHeader(ChatSerializer.fromMessage(header));
+        setFooter(ChatSerializer.fromMessage(footer));
+    }
+
+    public PacketPlayOutPlayerListHeaderFooter(IChatBaseComponent header, IChatBaseComponent footer) {
+        setHeader(header);
+        setFooter(footer);
+    }
+
+    @Override
+    public void read(PacketDataSerializer s) {
+        header = s.readStringBytes();
+        footer = s.readStringBytes();
+    }
+
+    @Override
+    public void write(PacketDataSerializer s) {
+        s.writeStringBytes(header);
+        s.writeStringBytes(footer);
+    }
+
+    public IChatBaseComponent getHeader() {
+        return ChatSerializer.fromJSON(header.getString());
+    }
+
+    public void setHeader(IChatBaseComponent header) {
+        this.header = new ByteString(ChatSerializer.toJSONString(header));
+    }
+
+    public IChatBaseComponent getFooter() {
+        return ChatSerializer.fromJSON(footer.getString());
+    }
+
+    public void setFooter(IChatBaseComponent footer) {
+        this.footer = new ByteString(ChatSerializer.toJSONString(footer));
+    }
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutPluginMessage.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutPluginMessage.java
index 3cfa4ec..4747502 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutPluginMessage.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutPluginMessage.java
@@ -2,81 +2,83 @@ package dev.wolveringer.BungeeUtil.packets;
 
 import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayIn;
 import dev.wolveringer.packet.PacketDataSerializer;
-import lombok.NoArgsConstructor;
-import org.jsoup.helper.Validate;
-
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufInputStream;
 import io.netty.buffer.ByteBufOutputStream;
-import io.netty.buffer.Unpooled;
+import lombok.NoArgsConstructor;
 
 @SuppressWarnings("Duplicates")
 @NoArgsConstructor
-public class PacketPlayOutPluginMessage extends Packet implements PacketPlayIn{
-	private String channel;
-	private ByteBuf data;
-	private ByteBufOutputStream os;
-	private ByteBufInputStream is;
+public class PacketPlayOutPluginMessage extends Packet implements PacketPlayIn {
+    private String channel;
+    private ByteBuf data;
+    private ByteBufOutputStream os;
+    private ByteBufInputStream is;
 //	private int length = -1;
-	
-	@Override
-	public void read(PacketDataSerializer s) {
-		int readerIndex = s.readerIndex();
-		try{
-			channel = s.readString(-1);
-			readerIndex = s.readerIndex();
-			if(s.readableBytes() + s.readerIndex() != s.writerIndex()){
-				System.out.println("Incorrect length: "+(s.readableBytes() + s.readerIndex()+" - "+s.writerIndex()));
-			}
-		}catch(Exception e){
-			channel = null;
-			e.printStackTrace();
-			s.readerIndex(readerIndex);
-		}
+
+    @Override
+    public void read(PacketDataSerializer s) {
+        int readerIndex = s.readerIndex();
+        try {
+            channel = s.readString(-1);
+            readerIndex = s.readerIndex();
+            if (s.readableBytes() + s.readerIndex() != s.writerIndex()) {
+                System.out.println("Incorrect length: " + (s.readableBytes() + s.readerIndex() + " - " + s.writerIndex()));
+            }
+        } catch (Exception e) {
+            channel = null;
+            e.printStackTrace();
+            s.readerIndex(readerIndex);
+        }
 //		length = s.readableBytes();
-		data = s.readBytes(s.readableBytes());
+        data = s.readBytes(s.readableBytes());
 //		data = Unpooled.buffer(length);
 //		s.readBytes(data, length);
-	}
+    }
+
+    @Override
+    public void write(PacketDataSerializer s) {
+        if (channel != null)
+            s.writeString(channel);
+        try {
+            data.readerIndex(0);
+            int length = data.readableBytes();
+            s.ensureWritable(length, true);
+            s.writeBytes(data, length);
+            data.release();
+        } catch (Exception e) {
+            System.out.println("out - Buffer: " + data + " - ");
+            throw e;
+        }
+    }
+
+    public String getChannel() {
+        return channel;
+    }
+
+    public void setChannel(String channel) {
+        this.channel = channel;
+    }
+
+    public ByteBufInputStream getCopiedByteBufInputStream() {
+        return new ByteBufInputStream(data.copy());
+    }
+
+    public ByteBufInputStream getByteBufInputStream() {
+        if (is == null)
+            is = new ByteBufInputStream(data);
+        return is;
+    }
+
+    public ByteBufOutputStream getByteBufOutputStream() {
+        if (os == null)
+            os = new ByteBufOutputStream(data);
+        return os;
+    }
 
-	@Override
-	public void write(PacketDataSerializer s) {
-		if(channel != null)
-			s.writeString(channel);
-		try{
-			data.readerIndex(0);
-			int length = data.readableBytes();
-			s.ensureWritable(length, true);
-			s.writeBytes(data, length);
-			data.release();
-		}catch(Exception e){
-			System.out.println("out - Buffer: "+data+" - ");
-			throw e;
-		}
-	}
-	
-	public String getChannel() {
-		return channel;
-	}
-	public void setChannel(String channel) {
-		this.channel = channel;
-	}
-	public ByteBufInputStream getCopiedByteBufInputStream(){
-		return new ByteBufInputStream(data.copy());
-	}
-	public ByteBufInputStream getByteBufInputStream(){
-		if(is == null)
-			is = new ByteBufInputStream(data);
-		return is;
-	}
-	public ByteBufOutputStream getByteBufOutputStream(){
-		if(os == null)
-			os = new ByteBufOutputStream(data);
-		return os;
-	}
-	public void setData(ByteBuf data) {
-		this.data = data;
-		this.os = null;
-		this.is = null;
-	}
+    public void setData(ByteBuf data) {
+        this.data = data;
+        this.os = null;
+        this.is = null;
+    }
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutPosition.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutPosition.java
index 07ae819..adae221 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutPosition.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutPosition.java
@@ -4,67 +4,69 @@ import dev.wolveringer.BungeeUtil.ClientVersion.BigClientVersion;
 import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
 import dev.wolveringer.api.position.Location;
 import dev.wolveringer.packet.PacketDataSerializer;
-public class PacketPlayOutPosition extends Packet implements PacketPlayOut{
-	private boolean ground;
-	private Location loc;
-	private byte flag;
-	private int teleportId;
-	
-	public PacketPlayOutPosition() {
-		super((byte) 0x08);
-	}
 
-	public PacketPlayOutPosition(Location loc, boolean b) {
-		super((byte) 0x08);
-		this.loc = loc;
-		this.ground = b;
-	}
+public class PacketPlayOutPosition extends Packet implements PacketPlayOut {
+    private boolean ground;
+    private Location loc;
+    private byte flag;
+    private int teleportId;
 
-	public Location getLocation() {
-		return loc;
-	}
+    public PacketPlayOutPosition() {
+        super((byte) 0x08);
+    }
 
-	public byte getFlag() {
-		return flag;
-	}
+    public PacketPlayOutPosition(Location loc, boolean b) {
+        super((byte) 0x08);
+        this.loc = loc;
+        this.ground = b;
+    }
 
-	public void setFlag(byte flag) {
-		this.flag = flag;
-	}
+    public Location getLocation() {
+        return loc;
+    }
 
-	public int getTeleportId() {
-		return teleportId;
-	}
-	public void setTeleportId(int teleportId) {
-		this.teleportId = teleportId;
-	}
-	
-	@Override
-	public void read(PacketDataSerializer s) {
-		loc = new Location(s.readDouble(), s.readDouble(), s.readDouble(), s.readFloat(), s.readFloat());
-		flag = (byte) s.readUnsignedByte();
-		if(getVersion().getBigVersion() == BigClientVersion.v1_9  || getBigVersion() == BigClientVersion.v1_10)
-			teleportId = s.readVarInt();
-	}
+    public void setLocation(Location loc) {
+        this.loc = loc;
+    }
 
-	public void setLocation(Location loc) {
-		this.loc = loc;
-	}
+    public byte getFlag() {
+        return flag;
+    }
 
-	@Override
-	public void write(PacketDataSerializer s) {
-		s.writeDouble(loc.getX());
-		s.writeDouble(loc.getY());
-		s.writeDouble(loc.getZ());
-		s.writeFloat(loc.getYaw());
-		s.writeFloat(loc.getPitch());
-		s.writeByte(flag);
-		if(getVersion().getBigVersion() == BigClientVersion.v1_9  || getBigVersion() == BigClientVersion.v1_10)
-			s.writeVarInt(teleportId);
-	}
+    public void setFlag(byte flag) {
+        this.flag = flag;
+    }
 
-	@Override
-	public String toString() {
-		return "PacketPlayOutPosition [ground=" + ground + ", loc=" + loc + ", flag=" + flag + ", teleportId=" + teleportId + "]";
-	}
+    public int getTeleportId() {
+        return teleportId;
+    }
+
+    public void setTeleportId(int teleportId) {
+        this.teleportId = teleportId;
+    }
+
+    @Override
+    public void read(PacketDataSerializer s) {
+        loc = new Location(s.readDouble(), s.readDouble(), s.readDouble(), s.readFloat(), s.readFloat());
+        flag = (byte) s.readUnsignedByte();
+        if (getVersion().getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10)
+            teleportId = s.readVarInt();
+    }
+
+    @Override
+    public void write(PacketDataSerializer s) {
+        s.writeDouble(loc.getX());
+        s.writeDouble(loc.getY());
+        s.writeDouble(loc.getZ());
+        s.writeFloat(loc.getYaw());
+        s.writeFloat(loc.getPitch());
+        s.writeByte(flag);
+        if (getVersion().getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10)
+            s.writeVarInt(teleportId);
+    }
+
+    @Override
+    public String toString() {
+        return "PacketPlayOutPosition [ground=" + ground + ", loc=" + loc + ", flag=" + flag + ", teleportId=" + teleportId + "]";
+    }
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutRemoveEntityEffect.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutRemoveEntityEffect.java
index 926b265..fac0b67 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutRemoveEntityEffect.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutRemoveEntityEffect.java
@@ -1,50 +1,49 @@
 package dev.wolveringer.BungeeUtil.packets;
 
-import dev.wolveringer.BungeeUtil.ClientVersion.BigClientVersion;
 import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
 import dev.wolveringer.packet.PacketDataSerializer;
 
 public class PacketPlayOutRemoveEntityEffect extends Packet implements PacketPlayOut {
-	
-	int entity;
-	int effect;
-	
-	public PacketPlayOutRemoveEntityEffect(int entity, int effect) {
-		super(0x1E);
-		this.entity = entity;
-		this.effect = effect;
-	}
-	
-	public PacketPlayOutRemoveEntityEffect() {
-		super(0x1E);
-	}
-	
-	@Override
-	public void read(PacketDataSerializer s) {
-		entity = s.readVarInt();
-		effect = s.readUnsignedByte();
-	}
-	
-	@Override
-	public void write(PacketDataSerializer s) {
-		s.writeVarInt(entity);
-		s.writeByte(effect);
-	}
-	
-	public int getEntity() {
-		return entity;
-	}
-	
-	public void setEntity(int entity) {
-		this.entity = entity;
-	}
-	
-	public int getEffect() {
-		return effect;
-	}
-	
-	public void setEffect(int effect) {
-		this.effect = effect;
-	}
-	
+
+    int entity;
+    int effect;
+
+    public PacketPlayOutRemoveEntityEffect(int entity, int effect) {
+        super(0x1E);
+        this.entity = entity;
+        this.effect = effect;
+    }
+
+    public PacketPlayOutRemoveEntityEffect() {
+        super(0x1E);
+    }
+
+    @Override
+    public void read(PacketDataSerializer s) {
+        entity = s.readVarInt();
+        effect = s.readUnsignedByte();
+    }
+
+    @Override
+    public void write(PacketDataSerializer s) {
+        s.writeVarInt(entity);
+        s.writeByte(effect);
+    }
+
+    public int getEntity() {
+        return entity;
+    }
+
+    public void setEntity(int entity) {
+        this.entity = entity;
+    }
+
+    public int getEffect() {
+        return effect;
+    }
+
+    public void setEffect(int effect) {
+        this.effect = effect;
+    }
+
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutScoreboardDisplayObjective.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutScoreboardDisplayObjective.java
index c263798..74942a8 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutScoreboardDisplayObjective.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutScoreboardDisplayObjective.java
@@ -3,54 +3,60 @@ package dev.wolveringer.BungeeUtil.packets;
 import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
 import dev.wolveringer.packet.PacketDataSerializer;
 
-public class PacketPlayOutScoreboardDisplayObjective extends Packet implements PacketPlayOut{
-	public static enum Position {
-		LIST(0),
-		SIDEBAR(1),
-		BELOW_NAME(2);
-		
-		private int i;
-		private Position(int i) {
-			this.i = i;
-		}
-		public static Position getPosition(int i){
-			for(Position p : values())
-				if(p.i == i)
-					return p;
-			return null;
-		}
-		public int getInt(){
-			return i;
-		}
-	}
-	String name;
-	Position p;
-	
-	public PacketPlayOutScoreboardDisplayObjective() {
-		super(0x3D);
-	}
-	
-	public PacketPlayOutScoreboardDisplayObjective(String name,Position p) {
-		this();
-		this.name = name;
-		this.p = p;
-	}
-	
-	@Override
-	public void read(PacketDataSerializer s) {
-		p = Position.getPosition(s.readByte());
-		name = s.readString(-1);
-	}
-	@Override
-	public void write(PacketDataSerializer s) {
-		s.writeByte(p.i);
-		s.writeString(name);
-	}
-	
-	public String getName() {
-		return this.name;
-	}
-	public Position getPosition() {
-		return this.p;
-	}
+public class PacketPlayOutScoreboardDisplayObjective extends Packet implements PacketPlayOut {
+    String name;
+    Position p;
+
+    public PacketPlayOutScoreboardDisplayObjective() {
+        super(0x3D);
+    }
+
+    public PacketPlayOutScoreboardDisplayObjective(String name, Position p) {
+        this();
+        this.name = name;
+        this.p = p;
+    }
+
+    @Override
+    public void read(PacketDataSerializer s) {
+        p = Position.getPosition(s.readByte());
+        name = s.readString(-1);
+    }
+
+    @Override
+    public void write(PacketDataSerializer s) {
+        s.writeByte(p.i);
+        s.writeString(name);
+    }
+
+    public String getName() {
+        return this.name;
+    }
+
+    public Position getPosition() {
+        return this.p;
+    }
+
+    public static enum Position {
+        LIST(0),
+        SIDEBAR(1),
+        BELOW_NAME(2);
+
+        private int i;
+
+        private Position(int i) {
+            this.i = i;
+        }
+
+        public static Position getPosition(int i) {
+            for (Position p : values())
+                if (p.i == i)
+                    return p;
+            return null;
+        }
+
+        public int getInt() {
+            return i;
+        }
+    }
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutScoreboardObjective.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutScoreboardObjective.java
index 667c23d..38a3729 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutScoreboardObjective.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutScoreboardObjective.java
@@ -1,114 +1,113 @@
 package dev.wolveringer.BungeeUtil.packets;
 
-import dev.wolveringer.BungeeUtil.ClientVersion.BigClientVersion;
 import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
 import dev.wolveringer.packet.PacketDataSerializer;
 
 public class PacketPlayOutScoreboardObjective extends Packet implements PacketPlayOut {
-	
-	public static enum Action {
-		CREATE(0), REMOVE(1), UPDATE(2);
-		
-		int i;
-		
-		private Action(int i) {
-			this.i = i;
-		}
-		
-		public static Action fromInt(int i) {
-			for (Action a : values())
-				if (a.i == i) return a;
-			return null;
-		}
-	}
-	
-	public static enum Type {
-		INTEGER("integer"), HEARTS("hearts");
-		
-		private String s;
-		
-		private Type(String s) {
-			this.s = s;
-		}
-		
-		public static Type fromString(String s) {
-			for (Type t : values())
-				if (t.s.equalsIgnoreCase(s)) return t;
-			return null;
-		}
-		
-		public String getIdentifire() {
-			return s;
-		}
-	}
-	
-	public PacketPlayOutScoreboardObjective(String scorebordName, Action action, String displayName, Type type) {
-		this();
-		this.scorebordName = scorebordName;
-		this.action = action;
-		this.displayName = displayName;
-		this.type = type;
-	}
-	
-	public PacketPlayOutScoreboardObjective() {
-		super(0x3B);
-	}
-	
-	String scorebordName;
-	Action action;
-	String displayName = "";
-	Type type = Type.INTEGER;
-	
-	@Override
-	public void read(PacketDataSerializer s) {
-		scorebordName = s.readString(-1);
-		action = Action.fromInt(s.readByte());
-		if (action.i != 1) {
-			displayName = s.readString(-1);
-			type = Type.fromString(s.readString(-1));
-		}
-	}
-	
-	@Override
-	public void write(PacketDataSerializer s) {
-		s.writeString(scorebordName);
-		s.writeByte(action.i);
-		if (action.i != 1) {
-			s.writeString(displayName);
-			s.writeString(type.getIdentifire());
-		}
-	}
-	
-	public String getScorebordName() {
-		return scorebordName;
-	}
-	
-	public void setScorebordName(String scorebordName) {
-		this.scorebordName = scorebordName;
-	}
-	
-	public Action getAction() {
-		return action;
-	}
-	
-	public void setAction(Action a) {
-		this.action = a;
-	}
-	
-	public String getDisplayName() {
-		return displayName;
-	}
-	
-	public void setDisplayName(String displayName) {
-		this.displayName = displayName;
-	}
-	
-	public Type getType() {
-		return type;
-	}
-	
-	public void setType(Type type) {
-		this.type = type;
-	}
-	
+
+    String scorebordName;
+    Action action;
+    String displayName = "";
+    Type type = Type.INTEGER;
+
+    public PacketPlayOutScoreboardObjective(String scorebordName, Action action, String displayName, Type type) {
+        this();
+        this.scorebordName = scorebordName;
+        this.action = action;
+        this.displayName = displayName;
+        this.type = type;
+    }
+
+    public PacketPlayOutScoreboardObjective() {
+        super(0x3B);
+    }
+
+    @Override
+    public void read(PacketDataSerializer s) {
+        scorebordName = s.readString(-1);
+        action = Action.fromInt(s.readByte());
+        if (action.i != 1) {
+            displayName = s.readString(-1);
+            type = Type.fromString(s.readString(-1));
+        }
+    }
+
+    @Override
+    public void write(PacketDataSerializer s) {
+        s.writeString(scorebordName);
+        s.writeByte(action.i);
+        if (action.i != 1) {
+            s.writeString(displayName);
+            s.writeString(type.getIdentifire());
+        }
+    }
+
+    public String getScorebordName() {
+        return scorebordName;
+    }
+
+    public void setScorebordName(String scorebordName) {
+        this.scorebordName = scorebordName;
+    }
+
+    public Action getAction() {
+        return action;
+    }
+
+    public void setAction(Action a) {
+        this.action = a;
+    }
+
+    public String getDisplayName() {
+        return displayName;
+    }
+
+    public void setDisplayName(String displayName) {
+        this.displayName = displayName;
+    }
+
+    public Type getType() {
+        return type;
+    }
+
+    public void setType(Type type) {
+        this.type = type;
+    }
+
+    public static enum Action {
+        CREATE(0), REMOVE(1), UPDATE(2);
+
+        int i;
+
+        private Action(int i) {
+            this.i = i;
+        }
+
+        public static Action fromInt(int i) {
+            for (Action a : values())
+                if (a.i == i) return a;
+            return null;
+        }
+    }
+
+    public static enum Type {
+        INTEGER("integer"), HEARTS("hearts");
+
+        private String s;
+
+        private Type(String s) {
+            this.s = s;
+        }
+
+        public static Type fromString(String s) {
+            for (Type t : values())
+                if (t.s.equalsIgnoreCase(s)) return t;
+            return null;
+        }
+
+        public String getIdentifire() {
+            return s;
+        }
+    }
+
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutScoreboardScore.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutScoreboardScore.java
index 2254e0c..c3fdda0 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutScoreboardScore.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutScoreboardScore.java
@@ -1,94 +1,93 @@
 package dev.wolveringer.BungeeUtil.packets;
 
-import dev.wolveringer.BungeeUtil.ClientVersion.BigClientVersion;
 import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
 import dev.wolveringer.packet.PacketDataSerializer;
 
-public class PacketPlayOutScoreboardScore extends Packet implements PacketPlayOut{
-
-	public static enum Action {
-		CREATE(0),
-		REMOVE(1),
-		UPDATE(0);
-		
-		int i;
-		private Action(int i) {
-			this.i = i;
-		}
-		
-		public static Action fromInt(int i){
-			for(Action a : values())
-				if(a.i == i)
-					return a;
-			return null;
-		}
-	}
-	
-	
-	public PacketPlayOutScoreboardScore(String name, String obj_name, int value, Action action) {
-		this();
-		this.name = name;
-		this.string_name = obj_name;
-		this.value = value;
-		this.action = action;
-	}
-
-	public PacketPlayOutScoreboardScore() {
-		super(0x3C);
-	}
-	
-	String name;
-	String string_name;
-	int value;
-	Action action;
-	
-	@Override
-	public void read(PacketDataSerializer s) {
-		name = s.readString(-1);
-		action = Action.fromInt(s.readByte());
-		string_name = s.readString(-1);
-		if(action.i == 0) value = PacketDataSerializer.readVarInt(s);
-	}
-
-	@Override
-	public void write(PacketDataSerializer s) {
-		s.writeString(name);
-		s.writeByte(action.i);
-		s.writeString(string_name);
-		if(action.i == 0) PacketDataSerializer.writeVarInt(value, s);
-		
-	}
-
-	public String getObjektiveName() {
-		return name;
-	}
-
-	public void setObjektiveName(String name) {
-		this.name = name;
-	}
-
-	public String getScoreName() {
-		return string_name;
-	}
-
-	public void setScoreName(String obj_name) {
-		this.string_name = obj_name;
-	}
-
-	public int getValue() {
-		return value;
-	}
-
-	public void setValue(int value) {
-		this.value = value;
-	}
-
-	public Action getAction() {
-		return action;
-	}
-
-	public void setAction(Action action) {
-		this.action = action;
-	}
-	
+public class PacketPlayOutScoreboardScore extends Packet implements PacketPlayOut {
+
+    String name;
+    String string_name;
+    int value;
+    Action action;
+
+    public PacketPlayOutScoreboardScore(String name, String obj_name, int value, Action action) {
+        this();
+        this.name = name;
+        this.string_name = obj_name;
+        this.value = value;
+        this.action = action;
+    }
+
+    public PacketPlayOutScoreboardScore() {
+        super(0x3C);
+    }
+
+    @Override
+    public void read(PacketDataSerializer s) {
+        name = s.readString(-1);
+        action = Action.fromInt(s.readByte());
+        string_name = s.readString(-1);
+        if (action.i == 0) value = PacketDataSerializer.readVarInt(s);
+    }
+
+    @Override
+    public void write(PacketDataSerializer s) {
+        s.writeString(name);
+        s.writeByte(action.i);
+        s.writeString(string_name);
+        if (action.i == 0) PacketDataSerializer.writeVarInt(value, s);
+
+    }
+
+    public String getObjektiveName() {
+        return name;
+    }
+
+    public void setObjektiveName(String name) {
+        this.name = name;
+    }
+
+    public String getScoreName() {
+        return string_name;
+    }
+
+    public void setScoreName(String obj_name) {
+        this.string_name = obj_name;
+    }
+
+    public int getValue() {
+        return value;
+    }
+
+    public void setValue(int value) {
+        this.value = value;
+    }
+
+    public Action getAction() {
+        return action;
+    }
+
+    public void setAction(Action action) {
+        this.action = action;
+    }
+
+    public static enum Action {
+        CREATE(0),
+        REMOVE(1),
+        UPDATE(0);
+
+        int i;
+
+        private Action(int i) {
+            this.i = i;
+        }
+
+        public static Action fromInt(int i) {
+            for (Action a : values())
+                if (a.i == i)
+                    return a;
+            return null;
+        }
+    }
+
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutScoreboardTeam.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutScoreboardTeam.java
index b312ee8..fb7eb7b 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutScoreboardTeam.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutScoreboardTeam.java
@@ -1,219 +1,221 @@
 package dev.wolveringer.BungeeUtil.packets;
 
-import java.util.Arrays;
-
 import net.md_5.bungee.api.ChatColor;
 import net.md_5.bungee.protocol.packet.Team;
+
+import java.util.Arrays;
+
 import dev.wolveringer.BungeeUtil.ClientVersion.BigClientVersion;
 import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
 import dev.wolveringer.packet.PacketDataSerializer;
 
 public class PacketPlayOutScoreboardTeam extends Packet implements PacketPlayOut {
-	public static enum Action {
-		CREATE(0), REMOVE(1), UPDATE(2), PLAYER_ADD(3), PLAYER_REMOVE(4);
-		
-		private int b;
-		
-		private Action(int b) {
-			this.b = b;
-		}
-		
-		public int getAction() {
-			return b;
-		}
-		
-		public static Action fromInt(int x) {
-			for (Action a : values())
-				if (a.getAction() == x) return a;
-			return null;
-		}
-	}
-	
-	public static enum NameTag {
-		VISIABLE("always"), INVISIABLE("never"), TEAM_VISIABLE("hideForOtherTeams"), OTHER_VISIABLE("hideForOwnTeam");
-		
-		private String s;
-		
-		private NameTag(String s) {
-			this.s = s;
-		}
-		
-		public static NameTag fromString(String s) {
-			for (NameTag t : values())
-				if (t.s.equalsIgnoreCase(s)) return t;
-			return null;
-		}
-		
-		public String getIdentifire() {
-			return s;
-		}
-	}
-	
-	String team;
-	Action action;
-	
-	String collisionRule = "always";
-	String displayName;
-	String prefix;
-	String suffix;
-	NameTag tag = NameTag.VISIABLE;
-	int color = -1;
-	int friendly_fire = 0;
-	String[] player;
-	
-	public PacketPlayOutScoreboardTeam() {
-		super(0x3E);
-	}
-	
-	public PacketPlayOutScoreboardTeam(Team t) {
-		super(0x3E);
-		action = Action.fromInt(t.getMode());
-		team = t.getName();
-		displayName = t.getDisplayName();
-		prefix = t.getPrefix();
-		suffix = t.getSuffix();
-		tag = NameTag.fromString(t.getNameTagVisibility());
-		color = t.getColor();
-		friendly_fire = t.getFriendlyFire();
-		player = t.getPlayers();
-	}
-	
-	public PacketPlayOutScoreboardTeam(dev.wolveringer.api.scoreboard.Team team) {
-		super(0x3E);
-		this.team = team.getName();
-		this.displayName = team.getDisplayName();
-		this.prefix = team.getPrefix();
-		this.suffix = team.getSuffix();
-		this.tag = team.getTagVisibility();
-		this.color = team.getColor().ordinal();
-		this.friendly_fire = team.getFriendlyFire();
-		this.player = team.getMember().toArray(new String[0]);
-	}
-	
-	@Override
-	public void write(PacketDataSerializer s) {
-		s.writeString(team);
-		s.writeByte(action.getAction());
-		if (action.getAction() == 0 || action.getAction() == 2) {
-			s.writeString(displayName);
-			s.writeString(prefix);
-			s.writeString(suffix);
-			s.writeByte(friendly_fire);
-			if (tag == null) tag = NameTag.VISIABLE;
-			s.writeString(tag.getIdentifire());
-			if (getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10) s.writeString(collisionRule);
-			s.writeByte(color);
-		}
-		if (action.getAction() == 0 || action.getAction() == 3 || action.getAction() == 4) {
-			s.writeVarInt(player.length);
-			for (String x : player)
-				s.writeString(x);
-		}
-	}
-	
-	public void read(PacketDataSerializer s) {
-		team = s.readString(16);
-		action = Action.fromInt(s.readByte());
-		if (action.getAction() == 0 || action.getAction() == 2) {
-			displayName = s.readString(32);
-			prefix = s.readString(16);
-			suffix = s.readString(16);
-			friendly_fire = s.readByte();
-			tag = NameTag.fromString(s.readString(32));
-			if (getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10) collisionRule = s.readString(-1);
-			color = s.readByte();
-		}
-		if (action.getAction() == 0 || action.getAction() == 3 || action.getAction() == 4) {
-			int i = PacketDataSerializer.readVarInt(s);
-			player = new String[i];
-			for (int x = 0; x < i; x++)
-				player[x] = s.readString(40);
-		}
-		
-	}
-	
-	@Override
-	public String toString() {
-		return "PacketPlayOutScoreboardTeam [team=" + team + ", action=" + action + ", displayName=" + displayName + ", prefix=" + prefix + ", suffix=" + suffix + ", tag=" + tag + ", color=" + color + ", friendly_fire=" + friendly_fire + ", player=" + Arrays.toString(player) + "]";
-	}
-	
-	public String getTeam() {
-		return team;
-	}
-	
-	public void setTeam(String team) {
-		this.team = team;
-	}
-	
-	public Action getAction() {
-		return action;
-	}
-	
-	public void setAction(Action action) {
-		this.action = action;
-	}
-	
-	public String getDisplayName() {
-		return displayName;
-	}
-	
-	public void setDisplayName(String displayName) {
-		this.displayName = displayName;
-	}
-	
-	public String getPrefix() {
-		return prefix;
-	}
-	
-	public void setPrefix(String prefix) {
-		this.prefix = prefix;
-	}
-	
-	public String getSuffix() {
-		return suffix;
-	}
-	
-	public void setSuffix(String suffix) {
-		this.suffix = suffix;
-	}
-	
-	public NameTag getTag() {
-		return tag;
-	}
-	
-	public void setTag(NameTag tag) {
-		this.tag = tag;
-	}
-	
-	public ChatColor getColor() {
-		return ChatColor.values()[color == -1 ? 0 : color];
-	}
-	
-	public void setColor(ChatColor color) {
-		this.color = color.ordinal();
-	}
-	
-	public int isFriendlyFire() {
-		return friendly_fire;
-	}
-	
-	public void setFriendlyFire(int friendly_fire) {
-		this.friendly_fire = friendly_fire;
-	}
-	
-	public String[] getPlayers() {
-		return player;
-	}
-	
-	public void setPlayers(String[] player) {
-		this.player = player;
-	}
-	
-	public String getCollisionRule() {
-		return collisionRule;
-	}
-	
-	public void setCollisionRule(String collisionRule) {
-		this.collisionRule = collisionRule;
-	}
+    String team;
+    Action action;
+    String collisionRule = "always";
+    String displayName;
+    String prefix;
+    String suffix;
+    NameTag tag = NameTag.VISIABLE;
+    int color = -1;
+    int friendly_fire = 0;
+    String[] player;
+
+    public PacketPlayOutScoreboardTeam() {
+        super(0x3E);
+    }
+
+    public PacketPlayOutScoreboardTeam(Team t) {
+        super(0x3E);
+        action = Action.fromInt(t.getMode());
+        team = t.getName();
+        displayName = t.getDisplayName();
+        prefix = t.getPrefix();
+        suffix = t.getSuffix();
+        tag = NameTag.fromString(t.getNameTagVisibility());
+        color = t.getColor();
+        friendly_fire = t.getFriendlyFire();
+        player = t.getPlayers();
+    }
+
+    public PacketPlayOutScoreboardTeam(dev.wolveringer.api.scoreboard.Team team) {
+        super(0x3E);
+        this.team = team.getName();
+        this.displayName = team.getDisplayName();
+        this.prefix = team.getPrefix();
+        this.suffix = team.getSuffix();
+        this.tag = team.getTagVisibility();
+        this.color = team.getColor().ordinal();
+        this.friendly_fire = team.getFriendlyFire();
+        this.player = team.getMember().toArray(new String[0]);
+    }
+
+    @Override
+    public void write(PacketDataSerializer s) {
+        s.writeString(team);
+        s.writeByte(action.getAction());
+        if (action.getAction() == 0 || action.getAction() == 2) {
+            s.writeString(displayName);
+            s.writeString(prefix);
+            s.writeString(suffix);
+            s.writeByte(friendly_fire);
+            if (tag == null) tag = NameTag.VISIABLE;
+            s.writeString(tag.getIdentifire());
+            if (getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10)
+                s.writeString(collisionRule);
+            s.writeByte(color);
+        }
+        if (action.getAction() == 0 || action.getAction() == 3 || action.getAction() == 4) {
+            s.writeVarInt(player.length);
+            for (String x : player)
+                s.writeString(x);
+        }
+    }
+
+    public void read(PacketDataSerializer s) {
+        team = s.readString(16);
+        action = Action.fromInt(s.readByte());
+        if (action.getAction() == 0 || action.getAction() == 2) {
+            displayName = s.readString(32);
+            prefix = s.readString(16);
+            suffix = s.readString(16);
+            friendly_fire = s.readByte();
+            tag = NameTag.fromString(s.readString(32));
+            if (getBigVersion() == BigClientVersion.v1_9 || getBigVersion() == BigClientVersion.v1_10)
+                collisionRule = s.readString(-1);
+            color = s.readByte();
+        }
+        if (action.getAction() == 0 || action.getAction() == 3 || action.getAction() == 4) {
+            int i = PacketDataSerializer.readVarInt(s);
+            player = new String[i];
+            for (int x = 0; x < i; x++)
+                player[x] = s.readString(40);
+        }
+
+    }
+
+    @Override
+    public String toString() {
+        return "PacketPlayOutScoreboardTeam [team=" + team + ", action=" + action + ", displayName=" + displayName + ", prefix=" + prefix + ", suffix=" + suffix + ", tag=" + tag + ", color=" + color + ", friendly_fire=" + friendly_fire + ", player=" + Arrays.toString(player) + "]";
+    }
+
+    public String getTeam() {
+        return team;
+    }
+
+    public void setTeam(String team) {
+        this.team = team;
+    }
+
+    public Action getAction() {
+        return action;
+    }
+
+    public void setAction(Action action) {
+        this.action = action;
+    }
+
+    public String getDisplayName() {
+        return displayName;
+    }
+
+    public void setDisplayName(String displayName) {
+        this.displayName = displayName;
+    }
+
+    public String getPrefix() {
+        return prefix;
+    }
+
+    public void setPrefix(String prefix) {
+        this.prefix = prefix;
+    }
+
+    public String getSuffix() {
+        return suffix;
+    }
+
+    public void setSuffix(String suffix) {
+        this.suffix = suffix;
+    }
+
+    public NameTag getTag() {
+        return tag;
+    }
+
+    public void setTag(NameTag tag) {
+        this.tag = tag;
+    }
+
+    public ChatColor getColor() {
+        return ChatColor.values()[color == -1 ? 0 : color];
+    }
+
+    public void setColor(ChatColor color) {
+        this.color = color.ordinal();
+    }
+
+    public int isFriendlyFire() {
+        return friendly_fire;
+    }
+
+    public void setFriendlyFire(int friendly_fire) {
+        this.friendly_fire = friendly_fire;
+    }
+
+    public String[] getPlayers() {
+        return player;
+    }
+
+    public void setPlayers(String[] player) {
+        this.player = player;
+    }
+
+    public String getCollisionRule() {
+        return collisionRule;
+    }
+
+    public void setCollisionRule(String collisionRule) {
+        this.collisionRule = collisionRule;
+    }
+
+    public static enum Action {
+        CREATE(0), REMOVE(1), UPDATE(2), PLAYER_ADD(3), PLAYER_REMOVE(4);
+
+        private int b;
+
+        private Action(int b) {
+            this.b = b;
+        }
+
+        public static Action fromInt(int x) {
+            for (Action a : values())
+                if (a.getAction() == x) return a;
+            return null;
+        }
+
+        public int getAction() {
+            return b;
+        }
+    }
+
+    public static enum NameTag {
+        VISIABLE("always"), INVISIABLE("never"), TEAM_VISIABLE("hideForOtherTeams"), OTHER_VISIABLE("hideForOwnTeam");
+
+        private String s;
+
+        private NameTag(String s) {
+            this.s = s;
+        }
+
+        public static NameTag fromString(String s) {
+            for (NameTag t : values())
+                if (t.s.equalsIgnoreCase(s)) return t;
+            return null;
+        }
+
+        public String getIdentifire() {
+            return s;
+        }
+    }
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutSetExperience.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutSetExperience.java
index d1f3cfa..7f11fb3 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutSetExperience.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutSetExperience.java
@@ -3,47 +3,53 @@ package dev.wolveringer.BungeeUtil.packets;
 import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
 import dev.wolveringer.packet.PacketDataSerializer;
 
-public class PacketPlayOutSetExperience extends Packet implements PacketPlayOut{
-	float exp;
-	int level;
-	int total;
-	
-	public PacketPlayOutSetExperience() {
-		super(0x1F);
-	}
-	
-	@Override
-	public void read(PacketDataSerializer s) {
-		exp = s.readFloat();
-		level = s.readVarInt();
-		total = s.readVarInt();
-	}
-	@Override
-	public void write(PacketDataSerializer s) {
-		s.writeFloat(exp);
-		s.writeVarInt(level);
-		s.writeVarInt(total);
-	}
-	
-	public float getExp() {
-		return exp;
-	}
-	public int getLevel() {
-		return level;
-	}
-	public int getTotal() {
-		return total;
-	}
-	public PacketPlayOutSetExperience setExp(float exp) {
-		this.exp = exp;
-		return this;
-	}
-	public PacketPlayOutSetExperience setLevel(int level) {
-		this.level = level;
-		return this;
-	}
-	public PacketPlayOutSetExperience setTotal(int total) {
-		this.total = total;
-		return this;
-	}
+public class PacketPlayOutSetExperience extends Packet implements PacketPlayOut {
+    float exp;
+    int level;
+    int total;
+
+    public PacketPlayOutSetExperience() {
+        super(0x1F);
+    }
+
+    @Override
+    public void read(PacketDataSerializer s) {
+        exp = s.readFloat();
+        level = s.readVarInt();
+        total = s.readVarInt();
+    }
+
+    @Override
+    public void write(PacketDataSerializer s) {
+        s.writeFloat(exp);
+        s.writeVarInt(level);
+        s.writeVarInt(total);
+    }
+
+    public float getExp() {
+        return exp;
+    }
+
+    public PacketPlayOutSetExperience setExp(float exp) {
+        this.exp = exp;
+        return this;
+    }
+
+    public int getLevel() {
+        return level;
+    }
+
+    public PacketPlayOutSetExperience setLevel(int level) {
+        this.level = level;
+        return this;
+    }
+
+    public int getTotal() {
+        return total;
+    }
+
+    public PacketPlayOutSetExperience setTotal(int total) {
+        this.total = total;
+        return this;
+    }
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutSetSlot.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutSetSlot.java
index dac7ae8..0ff46d7 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutSetSlot.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutSetSlot.java
@@ -6,57 +6,57 @@ import dev.wolveringer.packet.PacketDataSerializer;
 import lombok.NoArgsConstructor;
 
 @NoArgsConstructor
-public class PacketPlayOutSetSlot extends Packet implements PacketPlayOut{
-	private Item ItemStack;
-	private int slot;
-	private int window;
-
-	public PacketPlayOutSetSlot(Item itemstack, int window, int slot) {
-		this.ItemStack = itemstack == null ? null : itemstack;
-		this.window = window;
-		this.slot = slot;
-	}
-
-	public Item getItemStack() {
-		return ItemStack;
-	}
-
-	public int getSlot() {
-		return slot;
-	}
-
-	public int getWindow() {
-		return window;
-	}
-
-	@Override
-	public void read(PacketDataSerializer packetdataserializer) {
-		this.window = packetdataserializer.readByte();
-		this.slot = packetdataserializer.readShort();
-		this.ItemStack = packetdataserializer.readItem();
-	}
-
-	public void setItemStack(Item itemStack) {
-		ItemStack = itemStack;
-	}
-
-	public void setSlot(int slot) {
-		this.slot = slot;
-	}
-
-	public void setWindow(int window) {
-		this.window = window;
-	}
-
-	@Override
-	public void write(PacketDataSerializer packetdataserializer) {
-		packetdataserializer.writeByte(this.window);
-		packetdataserializer.writeShort(this.slot);
-		packetdataserializer.writeItem(this.ItemStack);
-	}
-
-	@Override
-	public String toString() {
-		return "PacketPlayOutSetSlot [ItemStack=" + ItemStack + ", slot=" + slot + ", window=" + window + "]";
-	}
+public class PacketPlayOutSetSlot extends Packet implements PacketPlayOut {
+    private Item ItemStack;
+    private int slot;
+    private int window;
+
+    public PacketPlayOutSetSlot(Item itemstack, int window, int slot) {
+        this.ItemStack = itemstack == null ? null : itemstack;
+        this.window = window;
+        this.slot = slot;
+    }
+
+    public Item getItemStack() {
+        return ItemStack;
+    }
+
+    public void setItemStack(Item itemStack) {
+        ItemStack = itemStack;
+    }
+
+    public int getSlot() {
+        return slot;
+    }
+
+    public void setSlot(int slot) {
+        this.slot = slot;
+    }
+
+    public int getWindow() {
+        return window;
+    }
+
+    public void setWindow(int window) {
+        this.window = window;
+    }
+
+    @Override
+    public void read(PacketDataSerializer packetdataserializer) {
+        this.window = packetdataserializer.readByte();
+        this.slot = packetdataserializer.readShort();
+        this.ItemStack = packetdataserializer.readItem();
+    }
+
+    @Override
+    public void write(PacketDataSerializer packetdataserializer) {
+        packetdataserializer.writeByte(this.window);
+        packetdataserializer.writeShort(this.slot);
+        packetdataserializer.writeItem(this.ItemStack);
+    }
+
+    @Override
+    public String toString() {
+        return "PacketPlayOutSetSlot [ItemStack=" + ItemStack + ", slot=" + slot + ", window=" + window + "]";
+    }
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutSpawnEntity.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutSpawnEntity.java
index c82be3f..c527304 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutSpawnEntity.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutSpawnEntity.java
@@ -5,72 +5,72 @@ import dev.wolveringer.api.datawatcher.DataWatcher;
 import dev.wolveringer.api.position.Location;
 import dev.wolveringer.packet.PacketDataSerializer;
 
-public class PacketPlayOutSpawnEntity extends Packet implements PacketPlayOut{
-	Location location;
-	int eid;
-	int type;
-	DataWatcher data;
-	
-	public PacketPlayOutSpawnEntity() {
-		super(0x0E);
-	}
-	
-	public PacketPlayOutSpawnEntity(Location location, int eid, int type, DataWatcher data) {
-		this();
-		this.location = location.multiply(32D);
-		this.eid = eid;
-		this.type = type;
-		this.data = data;
-	}
+public class PacketPlayOutSpawnEntity extends Packet implements PacketPlayOut {
+    Location location;
+    int eid;
+    int type;
+    DataWatcher data;
 
+    public PacketPlayOutSpawnEntity() {
+        super(0x0E);
+    }
 
+    public PacketPlayOutSpawnEntity(Location location, int eid, int type, DataWatcher data) {
+        this();
+        this.location = location.multiply(32D);
+        this.eid = eid;
+        this.type = type;
+        this.data = data;
+    }
 
-	@Override
-	public void read(PacketDataSerializer s) {
-		eid = s.readVarInt();
-		type = s.readByte();
-		location = new Location(s.readInt(), s.readInt(), s.readInt());
-		data = DataWatcher.createDataWatcher(getBigVersion(),s);
-	}
-	@Override
-	public void write(PacketDataSerializer s) {
-		s.writeVarInt(eid);
-		s.writeByte(type);
-		s.writeInt(location.getBlockX());
-		s.writeInt(location.getBlockY());
-		s.writeInt(location.getBlockZ());
-		data.write(s);
-	}
 
-	public Location getLocation() {
-		return location.clone().dividide(32D);
-	}
+    @Override
+    public void read(PacketDataSerializer s) {
+        eid = s.readVarInt();
+        type = s.readByte();
+        location = new Location(s.readInt(), s.readInt(), s.readInt());
+        data = DataWatcher.createDataWatcher(getBigVersion(), s);
+    }
 
-	public void setLocation(Location location) {
-		this.location = location.multiply(32D);
-	}
+    @Override
+    public void write(PacketDataSerializer s) {
+        s.writeVarInt(eid);
+        s.writeByte(type);
+        s.writeInt(location.getBlockX());
+        s.writeInt(location.getBlockY());
+        s.writeInt(location.getBlockZ());
+        data.write(s);
+    }
 
-	public int getEid() {
-		return eid;
-	}
+    public Location getLocation() {
+        return location.clone().dividide(32D);
+    }
 
-	public void setEid(int eid) {
-		this.eid = eid;
-	}
+    public void setLocation(Location location) {
+        this.location = location.multiply(32D);
+    }
 
-	public int getType() {
-		return type;
-	}
+    public int getEid() {
+        return eid;
+    }
 
-	public void setType(int type) {
-		this.type = type;
-	}
+    public void setEid(int eid) {
+        this.eid = eid;
+    }
 
-	public DataWatcher getData() {
-		return data;
-	}
+    public int getType() {
+        return type;
+    }
 
-	public void setData(DataWatcher data) {
-		this.data = data;
-	}
+    public void setType(int type) {
+        this.type = type;
+    }
+
+    public DataWatcher getData() {
+        return data;
+    }
+
+    public void setData(DataWatcher data) {
+        this.data = data;
+    }
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutSpawnEntityLiving.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutSpawnEntityLiving.java
index 0d5fba8..6182944 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutSpawnEntityLiving.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutSpawnEntityLiving.java
@@ -6,127 +6,132 @@ import dev.wolveringer.api.position.Location;
 import dev.wolveringer.api.position.Vector;
 import dev.wolveringer.packet.PacketDataSerializer;
 
-public class PacketPlayOutSpawnEntityLiving extends BetaPacket implements PacketPlayOut{
-	private byte type;
-	private Location location;
-	private int yaw = 0;
-	private int pitch = 0;
-	private int headRotation;
-	private Vector vector = new Vector();
-	private int id;
-	private DataWatcher meta;
-	public PacketPlayOutSpawnEntityLiving(byte type, Location location, int yaw, int pitch, int headRotation, Vector vector) {
-		this();
-		this.type = type;
-		this.location = location;
-		this.yaw = yaw;
-		this.pitch = pitch;
-		this.headRotation = headRotation;
-		this.vector = vector;
-	}
-
-	public PacketPlayOutSpawnEntityLiving() {
-		super(0x0F);
-	}
-	
-	@Override
-	public void read(PacketDataSerializer s) {
-		id = s.readVarInt();
-		type = s.readByte();
-		location = new Location(s.readInt(), s.readInt(), s.readInt());
-		yaw = s.readByte();
-		pitch = s.readByte();
-		headRotation = s.readByte();
-		if(headRotation > 0)
-			vector = new Vector(s.readShort(), s.readShort(), s.readShort());
-		meta = DataWatcher.createDataWatcher(getBigVersion(),s);
-	}
-
-	@Override
-	public void write(PacketDataSerializer s) {
-		s.writeVarInt(id);
-		s.writeByte(type);
-		s.writeInt(location.getBlockX());
-		s.writeInt(location.getBlockY());
-		s.writeInt(location.getBlockZ());
-		s.writeByte(yaw);
-		s.writeByte(pitch);
-		s.writeByte(headRotation);
-		if(headRotation > 0){
-			s.writeShort(vector.getBlockX());
-			s.writeShort(vector.getBlockY());
-			s.writeShort(vector.getBlockZ());
-		}
-		if(meta == null)
-			meta = DataWatcher.createDataWatcher(getBigVersion());
-		meta.write(s);
-	}
-
-	public boolean isItemFrame() {
-		return type == 71;
-	}
-
-	public boolean isFalingBlock() {
-		return type == 70;
-	}
-
-	public byte getType() {
-		return type;
-	}
-
-	public void setType(byte type) {
-		this.type = type;
-	}
-
-	public Location getLocation() {
-		return location;
-	}
-
-	public void setLocation(Location location) {
-		this.location = location.multiply(32.0D);
-	}
-
-	public int getYaw() {
-		return yaw;
-	}
-
-	public void setYaw(int yaw) {
-		this.yaw = yaw;
-	}
-
-	public int getPitch() {
-		return pitch;
-	}
-
-	public void setPitch(int pitch) {
-		this.pitch = pitch;
-	}
-
-	public int getHeadRotation() {
-		return headRotation;
-	}
-
-	public void setHeadRotation(int headRotation) {
-		this.headRotation = headRotation;
-	}
-
-	public Vector getVector() {
-		return vector;
-	}
-
-	public void setVector(Vector vector) {
-		this.vector = vector;
-	}
-	public void setEntityID(int id) {
-		this.id = id;
-	}
-	public int getEnityID() {
-		return id;
-	}
-	public void setMeta(DataWatcher meta) {
-		this.meta = meta;
-	}
-	public DataWatcher getMeta() {
-		return meta;
-	}
+public class PacketPlayOutSpawnEntityLiving extends BetaPacket implements PacketPlayOut {
+    private byte type;
+    private Location location;
+    private int yaw = 0;
+    private int pitch = 0;
+    private int headRotation;
+    private Vector vector = new Vector();
+    private int id;
+    private DataWatcher meta;
+
+    public PacketPlayOutSpawnEntityLiving(byte type, Location location, int yaw, int pitch, int headRotation, Vector vector) {
+        this();
+        this.type = type;
+        this.location = location;
+        this.yaw = yaw;
+        this.pitch = pitch;
+        this.headRotation = headRotation;
+        this.vector = vector;
+    }
+
+    public PacketPlayOutSpawnEntityLiving() {
+        super(0x0F);
+    }
+
+    @Override
+    public void read(PacketDataSerializer s) {
+        id = s.readVarInt();
+        type = s.readByte();
+        location = new Location(s.readInt(), s.readInt(), s.readInt());
+        yaw = s.readByte();
+        pitch = s.readByte();
+        headRotation = s.readByte();
+        if (headRotation > 0)
+            vector = new Vector(s.readShort(), s.readShort(), s.readShort());
+        meta = DataWatcher.createDataWatcher(getBigVersion(), s);
+    }
+
+    @Override
+    public void write(PacketDataSerializer s) {
+        s.writeVarInt(id);
+        s.writeByte(type);
+        s.writeInt(location.getBlockX());
+        s.writeInt(location.getBlockY());
+        s.writeInt(location.getBlockZ());
+        s.writeByte(yaw);
+        s.writeByte(pitch);
+        s.writeByte(headRotation);
+        if (headRotation > 0) {
+            s.writeShort(vector.getBlockX());
+            s.writeShort(vector.getBlockY());
+            s.writeShort(vector.getBlockZ());
+        }
+        if (meta == null)
+            meta = DataWatcher.createDataWatcher(getBigVersion());
+        meta.write(s);
+    }
+
+    public boolean isItemFrame() {
+        return type == 71;
+    }
+
+    public boolean isFalingBlock() {
+        return type == 70;
+    }
+
+    public byte getType() {
+        return type;
+    }
+
+    public void setType(byte type) {
+        this.type = type;
+    }
+
+    public Location getLocation() {
+        return location;
+    }
+
+    public void setLocation(Location location) {
+        this.location = location.multiply(32.0D);
+    }
+
+    public int getYaw() {
+        return yaw;
+    }
+
+    public void setYaw(int yaw) {
+        this.yaw = yaw;
+    }
+
+    public int getPitch() {
+        return pitch;
+    }
+
+    public void setPitch(int pitch) {
+        this.pitch = pitch;
+    }
+
+    public int getHeadRotation() {
+        return headRotation;
+    }
+
+    public void setHeadRotation(int headRotation) {
+        this.headRotation = headRotation;
+    }
+
+    public Vector getVector() {
+        return vector;
+    }
+
+    public void setVector(Vector vector) {
+        this.vector = vector;
+    }
+
+    public void setEntityID(int id) {
+        this.id = id;
+    }
+
+    public int getEnityID() {
+        return id;
+    }
+
+    public DataWatcher getMeta() {
+        return meta;
+    }
+
+    public void setMeta(DataWatcher meta) {
+        this.meta = meta;
+    }
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutSpawnPostition.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutSpawnPostition.java
index c25330b..e038bd3 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutSpawnPostition.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutSpawnPostition.java
@@ -4,24 +4,29 @@ import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
 import dev.wolveringer.api.position.BlockPosition;
 import dev.wolveringer.packet.PacketDataSerializer;
 
-public class PacketPlayOutSpawnPostition extends Packet implements PacketPlayOut{
-	BlockPosition loc;
-	public PacketPlayOutSpawnPostition() {
-		super(0x05);
-	}
-	public PacketPlayOutSpawnPostition(BlockPosition loc) {
-		super(0x05);
-		this.loc = loc;
-	}
-	@Override
-	public void read(PacketDataSerializer s) {
-		loc = s.readBlockPosition();
-	}
-	@Override
-	public void write(PacketDataSerializer s) {
-		s.writeBlockPosition(loc);
-	}
-	public BlockPosition getLocation() {
-		return loc;
-	}
+public class PacketPlayOutSpawnPostition extends Packet implements PacketPlayOut {
+    BlockPosition loc;
+
+    public PacketPlayOutSpawnPostition() {
+        super(0x05);
+    }
+
+    public PacketPlayOutSpawnPostition(BlockPosition loc) {
+        super(0x05);
+        this.loc = loc;
+    }
+
+    @Override
+    public void read(PacketDataSerializer s) {
+        loc = s.readBlockPosition();
+    }
+
+    @Override
+    public void write(PacketDataSerializer s) {
+        s.writeBlockPosition(loc);
+    }
+
+    public BlockPosition getLocation() {
+        return loc;
+    }
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutStatistic.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutStatistic.java
index 752ad40..9798ea1 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutStatistic.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutStatistic.java
@@ -5,43 +5,43 @@ import java.util.HashMap;
 import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
 import dev.wolveringer.packet.PacketDataSerializer;
 
-public class PacketPlayOutStatistic extends Packet implements PacketPlayOut{
-
-	public PacketPlayOutStatistic() {
-		super(0x37);
-	}
-
-	private HashMap<String, Integer> stats = new HashMap<String, Integer>();
-	private int x = -2;
-
-	@Override
-	public void read(PacketDataSerializer s) {
-		int max = s.readVarInt();
-		while (max > 0){
-			stats.put(s.readString(-1), s.readVarInt());
-			max--;
-		}
-	}
-
-	@Override
-	public void write(PacketDataSerializer s) {
-		s.writeVarInt(stats.size());
-		for(String x : stats.keySet()){
-			s.writeString(x);
-			if(this.x == -2)
-				s.writeVarInt(stats.get(x));
-			else
-				s.writeVarInt(this.x);
-		}
-	}
-
-	@Deprecated
-	public void a(int i) {
-		x = i;
-	}
-
-	@Override
-	public String toString() {
-		return "PacketPlayOutStatistic [stats=" + stats + "]";
-	}
+public class PacketPlayOutStatistic extends Packet implements PacketPlayOut {
+
+    private HashMap<String, Integer> stats = new HashMap<String, Integer>();
+    private int x = -2;
+
+    public PacketPlayOutStatistic() {
+        super(0x37);
+    }
+
+    @Override
+    public void read(PacketDataSerializer s) {
+        int max = s.readVarInt();
+        while (max > 0) {
+            stats.put(s.readString(-1), s.readVarInt());
+            max--;
+        }
+    }
+
+    @Override
+    public void write(PacketDataSerializer s) {
+        s.writeVarInt(stats.size());
+        for (String x : stats.keySet()) {
+            s.writeString(x);
+            if (this.x == -2)
+                s.writeVarInt(stats.get(x));
+            else
+                s.writeVarInt(this.x);
+        }
+    }
+
+    @Deprecated
+    public void a(int i) {
+        x = i;
+    }
+
+    @Override
+    public String toString() {
+        return "PacketPlayOutStatistic [stats=" + stats + "]";
+    }
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutTitle.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutTitle.java
index 717d48b..e3f2baf 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutTitle.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutTitle.java
@@ -12,57 +12,57 @@ import lombok.Setter;
 @Builder
 @Getter
 @Setter
-public class PacketPlayOutTitle extends Packet{
-	public static enum Action {
-		SET_TITLE,
-		SET_SUBTITLE,
-		UPDATE_TIMINGS,
-		HIDE,
-		RESET;
-	}
-	
-	private Action action;
-	private String title;
-	private int fadeIn;
-	private int stay;
-	private int fadeOut;
-	
-	@Override
-	public void read(PacketDataSerializer s) {
-		action = Action.values()[s.readVarInt()];
-		switch (action) {
-		case SET_TITLE:
-		case SET_SUBTITLE:
-			title = s.readString(-1);
-			break;
-		case UPDATE_TIMINGS:
-			fadeIn = s.readInt();
-			stay = s.readInt();
-			fadeOut = s.readInt();
-		case HIDE:
-		case RESET:
-			break;
-		default:
-			break;
-		}
-	}
+public class PacketPlayOutTitle extends Packet {
+    private Action action;
+    private String title;
+    private int fadeIn;
+    private int stay;
+    private int fadeOut;
 
-	@Override
-	public void write(PacketDataSerializer s) {
-		s.writeVarInt(action.ordinal());
-		switch (action) {
-		case SET_SUBTITLE:
-		case SET_TITLE:
-			s.writeString(title);
-			break;
-		case UPDATE_TIMINGS:
-			s.writeInt(fadeIn);
-			s.writeInt(stay);
-			s.writeInt(fadeOut);
-			break;
-		default:
-			break;
-		}
-	}
+    @Override
+    public void read(PacketDataSerializer s) {
+        action = Action.values()[s.readVarInt()];
+        switch (action) {
+            case SET_TITLE:
+            case SET_SUBTITLE:
+                title = s.readString(-1);
+                break;
+            case UPDATE_TIMINGS:
+                fadeIn = s.readInt();
+                stay = s.readInt();
+                fadeOut = s.readInt();
+            case HIDE:
+            case RESET:
+                break;
+            default:
+                break;
+        }
+    }
+
+    @Override
+    public void write(PacketDataSerializer s) {
+        s.writeVarInt(action.ordinal());
+        switch (action) {
+            case SET_SUBTITLE:
+            case SET_TITLE:
+                s.writeString(title);
+                break;
+            case UPDATE_TIMINGS:
+                s.writeInt(fadeIn);
+                s.writeInt(stay);
+                s.writeInt(fadeOut);
+                break;
+            default:
+                break;
+        }
+    }
+
+    public static enum Action {
+        SET_TITLE,
+        SET_SUBTITLE,
+        UPDATE_TIMINGS,
+        HIDE,
+        RESET;
+    }
 
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutTransaction.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutTransaction.java
index 02fd6a5..d9e02e2 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutTransaction.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutTransaction.java
@@ -3,60 +3,60 @@ package dev.wolveringer.BungeeUtil.packets;
 import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
 import dev.wolveringer.packet.PacketDataSerializer;
 
-public class PacketPlayOutTransaction extends Packet implements PacketPlayOut{
-
-	private int window;
-	private short id;
-	private boolean cancel;
-
-	public PacketPlayOutTransaction() {
-		super(0x32);
-	}
-
-	public PacketPlayOutTransaction(int window, short id, boolean flag) {
-		super(0x32);
-		this.window = window;
-		this.id = id;
-		this.cancel = flag;
-	}
-
-	public void read(PacketDataSerializer packetdataserializer) {
-		this.window = packetdataserializer.readUnsignedByte();
-		this.id = packetdataserializer.readShort();
-		this.cancel = packetdataserializer.readBoolean();
-	}
-
-	public void write(PacketDataSerializer packetdataserializer) {
-		packetdataserializer.writeByte(this.window);
-		packetdataserializer.writeShort(this.id);
-		packetdataserializer.writeBoolean(this.cancel);
-	}
-
-	public String toString() {
-		return String.format("id=%d, uid=%d, accepted=%b", new Object[] { Integer.valueOf(this.window), Short.valueOf(this.id), Boolean.valueOf(this.cancel) });
-	}
-
-	public int getWindow() {
-		return window;
-	}
-
-	public void setWindow(int window) {
-		this.window = window;
-	}
-
-	public short getId() {
-		return id;
-	}
-
-	public void setId(short id) {
-		this.id = id;
-	}
-
-	public boolean isCancel() {
-		return cancel;
-	}
-
-	public void setCancel(boolean cancel) {
-		this.cancel = cancel;
-	}
+public class PacketPlayOutTransaction extends Packet implements PacketPlayOut {
+
+    private int window;
+    private short id;
+    private boolean cancel;
+
+    public PacketPlayOutTransaction() {
+        super(0x32);
+    }
+
+    public PacketPlayOutTransaction(int window, short id, boolean flag) {
+        super(0x32);
+        this.window = window;
+        this.id = id;
+        this.cancel = flag;
+    }
+
+    public void read(PacketDataSerializer packetdataserializer) {
+        this.window = packetdataserializer.readUnsignedByte();
+        this.id = packetdataserializer.readShort();
+        this.cancel = packetdataserializer.readBoolean();
+    }
+
+    public void write(PacketDataSerializer packetdataserializer) {
+        packetdataserializer.writeByte(this.window);
+        packetdataserializer.writeShort(this.id);
+        packetdataserializer.writeBoolean(this.cancel);
+    }
+
+    public String toString() {
+        return String.format("id=%d, uid=%d, accepted=%b", new Object[]{Integer.valueOf(this.window), Short.valueOf(this.id), Boolean.valueOf(this.cancel)});
+    }
+
+    public int getWindow() {
+        return window;
+    }
+
+    public void setWindow(int window) {
+        this.window = window;
+    }
+
+    public short getId() {
+        return id;
+    }
+
+    public void setId(short id) {
+        this.id = id;
+    }
+
+    public boolean isCancel() {
+        return cancel;
+    }
+
+    public void setCancel(boolean cancel) {
+        this.cancel = cancel;
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutUpdateHealth.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutUpdateHealth.java
index 561173f..bcbf2bd 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutUpdateHealth.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutUpdateHealth.java
@@ -1,38 +1,37 @@
 package dev.wolveringer.BungeeUtil.packets;
 
-import dev.wolveringer.BungeeUtil.ClientVersion.BigClientVersion;
 import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
 import dev.wolveringer.packet.PacketDataSerializer;
 
-public class PacketPlayOutUpdateHealth extends Packet implements PacketPlayOut{
-
-	float health;
-	int food;
-	float food_indicase;
-	
-	public PacketPlayOutUpdateHealth(float health, int food, float food_indicase) {
-		this();
-		this.health = health;
-		this.food = food;
-		this.food_indicase = food_indicase;
-	}
-	
-	public PacketPlayOutUpdateHealth() {
-		super(0x06);
-	}
-
-	@Override
-	public void read(PacketDataSerializer s) {
-		health = s.readFloat();
-		food = s.readVarInt();
-		food_indicase = s.readFloat();
-	}
-
-	@Override
-	public void write(PacketDataSerializer s) {
-		s.writeFloat(health);
-		s.writeVarInt(food);
-		s.writeFloat(food_indicase);
-	}
+public class PacketPlayOutUpdateHealth extends Packet implements PacketPlayOut {
+
+    float health;
+    int food;
+    float food_indicase;
+
+    public PacketPlayOutUpdateHealth(float health, int food, float food_indicase) {
+        this();
+        this.health = health;
+        this.food = food;
+        this.food_indicase = food_indicase;
+    }
+
+    public PacketPlayOutUpdateHealth() {
+        super(0x06);
+    }
+
+    @Override
+    public void read(PacketDataSerializer s) {
+        health = s.readFloat();
+        food = s.readVarInt();
+        food_indicase = s.readFloat();
+    }
+
+    @Override
+    public void write(PacketDataSerializer s) {
+        s.writeFloat(health);
+        s.writeVarInt(food);
+        s.writeFloat(food_indicase);
+    }
 
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutUpdateSign.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutUpdateSign.java
index b9c1783..c6fbd32 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutUpdateSign.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutUpdateSign.java
@@ -4,42 +4,47 @@ import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
 import dev.wolveringer.api.position.BlockPosition;
 import dev.wolveringer.packet.PacketDataSerializer;
 
-public class PacketPlayOutUpdateSign extends Packet implements PacketPlayOut{
-	private BlockPosition loc;
-	private String[] lines = new String[4];
-	
-	public PacketPlayOutUpdateSign() {
-		super(0x33);
-	}
-
-	public PacketPlayOutUpdateSign(BlockPosition loc, String[] lines) {
-		super(0x33);
-		this.loc = loc;
-		this.lines = lines;
-	}
-
-	@Override
-	public void read(PacketDataSerializer s) {
-		loc = s.readBlockPosition();
-		for(int i = 0;i<4;i++)
-			lines[i] = s.readString(-1);
-	}
-	@Override
-	public void write(PacketDataSerializer s) {
-		s.writeBlockPosition(loc);
-		for(int i = 0;i<4;i++)
-			s.writeString(lines[i]);
-	}
-	public BlockPosition getLocation() {
-		return loc;
-	}
-	public void setLocation(BlockPosition loc) {
-		this.loc = loc;
-	}
-	public String[] getLines() {
-		return lines;
-	}
-	public void setLines(String[] lines) {
-		this.lines = lines;
-	}
+public class PacketPlayOutUpdateSign extends Packet implements PacketPlayOut {
+    private BlockPosition loc;
+    private String[] lines = new String[4];
+
+    public PacketPlayOutUpdateSign() {
+        super(0x33);
+    }
+
+    public PacketPlayOutUpdateSign(BlockPosition loc, String[] lines) {
+        super(0x33);
+        this.loc = loc;
+        this.lines = lines;
+    }
+
+    @Override
+    public void read(PacketDataSerializer s) {
+        loc = s.readBlockPosition();
+        for (int i = 0; i < 4; i++)
+            lines[i] = s.readString(-1);
+    }
+
+    @Override
+    public void write(PacketDataSerializer s) {
+        s.writeBlockPosition(loc);
+        for (int i = 0; i < 4; i++)
+            s.writeString(lines[i]);
+    }
+
+    public BlockPosition getLocation() {
+        return loc;
+    }
+
+    public void setLocation(BlockPosition loc) {
+        this.loc = loc;
+    }
+
+    public String[] getLines() {
+        return lines;
+    }
+
+    public void setLines(String[] lines) {
+        this.lines = lines;
+    }
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutWindowData.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutWindowData.java
index 126a113..91d9644 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutWindowData.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutWindowData.java
@@ -3,59 +3,59 @@ package dev.wolveringer.BungeeUtil.packets;
 import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
 import dev.wolveringer.packet.PacketDataSerializer;
 
-public class PacketPlayOutWindowData extends Packet implements PacketPlayOut{
-	
-	private int window;
-	private short action;
-	private short value;
-	
-	public PacketPlayOutWindowData() {
-		super(0x31);
-	}
-	
-	
-	
-	public PacketPlayOutWindowData(int window, short action, short value) {
-		super(0x31);
-		this.window = window;
-		this.action = action;
-		this.value = value;
-	}
-
-	@Override
-	public void read(PacketDataSerializer s) {
-		window = s.readUnsignedByte();
-		action = s.readShort();
-		value = s.readShort();
-	}
-	@Override
-	public void write(PacketDataSerializer s) {
-		s.writeByte(window);
-		s.writeShort(action);
-		s.writeShort(value);
-	}
-
-	public int getWindow() {
-		return window;
-	}
-
-	public void setWindow(int window) {
-		this.window = window;
-	}
-
-	public short getAction() {
-		return action;
-	}
-
-	public void setAction(short action) {
-		this.action = action;
-	}
-
-	public short getValue() {
-		return value;
-	}
-
-	public void setValue(short value) {
-		this.value = value;
-	}
+public class PacketPlayOutWindowData extends Packet implements PacketPlayOut {
+
+    private int window;
+    private short action;
+    private short value;
+
+    public PacketPlayOutWindowData() {
+        super(0x31);
+    }
+
+
+    public PacketPlayOutWindowData(int window, short action, short value) {
+        super(0x31);
+        this.window = window;
+        this.action = action;
+        this.value = value;
+    }
+
+    @Override
+    public void read(PacketDataSerializer s) {
+        window = s.readUnsignedByte();
+        action = s.readShort();
+        value = s.readShort();
+    }
+
+    @Override
+    public void write(PacketDataSerializer s) {
+        s.writeByte(window);
+        s.writeShort(action);
+        s.writeShort(value);
+    }
+
+    public int getWindow() {
+        return window;
+    }
+
+    public void setWindow(int window) {
+        this.window = window;
+    }
+
+    public short getAction() {
+        return action;
+    }
+
+    public void setAction(short action) {
+        this.action = action;
+    }
+
+    public short getValue() {
+        return value;
+    }
+
+    public void setValue(short value) {
+        this.value = value;
+    }
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutWindowItems.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutWindowItems.java
index d92c05d..9c108fa 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutWindowItems.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutWindowItems.java
@@ -7,63 +7,63 @@ import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
 import dev.wolveringer.packet.PacketDataSerializer;
 
 public class PacketPlayOutWindowItems extends Packet implements PacketPlayOut {
-	private int window;
-	private Item[] items;
+    private int window;
+    private Item[] items;
 
-	public PacketPlayOutWindowItems() {
-		super(0x30);
-	}
+    public PacketPlayOutWindowItems() {
+        super(0x30);
+    }
 
-	public PacketPlayOutWindowItems(int window, List<Item> list) {
-		super(0x30);
-		this.window = window;
-		this.items = new Item[list.size()];
-		for(int i = 0;i < this.items.length;++i){
-			this.items[i] = list.get(i);
-		}
-	}
+    public PacketPlayOutWindowItems(int window, List<Item> list) {
+        super(0x30);
+        this.window = window;
+        this.items = new Item[list.size()];
+        for (int i = 0; i < this.items.length; ++i) {
+            this.items[i] = list.get(i);
+        }
+    }
 
-	public PacketPlayOutWindowItems(int i, Item... items) {
-		super(0x30);
-		this.window = i;
-		this.items = items;
-	}
+    public PacketPlayOutWindowItems(int i, Item... items) {
+        super(0x30);
+        this.window = i;
+        this.items = items;
+    }
 
-	@Override
-	public void read(PacketDataSerializer s) {
-		this.window = s.readUnsignedByte();
-		short items_length = s.readShort();
+    @Override
+    public void read(PacketDataSerializer s) {
+        this.window = s.readUnsignedByte();
+        short items_length = s.readShort();
 
-		this.items = new Item[items_length];
+        this.items = new Item[items_length];
 
-		for(int i = 0;i < items_length;++i){
-			this.items[i] = s.readItem();
-		}
-	}
+        for (int i = 0; i < items_length; ++i) {
+            this.items[i] = s.readItem();
+        }
+    }
 
-	@Override
-	public void write(PacketDataSerializer s) {
-		s.writeByte(this.window);
-		s.writeShort(this.items.length);
-		for(int i = 0;i < this.items.length;++i){
-			s.writeItem(this.items[i]);
-		}
-	}
+    @Override
+    public void write(PacketDataSerializer s) {
+        s.writeByte(this.window);
+        s.writeShort(this.items.length);
+        for (int i = 0; i < this.items.length; ++i) {
+            s.writeItem(this.items[i]);
+        }
+    }
 
-	public int getWindow() {
-		return window;
-	}
+    public int getWindow() {
+        return window;
+    }
 
-	public void setWindow(int window) {
-		this.window = window;
-	}
+    public void setWindow(int window) {
+        this.window = window;
+    }
 
-	public Item[] getItems() {
-		return items;
-	}
+    public Item[] getItems() {
+        return items;
+    }
 
-	public void setItems(Item[] items) {
-		this.items = items;
-	}
+    public void setItems(Item[] items) {
+        this.items = items;
+    }
 
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutWorldParticles.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutWorldParticles.java
index 36639a0..d578c91 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutWorldParticles.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/PacketPlayOutWorldParticles.java
@@ -3,7 +3,6 @@ package dev.wolveringer.BungeeUtil.packets;
 import java.util.ArrayList;
 import java.util.Arrays;
 
-import dev.wolveringer.BungeeUtil.ClientVersion.BigClientVersion;
 import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
 import dev.wolveringer.api.particel.ParticleEffect;
 import dev.wolveringer.api.position.Location;
@@ -11,135 +10,134 @@ import dev.wolveringer.api.position.Vector;
 import dev.wolveringer.packet.PacketDataSerializer;
 
 public class PacketPlayOutWorldParticles extends Packet implements PacketPlayOut {
-	
-	private int count;
-	private float data;
-	private Location loc;
-	private ParticleEffect name;
-	private Vector vector;
-	
-	// 1.8
-	boolean far;
-	int[] p_data;
-	
-	public PacketPlayOutWorldParticles() {
-		super(0x2A);
-	}
-	
-	public PacketPlayOutWorldParticles(ParticleEffect s, Location loc, Vector v, float f6, int i, int... pdata) {
-		this.name = s;
-		this.loc = loc;
-		this.vector = v;
-		this.data = f6;
-		this.count = i;
-		this.p_data = pdata;
-	}
-	
-	public PacketPlayOutWorldParticles(ParticleEffect s, Location loc, Vector v, float f6, int i, boolean far, int... pdata) {
-		this.name = s;
-		this.loc = loc;
-		this.vector = v;
-		this.data = f6;
-		this.count = i;
-		this.p_data = pdata;
-		this.far = far;
-	}
-	
-	public int getCount() {
-		return count;
-	}
-	
-	public float getData() {
-		return data;
-	}
-	
-	public Location getLoc() {
-		return loc;
-	}
-	
-	public ParticleEffect getParticle() {
-		return name;
-	}
-	
-	public Vector getVector() {
-		return vector;
-	}
-	
-	@Override
-	public void read(PacketDataSerializer packetdataserializer) {
-		this.name = ParticleEffect.fromId(packetdataserializer.readInt());
-		this.far = packetdataserializer.readBoolean();
-		loc = new Location(packetdataserializer.readFloat(), packetdataserializer.readFloat(), packetdataserializer.readFloat());
-		vector = new Vector(packetdataserializer.readFloat(), packetdataserializer.readFloat(), packetdataserializer.readFloat());
-		this.data = packetdataserializer.readFloat();
-		this.count = packetdataserializer.readInt();
-		ArrayList<Integer> a = new ArrayList<Integer>();
-		while (packetdataserializer.readableBytes() > 0) {
-			a.add(packetdataserializer.readVarInt());
-		}
-		this.p_data = new int[a.size()];
-		int pos = 0;
-		for (Integer i : a) {
-			p_data[pos] = i;
-			pos++;
-		}
-	}
-	
-	public void setCount(int count) {
-		this.count = count;
-	}
-	
-	public void setData(float data) {
-		this.data = data;
-	}
-	
-	public void setLoc(Location loc) {
-		this.loc = loc;
-	}
-	
-	public void setParticle(ParticleEffect name) {
-		this.name = name;
-	}
-	
-	public void setVector(Vector vector) {
-		this.vector = vector;
-	}
-	
-	@Override
-	public String toString() {
-		return "PacketPlayOutWorldParticles [count=" + count + ", data=" + data + ", loc=" + loc + ", name=" + name + ", vector=" + vector + ", j=" + far + ", p_data=" + Arrays.toString(p_data) + "]";
-	}
-	
-	@Override
-	public void write(PacketDataSerializer packetdataserializer) {
-		packetdataserializer.writeInt(this.name.getId());
-		packetdataserializer.writeBoolean(this.far);
-		packetdataserializer.writeFloat(new Float(this.loc.getX()));
-		packetdataserializer.writeFloat(new Float(this.loc.getY()));
-		packetdataserializer.writeFloat(new Float(this.loc.getZ()));
-		packetdataserializer.writeFloat(new Float(this.vector.getX()));
-		packetdataserializer.writeFloat(new Float(this.vector.getY()));
-		packetdataserializer.writeFloat(new Float(this.vector.getZ()));
-		packetdataserializer.writeFloat(data);
-		packetdataserializer.writeInt(count);
-		for (Integer o : p_data)
-			packetdataserializer.writeVarInt((int) o);
-	}
-	
-	public boolean isFar() {
-		return far;
-	}
-	
-	public void setFar(boolean j) {
-		this.far = j;
-	}
-	
-	public int[] getMetaData() {
-		return p_data;
-	}
-	
-	public void setMetaData(int[] p_data) {
-		this.p_data = p_data;
-	}
-	
+
+    // 1.8
+    boolean far;
+    int[] p_data;
+    private int count;
+    private float data;
+    private Location loc;
+    private ParticleEffect name;
+    private Vector vector;
+
+    public PacketPlayOutWorldParticles() {
+        super(0x2A);
+    }
+
+    public PacketPlayOutWorldParticles(ParticleEffect s, Location loc, Vector v, float f6, int i, int... pdata) {
+        this.name = s;
+        this.loc = loc;
+        this.vector = v;
+        this.data = f6;
+        this.count = i;
+        this.p_data = pdata;
+    }
+
+    public PacketPlayOutWorldParticles(ParticleEffect s, Location loc, Vector v, float f6, int i, boolean far, int... pdata) {
+        this.name = s;
+        this.loc = loc;
+        this.vector = v;
+        this.data = f6;
+        this.count = i;
+        this.p_data = pdata;
+        this.far = far;
+    }
+
+    public int getCount() {
+        return count;
+    }
+
+    public void setCount(int count) {
+        this.count = count;
+    }
+
+    public float getData() {
+        return data;
+    }
+
+    public void setData(float data) {
+        this.data = data;
+    }
+
+    public Location getLoc() {
+        return loc;
+    }
+
+    public void setLoc(Location loc) {
+        this.loc = loc;
+    }
+
+    public ParticleEffect getParticle() {
+        return name;
+    }
+
+    public void setParticle(ParticleEffect name) {
+        this.name = name;
+    }
+
+    public Vector getVector() {
+        return vector;
+    }
+
+    public void setVector(Vector vector) {
+        this.vector = vector;
+    }
+
+    @Override
+    public void read(PacketDataSerializer packetdataserializer) {
+        this.name = ParticleEffect.fromId(packetdataserializer.readInt());
+        this.far = packetdataserializer.readBoolean();
+        loc = new Location(packetdataserializer.readFloat(), packetdataserializer.readFloat(), packetdataserializer.readFloat());
+        vector = new Vector(packetdataserializer.readFloat(), packetdataserializer.readFloat(), packetdataserializer.readFloat());
+        this.data = packetdataserializer.readFloat();
+        this.count = packetdataserializer.readInt();
+        ArrayList<Integer> a = new ArrayList<Integer>();
+        while (packetdataserializer.readableBytes() > 0) {
+            a.add(packetdataserializer.readVarInt());
+        }
+        this.p_data = new int[a.size()];
+        int pos = 0;
+        for (Integer i : a) {
+            p_data[pos] = i;
+            pos++;
+        }
+    }
+
+    @Override
+    public String toString() {
+        return "PacketPlayOutWorldParticles [count=" + count + ", data=" + data + ", loc=" + loc + ", name=" + name + ", vector=" + vector + ", j=" + far + ", p_data=" + Arrays.toString(p_data) + "]";
+    }
+
+    @Override
+    public void write(PacketDataSerializer packetdataserializer) {
+        packetdataserializer.writeInt(this.name.getId());
+        packetdataserializer.writeBoolean(this.far);
+        packetdataserializer.writeFloat(new Float(this.loc.getX()));
+        packetdataserializer.writeFloat(new Float(this.loc.getY()));
+        packetdataserializer.writeFloat(new Float(this.loc.getZ()));
+        packetdataserializer.writeFloat(new Float(this.vector.getX()));
+        packetdataserializer.writeFloat(new Float(this.vector.getY()));
+        packetdataserializer.writeFloat(new Float(this.vector.getZ()));
+        packetdataserializer.writeFloat(data);
+        packetdataserializer.writeInt(count);
+        for (Integer o : p_data)
+            packetdataserializer.writeVarInt((int) o);
+    }
+
+    public boolean isFar() {
+        return far;
+    }
+
+    public void setFar(boolean j) {
+        this.far = j;
+    }
+
+    public int[] getMetaData() {
+        return p_data;
+    }
+
+    public void setMetaData(int[] p_data) {
+        this.p_data = p_data;
+    }
+
 }
diff --git a/src/main/java/dev/wolveringer/BungeeUtil/packets/UnderknownPacket.java b/src/main/java/dev/wolveringer/BungeeUtil/packets/UnderknownPacket.java
index 3e05648..d536d99 100644
--- a/src/main/java/dev/wolveringer/BungeeUtil/packets/UnderknownPacket.java
+++ b/src/main/java/dev/wolveringer/BungeeUtil/packets/UnderknownPacket.java
@@ -5,16 +5,16 @@ import dev.wolveringer.packet.PacketDataSerializer;
 @SuppressWarnings("deprecation")
 public class UnderknownPacket extends Packet {
 
-	byte[] data;
+    byte[] data;
 
-	@Override
-	public void read(PacketDataSerializer s) {
-		data = new byte[s.readableBytes()];
-		s.readBytes(data);
-	}
+    @Override
+    public void read(PacketDataSerializer s) {
+        data = new byte[s.readableBytes()];
+        s.readBytes(data);
+    }
 
-	@Override
-	public void write(PacketDataSerializer s) {
-		s.writeBytes(data);
-	}
+    @Override
+    public void write(PacketDataSerializer s) {
+        s.writeBytes(data);
+    }
 }
diff --git a/src/main/java/dev/wolveringer/NPC/Equipment.java b/src/main/java/dev/wolveringer/NPC/Equipment.java
index ece0452..0951d48 100644
--- a/src/main/java/dev/wolveringer/NPC/Equipment.java
+++ b/src/main/java/dev/wolveringer/NPC/Equipment.java
@@ -6,67 +6,77 @@ import dev.wolveringer.BungeeUtil.packets.PacketPlayOutEntityEquipment;
 import dev.wolveringer.BungeeUtil.packets.PacketPlayOutEntityEquipment.Slot;
 
 public final class Equipment {
-	//0: Hand 1: Off hand 2: boots, 3: leggings, 4: chestplate, 5: helmet
-	private NPC handle;
-	private Item[] contains = new Item[6];
-	
-	public Equipment(NPC handle) {
-		this.handle = handle;
-	}
-	
-	public Item getHelmet() {
-		return contains[5];
-	}
-	public Item getChestplate() {
-		return contains[4];
-	}
-	public Item getLeggins() {
-		return contains[3];
-	}
-	public Item getBoots() {
-		return contains[2];
-	}
-	public Item getItemInHand(){
-		return contains[0];
-	}
-	public Item getItemInOffHand(){
-		return contains[1];
-	}
-	
-	public void setHelmet(Item head) {
-		this.contains[5] = head;
-		sendUpdate(5, head);
-	}
-	public void setLeggins(Item leggins) {
-		this.contains[3] = leggins;
-		sendUpdate(3, leggins);
-	}
-	public void setBoots(Item boots) {
-		this.contains[2] = boots;
-		sendUpdate(2,boots);	
-	}
-	public void setChestplate(Item chestplate) {
-		this.contains[4] = chestplate;
-		sendUpdate(4,chestplate);
-	}
-	public void setItemInHand(Item item){
-		this.contains[0] = item;
-		sendUpdate(0, item);
-	}
-	public void setItemInOffHand(Item item){
-		this.contains[1] = item;
-		sendUpdate(1, item);
-	}
-	
-	private void sendUpdate(int slot,Item i){
-		for(Player p : handle.getViewer())
-			p.sendPacket(new PacketPlayOutEntityEquipment(handle.getEntityID(), i, Slot.values()[slot]));
-	}
-	
-	protected void sendItems(Player p){
-		for(int i = 0;i < contains.length;i++){
-			if(contains[i] != null)
-				p.sendPacket(new PacketPlayOutEntityEquipment(handle.getEntityID(), contains[i], Slot.values()[i]));
-		}
-	}
+    //0: Hand 1: Off hand 2: boots, 3: leggings, 4: chestplate, 5: helmet
+    private NPC handle;
+    private Item[] contains = new Item[6];
+
+    public Equipment(NPC handle) {
+        this.handle = handle;
+    }
+
+    public Item getHelmet() {
+        return contains[5];
+    }
+
+    public void setHelmet(Item head) {
+        this.contains[5] = head;
+        sendUpdate(5, head);
+    }
+
+    public Item getChestplate() {
+        return contains[4];
+    }
+
+    public void setChestplate(Item chestplate) {
+        this.contains[4] = chestplate;
+        sendUpdate(4, chestplate);
+    }
+
+    public Item getLeggins() {
+        return contains[3];
+    }
+
+    public void setLeggins(Item leggins) {
+        this.contains[3] = leggins;
+        sendUpdate(3, leggins);
+    }
+
+    public Item getBoots() {
+        return contains[2];
+    }
+
+    public void setBoots(Item boots) {
+        this.contains[2] = boots;
+        sendUpdate(2, boots);
+    }
+
+    public Item getItemInHand() {
+        return contains[0];
+    }
+
+    public void setItemInHand(Item item) {
+        this.contains[0] = item;
+        sendUpdate(0, item);
+    }
+
+    public Item getItemInOffHand() {
+        return contains[1];
+    }
+
+    public void setItemInOffHand(Item item) {
+        this.contains[1] = item;
+        sendUpdate(1, item);
+    }
+
+    private void sendUpdate(int slot, Item i) {
+        for (Player p : handle.getViewer())
+            p.sendPacket(new PacketPlayOutEntityEquipment(handle.getEntityID(), i, Slot.values()[slot]));
+    }
+
+    protected void sendItems(Player p) {
+        for (int i = 0; i < contains.length; i++) {
+            if (contains[i] != null)
+                p.sendPacket(new PacketPlayOutEntityEquipment(handle.getEntityID(), contains[i], Slot.values()[i]));
+        }
+    }
 }
diff --git a/src/main/java/dev/wolveringer/NPC/InteractListener.java b/src/main/java/dev/wolveringer/NPC/InteractListener.java
index 212fe86..be99560 100644
--- a/src/main/java/dev/wolveringer/NPC/InteractListener.java
+++ b/src/main/java/dev/wolveringer/NPC/InteractListener.java
@@ -3,6 +3,7 @@ package dev.wolveringer.NPC;
 import dev.wolveringer.BungeeUtil.Player;
 
 public interface InteractListener {
-	public void rightClick(Player p);
-	public void leftClick(Player p);
+    public void rightClick(Player p);
+
+    public void leftClick(Player p);
 }
diff --git a/src/main/java/dev/wolveringer/NPC/NPC.java b/src/main/java/dev/wolveringer/NPC/NPC.java
index d0a953b..ce4bfe0 100644
--- a/src/main/java/dev/wolveringer/NPC/NPC.java
+++ b/src/main/java/dev/wolveringer/NPC/NPC.java
@@ -5,7 +5,6 @@ import java.util.List;
 import java.util.Random;
 import java.util.UUID;
 
-import dev.wolveringer.BungeeUtil.ClientVersion.BigClientVersion;
 import dev.wolveringer.BungeeUtil.PacketHandleEvent;
 import dev.wolveringer.BungeeUtil.PacketHandler;
 import dev.wolveringer.BungeeUtil.PacketLib;
@@ -13,7 +12,7 @@ import dev.wolveringer.BungeeUtil.Player;
 import dev.wolveringer.BungeeUtil.gameprofile.GameProfile;
 import dev.wolveringer.BungeeUtil.gameprofile.PlayerInfoData;
 import dev.wolveringer.BungeeUtil.gameprofile.Skin;
-import dev.wolveringer.BungeeUtil.gameprofile.SkinFactory;
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
 import dev.wolveringer.BungeeUtil.packets.Packet;
 import dev.wolveringer.BungeeUtil.packets.PacketPlayInUseEntity;
 import dev.wolveringer.BungeeUtil.packets.PacketPlayInUseEntity.Action;
@@ -25,307 +24,314 @@ import dev.wolveringer.BungeeUtil.packets.PacketPlayOutPlayerInfo;
 import dev.wolveringer.BungeeUtil.packets.PacketPlayOutPlayerInfo.EnumPlayerInfoAction;
 import dev.wolveringer.BungeeUtil.packets.PacketPlayOutScoreboardTeam;
 import dev.wolveringer.BungeeUtil.packets.PacketPlayOutScoreboardTeam.NameTag;
-import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
-import dev.wolveringer.api.datawatcher.DataWatcher;
 import dev.wolveringer.api.datawatcher.HumanDataWatcher;
 import dev.wolveringer.api.position.Location;
 import dev.wolveringer.chat.IChatBaseComponent;
 
 public final class NPC {
-	private static final Random RND_NAME = new Random();
-	private static ArrayList<String> base_names = new ArrayList<>();
-	private static int npc_count = 1000;
-	private PacketPlayOutEntityDestroy p2;
-	
-	private int ID;
-	private NPCData datawatcher = new NPCData();
-	
-	private ArrayList<Player> viewer = new ArrayList<Player>();
-	private NameSpliter name;
-	private String base_name;
-	private Location location;
-	
-	private int ping = 20;
-	
-	private GameProfile profile = new GameProfile(UUID.randomUUID(), "");
-	
-	private boolean tab;
-	
-	private ArrayList<InteractListener> listener = new ArrayList<InteractListener>();
-	
-	private IChatBaseComponent tabname = null;
-	
-	private PacketHandler<Packet> handler;
-	
-	private Equipment equipment = new Equipment(this);
-	
-	public NPC() {
-		this((System.currentTimeMillis() + "_0x" + Integer.toHexString(RND_NAME.nextInt()) + "00000000000000000").substring(0, 16));
-	}
-	
-	public NPC(String base_name) {
-		if (base_name.length() > 16) throw new NullPointerException("Base Name cant be longer than 16!");
-		if (base_names.contains(base_name)) throw new IllegalArgumentException("Base name is alredy in use!");
-		base_names.add(base_name);
-		this.ID = npc_count++;
-		this.base_name = base_name;
-		
-		this.name = new NameSpliter();
-		name.setOrginal(base_name);
-		
-		this.profile.setName(base_name);
-		this.location = new Location(0, 0, 0);
-		handler = new PacketHandler<Packet>() {
-			@SuppressWarnings("unchecked")
-			@Override
-			public void handle(PacketHandleEvent<Packet> e) {
-				if (e.getPacket() instanceof PacketPlayInUseEntity) {
-					PacketPlayInUseEntity packet = (PacketPlayInUseEntity) e.getPacket();
-					if (packet.getTarget() == ID) {
-						if (packet.getAction() == Action.ATTACK) for (InteractListener listener : (List<InteractListener>) NPC.this.listener.clone())
-							listener.leftClick(e.getPlayer());
-						else if (packet.getAction() == Action.INTERACT_AT && packet.getHand() == 0) // 1.9 sends 2 Packets (Hand 0 and hand 1)
-		                    for (InteractListener listener : (List<InteractListener>) NPC.this.listener.clone())
-							listener.rightClick(e.getPlayer());
-						e.setCancelled(true);
-					}
-				}
-			}
-		};
-		datawatcher.injektDefault();
-		PacketLib.addHandler(handler);
-		rebuild();
-	}
-	
-	public void setPing(int ping) {
-		this.ping = ping;
-		if (tab) broadcastPacket(new PacketPlayOutPlayerInfo(EnumPlayerInfoAction.UPDATE_PING, new PlayerInfoData(profile, ping, 0, tabname)));
-	}
-	
-	public int getPing() {
-		return ping;
-	}
-	
-	public void setVisiable(Player p, boolean b) {
-		if (b) if (!viewer.contains(p)) show(p);
-		else;
-		else if (viewer.contains(p)) hide(p);
-	}
-	
-	public boolean canSee(Player p) {
-		return viewer.contains(p);
-	}
-	
-	public String getName() {
-		return name.getOrginal();
-	}
-	
-	public void setName(String name) {
-		if (name.length() > 48) throw new NullPointerException(name.length() + " > 48");
-		this.name.setOrginal(name);
-		this.profile.setName(this.name.getMain());
-		rebuild();
-		for (Player p : viewer) {
-			sendDestroy(p);
-			sendSpawn(p);
-		}
-	}
-	
-	public Location getLocation() {
-		return location;
-	}
-	
-	public void setLocation(Location location) {
-		this.location = location;
-		rebuild();
-		broadcastPacket(new PacketPlayOutEntityTeleport(ID, location));
-		broadcastPacket(new PacketPlayOutEntityHeadRotation(ID, location.getYaw()));
-	}
-	
-	public HumanDataWatcher getDatawatcher() {
-		return datawatcher;
-	}
-	
-	public GameProfile getProfile() {
-		return profile;
-	}
-	
-	public void setSkin(Skin skin) {
-		skin.applay(this.profile);
-		setProfile(this.profile);
-	}
-	
-	public void setProfile(GameProfile profile) {
-		this.profile = profile;
-		if (this.profile == null) this.profile = new GameProfile(UUID.randomUUID(), this.name.getMain());
-		if (this.profile.getName() == null) {
-			System.err.print("Name of the GameProfile cant be null");
-			this.profile.setName("error");
-		}
-		rebuild();
-		ArrayList<Player> player = new ArrayList<>(viewer);
-		for (Player p : player) {
-			hide(p);
-			show(p);
-		}
-	}
-	
-	public void setTabListed(boolean listed) {
-		if (tab != listed) if (tab) broadcastPacket(new PacketPlayOutPlayerInfo(EnumPlayerInfoAction.ADD_PLAYER, new PlayerInfoData(profile, ping, 0, (IChatBaseComponent) tabname)));
-		else broadcastPacket(new PacketPlayOutPlayerInfo(EnumPlayerInfoAction.REMOVE_PLAYER, new PlayerInfoData(profile, ping, 0, tabname)));
-		this.tab = listed;
-	}
-	
-	public boolean isTabListed() {
-		return tab;
-	}
-	
-	public void setPlayerListName(IChatBaseComponent name) {
-		this.tabname = name;
-		broadcastPacket(new PacketPlayOutPlayerInfo(EnumPlayerInfoAction.UPDATE_DISPLAY_NAME, new PlayerInfoData(profile, ping, 0, tabname)));
-	}
-	
-	public IChatBaseComponent getPlayerListName() {
-		return tabname;
-	}
-	
-	public void addListener(InteractListener listener) {
-		this.listener.add(listener);
-	}
-	
-	public void removeListener(InteractListener listener) {
-		this.listener.remove(listener);
-	}
-	
-	public Equipment getEquipment() {
-		return equipment;
-	}
-	
-	private void hide(Player p) {
-		viewer.remove(p);
-		sendDestroy(p);
-	}
-	
-	private void show(Player p) {
-		viewer.add(p);
-		sendSpawn(p);
-	}
-
-	/**
-	 * Contains spelling mistake
-	 * @deprecated Use {@link #broadcastPacket(Packet a)} instead.  
-	 */
-	@Deprecated
-	private void brotcastPacket(Packet p) {
-		broadcastPacket(p);
-	}
-	
-	private void broadcastPacket(Packet p) {
-		for (Player pl : viewer)
-			pl.sendPacket((PacketPlayOut) p);
-	}
-	
-	private void sendSpawn(final Player p) {
-		p.sendPacket(new PacketPlayOutPlayerInfo(EnumPlayerInfoAction.ADD_PLAYER, new PlayerInfoData(profile, ping, 0, (IChatBaseComponent) tabname)));
-		p.sendPacket(new PacketPlayOutNamedEntitySpawn(ID, profile, location, 0, datawatcher.getWatcher(p.getVersion().getBigVersion())));
-		
-		PacketPlayOutScoreboardTeam team = new PacketPlayOutScoreboardTeam();
-		team.setTeam(base_name);
-		team.setDisplayName("Error (NCP-Team): 002");
-		team.setAction(PacketPlayOutScoreboardTeam.Action.CREATE);
-		team.setPrefix(name.getPrefix());
-		team.setSuffix(name.getSuffix());
-		team.setFriendlyFire(0);
-		team.setPlayers(new String[] { profile.getName() });
-		team.setTag(NameTag.VISIABLE);
-		p.sendPacket(team);
-		
-		p.sendPacket(new PacketPlayOutEntityHeadRotation(ID, p.getLocation().getYaw()));
-		
-		if (!tab) p.sendPacket(new PacketPlayOutPlayerInfo(EnumPlayerInfoAction.REMOVE_PLAYER, new PlayerInfoData(profile, ping, 0, tabname)));
-		else p.sendPacket(new PacketPlayOutPlayerInfo(EnumPlayerInfoAction.UPDATE_DISPLAY_NAME, new PlayerInfoData(profile, ping, 0, (IChatBaseComponent) tabname)));
-		equipment.sendItems(p);
-	}
-	
-	private void sendDestroy(Player p) {
-		if (tab) p.sendPacket(new PacketPlayOutPlayerInfo(EnumPlayerInfoAction.REMOVE_PLAYER, new PlayerInfoData(profile, ping, 0, (IChatBaseComponent) null)));
-		PacketPlayOutScoreboardTeam team = new PacketPlayOutScoreboardTeam();
-		team.setTeam(base_name);
-		team.setAction(PacketPlayOutScoreboardTeam.Action.REMOVE);
-		p.sendPacket(team);
-		p.sendPacket(p2);
-	}
-	
-	protected void rebuild() {
-		if (this.profile == null) {
-			System.err.print("NPC Profile is null. it will crash the Client");
-			this.profile = new GameProfile(UUID.randomUUID(), this.name.getMain());
-		}
-		p2 = new PacketPlayOutEntityDestroy(ID);
-	}
-	
-	public void delete() {
-		for (Player p : viewer)
-			sendDestroy(p);
-		viewer.clear();
-		try {
-			finalize();
-		}
-		catch (Throwable e) {
-			e.printStackTrace();
-		}
-	}
-	
-	public int getEntityID() {
-		return ID;
-	}
-	
-	protected ArrayList<Player> getViewer() {
-		return viewer;
-	}
-	
-	@Override
-	protected void finalize() throws Throwable {
-		PacketLib.removeHandler(handler);
-		base_names.remove(base_name);
-		super.finalize();
-	}
+    private static final Random RND_NAME = new Random();
+    private static ArrayList<String> base_names = new ArrayList<>();
+    private static int npc_count = 1000;
+    private PacketPlayOutEntityDestroy p2;
+
+    private int ID;
+    private NPCData datawatcher = new NPCData();
+
+    private ArrayList<Player> viewer = new ArrayList<Player>();
+    private NameSpliter name;
+    private String base_name;
+    private Location location;
+
+    private int ping = 20;
+
+    private GameProfile profile = new GameProfile(UUID.randomUUID(), "");
+
+    private boolean tab;
+
+    private ArrayList<InteractListener> listener = new ArrayList<InteractListener>();
+
+    private IChatBaseComponent tabname = null;
+
+    private PacketHandler<Packet> handler;
+
+    private Equipment equipment = new Equipment(this);
+
+    public NPC() {
+        this((System.currentTimeMillis() + "_0x" + Integer.toHexString(RND_NAME.nextInt()) + "00000000000000000").substring(0, 16));
+    }
+
+    public NPC(String base_name) {
+        if (base_name.length() > 16)
+            throw new NullPointerException("Base Name cant be longer than 16!");
+        if (base_names.contains(base_name))
+            throw new IllegalArgumentException("Base name is alredy in use!");
+        base_names.add(base_name);
+        this.ID = npc_count++;
+        this.base_name = base_name;
+
+        this.name = new NameSpliter();
+        name.setOrginal(base_name);
+
+        this.profile.setName(base_name);
+        this.location = new Location(0, 0, 0);
+        handler = new PacketHandler<Packet>() {
+            @SuppressWarnings("unchecked")
+            @Override
+            public void handle(PacketHandleEvent<Packet> e) {
+                if (e.getPacket() instanceof PacketPlayInUseEntity) {
+                    PacketPlayInUseEntity packet = (PacketPlayInUseEntity) e.getPacket();
+                    if (packet.getTarget() == ID) {
+                        if (packet.getAction() == Action.ATTACK)
+                            for (InteractListener listener : (List<InteractListener>) NPC.this.listener.clone())
+                                listener.leftClick(e.getPlayer());
+                        else if (packet.getAction() == Action.INTERACT_AT && packet.getHand() == 0) // 1.9 sends 2 Packets (Hand 0 and hand 1)
+                            for (InteractListener listener : (List<InteractListener>) NPC.this.listener.clone())
+                                listener.rightClick(e.getPlayer());
+                        e.setCancelled(true);
+                    }
+                }
+            }
+        };
+        datawatcher.injektDefault();
+        PacketLib.addHandler(handler);
+        rebuild();
+    }
+
+    public int getPing() {
+        return ping;
+    }
+
+    public void setPing(int ping) {
+        this.ping = ping;
+        if (tab)
+            broadcastPacket(new PacketPlayOutPlayerInfo(EnumPlayerInfoAction.UPDATE_PING, new PlayerInfoData(profile, ping, 0, tabname)));
+    }
+
+    public void setVisiable(Player p, boolean b) {
+        if (b) if (!viewer.contains(p)) show(p);
+        else ;
+        else if (viewer.contains(p)) hide(p);
+    }
+
+    public boolean canSee(Player p) {
+        return viewer.contains(p);
+    }
+
+    public String getName() {
+        return name.getOrginal();
+    }
+
+    public void setName(String name) {
+        if (name.length() > 48) throw new NullPointerException(name.length() + " > 48");
+        this.name.setOrginal(name);
+        this.profile.setName(this.name.getMain());
+        rebuild();
+        for (Player p : viewer) {
+            sendDestroy(p);
+            sendSpawn(p);
+        }
+    }
+
+    public Location getLocation() {
+        return location;
+    }
+
+    public void setLocation(Location location) {
+        this.location = location;
+        rebuild();
+        broadcastPacket(new PacketPlayOutEntityTeleport(ID, location));
+        broadcastPacket(new PacketPlayOutEntityHeadRotation(ID, location.getYaw()));
+    }
+
+    public HumanDataWatcher getDatawatcher() {
+        return datawatcher;
+    }
+
+    public GameProfile getProfile() {
+        return profile;
+    }
+
+    public void setProfile(GameProfile profile) {
+        this.profile = profile;
+        if (this.profile == null)
+            this.profile = new GameProfile(UUID.randomUUID(), this.name.getMain());
+        if (this.profile.getName() == null) {
+            System.err.print("Name of the GameProfile cant be null");
+            this.profile.setName("error");
+        }
+        rebuild();
+        ArrayList<Player> player = new ArrayList<>(viewer);
+        for (Player p : player) {
+            hide(p);
+            show(p);
+        }
+    }
+
+    public void setSkin(Skin skin) {
+        skin.applay(this.profile);
+        setProfile(this.profile);
+    }
+
+    public boolean isTabListed() {
+        return tab;
+    }
+
+    public void setTabListed(boolean listed) {
+        if (tab != listed) if (tab)
+            broadcastPacket(new PacketPlayOutPlayerInfo(EnumPlayerInfoAction.ADD_PLAYER, new PlayerInfoData(profile, ping, 0, (IChatBaseComponent) tabname)));
+        else
+            broadcastPacket(new PacketPlayOutPlayerInfo(EnumPlayerInfoAction.REMOVE_PLAYER, new PlayerInfoData(profile, ping, 0, tabname)));
+        this.tab = listed;
+    }
+
+    public IChatBaseComponent getPlayerListName() {
+        return tabname;
+    }
+
+    public void setPlayerListName(IChatBaseComponent name) {
+        this.tabname = name;
+        broadcastPacket(new PacketPlayOutPlayerInfo(EnumPlayerInfoAction.UPDATE_DISPLAY_NAME, new PlayerInfoData(profile, ping, 0, tabname)));
+    }
+
+    public void addListener(InteractListener listener) {
+        this.listener.add(listener);
+    }
+
+    public void removeListener(InteractListener listener) {
+        this.listener.remove(listener);
+    }
+
+    public Equipment getEquipment() {
+        return equipment;
+    }
+
+    private void hide(Player p) {
+        viewer.remove(p);
+        sendDestroy(p);
+    }
+
+    private void show(Player p) {
+        viewer.add(p);
+        sendSpawn(p);
+    }
+
+    /**
+     * Contains spelling mistake
+     *
+     * @deprecated Use {@link #broadcastPacket(Packet a)} instead.
+     */
+    @Deprecated
+    private void brotcastPacket(Packet p) {
+        broadcastPacket(p);
+    }
+
+    private void broadcastPacket(Packet p) {
+        for (Player pl : viewer)
+            pl.sendPacket((PacketPlayOut) p);
+    }
+
+    private void sendSpawn(final Player p) {
+        p.sendPacket(new PacketPlayOutPlayerInfo(EnumPlayerInfoAction.ADD_PLAYER, new PlayerInfoData(profile, ping, 0, (IChatBaseComponent) tabname)));
+        p.sendPacket(new PacketPlayOutNamedEntitySpawn(ID, profile, location, 0, datawatcher.getWatcher(p.getVersion().getBigVersion())));
+
+        PacketPlayOutScoreboardTeam team = new PacketPlayOutScoreboardTeam();
+        team.setTeam(base_name);
+        team.setDisplayName("Error (NCP-Team): 002");
+        team.setAction(PacketPlayOutScoreboardTeam.Action.CREATE);
+        team.setPrefix(name.getPrefix());
+        team.setSuffix(name.getSuffix());
+        team.setFriendlyFire(0);
+        team.setPlayers(new String[]{profile.getName()});
+        team.setTag(NameTag.VISIABLE);
+        p.sendPacket(team);
+
+        p.sendPacket(new PacketPlayOutEntityHeadRotation(ID, p.getLocation().getYaw()));
+
+        if (!tab)
+            p.sendPacket(new PacketPlayOutPlayerInfo(EnumPlayerInfoAction.REMOVE_PLAYER, new PlayerInfoData(profile, ping, 0, tabname)));
+        else
+            p.sendPacket(new PacketPlayOutPlayerInfo(EnumPlayerInfoAction.UPDATE_DISPLAY_NAME, new PlayerInfoData(profile, ping, 0, (IChatBaseComponent) tabname)));
+        equipment.sendItems(p);
+    }
+
+    private void sendDestroy(Player p) {
+        if (tab)
+            p.sendPacket(new PacketPlayOutPlayerInfo(EnumPlayerInfoAction.REMOVE_PLAYER, new PlayerInfoData(profile, ping, 0, (IChatBaseComponent) null)));
+        PacketPlayOutScoreboardTeam team = new PacketPlayOutScoreboardTeam();
+        team.setTeam(base_name);
+        team.setAction(PacketPlayOutScoreboardTeam.Action.REMOVE);
+        p.sendPacket(team);
+        p.sendPacket(p2);
+    }
+
+    protected void rebuild() {
+        if (this.profile == null) {
+            System.err.print("NPC Profile is null. it will crash the Client");
+            this.profile = new GameProfile(UUID.randomUUID(), this.name.getMain());
+        }
+        p2 = new PacketPlayOutEntityDestroy(ID);
+    }
+
+    public void delete() {
+        for (Player p : viewer)
+            sendDestroy(p);
+        viewer.clear();
+        try {
+            finalize();
+        } catch (Throwable e) {
+            e.printStackTrace();
+        }
+    }
+
+    public int getEntityID() {
+        return ID;
+    }
+
+    protected ArrayList<Player> getViewer() {
+        return viewer;
+    }
+
+    @Override
+    protected void finalize() throws Throwable {
+        PacketLib.removeHandler(handler);
+        base_names.remove(base_name);
+        super.finalize();
+    }
 }
 
 class NameSpliter {
-	private String orginal;
-	private String main, prefix, suffix;
-	
-	public String getPrefix() {
-		return prefix;
-	}
-	
-	public String getSuffix() {
-		return suffix;
-	}
-	
-	public String getMain() {
-		return main;
-	}
-	
-	public String getOrginal() {
-		return orginal;
-	}
-	
-	public void setOrginal(String orginal) {
-		this.orginal = orginal;
-		recalculate();
-	}
-	
-	private void recalculate() {
-		if (orginal.length() > 16) {
-			prefix = orginal.length() > 30 ? orginal.substring(0, 15) : "";
-			main = orginal.length() > 30 ? orginal.substring(15, orginal.length() < 30 ? orginal.length() : 30) : orginal.substring(0, 15);
-			suffix = orginal.length() > 30 ? orginal.substring(30, orginal.length() > 45 ? 45 : orginal.length()) : orginal.substring(15, orginal.length() > 30 ? 30 : orginal.length());
-		}
-		else {
-			prefix = suffix = "";
-			main = orginal;
-		}
-	}
+    private String orginal;
+    private String main, prefix, suffix;
+
+    public String getPrefix() {
+        return prefix;
+    }
+
+    public String getSuffix() {
+        return suffix;
+    }
+
+    public String getMain() {
+        return main;
+    }
+
+    public String getOrginal() {
+        return orginal;
+    }
+
+    public void setOrginal(String orginal) {
+        this.orginal = orginal;
+        recalculate();
+    }
+
+    private void recalculate() {
+        if (orginal.length() > 16) {
+            prefix = orginal.length() > 30 ? orginal.substring(0, 15) : "";
+            main = orginal.length() > 30 ? orginal.substring(15, orginal.length() < 30 ? orginal.length() : 30) : orginal.substring(0, 15);
+            suffix = orginal.length() > 30 ? orginal.substring(30, orginal.length() > 45 ? 45 : orginal.length()) : orginal.substring(15, orginal.length() > 30 ? 30 : orginal.length());
+        } else {
+            prefix = suffix = "";
+            main = orginal;
+        }
+    }
 }
diff --git a/src/main/java/dev/wolveringer/NPC/NPCData.java b/src/main/java/dev/wolveringer/NPC/NPCData.java
index 7a53b4e..259fce5 100644
--- a/src/main/java/dev/wolveringer/NPC/NPCData.java
+++ b/src/main/java/dev/wolveringer/NPC/NPCData.java
@@ -7,331 +7,331 @@ import dev.wolveringer.api.datawatcher.DataWatcher;
 import dev.wolveringer.api.datawatcher.HumanDataWatcher;
 
 public class NPCData implements HumanDataWatcher {
-	private HumanDataWatcher v1_8;
-	private HumanDataWatcher v1_9;
-	private HumanDataWatcher v1_10;
-	
-	public NPCData() {
-		v1_8 = DataWatcher.createDataWatcher(BigClientVersion.v1_8).getSpecialDataWatcher(HumanDataWatcher.class);
-		v1_9 = DataWatcher.createDataWatcher(BigClientVersion.v1_9).getSpecialDataWatcher(HumanDataWatcher.class);
-		v1_10 = DataWatcher.createDataWatcher(BigClientVersion.v1_10).getSpecialDataWatcher(HumanDataWatcher.class);
-	}
-	
-	public boolean isSneaking() {
-		return v1_8.isSneaking();
-	}
-	
-	public void setSkinFlags(final byte flag) {
-		applay(new Function<HumanDataWatcher, Void>() {
-			@Override
-			public Void apply(HumanDataWatcher arg0) {
-				arg0.setSkinFlags(flag);
-				return null;
-			}
-		});
-	}
-	
-	public void setHealth(final float h) {
-		applay(new Function<HumanDataWatcher, Void>() {
-			@Override
-			public Void apply(HumanDataWatcher arg0) {
-				arg0.setHealth(h);
-				return null;
-			}
-		});
-	}
-	
-	public void setSneaking(final boolean flag) {
-		applay(new Function<HumanDataWatcher, Void>() {
-			@Override
-			public Void apply(HumanDataWatcher arg0) {
-				arg0.setSneaking(flag);
-				return null;
-			}
-		});
-	}
-	
-	public byte getSkinFlag() {
-		return v1_8.getSkinFlag();
-	}
-	
-	public float getHealth() {
-		return v1_8.getHealth();
-	}
-	
-	public boolean isSprinting() {
-		return v1_8.isSprinting();
-	}
-	
-	public void setCapeActive(final boolean b) {
-		applay(new Function<HumanDataWatcher, Void>() {
-			@Override
-			public Void apply(HumanDataWatcher arg0) {
-				arg0.setCapeActive(b);
-				return null;
-			}
-		});
-	}
-	
-	public void setArrows(final int amauth) {
-		applay(new Function<HumanDataWatcher, Void>() {
-			@Override
-			public Void apply(HumanDataWatcher arg0) {
-				arg0.setArrows(amauth);
-				return null;
-			}
-		});
-	}
-	
-	public void setSprinting(final boolean flag) {
-		applay(new Function<HumanDataWatcher, Void>() {
-			@Override
-			public Void apply(HumanDataWatcher arg0) {
-				arg0.setSprinting(flag);
-				return null;
-			}
-		});
-	}
-	
-	public boolean isCapeActive() {
-		return v1_8.isCapeActive();
-	}
-	
-	public int getArrows() {
-		return v1_8.getArrows();
-	}
-	
-	public boolean isInvisible() {
-		return v1_8.isInvisible();
-	}
-	
-	public void setParicelColor(final int color) {
-		applay(new Function<HumanDataWatcher, Void>() {
-			@Override
-			public Void apply(HumanDataWatcher arg0) {
-				arg0.setParicelColor(color);
-				return null;
-			}
-		});
-	}
-	
-	public void setAbsorptionHearts(final float f) {
-		applay(new Function<HumanDataWatcher, Void>() {
-			@Override
-			public Void apply(HumanDataWatcher arg0) {
-				arg0.setAbsorptionHearts(f);
-				return null;
-			}
-		});
-	}
-	
-	public void setInvisible(final boolean flag) {
-		applay(new Function<HumanDataWatcher, Void>() {
-			@Override
-			public Void apply(HumanDataWatcher arg0) {
-				arg0.setInvisible(flag);
-				return null;
-			}
-		});
-	}
-	
-	public float getAbsorptionHearts() {
-		return v1_8.getAbsorptionHearts();
-	}
-	
-	public int getParicelColor() {
-		return v1_8.getParicelColor();
-	}
-	
-	public boolean isOnFire() {
-		return v1_8.isOnFire();
-	}
-	
-	public void setParticelVisiable(final boolean flag) {
-		applay(new Function<HumanDataWatcher, Void>() {
-			@Override
-			public Void apply(HumanDataWatcher arg0) {
-				arg0.setParticelVisiable(flag);
-				return null;
-			}
-		});
-	}
-	
-	public void setScore(final int score) {
-		applay(new Function<HumanDataWatcher, Void>() {
-			@Override
-			public Void apply(HumanDataWatcher arg0) {
-				arg0.setScore(score);
-				return null;
-			}
-		});
-	}
-	
-	public int getScore() {
-		return v1_8.getScore();
-	}
-	
-	public boolean isParticelVisiable() {
-		return v1_8.isParticelVisiable();
-	}
-	
-	public void setOnFire(final boolean fire) {
-		applay(new Function<HumanDataWatcher, Void>() {
-			@Override
-			public Void apply(HumanDataWatcher arg0) {
-				arg0.setOnFire(fire);
-				return null;
-			}
-		});
-	}
-	
-	public HumanDataWatcher injektDefault() {
-		v1_9.injektDefault();
-		v1_10.injektDefault();
-		return v1_8.injektDefault();
-	}
-	
-	public void setAI(final boolean flag) {
-		v1_8.setAI(flag);
-	}
-	
-	public boolean isBlocking() {
-		return v1_8.isBlocking();
-	}
-	
-	public void setBlocking(final boolean block) {
-		applay(new Function<HumanDataWatcher, Void>() {
-			@Override
-			public Void apply(HumanDataWatcher arg0) {
-				arg0.setBlocking(block);
-				return null;
-			}
-		});
-	}
-	
-	public boolean hasAI() {
-		return v1_8.hasAI();
-	}
-	
-	public boolean isGlowing() {
-		return v1_8.isGlowing();
-	}
-	
-	public void setGlowing(final boolean glow) {
-		applay(new Function<HumanDataWatcher, Void>() {
-			@Override
-			public Void apply(HumanDataWatcher arg0) {
-				arg0.setGlowing(glow);
-				return null;
-			}
-		});
-	}
-	
-	public boolean isElytra() {
-		return v1_9.isElytra();
-	}
-	
-	public void setElytra(final boolean elytra) {
-		v1_9.setElytra(elytra);
-	}
-	
-	public int getAir() {
-		return v1_8.getAir();
-	}
-	
-	public void setAir(final int air) {
-		applay(new Function<HumanDataWatcher, Void>() {
-			@Override
-			public Void apply(HumanDataWatcher arg0) {
-				arg0.setAir(air);
-				return null;
-			}
-		});
-	}
-	
-	public void setCostumName(final String name) {
-		applay(new Function<HumanDataWatcher, Void>() {
-			@Override
-			public Void apply(HumanDataWatcher arg0) {
-				arg0.setCostumName(name);
-				return null;
-			}
-		});
-	}
-	
-	public String getCostumName() {
-		return v1_8.getCostumName();
-	}
-	
-	public boolean isCostumNameVisiable() {
-		return v1_8.isCostumNameVisiable();
-	}
-	
-	public void setCostumNameVisiable(final boolean flag) {
-		applay(new Function<HumanDataWatcher, Void>() {
-			@Override
-			public Void apply(HumanDataWatcher arg0) {
-				arg0.setCostumNameVisiable(flag);
-				return null;
-			}
-		});
-	}
-	
-	public boolean isSlient() {
-		return v1_8.isSlient();
-	}
-	
-	public void setSlient(final boolean flag) {
-		applay(new Function<HumanDataWatcher, Void>() {
-			@Override
-			public Void apply(HumanDataWatcher arg0) {
-				arg0.setSlient(flag);
-				return null;
-			}
-		});
-	}
-	
-	@Override
-	public void setApplayGravity(final boolean flag) {
-		applay(new Function<HumanDataWatcher, Void>() {
-			@Override
-			public Void apply(HumanDataWatcher arg0) {
-				arg0.setApplayGravity(flag);
-				return null;
-			}
-		});
-	}
-	
-	public DataWatcher getWatcher() {
-		return null;
-	}
-	
-	public HumanDataWatcher getV1_8() {
-		return v1_8;
-	}
-	
-	public HumanDataWatcher getV1_9() {
-		return v1_9;
-	}
-	
-	public HumanDataWatcher getV1_10() {
-		return v1_10;
-	}
-	
-	public DataWatcher getWatcher(BigClientVersion bigVersion) {
-		if (bigVersion == BigClientVersion.v1_10) return v1_10.getWatcher();
-		else if (bigVersion == BigClientVersion.v1_9) return v1_9.getWatcher();
-		else return v1_8.getWatcher();
-	}
-	
-	@Override
-	public boolean hasGravity() {
-		return v1_9.hasGravity();
-	}
-	
-	private void applay(Function<HumanDataWatcher, Void> c) {
-		c.apply(v1_8);
-		c.apply(v1_9);
-		c.apply(v1_10);
-	}
+    private HumanDataWatcher v1_8;
+    private HumanDataWatcher v1_9;
+    private HumanDataWatcher v1_10;
+
+    public NPCData() {
+        v1_8 = DataWatcher.createDataWatcher(BigClientVersion.v1_8).getSpecialDataWatcher(HumanDataWatcher.class);
+        v1_9 = DataWatcher.createDataWatcher(BigClientVersion.v1_9).getSpecialDataWatcher(HumanDataWatcher.class);
+        v1_10 = DataWatcher.createDataWatcher(BigClientVersion.v1_10).getSpecialDataWatcher(HumanDataWatcher.class);
+    }
+
+    public boolean isSneaking() {
+        return v1_8.isSneaking();
+    }
+
+    public void setSneaking(final boolean flag) {
+        applay(new Function<HumanDataWatcher, Void>() {
+            @Override
+            public Void apply(HumanDataWatcher arg0) {
+                arg0.setSneaking(flag);
+                return null;
+            }
+        });
+    }
+
+    public void setSkinFlags(final byte flag) {
+        applay(new Function<HumanDataWatcher, Void>() {
+            @Override
+            public Void apply(HumanDataWatcher arg0) {
+                arg0.setSkinFlags(flag);
+                return null;
+            }
+        });
+    }
+
+    public byte getSkinFlag() {
+        return v1_8.getSkinFlag();
+    }
+
+    public float getHealth() {
+        return v1_8.getHealth();
+    }
+
+    public void setHealth(final float h) {
+        applay(new Function<HumanDataWatcher, Void>() {
+            @Override
+            public Void apply(HumanDataWatcher arg0) {
+                arg0.setHealth(h);
+                return null;
+            }
+        });
+    }
+
+    public boolean isSprinting() {
+        return v1_8.isSprinting();
+    }
+
+    public void setSprinting(final boolean flag) {
+        applay(new Function<HumanDataWatcher, Void>() {
+            @Override
+            public Void apply(HumanDataWatcher arg0) {
+                arg0.setSprinting(flag);
+                return null;
+            }
+        });
+    }
+
+    public boolean isCapeActive() {
+        return v1_8.isCapeActive();
+    }
+
+    public void setCapeActive(final boolean b) {
+        applay(new Function<HumanDataWatcher, Void>() {
+            @Override
+            public Void apply(HumanDataWatcher arg0) {
+                arg0.setCapeActive(b);
+                return null;
+            }
+        });
+    }
+
+    public int getArrows() {
+        return v1_8.getArrows();
+    }
+
+    public void setArrows(final int amauth) {
+        applay(new Function<HumanDataWatcher, Void>() {
+            @Override
+            public Void apply(HumanDataWatcher arg0) {
+                arg0.setArrows(amauth);
+                return null;
+            }
+        });
+    }
+
+    public boolean isInvisible() {
+        return v1_8.isInvisible();
+    }
+
+    public void setInvisible(final boolean flag) {
+        applay(new Function<HumanDataWatcher, Void>() {
+            @Override
+            public Void apply(HumanDataWatcher arg0) {
+                arg0.setInvisible(flag);
+                return null;
+            }
+        });
+    }
+
+    public float getAbsorptionHearts() {
+        return v1_8.getAbsorptionHearts();
+    }
+
+    public void setAbsorptionHearts(final float f) {
+        applay(new Function<HumanDataWatcher, Void>() {
+            @Override
+            public Void apply(HumanDataWatcher arg0) {
+                arg0.setAbsorptionHearts(f);
+                return null;
+            }
+        });
+    }
+
+    public int getParicelColor() {
+        return v1_8.getParicelColor();
+    }
+
+    public void setParicelColor(final int color) {
+        applay(new Function<HumanDataWatcher, Void>() {
+            @Override
+            public Void apply(HumanDataWatcher arg0) {
+                arg0.setParicelColor(color);
+                return null;
+            }
+        });
+    }
+
+    public boolean isOnFire() {
+        return v1_8.isOnFire();
+    }
+
+    public void setOnFire(final boolean fire) {
+        applay(new Function<HumanDataWatcher, Void>() {
+            @Override
+            public Void apply(HumanDataWatcher arg0) {
+                arg0.setOnFire(fire);
+                return null;
+            }
+        });
+    }
+
+    public int getScore() {
+        return v1_8.getScore();
+    }
+
+    public void setScore(final int score) {
+        applay(new Function<HumanDataWatcher, Void>() {
+            @Override
+            public Void apply(HumanDataWatcher arg0) {
+                arg0.setScore(score);
+                return null;
+            }
+        });
+    }
+
+    public boolean isParticelVisiable() {
+        return v1_8.isParticelVisiable();
+    }
+
+    public void setParticelVisiable(final boolean flag) {
+        applay(new Function<HumanDataWatcher, Void>() {
+            @Override
+            public Void apply(HumanDataWatcher arg0) {
+                arg0.setParticelVisiable(flag);
+                return null;
+            }
+        });
+    }
+
+    public HumanDataWatcher injektDefault() {
+        v1_9.injektDefault();
+        v1_10.injektDefault();
+        return v1_8.injektDefault();
+    }
+
+    public void setAI(final boolean flag) {
+        v1_8.setAI(flag);
+    }
+
+    public boolean isBlocking() {
+        return v1_8.isBlocking();
+    }
+
+    public void setBlocking(final boolean block) {
+        applay(new Function<HumanDataWatcher, Void>() {
+            @Override
+            public Void apply(HumanDataWatcher arg0) {
+                arg0.setBlocking(block);
+                return null;
+            }
+        });
+    }
+
+    public boolean hasAI() {
+        return v1_8.hasAI();
+    }
+
+    public boolean isGlowing() {
+        return v1_8.isGlowing();
+    }
+
+    public void setGlowing(final boolean glow) {
+        applay(new Function<HumanDataWatcher, Void>() {
+            @Override
+            public Void apply(HumanDataWatcher arg0) {
+                arg0.setGlowing(glow);
+                return null;
+            }
+        });
+    }
+
+    public boolean isElytra() {
+        return v1_9.isElytra();
+    }
+
+    public void setElytra(final boolean elytra) {
+        v1_9.setElytra(elytra);
+    }
+
+    public int getAir() {
+        return v1_8.getAir();
+    }
+
+    public void setAir(final int air) {
+        applay(new Function<HumanDataWatcher, Void>() {
+            @Override
+            public Void apply(HumanDataWatcher arg0) {
+                arg0.setAir(air);
+                return null;
+            }
+        });
+    }
+
+    public String getCostumName() {
+        return v1_8.getCostumName();
+    }
+
+    public void setCostumName(final String name) {
+        applay(new Function<HumanDataWatcher, Void>() {
+            @Override
+            public Void apply(HumanDataWatcher arg0) {
+                arg0.setCostumName(name);
+                return null;
+            }
+        });
+    }
+
+    public boolean isCostumNameVisiable() {
+        return v1_8.isCostumNameVisiable();
+    }
+
+    public void setCostumNameVisiable(final boolean flag) {
+        applay(new Function<HumanDataWatcher, Void>() {
+            @Override
+            public Void apply(HumanDataWatcher arg0) {
+                arg0.setCostumNameVisiable(flag);
+                return null;
+            }
+        });
+    }
+
+    public boolean isSlient() {
+        return v1_8.isSlient();
+    }
+
+    public void setSlient(final boolean flag) {
+        applay(new Function<HumanDataWatcher, Void>() {
+            @Override
+            public Void apply(HumanDataWatcher arg0) {
+                arg0.setSlient(flag);
+                return null;
+            }
+        });
+    }
+
+    @Override
+    public void setApplayGravity(final boolean flag) {
+        applay(new Function<HumanDataWatcher, Void>() {
+            @Override
+            public Void apply(HumanDataWatcher arg0) {
+                arg0.setApplayGravity(flag);
+                return null;
+            }
+        });
+    }
+
+    public DataWatcher getWatcher() {
+        return null;
+    }
+
+    public HumanDataWatcher getV1_8() {
+        return v1_8;
+    }
+
+    public HumanDataWatcher getV1_9() {
+        return v1_9;
+    }
+
+    public HumanDataWatcher getV1_10() {
+        return v1_10;
+    }
+
+    public DataWatcher getWatcher(BigClientVersion bigVersion) {
+        if (bigVersion == BigClientVersion.v1_10) return v1_10.getWatcher();
+        else if (bigVersion == BigClientVersion.v1_9) return v1_9.getWatcher();
+        else return v1_8.getWatcher();
+    }
+
+    @Override
+    public boolean hasGravity() {
+        return v1_9.hasGravity();
+    }
+
+    private void applay(Function<HumanDataWatcher, Void> c) {
+        c.apply(v1_8);
+        c.apply(v1_9);
+        c.apply(v1_10);
+    }
 }
diff --git a/src/main/java/dev/wolveringer/Reflect/Test/Main.java b/src/main/java/dev/wolveringer/Reflect/Test/Main.java
index e44e5b8..9bed6c9 100644
--- a/src/main/java/dev/wolveringer/Reflect/Test/Main.java
+++ b/src/main/java/dev/wolveringer/Reflect/Test/Main.java
@@ -3,38 +3,44 @@ package dev.wolveringer.Reflect.Test;
 import dev.wolveringer.api.position.Location;
 
 public class Main {
+    public static void main(String[] args) {
+        /*
+        final Friend alphonse = new Friend("Alphonse");
+        final Friend gaston = new Friend("Gaston");
+        new Thread(new Runnable() { public void run() { alphonse.bow(gaston); }  }).start();
+        new Thread(new Runnable() { public void run() { gaston.bow(alphonse); } }).start();
+        */
+    }
+
+    public static Location readPosition(long l) {
+        long val = l;
+        return new Location((int) (val >> 38), (int) (val << 26 >> 52), (int) (val << 38 >> 38));
+    }
+
     static class Friend {
         private final String name;
+
         public Friend(String name) {
             this.name = name;
         }
+
         public String getName() {
             return this.name;
         }
+
         public synchronized void bow(Friend bower) {
             System.out.format("%s: %s"
-                + "  has bowed to me!%n", 
-                this.name, bower.getName());
+                            + "  has bowed to me!%n",
+                    this.name, bower.getName());
             bower.bowBack(this);
         }
+
         public synchronized void bowBack(Friend bower) {
             System.out.format("%s: %s"
-                + " has bowed back to me!%n",
-                this.name, bower.getName());
+                            + " has bowed back to me!%n",
+                    this.name, bower.getName());
         }
     }
-    public static void main(String[] args) {
-    	/*
-        final Friend alphonse = new Friend("Alphonse");
-        final Friend gaston = new Friend("Gaston");
-        new Thread(new Runnable() { public void run() { alphonse.bow(gaston); }  }).start();
-        new Thread(new Runnable() { public void run() { gaston.bow(alphonse); } }).start();
-        */
-    }
-   	public static Location readPosition(long l) {
-   		long val = l;
-   		return new Location((int)(val >> 38), (int)(val << 26 >> 52), (int)(val << 38 >> 38));
-   	}
 
-    
+
 }
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/Reflect/Test/TEST.java b/src/main/java/dev/wolveringer/Reflect/Test/TEST.java
index 82db7d0..1a93951 100644
--- a/src/main/java/dev/wolveringer/Reflect/Test/TEST.java
+++ b/src/main/java/dev/wolveringer/Reflect/Test/TEST.java
@@ -9,10 +9,10 @@ import dev.wolveringer.BungeeUtil.packets.Packet;
 import dev.wolveringer.chat.ChatSerializer;
 
 public class TEST {
-	public static void main(String[] args) {
-		System.out.print(ChatSerializer.toJSONString(ChatSerializer.fromMessage("aSleef-Event")));
-		/*
-		PacketHandler h = new PacketHandler() {
+    public static void main(String[] args) {
+        System.out.print(ChatSerializer.toJSONString(ChatSerializer.fromMessage("aSleef-Event")));
+        /*
+        PacketHandler h = new PacketHandler() {
 			public void handle(PacketHandleEvent e) {
 				Main.sendMessage(e.getPacket());
 			};
@@ -51,39 +51,39 @@ public class TEST {
 		 * System.out.print((System.nanoTime()-ns)+":"+(System.currentTimeMillis(
 		 * )-ms));
 		 */
-	}
+    }
 
-	private static Class getPacketType(Class s) {
-		for(Type interfaces : s.getGenericInterfaces())
-			for(Type c : ((ParameterizedType) interfaces).getActualTypeArguments())
-				try{
-					if(c.equals(Packet.class))
-						continue;
-					return Class.forName(c.toString().split(" ")[1]);
-				}catch (ClassNotFoundException e){
-					e.printStackTrace();
-				}
-		return Packet.class;
-	}
+    private static Class getPacketType(Class s) {
+        for (Type interfaces : s.getGenericInterfaces())
+            for (Type c : ((ParameterizedType) interfaces).getActualTypeArguments())
+                try {
+                    if (c.equals(Packet.class))
+                        continue;
+                    return Class.forName(c.toString().split(" ")[1]);
+                } catch (ClassNotFoundException e) {
+                    e.printStackTrace();
+                }
+        return Packet.class;
+    }
 
-	private static boolean checkVersion(String version1, String version2) {
-		String[] v1 = version1.split("\\.");
-		String[] v2 = version2.split("\\.");
-		for(int i = 0;i < Collections.max(Arrays.asList(v1.length, v2.length));i++){
-			if(i + 1 < v1.length && i + 1 >= v2.length)
-				return !isNotZero(Arrays.copyOfRange(v1, i + 1, v1.length));
-			else if(i + 1 < v2.length && i + 1 >= v1.length)
-				return isNotZero(Arrays.copyOfRange(v2, i + 1, v2.length));
-			else if(Integer.parseInt(v1[i]) < Integer.parseInt(v2[i]))
-				return true;
-		}
-		return false;
-	}
+    private static boolean checkVersion(String version1, String version2) {
+        String[] v1 = version1.split("\\.");
+        String[] v2 = version2.split("\\.");
+        for (int i = 0; i < Collections.max(Arrays.asList(v1.length, v2.length)); i++) {
+            if (i + 1 < v1.length && i + 1 >= v2.length)
+                return !isNotZero(Arrays.copyOfRange(v1, i + 1, v1.length));
+            else if (i + 1 < v2.length && i + 1 >= v1.length)
+                return isNotZero(Arrays.copyOfRange(v2, i + 1, v2.length));
+            else if (Integer.parseInt(v1[i]) < Integer.parseInt(v2[i]))
+                return true;
+        }
+        return false;
+    }
 
-	private static boolean isNotZero(String[] x) {
-		for(String s : x)
-			if(Integer.parseInt(s) != 0)
-				return true;
-		return false;
-	}
+    private static boolean isNotZero(String[] x) {
+        for (String s : x)
+            if (Integer.parseInt(s) != 0)
+                return true;
+        return false;
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/Reflect/Test/TestClass.java b/src/main/java/dev/wolveringer/Reflect/Test/TestClass.java
index f8dc69d..8fd156a 100644
--- a/src/main/java/dev/wolveringer/Reflect/Test/TestClass.java
+++ b/src/main/java/dev/wolveringer/Reflect/Test/TestClass.java
@@ -4,6 +4,6 @@ import java.util.Arrays;
 import java.util.Collection;
 
 public class TestClass {
-	@SuppressWarnings("unused")
-	private final Collection<String> a = Arrays.asList("THIS IS A TEST STRING");
+    @SuppressWarnings("unused")
+    private final Collection<String> a = Arrays.asList("THIS IS A TEST STRING");
 }
diff --git a/src/main/java/dev/wolveringer/Reflect/Until.java b/src/main/java/dev/wolveringer/Reflect/Until.java
index e0b26da..69121e8 100644
--- a/src/main/java/dev/wolveringer/Reflect/Until.java
+++ b/src/main/java/dev/wolveringer/Reflect/Until.java
@@ -1,35 +1,35 @@
 package dev.wolveringer.Reflect;
 
-import io.netty.channel.Channel;
-
-import java.lang.reflect.Field;
-import java.util.Collection;
-
 import net.md_5.bungee.BungeeCord;
 import net.md_5.bungee.protocol.MinecraftDecoder;
 import net.md_5.bungee.protocol.MinecraftEncoder;
 import net.md_5.bungee.protocol.Protocol;
 
+import java.lang.reflect.Field;
+import java.util.Collection;
+
+import io.netty.channel.Channel;
+
 public class Until {
-	@SuppressWarnings("unchecked")
-	public static Collection<Channel> getChannels() throws IllegalArgumentException, IllegalAccessException, NoSuchFieldException, SecurityException {
-		Field f = BungeeCord.getInstance().getClass().getField("saveThread");
-		f.setAccessible(true);
-		return (Collection<Channel>) f.get(BungeeCord.class);
-	}
+    @SuppressWarnings("unchecked")
+    public static Collection<Channel> getChannels() throws IllegalArgumentException, IllegalAccessException, NoSuchFieldException, SecurityException {
+        Field f = BungeeCord.getInstance().getClass().getField("saveThread");
+        f.setAccessible(true);
+        return (Collection<Channel>) f.get(BungeeCord.class);
+    }
 
-	public static Protocol getProtocol(Object o) {
-		try{
-			if(o == null)
-				throw new RuntimeException("Objekt is null");
-			Field f = (o instanceof MinecraftDecoder ? MinecraftDecoder.class : MinecraftEncoder.class).getDeclaredField("protocol");
-			f.setAccessible(true);
-			return (Protocol) f.get(o);
-		}catch (NoSuchFieldException e){
-			return Protocol.HANDSHAKE;
-		}catch (Exception e){
-			e.printStackTrace();
-			return Protocol.HANDSHAKE;
-		}
-	}
+    public static Protocol getProtocol(Object o) {
+        try {
+            if (o == null)
+                throw new RuntimeException("Objekt is null");
+            Field f = (o instanceof MinecraftDecoder ? MinecraftDecoder.class : MinecraftEncoder.class).getDeclaredField("protocol");
+            f.setAccessible(true);
+            return (Protocol) f.get(o);
+        } catch (NoSuchFieldException e) {
+            return Protocol.HANDSHAKE;
+        } catch (Exception e) {
+            e.printStackTrace();
+            return Protocol.HANDSHAKE;
+        }
+    }
 }
diff --git a/src/main/java/dev/wolveringer/ServerDatReader.java b/src/main/java/dev/wolveringer/ServerDatReader.java
index 6f72201..0e13ecc 100644
--- a/src/main/java/dev/wolveringer/ServerDatReader.java
+++ b/src/main/java/dev/wolveringer/ServerDatReader.java
@@ -1,20 +1,16 @@
 package dev.wolveringer;
+
+import net.md_5.bungee.api.ChatColor;
+
 import java.io.BufferedInputStream;
 import java.io.DataInputStream;
 import java.io.DataOutput;
 import java.io.DataOutputStream;
 import java.io.File;
 import java.io.FileInputStream;
-import java.io.FileOutputStream;
 import java.io.OutputStream;
-import java.net.InetSocketAddress;
-import java.net.Proxy;
-import java.net.Proxy.Type;
-import java.net.Socket;
 
-import net.md_5.bungee.api.ChatColor;
 import dev.wolveringer.BungeeUtil.BungeeUtil;
-import dev.wolveringer.BungeeUtil.Main;
 import dev.wolveringer.nbt.NBTBase;
 import dev.wolveringer.nbt.NBTCompressedStreamTools;
 import dev.wolveringer.nbt.NBTTagCompound;
@@ -22,37 +18,37 @@ import dev.wolveringer.nbt.NBTTagList;
 import dev.wolveringer.nbt.NBTTagString;
 
 public class ServerDatReader {
-	public static void main(String[] args) throws Exception {
-		System.out.print("X");
-		File f = new File("/home/wolverindev/.minecraft/servers.dat");
-		FileInputStream in = new FileInputStream(f);
-		NBTTagCompound base = NBTCompressedStreamTools.read(new DataInputStream(new BufferedInputStream(in)));
-		NBTTagList list = base.getList("servers");
-		for(NBTBase comp : list.asList()){
-			NBTTagCompound c = (NBTTagCompound) comp;
-			c.set("name", new NBTTagString("\u00A7a\u00A7l\u00A7n"+reset(c.getString("name"))));
-			BungeeUtil.getInstance().sendMessage(comp.toString());
-		}
-		//FileOutputStream out = new FileOutputStream(f);
-		//write(base, out);
-		//out.close();
-	}
-	
-	public static String reset(String  in){
-		return ChatColor.stripColor(in);
-	}
-	
-	public static void write(NBTTagCompound nbttagcompound, OutputStream outputstream) throws Exception {
-		DataOutputStream dataoutputstream = new DataOutputStream(outputstream);
-		try{
-			NBTCompressedStreamTools.write(nbttagcompound,(DataOutput) dataoutputstream);
-		}finally{
-			try{
-				dataoutputstream.close();
-			}catch (java.io.IOException e){
-				e.printStackTrace();
-			}
-		}
-	}
-	
+    public static void main(String[] args) throws Exception {
+        System.out.print("X");
+        File f = new File("/home/wolverindev/.minecraft/servers.dat");
+        FileInputStream in = new FileInputStream(f);
+        NBTTagCompound base = NBTCompressedStreamTools.read(new DataInputStream(new BufferedInputStream(in)));
+        NBTTagList list = base.getList("servers");
+        for (NBTBase comp : list.asList()) {
+            NBTTagCompound c = (NBTTagCompound) comp;
+            c.set("name", new NBTTagString("\u00A7a\u00A7l\u00A7n" + reset(c.getString("name"))));
+            BungeeUtil.getInstance().sendMessage(comp.toString());
+        }
+        //FileOutputStream out = new FileOutputStream(f);
+        //write(base, out);
+        //out.close();
+    }
+
+    public static String reset(String in) {
+        return ChatColor.stripColor(in);
+    }
+
+    public static void write(NBTTagCompound nbttagcompound, OutputStream outputstream) throws Exception {
+        DataOutputStream dataoutputstream = new DataOutputStream(outputstream);
+        try {
+            NBTCompressedStreamTools.write(nbttagcompound, (DataOutput) dataoutputstream);
+        } finally {
+            try {
+                dataoutputstream.close();
+            } catch (java.io.IOException e) {
+                e.printStackTrace();
+            }
+        }
+    }
+
 }
diff --git a/src/main/java/dev/wolveringer/TimingsDataReader.java b/src/main/java/dev/wolveringer/TimingsDataReader.java
index 8e6e15b..a81d1f4 100644
--- a/src/main/java/dev/wolveringer/TimingsDataReader.java
+++ b/src/main/java/dev/wolveringer/TimingsDataReader.java
@@ -1,52 +1,51 @@
 package dev.wolveringer;
 
 import dev.wolveringer.BungeeUtil.BungeeUtil;
-import dev.wolveringer.BungeeUtil.Main;
 import dev.wolveringer.hastebin.HastebinDocument;
 import dev.wolveringer.nbt.NBTCompressedStreamTools;
 import dev.wolveringer.nbt.NBTTagCompound;
 
 public class TimingsDataReader {
-	public static void main(String[] args) {
-		try{
-			NBTTagCompound s = NBTCompressedStreamTools.read(getNBTTagString());
-			BungeeUtil.getInstance().sendMessage(s.toFormatedString());
-		}catch (Exception ex){
-			ex.printStackTrace();
-		}
-	}
+    public static void main(String[] args) {
+        try {
+            NBTTagCompound s = NBTCompressedStreamTools.read(getNBTTagString());
+            BungeeUtil.getInstance().sendMessage(s.toFormatedString());
+        } catch (Exception ex) {
+            ex.printStackTrace();
+        }
+    }
 
-	public static String getNBTTagString() {
-		int mode =1;
-		switch (mode) {
-			case 0:
-				return getFixedNBTTagString();
-			case 1:
-				return getHastebinNBTTag();
-			default:
-				break;
-		}
-		return "";
-	}
+    public static String getNBTTagString() {
+        int mode = 1;
+        switch (mode) {
+            case 0:
+                return getFixedNBTTagString();
+            case 1:
+                return getHastebinNBTTag();
+            default:
+                break;
+        }
+        return "";
+    }
 
-	public static String getHastebinNBTTag() {
-		String url = "http://hastebin.com/kecotidamu";
-		HastebinDocument doc = new HastebinDocument(url);
-		doc.load();
-		boolean active = false;
-		String out = "";
-		for(String s : doc.getLines())
-			if(s.equalsIgnoreCase("Details: (Base64 NBTTag Structure)"))
-				active = true;
-			else if(s.equalsIgnoreCase(""))
-				active = false;
-			else if(active)
-				out += s;
-		return out;
-	}
+    public static String getHastebinNBTTag() {
+        String url = "http://hastebin.com/kecotidamu";
+        HastebinDocument doc = new HastebinDocument(url);
+        doc.load();
+        boolean active = false;
+        String out = "";
+        for (String s : doc.getLines())
+            if (s.equalsIgnoreCase("Details: (Base64 NBTTag Structure)"))
+                active = true;
+            else if (s.equalsIgnoreCase(""))
+                active = false;
+            else if (active)
+                out += s;
+        return out;
+    }
+
+    public static String getFixedNBTTagString() {
+        return "H4sIAAAAAAAAAO2beVhV1frH14a9j4qmlqalWTSodcvKa9ZttmxwqpxRTITgMChw4AyAIILihEM4XSdwzCmqK5hmaZapdTVz1tLMpEzTNO1WeruZ+TO+n+Oj/bTn9jz3T88/X9baa6+9hnf4vu9ahBkTZmr5k1KSUhN8d7pTYz1xbm+YqR6bGJOa6k7u7I6JCzM1I7xJfnf44/397scD8fHVjHP2BbfPNsa0Mb/9rLZDhIVJlO8RdqgqvKZXJZodbpVjo4XW7cLFrYR5Y9TuTCeVH20qbLlEeO/Ver4vXbjgV2FpXT1v/j7tbxUWfSVs3UBYkMB4jtNugrDOv4WNN1ZiSPM0xj9DGHWnMOUbxrVPmB7Q99c/JvxA4zQvLxeuaCz8+S/CZfmMp6XwqQjVb5ilcpbWwRyJVfnWT4RNR6n+rcXCGWWqT3pAeFsXoTdUeEsTYflS4ambmfcaYfFQYftPhRPeZvxxwlKta2ik1scxsyux1lHNK7Qp61ND+2u+6iNcUiB8sYdwZE21C7eFB9oJT7xXidsXp1c1dmpMivv3MmabGo9luL0xCe4usR4vUvNIlWqmRprbm+SJ63NOAjVi68bVwtBwYf1MYQMkMSRHWK+3RnbmC5WrNmTlHqRdM2a2V1jtBrU//S7tDgmvZEXv13fNYSTEeUhYva3qTyzl/cGqv/0mYU9phFWXnbj+Q/q5Q+VYF+Oorfrv9Z2Qtny/+LDwlmX0w0rXbC0sH8jzcuF9rOHf7hfeliKc4xHWkSRbN80UtiylXU/6t4Qe1rs+GpoXJmw6l+/0FbZ7XPgwEtxY87CuXSlshgS1YJ9aPCu8dT7jjhSW3M046P/eA8LdjKNlPWEUkn3tLVqvXzYIT7MON2ym378L73+K77YXRr4ofC5GmMZ+JmUz72PCRL5fjkWJf4v5zRE+ixy1/VHYYaSwfyvW4xVhc/Y/XesSEkX7a2YJ22D5nmN/3mRdnnla2ORJ4Tjmd3cH4e0/MM+fhU+c+s3CO5m/aVeYcbWJSY1Ldp9vwWWB7H0ThfGarz1VlsUeLwtmF8ni2r1kIe1UWRg7KlWYrv2z+/ipl1zbL1fKbcj0LZIvO0GWzHbXEDZeJLyhD6h9te85KGwjC2V3aSS0Ogp7t6jE0NOjhb8MU30nWST7dlms0M+OCitChJ9LX+wmsgN2tWsr0bmiOs/L6C+e8kvCvVi+Q/Ioofva8nw1eAf1klO7ruTHfkrtnU3hKl+7S3jdE8L6J4RXU99ggLCpPI39xHHe+0x4Vz9h+Lf08yvPWe/rTglvlEezB1whvH+H8B4P472ZdvJMdvu7mPd4UPscerohZdkL275N6DwNbtPzU5Lf0BPyGC5/Nz1vUsQ8r2ecOZTvZb5DaNdfeH1zYYdkvhdB/6oP/XWq6hvOCXoOZPpiHsPe3eKSHsO5QxbAqSoJdKbIcthLvhMWf676igUq73pV6H9HOIgVTtaK2lfXUfv3olX+SZJpe9cKPXnCOhYrIMvqrNTOO09qp8OmbdLz2z8Q3rxKWDdKeGuxMJr+bkOib40H0dCbmEeTG+jnDsriRnYz+Wi76SRhuMZvN3qbfp4TNp7CeM4IH1xBPZJ789W0l6bYgUM8Fydyussj2GWyYPb9WIxDGcJISWjYyOEqJ2FBGj8jvEYeyfGpX+cv8qj2JPYjRx7Ebi2PY18nSXU1lId0RX+v93o2YTyPCJ9hX+aKczoucRJnChZk133C4/IMthcNvQaNqcc6NkRT64gh2DfIMtvPyiPZzRYKb1H/9kNiAnZLeeJaXu2rc4T5JEwWusVQ7AifEPmwn9V3nQnSDFdtxvu6LIczVhbAOYw8HOW99mIU9k3oRiN5QnvMCLXfwbquOXXWYVwhpQpvm+p3e1PP9xfyt+ZD6a9ZX53ycMrThOv+CVZQX0y7O6nfXwlW+3+pvLmWcJNWx2xpSnkgz2vQzw+8L/tljsmumO0HqT/Fd1y0zw3aiQundDFzYQ5PvqS5MEchXOFST/NLd+Gn81R/k8TMMnK8Zr+2wxwQ1Tc7S4RbITo1IFQOBPKQ1MB8PJaJ38XEofxnZA6s+mFMvCsTH8GCvcp7VSgf532o/Zb+jGMW4zhNPePa9D0o4ms2smEbRVjNLjZ22zb6fQhcQT+EAlu30m4j84nleRLPISqNEIRNIlLmlzeEJ+XozGdSV/NtNeHBf9PPdOHu+vRvMQ5CD0ILq65CInNcjs98IXNr9k6mvcyZ+UHPrd7JjAsifkbqbzX8iH4RuN2dVd9sHu3+JvxS5tRyO4yTUHUTAcfmidTLjJmPZNbMLrkZs91Le0Ll7YR8OxD4bRDqKjKLZo/MmKkg1NoVSXsRXfMxAchRuQlrAvUnGdcRmV/rYULF5rmq/6Iz43yd8fQDCdUbRKv88/PC3cnnmYsns35vLjRqE9cG/Ap8FBQ9NrGi0Saa1YlGemJYveg1lFuBmJ3B+ygvAJl19McgZiGaVY7JAtm9GLQumvejjwgT5AzN8X9QRsoSkNJ4wosE5pHAaiTM5jnWIR6p78sqxu+hHbuVwPdjZYxNHOs1pIJyC8Z1gvEi9YMk5cbNbsWuAt+lnnHFLqOcDE6i/n3670YZ6Vwwn3G+ceH44leCRdTP5b1o+sWKJKANsTPovx1lEgSxm35vjiUyFzXH3h8vbY4HIlBDMYPDUScv5mLQA9TLW5qMLUIP5svDBIIbmb5KOAoBzBJPNcmYyQQyTQn4PzcbNgn1zBdPNkkIePwc2kdR5nlCNmXMcyLq25e4NShI8QhkPGYt4Q7KmMFEQ7k5yLgThvE8+D6KlPgKz3EP8VOpv496BCLpa2EKHyhQHsB4dwv7kbHKuZIy/jderNh4rhG611H/srAIQc5lnGmMO93DOA7QHrdZyr5NEUsyg+i/kHENMoxLbMsME0szI24UZtZlfMgSenjO4MTjFhMxc3GMMwFDk8Q4Etj/xELKGJS+NanH3adCCzzke1JkLk0y+5BEJrAfCjgJ+StkfX24z/EdqY9hHpjlRGhCAmY8qJADMHQ72T//gnPh/vlmWFphH5DZsY+KNNjfaBZObUV99jo5efuwpNheo+yRvZc8qdU9qL76xMXU1lk//9JB1xeiea4Vmo6zDFL+tLahSrgG4nzqoV5pBydd6uw8yEC/kti5lqreZSscdSJPCtspvWR/XkJ72XNXiYIUl1vbU70Icv8jYfV38if2l7LT9vfafqeF/Ip9kqDn5GqeQ/pPEA4fG0v9a+B0noMnH2aBSW8cJEz+7hjPCa9/kD12av7Ic9Imh5ROs/8j8XAeC+c78gOuR8RSnVelJs5VYi3OhzJHzsOi6dUjxe6cR2vSH8HmPtl7V2clyl2t5c+cYbLrTqTUxGnAOA+JnVZ5oZVwjRLQrmz5TVdbCZwrVWzPKRGdd9aKhbk2yp85e9h3j9bTmUsapYIgbB/rp5jobD3B6V7k5GYE9/R24Y9aL6e6gl8nQmpWu5WCPVdXqZnT6i7WUeGG00Lr4Nwos+M01AddDWT2qoxGzpZJjpwzCu6qeGUuXFXEtpwnxTbtY6QrDmv97eMKbqs0IrmwVea++vv1z6ptjVivO8bv7hgT28/tP197lSsyXmxvegYI+Ukj5kmXcBgfNioFcpC6HoQ8pGEjyeEZD7Y9lZguBcqfAhlIgfqnYBtTjtIe0pACqUlZS72EwEzEB0witAjga/z4Pj+kxo/P9uMLM1MoMx4/NtMP9c+EzPghh35sZhq+Lw0ukDZLmA+ZmTCUcSqiNsnY6jRCFu91lPH9acwrnfVNe4oyMarvKuqDPg3OUR7OuPA9PnyE7xeQ0CPwLP3BQdL2M45gGZ+dTkjgJab2EcLEsD7J1wet8gUSdFFONey+P+BUkM/BrGsmcvH6OOF8yN0UQpCh/xHmwHn8yGWgQjgA8lkmo2TGMd5cfGsOvj3Qnvchlz64QiY+NgNfneGnPXKXNZr32JfAeOonUCZk68/3Az/RP/LtRR4yIM0B9n+IQlSTDTcJwL38hNCBYyBc0E8IO1VGyQy9lnHATUejt3nImZ9QNKcZ81xEvTJt5u+E+DPhRIVwsnxyIHm38f2dzIfQ8R2CnDL0eyI5menI60ROTQfDNUvgJHOQx9GQ+FxSEH7lmM17nIH52Wcv7fxwSx/rm07oXASn8cNNgnIUIKTN1BmJyVawZRVhX3IfBrFjeehpAVwwG7uTA4fLRn/L+c50Ui1DsCNT0fu34Hbj4JB5cKUA+5RBUJiB3E9S5sxMYb2G7DR/eAiOmAXIwGQQO2ZxKJyB2QswbC/iNREKPgoq7RNnMB7EwtMJlE8zmVBdL6GPj+VMhxKnf39h/76geBLDpkMh01HDTzikHsw2BzC7GSxbALOQgTn3Ip5eMis+zK4X85BODO9HncZX/InDXTP+sUsbphEI6Jxw4bgPqGelZ5ZTr8MiU0AOqYAVymEGAUj5eHJXU1HoYPCY/SbtOHT1E2yNxDDNRoDGwCZ7oXAZGOgA1wEyyc0EDUsGUXQmObWMfNojAZkYtmzaBf5KfR5IUOXH4HrB/iHU42j9BA3ZSFQgaNioz0CBM1HYDAzMaILUInKJeRjQAq4zDCEXmcV72eT0cnAY/nDhUAzLTNqPpF0+WZlcJDcDA5eNw9iM43uJcb6IQZvHPo3GseZiKBeQVZiAIRwE4cnBUQRIKvuRcD85OR9BeVDxszFsWRjKLF1TMANwKJkQqP6KKsxYNCcfw1mAwc/H0A9Eg3MZ30CyPivv5n0c50D24S3GM4X5FWD4Ahik/mikj/lMw/GNZR0H/mbIwkzt4P2dNK8nPinZ7T3/Tk+c+6J3en53ElzZ3X9xomZ+CyUvpaaXf5d/l38X/f3RiRrO5ojOMc14nFYR7GY+bv8lhZ5mnlhxaC2c0zy0bwZOZyT0oRDWU0jUNEtGzOqlDKjVBue3cP2fOCHbMObS6v8aSSJDyrIUK/s+vOhtUqgLSZUt4grOVYqlzWrlOsxyxdRmJdZxCZfarqK8HG/yT3KArxHWlhGGleNN5mK15/fle4QTZVy1mQvdn0UqbjZhaSlh5EZ424ewiwXwnFcJT5biDctPXNh/ueYb0h/v9fEzF85nORvyBlfCfv1S5a3aMKsL9Ph9Uo6zSUGuIlzcpoN98wH0eCn8cznh4krmAws3b9NP6boLx72MM5S34JkrdBXDlMHr3oQVlOng2yzhsmBNwtNFsKIVs4Tz2O+l7N8iwvR3SZEvgg0s5bulfO8wbOMVsSDLYv23EIYfZl6fczazBy97ENb1MuHcftZhBaxqJ+u0gXDmYxRpH965nPJKLmeu4MzmHeZfBrtaTe54Ad9bDa//B+PawDzeJRz6CfawLly4dssfnpDBhbqyql3grp3gfq3htK0JklpzHtyV4OQ9EszzdNGxds2MP3HC4qt1aXXuzkHw82x/BCcYvRDH4JFaF8SkBwPqw4FpJEdskWxPJNF5N/rvQrjQUwM3w1nO7kSREZCfCNSjC+rTke3Pgzz2REx6kx3pSPTbB7HqwtFTtwphDNvckWxGDOHSErJh0UTnI4jqezDfxUTx0ZDQPpC6FxC7hdzEe5FxP4/4RStKD1mOPnbC/MWx4T7sdAT2OJKbD71ZryhIZwTiFUXQ0z2N9hxN9kOQ/BpHSBhksQdhWzRqFc+BeCTmM5q7xFcSvDxPmNiVbEVPouEsgoPuBEk9WI+ekP5uqEt+6wu/mxvMtrG/XuQqjeAjGbO7h33ohvmOI1sTxYlVCuqayPr1YzxRBBuRRP9R9BvJ+KLIYnbH/bjJmnACa6IJDp9XyvvcEXEvzEYs2ddYgs4pp8+qrO09y6LP12IJnTWPi92dpZXWlopKdHYr8nN9rlSIa4p8iGu+Uju2WwzfDlHqwvWD8uVVJysitOpq8eq8pk2udp+E2J6Gz6jaSuV2uowUOlu2NLS9UmuhT0iJ7FUS5moFXNy3telVD3LbYbCsizVAymxFKP9vxZEK+wSl2okv2qnU6Ndu6o/0CVqfyhW6mNEJGf32pa9xD+O6cBHXordx62Ystw+KlQq2ChXZWVuV2rZWc213Bhf8FyLUM5UasoaIXIWsY3/2sl9TJVzWdK4BF3BbYh2+LpF/JNgfLszSbRfrVxkVK5d+Q5SDsYjMrU+kfNbQCuEGrhNPkhJbi3nfN555KUdjdabdVkXAlkeRq0UEabXjHxcGK/VsBZQZsJZwbbuEfV0s42YNkvJay7gOPJJ1my/OYvWTEQ+px3VvD9faD3H9uC/Xyb/k+vFMOMsS+XprGNeuB4trhe6UMXdqcRnydd1TCC3RuoSMle8MKVSGI7SNvJoTGS68VylOZwz/eFHAP5ZMZb59RXKtbDmDKmN2M9584Sc6Rg1dybnhk5zX9Oa68VplClzNZPzsr2XMnEact5WvUn1XLtE1FOewS3Tc77TUvthHuVz5iI48nJkalz1cRwah73Et/QWtn71bmYmQTnBZrzis1Xs78+R6eTwcKJ35xnCd/NSoPzofIm/ah6tYcfwXzUAsYgxpoCie9yJtEY9ldJNeS4TojCDfOg5C14/6tRCdIZz5J0GMN2MMdkPAcyF8J/HUG7nDXk/EzHoAj1pGxNKNq2DPYIl7QLAwUiab+bxMYJGHh93MHb9vMA71IGiHg/+zQCQ1Cs+XDDHeRlpnB+keH4HCetI6m1i3DaxXMpZ/GWm3Qs5xXiBA6MP6fsT/mOSzTvH8L0k05xzFMKKxpNVyId6FjK8THr0Dnq0dVPAUkV/ko//9OU/pzEszu7kEKkPxhEvxsMPwnC/hyfOglosZzxjuHKwgvTiMwG0eEewQBVTWdsY9gfTXXO5mjESOJiNXE2Fu42BuxaQ9p8IUSpDrachTKedEY6HEC0nnDq4QLuGco4B03iLObQZzGWo68pFHmm0WVHo0zG96OPNgXwvZ/yn0MwEGVwzjGYscF0PNR8HoijlHGEW/40gvl7A3k9GX+cHxEFguozwaPVpIu6EwwqkEUJO4I/QtgfAaGMuHnMtM5iBgKUx6Kecv+5Gjzdo36zoS/zMI2ErZ14Wko6ezL2th9GdY3x0E3K8i9+s5b/mAff+WfdrD/m2Fka/j6uEBGO8a+j3NOLdyXriNA4gvmOcysILxvouebsH+ZLJOwwmc3+AcehT9DUT/CpHvAejbUJhnDgFfpbkIMzWDqdPEyvjprN3VH9K2MHOlihFJqXGezNbJSbH9LppF/f/NLidUL/8u//43v3NaeWE+tfLZOS95fovLynf5d/n3P/v9H1a5v6E5QAAA";
+    }
 
-	public static String getFixedNBTTagString() {
-		return "H4sIAAAAAAAAAO2beVhV1frH14a9j4qmlqalWTSodcvKa9ZttmxwqpxRTITgMChw4AyAIILihEM4XSdwzCmqK5hmaZapdTVz1tLMpEzTNO1WeruZ+TO+n+Oj/bTn9jz3T88/X9baa6+9hnf4vu9ahBkTZmr5k1KSUhN8d7pTYz1xbm+YqR6bGJOa6k7u7I6JCzM1I7xJfnf44/397scD8fHVjHP2BbfPNsa0Mb/9rLZDhIVJlO8RdqgqvKZXJZodbpVjo4XW7cLFrYR5Y9TuTCeVH20qbLlEeO/Ver4vXbjgV2FpXT1v/j7tbxUWfSVs3UBYkMB4jtNugrDOv4WNN1ZiSPM0xj9DGHWnMOUbxrVPmB7Q99c/JvxA4zQvLxeuaCz8+S/CZfmMp6XwqQjVb5ilcpbWwRyJVfnWT4RNR6n+rcXCGWWqT3pAeFsXoTdUeEsTYflS4ambmfcaYfFQYftPhRPeZvxxwlKta2ik1scxsyux1lHNK7Qp61ND+2u+6iNcUiB8sYdwZE21C7eFB9oJT7xXidsXp1c1dmpMivv3MmabGo9luL0xCe4usR4vUvNIlWqmRprbm+SJ63NOAjVi68bVwtBwYf1MYQMkMSRHWK+3RnbmC5WrNmTlHqRdM2a2V1jtBrU//S7tDgmvZEXv13fNYSTEeUhYva3qTyzl/cGqv/0mYU9phFWXnbj+Q/q5Q+VYF+Oorfrv9Z2Qtny/+LDwlmX0w0rXbC0sH8jzcuF9rOHf7hfeliKc4xHWkSRbN80UtiylXU/6t4Qe1rs+GpoXJmw6l+/0FbZ7XPgwEtxY87CuXSlshgS1YJ9aPCu8dT7jjhSW3M046P/eA8LdjKNlPWEUkn3tLVqvXzYIT7MON2ym378L73+K77YXRr4ofC5GmMZ+JmUz72PCRL5fjkWJf4v5zRE+ixy1/VHYYaSwfyvW4xVhc/Y/XesSEkX7a2YJ22D5nmN/3mRdnnla2ORJ4Tjmd3cH4e0/MM+fhU+c+s3CO5m/aVeYcbWJSY1Ldp9vwWWB7H0ThfGarz1VlsUeLwtmF8ni2r1kIe1UWRg7KlWYrv2z+/ipl1zbL1fKbcj0LZIvO0GWzHbXEDZeJLyhD6h9te85KGwjC2V3aSS0Ogp7t6jE0NOjhb8MU30nWST7dlms0M+OCitChJ9LX+wmsgN2tWsr0bmiOs/L6C+e8kvCvVi+Q/Ioofva8nw1eAf1klO7ruTHfkrtnU3hKl+7S3jdE8L6J4RXU99ggLCpPI39xHHe+0x4Vz9h+Lf08yvPWe/rTglvlEezB1whvH+H8B4P472ZdvJMdvu7mPd4UPscerohZdkL275N6DwNbtPzU5Lf0BPyGC5/Nz1vUsQ8r2ecOZTvZb5DaNdfeH1zYYdkvhdB/6oP/XWq6hvOCXoOZPpiHsPe3eKSHsO5QxbAqSoJdKbIcthLvhMWf676igUq73pV6H9HOIgVTtaK2lfXUfv3olX+SZJpe9cKPXnCOhYrIMvqrNTOO09qp8OmbdLz2z8Q3rxKWDdKeGuxMJr+bkOib40H0dCbmEeTG+jnDsriRnYz+Wi76SRhuMZvN3qbfp4TNp7CeM4IH1xBPZJ789W0l6bYgUM8Fydyussj2GWyYPb9WIxDGcJISWjYyOEqJ2FBGj8jvEYeyfGpX+cv8qj2JPYjRx7Ebi2PY18nSXU1lId0RX+v93o2YTyPCJ9hX+aKczoucRJnChZk133C4/IMthcNvQaNqcc6NkRT64gh2DfIMtvPyiPZzRYKb1H/9kNiAnZLeeJaXu2rc4T5JEwWusVQ7AifEPmwn9V3nQnSDFdtxvu6LIczVhbAOYw8HOW99mIU9k3oRiN5QnvMCLXfwbquOXXWYVwhpQpvm+p3e1PP9xfyt+ZD6a9ZX53ycMrThOv+CVZQX0y7O6nfXwlW+3+pvLmWcJNWx2xpSnkgz2vQzw+8L/tljsmumO0HqT/Fd1y0zw3aiQundDFzYQ5PvqS5MEchXOFST/NLd+Gn81R/k8TMMnK8Zr+2wxwQ1Tc7S4RbITo1IFQOBPKQ1MB8PJaJ38XEofxnZA6s+mFMvCsTH8GCvcp7VSgf532o/Zb+jGMW4zhNPePa9D0o4ms2smEbRVjNLjZ22zb6fQhcQT+EAlu30m4j84nleRLPISqNEIRNIlLmlzeEJ+XozGdSV/NtNeHBf9PPdOHu+vRvMQ5CD0ILq65CInNcjs98IXNr9k6mvcyZ+UHPrd7JjAsifkbqbzX8iH4RuN2dVd9sHu3+JvxS5tRyO4yTUHUTAcfmidTLjJmPZNbMLrkZs91Le0Ll7YR8OxD4bRDqKjKLZo/MmKkg1NoVSXsRXfMxAchRuQlrAvUnGdcRmV/rYULF5rmq/6Iz43yd8fQDCdUbRKv88/PC3cnnmYsns35vLjRqE9cG/Ap8FBQ9NrGi0Saa1YlGemJYveg1lFuBmJ3B+ygvAJl19McgZiGaVY7JAtm9GLQumvejjwgT5AzN8X9QRsoSkNJ4wosE5pHAaiTM5jnWIR6p78sqxu+hHbuVwPdjZYxNHOs1pIJyC8Z1gvEi9YMk5cbNbsWuAt+lnnHFLqOcDE6i/n3670YZ6Vwwn3G+ceH44leCRdTP5b1o+sWKJKANsTPovx1lEgSxm35vjiUyFzXH3h8vbY4HIlBDMYPDUScv5mLQA9TLW5qMLUIP5svDBIIbmb5KOAoBzBJPNcmYyQQyTQn4PzcbNgn1zBdPNkkIePwc2kdR5nlCNmXMcyLq25e4NShI8QhkPGYt4Q7KmMFEQ7k5yLgThvE8+D6KlPgKz3EP8VOpv496BCLpa2EKHyhQHsB4dwv7kbHKuZIy/jderNh4rhG611H/srAIQc5lnGmMO93DOA7QHrdZyr5NEUsyg+i/kHENMoxLbMsME0szI24UZtZlfMgSenjO4MTjFhMxc3GMMwFDk8Q4Etj/xELKGJS+NanH3adCCzzke1JkLk0y+5BEJrAfCjgJ+StkfX24z/EdqY9hHpjlRGhCAmY8qJADMHQ72T//gnPh/vlmWFphH5DZsY+KNNjfaBZObUV99jo5efuwpNheo+yRvZc8qdU9qL76xMXU1lk//9JB1xeiea4Vmo6zDFL+tLahSrgG4nzqoV5pBydd6uw8yEC/kti5lqreZSscdSJPCtspvWR/XkJ72XNXiYIUl1vbU70Icv8jYfV38if2l7LT9vfafqeF/Ip9kqDn5GqeQ/pPEA4fG0v9a+B0noMnH2aBSW8cJEz+7hjPCa9/kD12av7Ic9Imh5ROs/8j8XAeC+c78gOuR8RSnVelJs5VYi3OhzJHzsOi6dUjxe6cR2vSH8HmPtl7V2clyl2t5c+cYbLrTqTUxGnAOA+JnVZ5oZVwjRLQrmz5TVdbCZwrVWzPKRGdd9aKhbk2yp85e9h3j9bTmUsapYIgbB/rp5jobD3B6V7k5GYE9/R24Y9aL6e6gl8nQmpWu5WCPVdXqZnT6i7WUeGG00Lr4Nwos+M01AddDWT2qoxGzpZJjpwzCu6qeGUuXFXEtpwnxTbtY6QrDmv97eMKbqs0IrmwVea++vv1z6ptjVivO8bv7hgT28/tP197lSsyXmxvegYI+Ukj5kmXcBgfNioFcpC6HoQ8pGEjyeEZD7Y9lZguBcqfAhlIgfqnYBtTjtIe0pACqUlZS72EwEzEB0witAjga/z4Pj+kxo/P9uMLM1MoMx4/NtMP9c+EzPghh35sZhq+Lw0ukDZLmA+ZmTCUcSqiNsnY6jRCFu91lPH9acwrnfVNe4oyMarvKuqDPg3OUR7OuPA9PnyE7xeQ0CPwLP3BQdL2M45gGZ+dTkjgJab2EcLEsD7J1wet8gUSdFFONey+P+BUkM/BrGsmcvH6OOF8yN0UQpCh/xHmwHn8yGWgQjgA8lkmo2TGMd5cfGsOvj3Qnvchlz64QiY+NgNfneGnPXKXNZr32JfAeOonUCZk68/3Az/RP/LtRR4yIM0B9n+IQlSTDTcJwL38hNCBYyBc0E8IO1VGyQy9lnHATUejt3nImZ9QNKcZ81xEvTJt5u+E+DPhRIVwsnxyIHm38f2dzIfQ8R2CnDL0eyI5menI60ROTQfDNUvgJHOQx9GQ+FxSEH7lmM17nIH52Wcv7fxwSx/rm07oXASn8cNNgnIUIKTN1BmJyVawZRVhX3IfBrFjeehpAVwwG7uTA4fLRn/L+c50Ui1DsCNT0fu34Hbj4JB5cKUA+5RBUJiB3E9S5sxMYb2G7DR/eAiOmAXIwGQQO2ZxKJyB2QswbC/iNREKPgoq7RNnMB7EwtMJlE8zmVBdL6GPj+VMhxKnf39h/76geBLDpkMh01HDTzikHsw2BzC7GSxbALOQgTn3Ip5eMis+zK4X85BODO9HncZX/InDXTP+sUsbphEI6Jxw4bgPqGelZ5ZTr8MiU0AOqYAVymEGAUj5eHJXU1HoYPCY/SbtOHT1E2yNxDDNRoDGwCZ7oXAZGOgA1wEyyc0EDUsGUXQmObWMfNojAZkYtmzaBf5KfR5IUOXH4HrB/iHU42j9BA3ZSFQgaNioz0CBM1HYDAzMaILUInKJeRjQAq4zDCEXmcV72eT0cnAY/nDhUAzLTNqPpF0+WZlcJDcDA5eNw9iM43uJcb6IQZvHPo3GseZiKBeQVZiAIRwE4cnBUQRIKvuRcD85OR9BeVDxszFsWRjKLF1TMANwKJkQqP6KKsxYNCcfw1mAwc/H0A9Eg3MZ30CyPivv5n0c50D24S3GM4X5FWD4Ahik/mikj/lMw/GNZR0H/mbIwkzt4P2dNK8nPinZ7T3/Tk+c+6J3en53ElzZ3X9xomZ+CyUvpaaXf5d/l38X/f3RiRrO5ojOMc14nFYR7GY+bv8lhZ5mnlhxaC2c0zy0bwZOZyT0oRDWU0jUNEtGzOqlDKjVBue3cP2fOCHbMObS6v8aSSJDyrIUK/s+vOhtUqgLSZUt4grOVYqlzWrlOsxyxdRmJdZxCZfarqK8HG/yT3KArxHWlhGGleNN5mK15/fle4QTZVy1mQvdn0UqbjZhaSlh5EZ424ewiwXwnFcJT5biDctPXNh/ueYb0h/v9fEzF85nORvyBlfCfv1S5a3aMKsL9Ph9Uo6zSUGuIlzcpoN98wH0eCn8cznh4krmAws3b9NP6boLx72MM5S34JkrdBXDlMHr3oQVlOng2yzhsmBNwtNFsKIVs4Tz2O+l7N8iwvR3SZEvgg0s5bulfO8wbOMVsSDLYv23EIYfZl6fczazBy97ENb1MuHcftZhBaxqJ+u0gXDmYxRpH965nPJKLmeu4MzmHeZfBrtaTe54Ad9bDa//B+PawDzeJRz6CfawLly4dssfnpDBhbqyql3grp3gfq3htK0JklpzHtyV4OQ9EszzdNGxds2MP3HC4qt1aXXuzkHw82x/BCcYvRDH4JFaF8SkBwPqw4FpJEdskWxPJNF5N/rvQrjQUwM3w1nO7kSREZCfCNSjC+rTke3Pgzz2REx6kx3pSPTbB7HqwtFTtwphDNvckWxGDOHSErJh0UTnI4jqezDfxUTx0ZDQPpC6FxC7hdzEe5FxP4/4RStKD1mOPnbC/MWx4T7sdAT2OJKbD71ZryhIZwTiFUXQ0z2N9hxN9kOQ/BpHSBhksQdhWzRqFc+BeCTmM5q7xFcSvDxPmNiVbEVPouEsgoPuBEk9WI+ekP5uqEt+6wu/mxvMtrG/XuQqjeAjGbO7h33ohvmOI1sTxYlVCuqayPr1YzxRBBuRRP9R9BvJ+KLIYnbH/bjJmnACa6IJDp9XyvvcEXEvzEYs2ddYgs4pp8+qrO09y6LP12IJnTWPi92dpZXWlopKdHYr8nN9rlSIa4p8iGu+Uju2WwzfDlHqwvWD8uVVJysitOpq8eq8pk2udp+E2J6Gz6jaSuV2uowUOlu2NLS9UmuhT0iJ7FUS5moFXNy3telVD3LbYbCsizVAymxFKP9vxZEK+wSl2okv2qnU6Ndu6o/0CVqfyhW6mNEJGf32pa9xD+O6cBHXordx62Ystw+KlQq2ChXZWVuV2rZWc213Bhf8FyLUM5UasoaIXIWsY3/2sl9TJVzWdK4BF3BbYh2+LpF/JNgfLszSbRfrVxkVK5d+Q5SDsYjMrU+kfNbQCuEGrhNPkhJbi3nfN555KUdjdabdVkXAlkeRq0UEabXjHxcGK/VsBZQZsJZwbbuEfV0s42YNkvJay7gOPJJ1my/OYvWTEQ+px3VvD9faD3H9uC/Xyb/k+vFMOMsS+XprGNeuB4trhe6UMXdqcRnydd1TCC3RuoSMle8MKVSGI7SNvJoTGS68VylOZwz/eFHAP5ZMZb59RXKtbDmDKmN2M9584Sc6Rg1dybnhk5zX9Oa68VplClzNZPzsr2XMnEact5WvUn1XLtE1FOewS3Tc77TUvthHuVz5iI48nJkalz1cRwah73Et/QWtn71bmYmQTnBZrzis1Xs78+R6eTwcKJ35xnCd/NSoPzofIm/ah6tYcfwXzUAsYgxpoCie9yJtEY9ldJNeS4TojCDfOg5C14/6tRCdIZz5J0GMN2MMdkPAcyF8J/HUG7nDXk/EzHoAj1pGxNKNq2DPYIl7QLAwUiab+bxMYJGHh93MHb9vMA71IGiHg/+zQCQ1Cs+XDDHeRlpnB+keH4HCetI6m1i3DaxXMpZ/GWm3Qs5xXiBA6MP6fsT/mOSzTvH8L0k05xzFMKKxpNVyId6FjK8THr0Dnq0dVPAUkV/ko//9OU/pzEszu7kEKkPxhEvxsMPwnC/hyfOglosZzxjuHKwgvTiMwG0eEewQBVTWdsY9gfTXXO5mjESOJiNXE2Fu42BuxaQ9p8IUSpDrachTKedEY6HEC0nnDq4QLuGco4B03iLObQZzGWo68pFHmm0WVHo0zG96OPNgXwvZ/yn0MwEGVwzjGYscF0PNR8HoijlHGEW/40gvl7A3k9GX+cHxEFguozwaPVpIu6EwwqkEUJO4I/QtgfAaGMuHnMtM5iBgKUx6Kecv+5Gjzdo36zoS/zMI2ErZ14Wko6ezL2th9GdY3x0E3K8i9+s5b/mAff+WfdrD/m2Fka/j6uEBGO8a+j3NOLdyXriNA4gvmOcysILxvouebsH+ZLJOwwmc3+AcehT9DUT/CpHvAejbUJhnDgFfpbkIMzWDqdPEyvjprN3VH9K2MHOlihFJqXGezNbJSbH9LppF/f/NLidUL/8u//43v3NaeWE+tfLZOS95fovLynf5d/n3P/v9H1a5v6E5QAAA";
-	}
-	
 }
diff --git a/src/main/java/dev/wolveringer/animations/Animation.java b/src/main/java/dev/wolveringer/animations/Animation.java
index 8c9d105..60fcb4e 100644
--- a/src/main/java/dev/wolveringer/animations/Animation.java
+++ b/src/main/java/dev/wolveringer/animations/Animation.java
@@ -1,10 +1,10 @@
 package dev.wolveringer.animations;
 
 public class Animation {
-	private int PID;
-	
-	
-	public int getPID() {
-		return this.PID;
-	}
+    private int PID;
+
+
+    public int getPID() {
+        return this.PID;
+    }
 }
diff --git a/src/main/java/dev/wolveringer/animations/AnimationCallback.java b/src/main/java/dev/wolveringer/animations/AnimationCallback.java
index 80a4afe..7f37b47 100644
--- a/src/main/java/dev/wolveringer/animations/AnimationCallback.java
+++ b/src/main/java/dev/wolveringer/animations/AnimationCallback.java
@@ -1,5 +1,5 @@
 package dev.wolveringer.animations;
 
 public interface AnimationCallback {
-	public void done();
+    public void done();
 }
diff --git a/src/main/java/dev/wolveringer/animations/inventory/InventoryViewChangeAnimations.java b/src/main/java/dev/wolveringer/animations/inventory/InventoryViewChangeAnimations.java
index c137d9a..2d0bdaa 100644
--- a/src/main/java/dev/wolveringer/animations/inventory/InventoryViewChangeAnimations.java
+++ b/src/main/java/dev/wolveringer/animations/inventory/InventoryViewChangeAnimations.java
@@ -1,223 +1,222 @@
 package dev.wolveringer.animations.inventory;
 
+import net.md_5.bungee.api.Callback;
+
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.concurrent.TimeUnit;
 
-import net.md_5.bungee.BungeeCord;
-import net.md_5.bungee.api.Callback;
-import dev.wolveringer.BungeeUtil.Main;
 import dev.wolveringer.BungeeUtil.Material;
 import dev.wolveringer.BungeeUtil.Player;
 import dev.wolveringer.BungeeUtil.item.Item;
-import dev.wolveringer.animations.inventory.InventoryViewChangeAnimations.AnimationType;
 import dev.wolveringer.api.inventory.Inventory;
 import dev.wolveringer.api.inventory.ItemContainer;
 
 public class InventoryViewChangeAnimations {
-	public static enum AnimationType {
-		SCROLL_DOWN,
-		SCROLL_UP,
-		SCROLL_LEFT;
-	}
-
-	public static void runAnimation(AnimationType type, Inventory base, ItemContainer new_contains) {
-		runAnimation(type, base, new_contains, base.getName());
-	}
-
-	public static void runAnimation(AnimationType type, Inventory base, ItemContainer new_contains, String new_name) {
-		runAnimation(type, base, new_contains, new_name, new Item(Material.WOOL));
-	}
-
-	public static void runAnimation(AnimationType type, Inventory base, ItemContainer new_contains, String new_name, Item spacer) {
-		runAnimation(type, base, new_contains, new_name, spacer, 200);
-	}
-
-	public static void runAnimation(AnimationType type, Inventory base, ItemContainer new_contains, String new_name, Item spacer,int delay) {
-		runAnimation(type, base, new_contains, new_name, spacer, delay, null);
-	}
-	
-	public static void runAnimation(AnimationType type,final Inventory base,final Inventory new_inventory, String new_name, Item spacer,int delay,final Callback<Void> callback) {
-		Callback _callback = new Callback<Void>() {
-			@Override
-			public void done(Void arg0, Throwable arg1) {
-				for(Player p : new ArrayList<>(base.getViewer()))
-					p.openInventory(new_inventory);
-				if(callback != null)
-					callback.done(arg0, arg1);
-			}
-		};
-		if(type == AnimationType.SCROLL_DOWN)
-			runScroolUpAnimation(base, new_inventory.unsave().getItemContainer(), new_name, spacer,delay,_callback);
-		else if(type == AnimationType.SCROLL_UP)
-			runScroolDownAnimation(base, new_inventory.unsave().getItemContainer(), new_name, spacer, delay,_callback);
-	}
-	
-	public static void runAnimation(AnimationType type, Inventory base, ItemContainer new_contains, String new_name, Item spacer,int delay,final Callback<Void> callback) {
-		if(type == AnimationType.SCROLL_DOWN)
-			runScroolUpAnimation(base, new_contains, new_name, spacer,delay,callback);
-		else if(type == AnimationType.SCROLL_UP)
-			runScroolDownAnimation(base, new_contains, new_name, spacer, delay,callback);
-	}
-	
-	private static void runScroolLeftAnimation(final Inventory base, final ItemContainer new_contains, final String new_name, final Item space,int delay,final Callback<Void> callback) {
-		
-	}
-	
-	private static void runScroolUpAnimation(final Inventory base, final ItemContainer new_contains, final String new_name, final Item space,int delay,final Callback<Void> callback) {
-		final Item[][] old_rows = buildCollums(base);
-		final Item[][] new_rows = buildCollums(new_contains);
-
-		final Item[][] spacer = new Item[1][9];
-		Arrays.fill(spacer[0], space);
-
-		/**
-		 * [ROW_NUMBER][ROW]
-		 */
-		final Item[][] rows = new Item[old_rows.length + new_rows.length + 1][9];
-
-		put(rows, old_rows, 0);
-		put(rows, spacer, old_rows.length);
-		put(rows, new_rows, old_rows.length + 1);
-
-		final int old_row_count = base.getSlots() / 9;
-		final int row_count = new_contains.getSize() / 9;
-		final int row_diff = row_count - old_row_count;
-
-		LimetedScheduller scheduller = new LimetedScheduller(old_rows.length + new_rows.length + 1 - row_count, delay, TimeUnit.MILLISECONDS) {
-			@Override
-			public void run(int count) {
-				base.disableUpdate();
-				if(limit - count + 1 <= row_diff){
-					base.resize(base.getSlots() + 9);
-					for(int i = count;i < count + row_count;i++)
-						if((i - count) * 9 < base.getSlots())
-							if(i < rows.length)
-								setRowContains(base, i - count, rows[i]);
-				}else{
-					boolean x = false;
-					for(int i = count;i < count + old_row_count;i++){
-						if(i < rows.length)
-							setRowContains(base, i - count, rows[i]);
-						else
-							x = true;
-					}
-					if(x)
-						base.resize(base.getSlots() - 9);
-				}
-				if(this.count ==(int) (this.limit/2) && !base.getName().equalsIgnoreCase(new_name))
-					base.setName(new_name);
-				base.enableUpdate();
-			}
-			@Override
-			public void done() {
-				if(callback != null)
-					callback.done(null, null);
-			}
-		};
-		scheduller.start();
-	}
-
-	private static void runScroolDownAnimation(final Inventory base, final ItemContainer new_contains, final String new_name, final Item space,int delay,final Callback<Void> callback) {
-		final Item[][] old_rows = buildCollums(base);
-		final Item[][] new_rows = buildCollums(new_contains);
-
-		final Item[][] spacer = new Item[1][9];
-		Arrays.fill(spacer[0], space);
-
-		/**
-		 * [ROW_NUMBER][ROW]
-		 */
-		final Item[][] rows = new Item[old_rows.length + new_rows.length + 1][9];
-
-		put(rows, new_rows, 0);
-		put(rows, spacer, new_rows.length);
-		put(rows, old_rows, new_rows.length + 1);
-
-		final int new_row_count = new_contains.getSize() / 9;
-
-		LimetedScheduller scheduller = new LimetedScheduller(old_rows.length + new_rows.length + 1  - new_row_count, delay, TimeUnit.MILLISECONDS) {
-			boolean rezised_done = false;
-			@Override
-			public void run(int c) {
-				base.disableUpdate();
-				int count = limit-c;
-				boolean resized = false;
-				if(count < 0){
-					base.enableUpdate();
-					return;
-				}
-				if(base.getSlots() / 9 < new_row_count){
-					base.resize(base.getSlots() + 9);
-					this.count-=1;
-					resized = true;
-					if((int)(base.getSlots() / 9) == new_row_count){
-						resized = false;
-						rezised_done = true;
-					}
-				}
-				if(base.getSlots() / 9 > new_row_count){
-					base.resize(base.getSlots()-9);
-					base.enableUpdate();
-					return;
-				}
-				base.clear();
-				for(int i = count;i < count+new_row_count;i++){
-					if(rows.length>i+(resized?1:0))
-						setRowContains(base, i-count, rows[i+(resized?1:0)]);
-					else
-						setRowContains(base, i-count, rows[i]);
-				}
-				if(rezised_done){
-					this.count++;
-					rezised_done = false;
-				}
-				if(this.count ==(int) (this.limit/2) && !base.getName().equalsIgnoreCase(new_name))
-					base.setName(new_name);
-				base.enableUpdate();
-			}
-			@Override
-			public void done() {
-				if(callback != null)
-					callback.done(null, null);
-			}
-		};
-		scheduller.start();
-	}
-
-	private static void put(Item[][] base, Item[][] data, int start) {
-		for(int i = start;i - start < data.length;i++){
-			base[i] = data[i - start];
-		}
-	}
-
-	private static void setRowContains(Inventory inv, int row, Item[] rowItems) {
-		for(int i = row * 9;i < row * 9 + 9;i++)
-			if(i < inv.getSlots())
-				inv.setItem(i, rowItems[i - row * 9]);
-	}
-
-	/**
-	 * @param inv
-	 * @return Item[ROW_NUMBER][ROW]
-	 */
-	private static Item[][] buildCollums(Inventory inv) {
-		Item[][] rows = new Item[inv.getSlots() / 9][9];
-		for(int x = 0;x < rows.length;x++)
-			for(int y = 0;y < rows[0].length;y++)
-				rows[x][y] = inv.getItem(x * 9 + y);
-		return rows;
-	}
-
-	/**
-	 * @param container
-	 * @return Item[ROW_NUMBER][ROW]
-	 */
-	private static Item[][] buildCollums(ItemContainer container) {
-		Item[][] rows = new Item[container.getSize() / 9][9];
-		for(int x = 0;x < rows.length;x++)
-			for(int y = 0;y < rows[0].length;y++)
-				rows[x][y] = container.getItem(x * 9 + y);
-		return rows;
-	}
+    public static void runAnimation(AnimationType type, Inventory base, ItemContainer new_contains) {
+        runAnimation(type, base, new_contains, base.getName());
+    }
+
+    public static void runAnimation(AnimationType type, Inventory base, ItemContainer new_contains, String new_name) {
+        runAnimation(type, base, new_contains, new_name, new Item(Material.WOOL));
+    }
+
+    public static void runAnimation(AnimationType type, Inventory base, ItemContainer new_contains, String new_name, Item spacer) {
+        runAnimation(type, base, new_contains, new_name, spacer, 200);
+    }
+
+    public static void runAnimation(AnimationType type, Inventory base, ItemContainer new_contains, String new_name, Item spacer, int delay) {
+        runAnimation(type, base, new_contains, new_name, spacer, delay, null);
+    }
+
+    public static void runAnimation(AnimationType type, final Inventory base, final Inventory new_inventory, String new_name, Item spacer, int delay, final Callback<Void> callback) {
+        Callback _callback = new Callback<Void>() {
+            @Override
+            public void done(Void arg0, Throwable arg1) {
+                for (Player p : new ArrayList<>(base.getViewer()))
+                    p.openInventory(new_inventory);
+                if (callback != null)
+                    callback.done(arg0, arg1);
+            }
+        };
+        if (type == AnimationType.SCROLL_DOWN)
+            runScroolUpAnimation(base, new_inventory.unsave().getItemContainer(), new_name, spacer, delay, _callback);
+        else if (type == AnimationType.SCROLL_UP)
+            runScroolDownAnimation(base, new_inventory.unsave().getItemContainer(), new_name, spacer, delay, _callback);
+    }
+
+    public static void runAnimation(AnimationType type, Inventory base, ItemContainer new_contains, String new_name, Item spacer, int delay, final Callback<Void> callback) {
+        if (type == AnimationType.SCROLL_DOWN)
+            runScroolUpAnimation(base, new_contains, new_name, spacer, delay, callback);
+        else if (type == AnimationType.SCROLL_UP)
+            runScroolDownAnimation(base, new_contains, new_name, spacer, delay, callback);
+    }
+
+    private static void runScroolLeftAnimation(final Inventory base, final ItemContainer new_contains, final String new_name, final Item space, int delay, final Callback<Void> callback) {
+
+    }
+
+    private static void runScroolUpAnimation(final Inventory base, final ItemContainer new_contains, final String new_name, final Item space, int delay, final Callback<Void> callback) {
+        final Item[][] old_rows = buildCollums(base);
+        final Item[][] new_rows = buildCollums(new_contains);
+
+        final Item[][] spacer = new Item[1][9];
+        Arrays.fill(spacer[0], space);
+
+        /**
+         * [ROW_NUMBER][ROW]
+         */
+        final Item[][] rows = new Item[old_rows.length + new_rows.length + 1][9];
+
+        put(rows, old_rows, 0);
+        put(rows, spacer, old_rows.length);
+        put(rows, new_rows, old_rows.length + 1);
+
+        final int old_row_count = base.getSlots() / 9;
+        final int row_count = new_contains.getSize() / 9;
+        final int row_diff = row_count - old_row_count;
+
+        LimetedScheduller scheduller = new LimetedScheduller(old_rows.length + new_rows.length + 1 - row_count, delay, TimeUnit.MILLISECONDS) {
+            @Override
+            public void run(int count) {
+                base.disableUpdate();
+                if (limit - count + 1 <= row_diff) {
+                    base.resize(base.getSlots() + 9);
+                    for (int i = count; i < count + row_count; i++)
+                        if ((i - count) * 9 < base.getSlots())
+                            if (i < rows.length)
+                                setRowContains(base, i - count, rows[i]);
+                } else {
+                    boolean x = false;
+                    for (int i = count; i < count + old_row_count; i++) {
+                        if (i < rows.length)
+                            setRowContains(base, i - count, rows[i]);
+                        else
+                            x = true;
+                    }
+                    if (x)
+                        base.resize(base.getSlots() - 9);
+                }
+                if (this.count == (int) (this.limit / 2) && !base.getName().equalsIgnoreCase(new_name))
+                    base.setName(new_name);
+                base.enableUpdate();
+            }
+
+            @Override
+            public void done() {
+                if (callback != null)
+                    callback.done(null, null);
+            }
+        };
+        scheduller.start();
+    }
+
+    private static void runScroolDownAnimation(final Inventory base, final ItemContainer new_contains, final String new_name, final Item space, int delay, final Callback<Void> callback) {
+        final Item[][] old_rows = buildCollums(base);
+        final Item[][] new_rows = buildCollums(new_contains);
+
+        final Item[][] spacer = new Item[1][9];
+        Arrays.fill(spacer[0], space);
+
+        /**
+         * [ROW_NUMBER][ROW]
+         */
+        final Item[][] rows = new Item[old_rows.length + new_rows.length + 1][9];
+
+        put(rows, new_rows, 0);
+        put(rows, spacer, new_rows.length);
+        put(rows, old_rows, new_rows.length + 1);
+
+        final int new_row_count = new_contains.getSize() / 9;
+
+        LimetedScheduller scheduller = new LimetedScheduller(old_rows.length + new_rows.length + 1 - new_row_count, delay, TimeUnit.MILLISECONDS) {
+            boolean rezised_done = false;
+
+            @Override
+            public void run(int c) {
+                base.disableUpdate();
+                int count = limit - c;
+                boolean resized = false;
+                if (count < 0) {
+                    base.enableUpdate();
+                    return;
+                }
+                if (base.getSlots() / 9 < new_row_count) {
+                    base.resize(base.getSlots() + 9);
+                    this.count -= 1;
+                    resized = true;
+                    if ((int) (base.getSlots() / 9) == new_row_count) {
+                        resized = false;
+                        rezised_done = true;
+                    }
+                }
+                if (base.getSlots() / 9 > new_row_count) {
+                    base.resize(base.getSlots() - 9);
+                    base.enableUpdate();
+                    return;
+                }
+                base.clear();
+                for (int i = count; i < count + new_row_count; i++) {
+                    if (rows.length > i + (resized ? 1 : 0))
+                        setRowContains(base, i - count, rows[i + (resized ? 1 : 0)]);
+                    else
+                        setRowContains(base, i - count, rows[i]);
+                }
+                if (rezised_done) {
+                    this.count++;
+                    rezised_done = false;
+                }
+                if (this.count == (int) (this.limit / 2) && !base.getName().equalsIgnoreCase(new_name))
+                    base.setName(new_name);
+                base.enableUpdate();
+            }
+
+            @Override
+            public void done() {
+                if (callback != null)
+                    callback.done(null, null);
+            }
+        };
+        scheduller.start();
+    }
+
+    private static void put(Item[][] base, Item[][] data, int start) {
+        for (int i = start; i - start < data.length; i++) {
+            base[i] = data[i - start];
+        }
+    }
+
+    private static void setRowContains(Inventory inv, int row, Item[] rowItems) {
+        for (int i = row * 9; i < row * 9 + 9; i++)
+            if (i < inv.getSlots())
+                inv.setItem(i, rowItems[i - row * 9]);
+    }
+
+    /**
+     * @return Item[ROW_NUMBER][ROW]
+     */
+    private static Item[][] buildCollums(Inventory inv) {
+        Item[][] rows = new Item[inv.getSlots() / 9][9];
+        for (int x = 0; x < rows.length; x++)
+            for (int y = 0; y < rows[0].length; y++)
+                rows[x][y] = inv.getItem(x * 9 + y);
+        return rows;
+    }
+
+    /**
+     * @return Item[ROW_NUMBER][ROW]
+     */
+    private static Item[][] buildCollums(ItemContainer container) {
+        Item[][] rows = new Item[container.getSize() / 9][9];
+        for (int x = 0; x < rows.length; x++)
+            for (int y = 0; y < rows[0].length; y++)
+                rows[x][y] = container.getItem(x * 9 + y);
+        return rows;
+    }
+
+    public static enum AnimationType {
+        SCROLL_DOWN,
+        SCROLL_UP,
+        SCROLL_LEFT;
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/animations/inventory/LimetedScheduller.java b/src/main/java/dev/wolveringer/animations/inventory/LimetedScheduller.java
index 6c57977..c09c764 100644
--- a/src/main/java/dev/wolveringer/animations/inventory/LimetedScheduller.java
+++ b/src/main/java/dev/wolveringer/animations/inventory/LimetedScheduller.java
@@ -1,52 +1,52 @@
 package dev.wolveringer.animations.inventory;
 
+import net.md_5.bungee.BungeeCord;
+
 import java.util.concurrent.TimeUnit;
 
-import net.md_5.bungee.BungeeCord;
 import dev.wolveringer.BungeeUtil.BungeeUtil;
-import dev.wolveringer.BungeeUtil.Main;
 
 public abstract class LimetedScheduller implements Runnable {
-	protected int limit;
-	protected int count;
-	private int repeat_time;
-	private TimeUnit unit;
-	private int ID;
-	
-	public LimetedScheduller(int limit, int repeat_time, TimeUnit unit) {
-		this.limit = limit;
-		this.repeat_time = repeat_time;
-		this.unit = unit;
-	}
-	
-	public LimetedScheduller(int persiod,TimeUnit untim, int repeat_time, TimeUnit unit) {
-		this.limit = (int) (untim.toMillis(persiod)/unit.toMillis(repeat_time));
-		this.repeat_time = repeat_time;
-		this.unit = unit;
-	}
-
-	@Override
-	public void run() {
-		if(count > limit){
-			BungeeCord.getInstance().getScheduler().cancel(ID);
-			done();
-		}
-		run(count);
-		count++;
-	}
-
-	public abstract void run(int count);
-
-	public void done() {
-
-	}
-
-	public void start() {
-		ID = BungeeCord.getInstance().getScheduler().schedule(BungeeUtil.getPluginInstance(), this, 0, repeat_time, unit).getId();
-	}
-
-	public void stop() {
-		BungeeCord.getInstance().getScheduler().cancel(ID);
-		done();
-	}
+    protected int limit;
+    protected int count;
+    private int repeat_time;
+    private TimeUnit unit;
+    private int ID;
+
+    public LimetedScheduller(int limit, int repeat_time, TimeUnit unit) {
+        this.limit = limit;
+        this.repeat_time = repeat_time;
+        this.unit = unit;
+    }
+
+    public LimetedScheduller(int persiod, TimeUnit untim, int repeat_time, TimeUnit unit) {
+        this.limit = (int) (untim.toMillis(persiod) / unit.toMillis(repeat_time));
+        this.repeat_time = repeat_time;
+        this.unit = unit;
+    }
+
+    @Override
+    public void run() {
+        if (count > limit) {
+            BungeeCord.getInstance().getScheduler().cancel(ID);
+            done();
+        }
+        run(count);
+        count++;
+    }
+
+    public abstract void run(int count);
+
+    public void done() {
+
+    }
+
+    public void start() {
+        ID = BungeeCord.getInstance().getScheduler().schedule(BungeeUtil.getPluginInstance(), this, 0, repeat_time, unit).getId();
+    }
+
+    public void stop() {
+        BungeeCord.getInstance().getScheduler().cancel(ID);
+        done();
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/animations/text/FormatTest.java b/src/main/java/dev/wolveringer/animations/text/FormatTest.java
index bcd882d..0ec5c6d 100644
--- a/src/main/java/dev/wolveringer/animations/text/FormatTest.java
+++ b/src/main/java/dev/wolveringer/animations/text/FormatTest.java
@@ -1,28 +1,28 @@
 package dev.wolveringer.animations.text;
 
-import dev.wolveringer.BungeeUtil.BungeeUtil;
-import dev.wolveringer.BungeeUtil.Main;
 import net.md_5.bungee.api.ChatColor;
 
+import dev.wolveringer.BungeeUtil.BungeeUtil;
+
 public class FormatTest {
-	public static void main(String[] args) {
-		new scroler().start();
-	}
+    public static void main(String[] args) {
+        new scroler().start();
+    }
 }
 
 class scroler extends Thread {
-	TextFormater s = new TextFormater("<scroller width=10  space=0 time=100>HELL"+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"nO THIS IS A"+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"a TEST"+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"a STRING!</scroller>XX<scroller width=10  space=0 time=150>HELLO THIS IS A TEST STRING!</scroller>XX<scroller width=10  space=0 time=200>HELLO THIS IS A TEST STRING!</scroller>");
+    TextFormater s = new TextFormater("<scroller width=10  space=0 time=100>HELL" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "nO THIS IS A" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "a TEST" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "a STRING!</scroller>XX<scroller width=10  space=0 time=150>HELLO THIS IS A TEST STRING!</scroller>XX<scroller width=10  space=0 time=200>HELLO THIS IS A TEST STRING!</scroller>");
 
-	@Override
-	public void run() {
-		while (true){
-			BungeeUtil.getInstance().sendMessage("\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n");
-			BungeeUtil.getInstance().sendMessage("\"" + ChatColor.stripColor(s.getNextString()) + "\"");
-			try{
-				Thread.sleep(s.getTick());
-			}catch (InterruptedException e){
-				e.printStackTrace();
-			}
-		}
-	}
+    @Override
+    public void run() {
+        while (true) {
+            BungeeUtil.getInstance().sendMessage("\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n");
+            BungeeUtil.getInstance().sendMessage("\"" + ChatColor.stripColor(s.getNextString()) + "\"");
+            try {
+                Thread.sleep(s.getTick());
+            } catch (InterruptedException e) {
+                e.printStackTrace();
+            }
+        }
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/animations/text/NumericUntil.java b/src/main/java/dev/wolveringer/animations/text/NumericUntil.java
index 706bbd5..deae989 100644
--- a/src/main/java/dev/wolveringer/animations/text/NumericUntil.java
+++ b/src/main/java/dev/wolveringer/animations/text/NumericUntil.java
@@ -1,31 +1,31 @@
 package dev.wolveringer.animations.text;
 
 public class NumericUntil {
-	public static long ggt(long a,long b){
-		if(a > b){
-			long h = a;
-			a = b;
-			b = h;
-		}
-		long r;
-		while (a > 0){
-			r = b % a;
-			b = a;
-			a = r;
-		}
-		return b;
-	}
-	public static long ggt(long...z){
-		if(z.length>2){
-			long nenner = ggt(z[0],z[1]);
-			for(int i = 2;i<z.length;i++)
-				nenner= ggt(nenner,z[i]);
-			return nenner;
-		}
-		else if(z.length==2)
-			return ggt(z[0],z[1]);
-		else if(z.length==1)
-			return z[0];
-		return 1;
-	}
+    public static long ggt(long a, long b) {
+        if (a > b) {
+            long h = a;
+            a = b;
+            b = h;
+        }
+        long r;
+        while (a > 0) {
+            r = b % a;
+            b = a;
+            a = r;
+        }
+        return b;
+    }
+
+    public static long ggt(long... z) {
+        if (z.length > 2) {
+            long nenner = ggt(z[0], z[1]);
+            for (int i = 2; i < z.length; i++)
+                nenner = ggt(nenner, z[i]);
+            return nenner;
+        } else if (z.length == 2)
+            return ggt(z[0], z[1]);
+        else if (z.length == 1)
+            return z[0];
+        return 1;
+    }
 }
diff --git a/src/main/java/dev/wolveringer/animations/text/RunningTextFormater.java b/src/main/java/dev/wolveringer/animations/text/RunningTextFormater.java
index 76cee94..8c11919 100644
--- a/src/main/java/dev/wolveringer/animations/text/RunningTextFormater.java
+++ b/src/main/java/dev/wolveringer/animations/text/RunningTextFormater.java
@@ -1,53 +1,54 @@
 package dev.wolveringer.animations.text;
 
+import net.md_5.bungee.BungeeCord;
+
 import java.util.concurrent.TimeUnit;
 
-import net.md_5.bungee.BungeeCord;
 import dev.wolveringer.BungeeUtil.BungeeUtil;
-import dev.wolveringer.BungeeUtil.Main;
 
 public abstract class RunningTextFormater {
-	private int PID = -1;
-	private TextFormater format;
-
-	public RunningTextFormater(String in) {
-		format = new TextFormater(in);
-	}
-
-	public void start(){
-		if(PID == -1){
-			BungeeCord.getInstance().getScheduler().schedule(BungeeUtil.getPluginInstance(), new Runnable() {
-				@Override
-				public void run() {
-					update(format.getNextString());
-				}
-			}, 0, format.getTick(), TimeUnit.MILLISECONDS);
-		}
-	}
-
-	public void stop() {
-		if(PID != -1){
-			BungeeCord.getInstance().getScheduler().cancel(PID);
-			PID = -1;
-		}
-	}
-	
-	public TextFormater getFormater() {
-		return this.format;
-	}
-	public abstract void update(String newText);
-	
-	public static void main(String[] args) {
-		//Starting an scroler animation with the HTML tag <scroller>
-		//Needet arguments are:
-		//  - width --> The maximung with of the scroler
-		//  - space --> Space between repeating
-		//  - time --> time per step in ms
-		RunningTextFormater scrooler = new RunningTextFormater("<scroller width=10  space=0 time=100>HELL"+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"nO THIS IS A"+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"a TEST"+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"a STRING!</scroller>XX<scroller width=10  space=0 time=150>HELLO THIS IS A TEST STRING!</scroller>XX<scroller width=10  space=0 time=200>HELLO THIS IS A TEST STRING!</scroller>") {
-			@Override
-			public void update(String newText) {
-				//this methode will run when the text is updating
-			}
-		};
-	}
+    private int PID = -1;
+    private TextFormater format;
+
+    public RunningTextFormater(String in) {
+        format = new TextFormater(in);
+    }
+
+    public static void main(String[] args) {
+        //Starting an scroler animation with the HTML tag <scroller>
+        //Needet arguments are:
+        //  - width --> The maximung with of the scroler
+        //  - space --> Space between repeating
+        //  - time --> time per step in ms
+        RunningTextFormater scrooler = new RunningTextFormater("<scroller width=10  space=0 time=100>HELL" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "nO THIS IS A" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "a TEST" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "a STRING!</scroller>XX<scroller width=10  space=0 time=150>HELLO THIS IS A TEST STRING!</scroller>XX<scroller width=10  space=0 time=200>HELLO THIS IS A TEST STRING!</scroller>") {
+            @Override
+            public void update(String newText) {
+                //this methode will run when the text is updating
+            }
+        };
+    }
+
+    public void start() {
+        if (PID == -1) {
+            BungeeCord.getInstance().getScheduler().schedule(BungeeUtil.getPluginInstance(), new Runnable() {
+                @Override
+                public void run() {
+                    update(format.getNextString());
+                }
+            }, 0, format.getTick(), TimeUnit.MILLISECONDS);
+        }
+    }
+
+    public void stop() {
+        if (PID != -1) {
+            BungeeCord.getInstance().getScheduler().cancel(PID);
+            PID = -1;
+        }
+    }
+
+    public TextFormater getFormater() {
+        return this.format;
+    }
+
+    public abstract void update(String newText);
 }
diff --git a/src/main/java/dev/wolveringer/animations/text/Scroller.java b/src/main/java/dev/wolveringer/animations/text/Scroller.java
index e28cff8..2a4cc7b 100644
--- a/src/main/java/dev/wolveringer/animations/text/Scroller.java
+++ b/src/main/java/dev/wolveringer/animations/text/Scroller.java
@@ -1,67 +1,68 @@
 package dev.wolveringer.animations.text;
 
+import net.md_5.bungee.api.ChatColor;
+
 import java.util.ArrayList;
 import java.util.List;
 
-import net.md_5.bungee.api.ChatColor;
 import dev.wolveringer.chat.ChatColor.ChatColorUtils;
 
 public class Scroller {
-	private int position;
-	private List<String> list;
-	private String colour = ChatColor.RESET + "";
+    private int position;
+    private List<String> list;
+    private String colour = ChatColor.RESET + "";
 
-	public Scroller(String message, int width, int spaceBetween, char colourChar) {
-		list = new ArrayList<String>();
-		if(ChatColor.stripColor(message).length() < width){
-			while (ChatColor.stripColor(message).length() < width)
-				message += " ";
-		}
+    public Scroller(String message, int width, int spaceBetween, char colourChar) {
+        list = new ArrayList<String>();
+        if (ChatColor.stripColor(message).length() < width) {
+            while (ChatColor.stripColor(message).length() < width)
+                message += " ";
+        }
 
-		if(width < 1)
-			width = 1;
-		if(spaceBetween < 0)
-			spaceBetween = 0;
+        if (width < 1)
+            width = 1;
+        if (spaceBetween < 0)
+            spaceBetween = 0;
 
-		if(colourChar != dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR)
-			message = ChatColor.translateAlternateColorCodes(colourChar, message);
+        if (colourChar != dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR)
+            message = ChatColor.translateAlternateColorCodes(colourChar, message);
 
-		String raw = ChatColor.stripColor(message);
-		while (raw.length() < message.length() + spaceBetween){
-			raw += " ";
-		}
-		String msg = message;
-		while (msg.length() <= message.length() + spaceBetween){
-			msg += " ";
-		}
-		String color = "";
-		for(int i = 0;i < raw.length();i++){
-			while (i - 1 >= 0 && msg.charAt(i - 1) == dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR){
-				ChatColor g = ChatColor.getByChar(msg.charAt(i));
-				if(ChatColorUtils.isColor(g)) //WORK?
-					color = g + "";
-				else
-					color += g;
-				i++;
-			}
-			while (msg.charAt(i % msg.length()) == dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR){
-				ChatColor g = ChatColor.getByChar(msg.charAt((i % msg.length()) + 1));
-				if(ChatColorUtils.isColor(g)) //WORK?
-					color = g + "";
-				else
-					color += g;
-				i += 2;
-			}
-			list.add(color + StringUntils.subStringWithoutChatcolors(msg, i > msg.length() ? msg.length() : i, i + width > msg.length() ? msg.length() : i + width) + StringUntils.subStringWithoutChatcolors(msg, 0, i + width > msg.length() ? (i + width) - msg.length() : 0));
-		}
-	}
+        String raw = ChatColor.stripColor(message);
+        while (raw.length() < message.length() + spaceBetween) {
+            raw += " ";
+        }
+        String msg = message;
+        while (msg.length() <= message.length() + spaceBetween) {
+            msg += " ";
+        }
+        String color = "";
+        for (int i = 0; i < raw.length(); i++) {
+            while (i - 1 >= 0 && msg.charAt(i - 1) == dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR) {
+                ChatColor g = ChatColor.getByChar(msg.charAt(i));
+                if (ChatColorUtils.isColor(g)) //WORK?
+                    color = g + "";
+                else
+                    color += g;
+                i++;
+            }
+            while (msg.charAt(i % msg.length()) == dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR) {
+                ChatColor g = ChatColor.getByChar(msg.charAt((i % msg.length()) + 1));
+                if (ChatColorUtils.isColor(g)) //WORK?
+                    color = g + "";
+                else
+                    color += g;
+                i += 2;
+            }
+            list.add(color + StringUntils.subStringWithoutChatcolors(msg, i > msg.length() ? msg.length() : i, i + width > msg.length() ? msg.length() : i + width) + StringUntils.subStringWithoutChatcolors(msg, 0, i + width > msg.length() ? (i + width) - msg.length() : 0));
+        }
+    }
 
-	public String next() {
-		return list.get(position++ % list.size()).substring(0);
-	}
+    public String next() {
+        return list.get(position++ % list.size()).substring(0);
+    }
 
-	@Override
-	public String toString() {
-		return "Scroller [position=" + position + ", list=" + list + ", colour=" + colour + "]";
-	}
+    @Override
+    public String toString() {
+        return "Scroller [position=" + position + ", list=" + list + ", colour=" + colour + "]";
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/animations/text/StringUntils.java b/src/main/java/dev/wolveringer/animations/text/StringUntils.java
index 27b838a..41bb721 100644
--- a/src/main/java/dev/wolveringer/animations/text/StringUntils.java
+++ b/src/main/java/dev/wolveringer/animations/text/StringUntils.java
@@ -1,24 +1,24 @@
 package dev.wolveringer.animations.text;
 
 public class StringUntils {
-	public static String subStringWithoutChatcolors(String s,int min,int max){
-		String out = "";
-		int pos = min;
-		int rpos = min;
-		while (rpos<max){
-			if(s.length()<pos)
-				break;
-			while (s.charAt(pos) == dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR){
-				if(s.length()<pos)
-					break;
-				pos++;
-				out += ""+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+""+s.charAt(pos);
-				pos++;
-			}
-			out+=s.charAt(pos);
-			pos++;
-			rpos++;
-		}
-		return out;
-	}
+    public static String subStringWithoutChatcolors(String s, int min, int max) {
+        String out = "";
+        int pos = min;
+        int rpos = min;
+        while (rpos < max) {
+            if (s.length() < pos)
+                break;
+            while (s.charAt(pos) == dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR) {
+                if (s.length() < pos)
+                    break;
+                pos++;
+                out += "" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "" + s.charAt(pos);
+                pos++;
+            }
+            out += s.charAt(pos);
+            pos++;
+            rpos++;
+        }
+        return out;
+    }
 }
diff --git a/src/main/java/dev/wolveringer/animations/text/TextFormater.java b/src/main/java/dev/wolveringer/animations/text/TextFormater.java
index 7da1bdf..cd34b04 100644
--- a/src/main/java/dev/wolveringer/animations/text/TextFormater.java
+++ b/src/main/java/dev/wolveringer/animations/text/TextFormater.java
@@ -1,109 +1,114 @@
 package dev.wolveringer.animations.text;
 
-import java.util.ArrayList;
-
 import org.jsoup.Jsoup;
 import org.jsoup.nodes.Element;
 
+import java.util.ArrayList;
+
 /**
- * Usage:<br>
- * Base-Text: <br>{@code <scroller width=10  space=0 time=100>HELLO THIS IS A"+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"a TEST"+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"a STRING!</scroller>XX<scroller width=10  space=0 time=150>HELLO THIS IS A TEST STRING!</scroller>XX<scroller width=10  space=0 time=200>HELLO THIS IS A TEST STRING!</scroller>}<br>
- * Start scroler with: {@code <scroller width=<Text With>  space=<Space between end and start> time=<time per step>>}<br>
- * @author wolverindev
+ * Usage:<br> Base-Text: <br>{@code <scroller width=10  space=0 time=100>HELLO THIS IS
+ * A"+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"a TEST"+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"a
+ * STRING!</scroller>XX<scroller width=10  space=0 time=150>HELLO THIS IS A TEST
+ * STRING!</scroller>XX<scroller width=10  space=0 time=200>HELLO THIS IS A TEST
+ * STRING!</scroller>}<br> Start scroler with: {@code <scroller width=<Text With>  space=<Space
+ * between end and start> time=<time per step>>}<br>
  *
+ * @author wolverindev
  */
 public class TextFormater {
-	private final String raw;
-	private ArrayList<SpecScroll> scroler = new ArrayList<SpecScroll>();
-	private long kgn;
-
-	public TextFormater(String raw) {
-		this.raw = loadElement(Jsoup.parse(raw.replaceAll("&", ""+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"")));
-	}
-	private String loadElement(Element e) {
-		long[] l = new long[e.getElementsByTag("scroller").size()];
-		for(int o = 0;o<e.getElementsByTag("scroller").size();o++)
-			l[o] = Integer.parseInt(e.getElementsByTag("scroller").get(o).attr("time"));
-		kgn = NumericUntil.ggt(l);
-		for(Element x : e.getElementsByTag("scroller")){
-			x.attr("sid", scroler.size() + "");
-			scroler.add(new SpecScroll(x.text(), Integer.parseInt(x.attr("width")), Integer.parseInt(x.attr("space")), (int) (Integer.parseInt(x.attr("time"))/kgn)));
-		}
-		return e.html();
-	}
-	public String getNextString() {
-		for(SpecScroll s : scroler)
-			s.runTick();
-		Element e = Jsoup.parse(raw);
-		for(Element x : e.getElementsByTag("scroller")){
-			x.html(scroler.get(Integer.parseInt(x.attr("sid"))).getMessage().replaceAll(" ", "&nbsp;"));
-		}
-		return e.text().replaceAll("&nbsp;", " ");
-	}
-
-	public long getTick() {
-		return kgn;
-	}
-
-	public String getRawMessage() {
-		return raw;
-	}
+    private final String raw;
+    private ArrayList<SpecScroll> scroler = new ArrayList<SpecScroll>();
+    private long kgn;
+
+    public TextFormater(String raw) {
+        this.raw = loadElement(Jsoup.parse(raw.replaceAll("&", "" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "")));
+    }
+
+    private String loadElement(Element e) {
+        long[] l = new long[e.getElementsByTag("scroller").size()];
+        for (int o = 0; o < e.getElementsByTag("scroller").size(); o++)
+            l[o] = Integer.parseInt(e.getElementsByTag("scroller").get(o).attr("time"));
+        kgn = NumericUntil.ggt(l);
+        for (Element x : e.getElementsByTag("scroller")) {
+            x.attr("sid", scroler.size() + "");
+            scroler.add(new SpecScroll(x.text(), Integer.parseInt(x.attr("width")), Integer.parseInt(x.attr("space")), (int) (Integer.parseInt(x.attr("time")) / kgn)));
+        }
+        return e.html();
+    }
+
+    public String getNextString() {
+        for (SpecScroll s : scroler)
+            s.runTick();
+        Element e = Jsoup.parse(raw);
+        for (Element x : e.getElementsByTag("scroller")) {
+            x.html(scroler.get(Integer.parseInt(x.attr("sid"))).getMessage().replaceAll(" ", "&nbsp;"));
+        }
+        return e.text().replaceAll("&nbsp;", " ");
+    }
+
+    public long getTick() {
+        return kgn;
+    }
+
+    public String getRawMessage() {
+        return raw;
+    }
 }
 
 class SpecScroll extends Scroller {
-	private final int ft;
-	private int t;
-	private String now;
-
-	public SpecScroll(String message, int width, int spaceBetween, int tics) {
-		super(message, width, spaceBetween, dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR);
-		t = ft = tics;
-		now = super.next();
-	}
-
-	public SpecScroll runTick() {
-		t--;
-		if(t <= 0){
-			t = ft;
-			now = super.next();
-		}
-		return this;
-	}
-
-	public String getMessage() {
-		return now;
-	}
-	
-	public int getTickRate(){
-		return ft;
-	}
-
-	@Deprecated
-	@Override
-	public String next() {
-		throw new OperationNotSupportedException();
-	}
+    private final int ft;
+    private int t;
+    private String now;
+
+    public SpecScroll(String message, int width, int spaceBetween, int tics) {
+        super(message, width, spaceBetween, dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR);
+        t = ft = tics;
+        now = super.next();
+    }
+
+    public SpecScroll runTick() {
+        t--;
+        if (t <= 0) {
+            t = ft;
+            now = super.next();
+        }
+        return this;
+    }
+
+    public String getMessage() {
+        return now;
+    }
+
+    public int getTickRate() {
+        return ft;
+    }
+
+    @Deprecated
+    @Override
+    public String next() {
+        throw new OperationNotSupportedException();
+    }
 }
 
 @SuppressWarnings("serial")
 class OperationNotSupportedException extends RuntimeException {
-	public OperationNotSupportedException() {
-		super();
-	}
+    public OperationNotSupportedException() {
+        super();
+    }
 
-	public OperationNotSupportedException(String arg0, Throwable arg1, boolean arg2, boolean arg3) {
-		super(arg0, arg1, arg2, arg3);
-	}
+    public OperationNotSupportedException(String arg0, Throwable arg1, boolean arg2, boolean arg3) {
+        super(arg0, arg1, arg2, arg3);
+    }
 
-	public OperationNotSupportedException(String arg0, Throwable arg1) {
-		super(arg0, arg1);
-	}
+    public OperationNotSupportedException(String arg0, Throwable arg1) {
+        super(arg0, arg1);
+    }
 
-	public OperationNotSupportedException(String arg0) {
-		super(arg0);
-	}
+    public OperationNotSupportedException(String arg0) {
+        super(arg0);
+    }
 
-	public OperationNotSupportedException(Throwable arg0) {
-		super(arg0);
-	}
+    public OperationNotSupportedException(Throwable arg0) {
+        super(arg0);
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/animations/text/TickedTextFormater.java b/src/main/java/dev/wolveringer/animations/text/TickedTextFormater.java
index e7059ae..9260737 100644
--- a/src/main/java/dev/wolveringer/animations/text/TickedTextFormater.java
+++ b/src/main/java/dev/wolveringer/animations/text/TickedTextFormater.java
@@ -1,35 +1,35 @@
 package dev.wolveringer.animations.text;
 
-public class TickedTextFormater extends TextFormater{
-	private final int ft;
-	private int t;
-	private String now;
+public class TickedTextFormater extends TextFormater {
+    private final int ft;
+    private int t;
+    private String now;
 
-	public TickedTextFormater(String raw, int ticks) {
-		super(raw);
-		t = ft = ticks;
-		now = super.getNextString();
-	}
+    public TickedTextFormater(String raw, int ticks) {
+        super(raw);
+        t = ft = ticks;
+        now = super.getNextString();
+    }
 
-	public TickedTextFormater runTick() {
-		t--;
-		if(t <= 0){
-			t = ft;
-			now = super.getNextString();
-		}
-		return this;
-	}
+    public TickedTextFormater runTick() {
+        t--;
+        if (t <= 0) {
+            t = ft;
+            now = super.getNextString();
+        }
+        return this;
+    }
 
-	public String getMessage() {
-		return now;
-	}
-	
-	public int getTickRate(){
-		return ft;
-	}
+    public String getMessage() {
+        return now;
+    }
 
-	@Override
-	public String getNextString() {
-		throw new OperationNotSupportedException();
-	}
+    public int getTickRate() {
+        return ft;
+    }
+
+    @Override
+    public String getNextString() {
+        throw new OperationNotSupportedException();
+    }
 }
diff --git a/src/main/java/dev/wolveringer/annotations/Beta.java b/src/main/java/dev/wolveringer/annotations/Beta.java
new file mode 100644
index 0000000..4cdaf15
--- /dev/null
+++ b/src/main/java/dev/wolveringer/annotations/Beta.java
@@ -0,0 +1,37 @@
+/* Copyright 2016 Acquized
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dev.wolveringer.annotations;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Marks a Field/Constructor/Class as Beta Feature. Beta Features may
+ * get incompatible changes or even removal in future releases. An API
+ * bearing this annotation is exempt from any compatibility guarantees
+ * made by its containing library. Note that the presence of this annotation
+ * implies nothing about the quality or performance of the API in question,
+ * only the fact that its not "API-frozen".
+ *
+ * @author Acquized
+ * @origin Guava
+ */
+@Retention(RetentionPolicy.CLASS)
+@Target({ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.FIELD, ElementType.METHOD, ElementType.TYPE})
+@Documented
+public @interface Beta {
+}
diff --git a/src/main/java/dev/wolveringer/annotations/Documented.java b/src/main/java/dev/wolveringer/annotations/Documented.java
new file mode 100644
index 0000000..bcfde15
--- /dev/null
+++ b/src/main/java/dev/wolveringer/annotations/Documented.java
@@ -0,0 +1,37 @@
+/* Copyright 2016 Acquized
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dev.wolveringer.annotations;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Marks a API Part as Documented. Documented API Features
+ * are documented in any way of JavaDocs or in the wiki by
+ * the authors or contributors of this Library. This annotation
+ * is used to indicate which features have JavaDoc / Wiki
+ * Article. All Features of this API are automaticly Undocumented
+ * when not bearing a {@link dev.wolveringer.annotations.Documented}
+ * annotation.
+ *
+ * @author Acquized
+ */
+@Retention(RetentionPolicy.CLASS)
+@Target({ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.FIELD, ElementType.METHOD, ElementType.TYPE})
+@Documented
+public @interface Documented {
+}
diff --git a/src/main/java/dev/wolveringer/api/bossbar/BossBarListener.java b/src/main/java/dev/wolveringer/api/bossbar/BossBarListener.java
index 395ac41..99ef617 100644
--- a/src/main/java/dev/wolveringer/api/bossbar/BossBarListener.java
+++ b/src/main/java/dev/wolveringer/api/bossbar/BossBarListener.java
@@ -9,50 +9,51 @@ import dev.wolveringer.BungeeUtil.packets.PacketPlayOutBossBar;
 import dev.wolveringer.BungeeUtil.packets.PacketPlayOutBossBar.Action;
 import dev.wolveringer.api.bossbar.BossBarManager.BossBar;
 
-public class BossBarListener implements PacketHandler<PacketPlayOutBossBar>{
-	private static BossBarListener listener;
-	public static void init(){
-		if(listener == null && Configuration.isBossBarhandleEnabled())
-			PacketLib.addHandler(listener = new BossBarListener()); 
-	}
-	
-	@Override
-	public void handle(PacketHandleEvent<PacketPlayOutBossBar> e) {
-		Player player = e.getPlayer();
-		BossBarManager manager = player.getBossBarManager();
-		BossBar bar = null;
-		if(e.getPacket().getAction() != Action.CREATE){
-			bar = manager.getBossBar(e.getPacket().getBarId());
-			if(bar == null || !bar.isVisiable()) //Bar hidden / removed. Client dont need to get them
-				e.setCancelled(true);
-		}
-		
-		switch (e.getPacket().getAction()) {
-			case CREATE:
-				manager.bars.add(new BossBar(manager, e.getPacket().getBarId(), e.getPacket().getColor(), e.getPacket().getDivision(), e.getPacket().getHealth(), e.getPacket().getTitle(), true));
-				break;
-			case DELETE:
-				if(bar != null)
-					manager.bars.remove(bar);
-				break;
-			case UPDATE_HEALTH:
-				if(bar != null){
-					bar.setHealth(e.getPacket().getHealth());
-				}
-				break;
-			case UPDATE_STYLE:
-				if(bar != null){
-					bar.setColor(e.getPacket().getColor());
-					bar.setDivision(e.getPacket().getDivision());
-				}
-				break;
-			case UPDATE_TITLE:
-				if(bar != null){
-					bar.setMessage(e.getPacket().getTitle());
-				}
-				break;
-			default:
-				break;
-		}
-	}
+public class BossBarListener implements PacketHandler<PacketPlayOutBossBar> {
+    private static BossBarListener listener;
+
+    public static void init() {
+        if (listener == null && Configuration.isBossBarhandleEnabled())
+            PacketLib.addHandler(listener = new BossBarListener());
+    }
+
+    @Override
+    public void handle(PacketHandleEvent<PacketPlayOutBossBar> e) {
+        Player player = e.getPlayer();
+        BossBarManager manager = player.getBossBarManager();
+        BossBar bar = null;
+        if (e.getPacket().getAction() != Action.CREATE) {
+            bar = manager.getBossBar(e.getPacket().getBarId());
+            if (bar == null || !bar.isVisiable()) //Bar hidden / removed. Client dont need to get them
+                e.setCancelled(true);
+        }
+
+        switch (e.getPacket().getAction()) {
+            case CREATE:
+                manager.bars.add(new BossBar(manager, e.getPacket().getBarId(), e.getPacket().getColor(), e.getPacket().getDivision(), e.getPacket().getHealth(), e.getPacket().getTitle(), true));
+                break;
+            case DELETE:
+                if (bar != null)
+                    manager.bars.remove(bar);
+                break;
+            case UPDATE_HEALTH:
+                if (bar != null) {
+                    bar.setHealth(e.getPacket().getHealth());
+                }
+                break;
+            case UPDATE_STYLE:
+                if (bar != null) {
+                    bar.setColor(e.getPacket().getColor());
+                    bar.setDivision(e.getPacket().getDivision());
+                }
+                break;
+            case UPDATE_TITLE:
+                if (bar != null) {
+                    bar.setMessage(e.getPacket().getTitle());
+                }
+                break;
+            default:
+                break;
+        }
+    }
 }
diff --git a/src/main/java/dev/wolveringer/api/bossbar/BossBarManager.java b/src/main/java/dev/wolveringer/api/bossbar/BossBarManager.java
index d963951..36ea42b 100644
--- a/src/main/java/dev/wolveringer/api/bossbar/BossBarManager.java
+++ b/src/main/java/dev/wolveringer/api/bossbar/BossBarManager.java
@@ -12,152 +12,155 @@ import dev.wolveringer.BungeeUtil.packets.PacketPlayOutBossBar.Action;
 import dev.wolveringer.BungeeUtil.packets.PacketPlayOutBossBar.BarColor;
 import dev.wolveringer.BungeeUtil.packets.PacketPlayOutBossBar.BarDivision;
 import dev.wolveringer.animations.inventory.LimetedScheduller;
+import dev.wolveringer.chat.ChatColor.ChatColorUtils;
 import dev.wolveringer.chat.ChatSerializer;
 import dev.wolveringer.chat.IChatBaseComponent;
-import dev.wolveringer.chat.ChatColor.ChatColorUtils;
 import lombok.Getter;
-import net.md_5.bungee.api.ChatColor;
-import net.md_5.bungee.api.scheduler.ScheduledTask;
 
 public class BossBarManager {
-	
-	private static class DynamicBossBarRunner implements Runnable{
-
-		@Override
-		public void run() {
-			
-		}
-		
-	}
-	
-	@Getter
-	public static class BossBar {
-		private static float steps = 0.01F;
-		private BossBarManager manager;
-		private UUID uuid;
-		private PacketPlayOutBossBar.BarColor color;
-		private PacketPlayOutBossBar.BarDivision division;
-		private float health;
-		private IChatBaseComponent message;
-		private boolean visiable;
-		private LimetedScheduller curruntTask;
-		
-		private BossBar(BossBarManager manager) {
-			this.manager = manager;
-			uuid = UUID.randomUUID();
-			color = BarColor.PING;
-			division = BarDivision.TEN_DIVISIONS;
-			health = 0.5F;
-			message = ChatSerializer.fromMessage(ChatColorUtils.COLOR_CHAR+"cUndefined");
-		}
-		
-		public void setColor(PacketPlayOutBossBar.BarColor color) {
-			this.color = color;
-			if (visiable) this.manager.player.sendPacket(new PacketPlayOutBossBar().setBarId(uuid).setAction(Action.UPDATE_STYLE).setColor(color).setDivision(division));
-		}
-		
-		public void setDivision(PacketPlayOutBossBar.BarDivision division) {
-			this.division = division;
-			if (visiable) this.manager.player.sendPacket(new PacketPlayOutBossBar().setBarId(uuid).setAction(Action.UPDATE_STYLE).setColor(color).setDivision(division));
-		}
-		
-		public void setHealth(float value) {
-			this.health = value;
-			if (visiable) this.manager.player.sendPacket(new PacketPlayOutBossBar().setBarId(uuid).setAction(Action.UPDATE_HEALTH).setHealth(value));
-		}
-		
-		public void setMessage(IChatBaseComponent message) {
-			this.message = message;
-			if (visiable) this.manager.player.sendPacket(new PacketPlayOutBossBar().setBarId(uuid).setAction(Action.UPDATE_TITLE).setTitle(message));
-		}
-		
-		public void display() {
-			if (manager.getActiveBossBars().size() + 1 > manager.getBarLimit()) throw new RuntimeException("BossBar limit is reached!");
-			if (visiable) return;
-			visiable = true;
-			this.manager.player.sendPacket(new PacketPlayOutBossBar().setBarId(uuid).setAction(Action.CREATE).setTitle(message).setHealth(health).setColor(color).setDivision(division));
-		}
-		
-		public void hide() {
-			if (!visiable) return;
-			visiable = false;
-			this.manager.player.sendPacket(new PacketPlayOutBossBar().setBarId(uuid).setAction(Action.DELETE));
-		}
-		
-		public void dynamicChangeHealth(float health,int time,TimeUnit unit){
-			if(curruntTask != null)
-				curruntTask.stop();
-			float diff = this.health-health;
-			if(diff == 0)
-				return;
-			final float base = this.health;
-			int stepCount = (int) (diff/steps);
-			final float addPerStep = diff/stepCount;
-			int millis = (int) unit.toMillis(time);
-			int loopsTime = (int) (millis/stepCount);
-			
-			new LimetedScheduller(millis,Math.abs(loopsTime),TimeUnit.MILLISECONDS) {
-				@Override
-				public void run(int count) {
-					setHealth(base+(addPerStep*count));
-				}
-			}.start();
-		}
-		
-		protected BossBar(BossBarManager manager, UUID uuid, BarColor color, BarDivision division, float value, IChatBaseComponent message, boolean visiable) {
-			this.manager = manager;
-			this.uuid = uuid;
-			this.color = color;
-			this.division = division;
-			this.health = value;
-			this.message = message;
-			this.visiable = visiable;
-		}
-	}
-	
-	private Player player;
-	protected ArrayList<BossBar> bars = new ArrayList<>();
-	private int limit = -1;
-	
-	public BossBarManager(Player player) {
-		this.player = player;
-	}
-	
-	public BossBar getBossBar(UUID uuid) {
-		for (BossBar b : bars)
-			if (b.uuid.equals(uuid)) return b;
-		return null;
-	}
-	
-	public int getBarLimit() {
-		return limit == -1 ? Integer.MAX_VALUE : limit;
-	}
-	
-	public void setBarLimit(int limit) {
-		this.limit = limit;
-	}
-	
-	public BossBar createNewBossBar() {
-		BossBar _new = new BossBar(this);
-		bars.add(_new);
-		return _new;
-	}
-	
-	public List<BossBar> getActiveBossBars() {
-		List<BossBar> bars = new ArrayList<>();
-		for (BossBar bar : this.bars)
-			if (bar.isVisiable()) bars.add(bar);
-		return Collections.unmodifiableList(bars);
-	}
-	
-	public List<BossBar> getAllBossBars() {
-		return Collections.unmodifiableList(bars);
-	}
-	
-	public void deleteBossBar(BossBar bar) {
-		if(bar == null)
-			return;
-		bars.remove(bar);
-		bar.hide();
-	}
+
+    protected ArrayList<BossBar> bars = new ArrayList<>();
+    private Player player;
+    private int limit = -1;
+
+    public BossBarManager(Player player) {
+        this.player = player;
+    }
+
+    public BossBar getBossBar(UUID uuid) {
+        for (BossBar b : bars)
+            if (b.uuid.equals(uuid)) return b;
+        return null;
+    }
+
+    public int getBarLimit() {
+        return limit == -1 ? Integer.MAX_VALUE : limit;
+    }
+
+    public void setBarLimit(int limit) {
+        this.limit = limit;
+    }
+
+    public BossBar createNewBossBar() {
+        BossBar _new = new BossBar(this);
+        bars.add(_new);
+        return _new;
+    }
+
+    public List<BossBar> getActiveBossBars() {
+        List<BossBar> bars = new ArrayList<>();
+        for (BossBar bar : this.bars)
+            if (bar.isVisiable()) bars.add(bar);
+        return Collections.unmodifiableList(bars);
+    }
+
+    public List<BossBar> getAllBossBars() {
+        return Collections.unmodifiableList(bars);
+    }
+
+    public void deleteBossBar(BossBar bar) {
+        if (bar == null)
+            return;
+        bars.remove(bar);
+        bar.hide();
+    }
+
+    private static class DynamicBossBarRunner implements Runnable {
+
+        @Override
+        public void run() {
+
+        }
+
+    }
+
+    @Getter
+    public static class BossBar {
+        private static float steps = 0.01F;
+        private BossBarManager manager;
+        private UUID uuid;
+        private PacketPlayOutBossBar.BarColor color;
+        private PacketPlayOutBossBar.BarDivision division;
+        private float health;
+        private IChatBaseComponent message;
+        private boolean visiable;
+        private LimetedScheduller curruntTask;
+
+        private BossBar(BossBarManager manager) {
+            this.manager = manager;
+            uuid = UUID.randomUUID();
+            color = BarColor.PING;
+            division = BarDivision.TEN_DIVISIONS;
+            health = 0.5F;
+            message = ChatSerializer.fromMessage(ChatColorUtils.COLOR_CHAR + "cUndefined");
+        }
+
+        protected BossBar(BossBarManager manager, UUID uuid, BarColor color, BarDivision division, float value, IChatBaseComponent message, boolean visiable) {
+            this.manager = manager;
+            this.uuid = uuid;
+            this.color = color;
+            this.division = division;
+            this.health = value;
+            this.message = message;
+            this.visiable = visiable;
+        }
+
+        public void setColor(PacketPlayOutBossBar.BarColor color) {
+            this.color = color;
+            if (visiable)
+                this.manager.player.sendPacket(new PacketPlayOutBossBar().setBarId(uuid).setAction(Action.UPDATE_STYLE).setColor(color).setDivision(division));
+        }
+
+        public void setDivision(PacketPlayOutBossBar.BarDivision division) {
+            this.division = division;
+            if (visiable)
+                this.manager.player.sendPacket(new PacketPlayOutBossBar().setBarId(uuid).setAction(Action.UPDATE_STYLE).setColor(color).setDivision(division));
+        }
+
+        public void setHealth(float value) {
+            this.health = value;
+            if (visiable)
+                this.manager.player.sendPacket(new PacketPlayOutBossBar().setBarId(uuid).setAction(Action.UPDATE_HEALTH).setHealth(value));
+        }
+
+        public void setMessage(IChatBaseComponent message) {
+            this.message = message;
+            if (visiable)
+                this.manager.player.sendPacket(new PacketPlayOutBossBar().setBarId(uuid).setAction(Action.UPDATE_TITLE).setTitle(message));
+        }
+
+        public void display() {
+            if (manager.getActiveBossBars().size() + 1 > manager.getBarLimit())
+                throw new RuntimeException("BossBar limit is reached!");
+            if (visiable) return;
+            visiable = true;
+            this.manager.player.sendPacket(new PacketPlayOutBossBar().setBarId(uuid).setAction(Action.CREATE).setTitle(message).setHealth(health).setColor(color).setDivision(division));
+        }
+
+        public void hide() {
+            if (!visiable) return;
+            visiable = false;
+            this.manager.player.sendPacket(new PacketPlayOutBossBar().setBarId(uuid).setAction(Action.DELETE));
+        }
+
+        public void dynamicChangeHealth(float health, int time, TimeUnit unit) {
+            if (curruntTask != null)
+                curruntTask.stop();
+            float diff = this.health - health;
+            if (diff == 0)
+                return;
+            final float base = this.health;
+            int stepCount = (int) (diff / steps);
+            final float addPerStep = diff / stepCount;
+            int millis = (int) unit.toMillis(time);
+            int loopsTime = (int) (millis / stepCount);
+
+            new LimetedScheduller(millis, Math.abs(loopsTime), TimeUnit.MILLISECONDS) {
+                @Override
+                public void run(int count) {
+                    setHealth(base + (addPerStep * count));
+                }
+            }.start();
+        }
+    }
 }
diff --git a/src/main/java/dev/wolveringer/api/datawatcher/BlockData.java b/src/main/java/dev/wolveringer/api/datawatcher/BlockData.java
index 1fa0c8c..8e6398d 100644
--- a/src/main/java/dev/wolveringer/api/datawatcher/BlockData.java
+++ b/src/main/java/dev/wolveringer/api/datawatcher/BlockData.java
@@ -1,18 +1,18 @@
 package dev.wolveringer.api.datawatcher;
 
 public class BlockData {
-	private int data;
+    private int data;
 
-	public BlockData(int data) {
-		super();
-		this.data = data;
-	}
+    public BlockData(int data) {
+        super();
+        this.data = data;
+    }
 
-	public int getData() {
-		return data;
-	}
+    public int getData() {
+        return data;
+    }
 
-	public void setData(int data) {
-		this.data = data;
-	}
+    public void setData(int data) {
+        this.data = data;
+    }
 }
diff --git a/src/main/java/dev/wolveringer/api/datawatcher/DataWatcher.java b/src/main/java/dev/wolveringer/api/datawatcher/DataWatcher.java
index d790a8f..7d255fe 100644
--- a/src/main/java/dev/wolveringer/api/datawatcher/DataWatcher.java
+++ b/src/main/java/dev/wolveringer/api/datawatcher/DataWatcher.java
@@ -7,46 +7,46 @@ import dev.wolveringer.api.datawatcher.impl.v1_9_DataWatcher;
 import dev.wolveringer.packet.PacketDataSerializer;
 
 public abstract class DataWatcher {
-	
-	public static DataWatcher createDataWatcher(BigClientVersion version){
-		return createDataWatcher(version, null);
-	}
-	
-	public static DataWatcher createDataWatcher(BigClientVersion version,PacketDataSerializer watcher){
-		switch (version) {
-			case v1_8:
-				return new v1_8_DataWatcher(watcher);
-			case v1_9:
-				return new v1_9_DataWatcher(watcher);
-			case v1_10:
-				return new v1_10_DataWatcher(watcher);
-			default:
-				throw new RuntimeException("Cant find datawatcher for "+version);
-		}
-	}
-	
-	public abstract void write(PacketDataSerializer packetdataserializer);
-	
-	public abstract void setValue(int pos, Object object);
-	
-	@Override
-	public abstract String toString();
-	
-	public abstract DataWatcher copy();
-	
-	public abstract EntityDataWatcher getEntityDataWatcher();
-	
-	public abstract <T extends EntityDataWatcher> T getSpecialDataWatcher(Class<T> clazz);
-	
-	public abstract Object get(int i);
-	
-	public abstract byte getByte(int i);
-	
-	public abstract short getShort(int i);
-	
-	public abstract int getInt(int i);
-	
-	public abstract String getString(int i);
-	
-	public abstract float getFloat(int i);
+
+    public static DataWatcher createDataWatcher(BigClientVersion version) {
+        return createDataWatcher(version, null);
+    }
+
+    public static DataWatcher createDataWatcher(BigClientVersion version, PacketDataSerializer watcher) {
+        switch (version) {
+            case v1_8:
+                return new v1_8_DataWatcher(watcher);
+            case v1_9:
+                return new v1_9_DataWatcher(watcher);
+            case v1_10:
+                return new v1_10_DataWatcher(watcher);
+            default:
+                throw new RuntimeException("Cant find datawatcher for " + version);
+        }
+    }
+
+    public abstract void write(PacketDataSerializer packetdataserializer);
+
+    public abstract void setValue(int pos, Object object);
+
+    @Override
+    public abstract String toString();
+
+    public abstract DataWatcher copy();
+
+    public abstract EntityDataWatcher getEntityDataWatcher();
+
+    public abstract <T extends EntityDataWatcher> T getSpecialDataWatcher(Class<T> clazz);
+
+    public abstract Object get(int i);
+
+    public abstract byte getByte(int i);
+
+    public abstract short getShort(int i);
+
+    public abstract int getInt(int i);
+
+    public abstract String getString(int i);
+
+    public abstract float getFloat(int i);
 }
diff --git a/src/main/java/dev/wolveringer/api/datawatcher/DataWatcherObjekt.java b/src/main/java/dev/wolveringer/api/datawatcher/DataWatcherObjekt.java
index 28933c7..10578fd 100644
--- a/src/main/java/dev/wolveringer/api/datawatcher/DataWatcherObjekt.java
+++ b/src/main/java/dev/wolveringer/api/datawatcher/DataWatcherObjekt.java
@@ -3,44 +3,44 @@ package dev.wolveringer.api.datawatcher;
 import dev.wolveringer.BungeeUtil.ClientVersion.BigClientVersion;
 
 public class DataWatcherObjekt {
-	private final Class<?> clazz;
-	private final int pos;
-	private Object value;
-	private boolean update;
-	
-	public DataWatcherObjekt(Class<?> clazz, int pos, Object object) {
-		this.pos = pos;
-		this.value = object;
-		this.clazz = clazz;
-	}
-
-	public int getPostition() {
-		return this.pos;
-	}
-
-	public void setValue(Object object) {
-		this.value = object;
-		update = true;
-	}
-
-	public Object getValue() {
-		return this.value;
-	}
-
-	public Class<?> getType() {
-		return this.clazz;
-	}
-	
-	public boolean hasUpdate() {
-		return update;
-	}
-	
-	@Override
-	public String toString() {
-		return "[" + pos + "=" + value + " (" + value.getClass().getName().split("\\.")[value.getClass().getName().split("\\.").length - 1] + ")],";
-	}
-
-	public int getTypeId(BigClientVersion version) {
-		return 0;
-	}
+    private final Class<?> clazz;
+    private final int pos;
+    private Object value;
+    private boolean update;
+
+    public DataWatcherObjekt(Class<?> clazz, int pos, Object object) {
+        this.pos = pos;
+        this.value = object;
+        this.clazz = clazz;
+    }
+
+    public int getPostition() {
+        return this.pos;
+    }
+
+    public Object getValue() {
+        return this.value;
+    }
+
+    public void setValue(Object object) {
+        this.value = object;
+        update = true;
+    }
+
+    public Class<?> getType() {
+        return this.clazz;
+    }
+
+    public boolean hasUpdate() {
+        return update;
+    }
+
+    @Override
+    public String toString() {
+        return "[" + pos + "=" + value + " (" + value.getClass().getName().split("\\.")[value.getClass().getName().split("\\.").length - 1] + ")],";
+    }
+
+    public int getTypeId(BigClientVersion version) {
+        return 0;
+    }
 }
diff --git a/src/main/java/dev/wolveringer/api/datawatcher/Direction.java b/src/main/java/dev/wolveringer/api/datawatcher/Direction.java
index bc23572..da1601d 100644
--- a/src/main/java/dev/wolveringer/api/datawatcher/Direction.java
+++ b/src/main/java/dev/wolveringer/api/datawatcher/Direction.java
@@ -1,17 +1,17 @@
 package dev.wolveringer.api.datawatcher;
 
 public class Direction {
-	private int direction;
+    private int direction;
 
-	public Direction(int direction) {
-		this.direction = direction;
-	}
+    public Direction(int direction) {
+        this.direction = direction;
+    }
 
-	public int getDirection() {
-		return direction;
-	}
+    public int getDirection() {
+        return direction;
+    }
 
-	public void setDirection(int direction) {
-		this.direction = direction;
-	}
+    public void setDirection(int direction) {
+        this.direction = direction;
+    }
 }
diff --git a/src/main/java/dev/wolveringer/api/datawatcher/EntityDataWatcher.java b/src/main/java/dev/wolveringer/api/datawatcher/EntityDataWatcher.java
index 3fedc9f..024322a 100644
--- a/src/main/java/dev/wolveringer/api/datawatcher/EntityDataWatcher.java
+++ b/src/main/java/dev/wolveringer/api/datawatcher/EntityDataWatcher.java
@@ -1,60 +1,61 @@
 package dev.wolveringer.api.datawatcher;
 
-public interface EntityDataWatcher{
-	
-	public boolean isSneaking();
-
-	public void setSneaking(boolean flag);
-
-	public boolean isSprinting();
-
-	public void setSprinting(boolean flag);
-
-	public boolean isInvisible();
-
-	public void setInvisible(boolean flag);
-	
-	/**
-	 *  Minecrat 1.9
-	 */
-	
-	public boolean isOnFire();
-	
-	public void setOnFire(boolean fire);
-	
-	public boolean isBlocking();
-	
-	public void setBlocking(boolean block); 
-	
-	public boolean isGlowing();
-	
-	public void setGlowing(boolean glow); 
-	
-	public boolean isElytra();
-	
-	public void setElytra(boolean elytra); 
-	
-	public int getAir();
-	
-	public void setAir(int air);
-	
-	public void setCostumName(String name);
-	
-	public String getCostumName();
-	
-	public boolean isCostumNameVisiable();
-	
-	public void setCostumNameVisiable(boolean flag);
-	
-	public boolean isSlient();
-	
-	public void setSlient(boolean flag);
-	
-	public boolean hasGravity();
-	public void setApplayGravity(boolean flag);
-	
-	
-	public DataWatcher getWatcher();
-	
-	public EntityDataWatcher injektDefault();
+public interface EntityDataWatcher {
+
+    public boolean isSneaking();
+
+    public void setSneaking(boolean flag);
+
+    public boolean isSprinting();
+
+    public void setSprinting(boolean flag);
+
+    public boolean isInvisible();
+
+    public void setInvisible(boolean flag);
+
+    /**
+     * Minecrat 1.9
+     */
+
+    public boolean isOnFire();
+
+    public void setOnFire(boolean fire);
+
+    public boolean isBlocking();
+
+    public void setBlocking(boolean block);
+
+    public boolean isGlowing();
+
+    public void setGlowing(boolean glow);
+
+    public boolean isElytra();
+
+    public void setElytra(boolean elytra);
+
+    public int getAir();
+
+    public void setAir(int air);
+
+    public String getCostumName();
+
+    public void setCostumName(String name);
+
+    public boolean isCostumNameVisiable();
+
+    public void setCostumNameVisiable(boolean flag);
+
+    public boolean isSlient();
+
+    public void setSlient(boolean flag);
+
+    public boolean hasGravity();
+
+    public void setApplayGravity(boolean flag);
+
+
+    public DataWatcher getWatcher();
+
+    public EntityDataWatcher injektDefault();
 }
diff --git a/src/main/java/dev/wolveringer/api/datawatcher/HumanDataWatcher.java b/src/main/java/dev/wolveringer/api/datawatcher/HumanDataWatcher.java
index 9c4b823..2b3e765 100644
--- a/src/main/java/dev/wolveringer/api/datawatcher/HumanDataWatcher.java
+++ b/src/main/java/dev/wolveringer/api/datawatcher/HumanDataWatcher.java
@@ -1,22 +1,22 @@
 package dev.wolveringer.api.datawatcher;
 
 public interface HumanDataWatcher extends LivingEntityDataWatcher {
-	public void setSkinFlags(byte flag);
+    public void setSkinFlags(byte flag);
 
-	public byte getSkinFlag();
+    public byte getSkinFlag();
 
-	public void setCapeActive(boolean b);
+    public boolean isCapeActive();
 
-	public boolean isCapeActive();
+    public void setCapeActive(boolean b);
 
-	public void setAbsorptionHearts(float f);
+    public float getAbsorptionHearts();
 
-	public float getAbsorptionHearts();
+    public void setAbsorptionHearts(float f);
 
-	public void setScore(int score);
+    public int getScore();
 
-	public int getScore();
+    public void setScore(int score);
 
-	@Override
-	public HumanDataWatcher injektDefault();
+    @Override
+    public HumanDataWatcher injektDefault();
 }
diff --git a/src/main/java/dev/wolveringer/api/datawatcher/LivingEntityDataWatcher.java b/src/main/java/dev/wolveringer/api/datawatcher/LivingEntityDataWatcher.java
index ff382ee..d09a40e 100644
--- a/src/main/java/dev/wolveringer/api/datawatcher/LivingEntityDataWatcher.java
+++ b/src/main/java/dev/wolveringer/api/datawatcher/LivingEntityDataWatcher.java
@@ -2,26 +2,28 @@ package dev.wolveringer.api.datawatcher;
 
 public interface LivingEntityDataWatcher extends EntityDataWatcher {
 
-	public void setHealth(float h);
+    public float getHealth();
 
-	public float getHealth();;
+    public void setHealth(float h);
 
-	public void setArrows(int amauth);
+    ;
 
-	public int getArrows();
+    public int getArrows();
 
-	public void setParicelColor(int color);
-	
-	public int getParicelColor();
-	
-	public void setParticelVisiable(boolean flag);
-	
-	public boolean isParticelVisiable();
+    public void setArrows(int amauth);
 
-	public void setAI(boolean flag);
-	
-	public boolean hasAI();
+    public int getParicelColor();
 
-	@Override
-	public LivingEntityDataWatcher injektDefault();
+    public void setParicelColor(int color);
+
+    public boolean isParticelVisiable();
+
+    public void setParticelVisiable(boolean flag);
+
+    public void setAI(boolean flag);
+
+    public boolean hasAI();
+
+    @Override
+    public LivingEntityDataWatcher injektDefault();
 }
diff --git a/src/main/java/dev/wolveringer/api/datawatcher/OptionalBlockPosition.java b/src/main/java/dev/wolveringer/api/datawatcher/OptionalBlockPosition.java
index fc69ade..91d38b6 100644
--- a/src/main/java/dev/wolveringer/api/datawatcher/OptionalBlockPosition.java
+++ b/src/main/java/dev/wolveringer/api/datawatcher/OptionalBlockPosition.java
@@ -3,20 +3,20 @@ package dev.wolveringer.api.datawatcher;
 import dev.wolveringer.api.position.BlockPosition;
 
 public class OptionalBlockPosition {
-	private BlockPosition position;
+    private BlockPosition position;
 
-	public OptionalBlockPosition(BlockPosition position) {
-		super();
-		this.position = position;
-	}
+    public OptionalBlockPosition(BlockPosition position) {
+        super();
+        this.position = position;
+    }
+
+    public BlockPosition getPosition() {
+        return position;
+    }
+
+    public void setPosition(BlockPosition position) {
+        this.position = position;
+    }
 
-	public BlockPosition getPosition() {
-		return position;
-	}
 
-	public void setPosition(BlockPosition position) {
-		this.position = position;
-	}
-	
-	
 }
diff --git a/src/main/java/dev/wolveringer/api/datawatcher/OptionalUUID.java b/src/main/java/dev/wolveringer/api/datawatcher/OptionalUUID.java
index e135eb8..5c0df31 100644
--- a/src/main/java/dev/wolveringer/api/datawatcher/OptionalUUID.java
+++ b/src/main/java/dev/wolveringer/api/datawatcher/OptionalUUID.java
@@ -3,18 +3,18 @@ package dev.wolveringer.api.datawatcher;
 import java.util.UUID;
 
 public class OptionalUUID {
-	private UUID uuid;
+    private UUID uuid;
 
-	public OptionalUUID(UUID uuid) {
-		super();
-		this.uuid = uuid;
-	}
+    public OptionalUUID(UUID uuid) {
+        super();
+        this.uuid = uuid;
+    }
 
-	public UUID getUuid() {
-		return uuid;
-	}
+    public UUID getUuid() {
+        return uuid;
+    }
 
-	public void setUuid(UUID uuid) {
-		this.uuid = uuid;
-	}
+    public void setUuid(UUID uuid) {
+        this.uuid = uuid;
+    }
 }
diff --git a/src/main/java/dev/wolveringer/api/datawatcher/impl/DataWatcherObjekt.java b/src/main/java/dev/wolveringer/api/datawatcher/impl/DataWatcherObjekt.java
index bae649e..ae8d567 100644
--- a/src/main/java/dev/wolveringer/api/datawatcher/impl/DataWatcherObjekt.java
+++ b/src/main/java/dev/wolveringer/api/datawatcher/impl/DataWatcherObjekt.java
@@ -3,44 +3,44 @@ package dev.wolveringer.api.datawatcher.impl;
 import dev.wolveringer.BungeeUtil.ClientVersion.BigClientVersion;
 
 public class DataWatcherObjekt {
-	private final Class<?> clazz;
-	private final int pos;
-	private Object value;
-	private boolean update;
-	
-	public DataWatcherObjekt(Class<?> clazz, int pos, Object object) {
-		this.pos = pos;
-		this.value = object;
-		this.clazz = clazz;
-	}
-
-	public int getPostition() {
-		return this.pos;
-	}
-
-	public void setValue(Object object) {
-		this.value = object;
-		update = true;
-	}
-
-	public Object getValue() {
-		return this.value;
-	}
-
-	public Class<?> getType() {
-		return this.clazz;
-	}
-	
-	public boolean hasUpdate() {
-		return update;
-	}
-	
-	@Override
-	public String toString() {
-		return "[" + pos + "=" + value + " (" + value.getClass().getName().split("\\.")[value.getClass().getName().split("\\.").length - 1] + ")],";
-	}
-
-	public int getTypeId(BigClientVersion version) {
-		return 0;
-	}
+    private final Class<?> clazz;
+    private final int pos;
+    private Object value;
+    private boolean update;
+
+    public DataWatcherObjekt(Class<?> clazz, int pos, Object object) {
+        this.pos = pos;
+        this.value = object;
+        this.clazz = clazz;
+    }
+
+    public int getPostition() {
+        return this.pos;
+    }
+
+    public Object getValue() {
+        return this.value;
+    }
+
+    public void setValue(Object object) {
+        this.value = object;
+        update = true;
+    }
+
+    public Class<?> getType() {
+        return this.clazz;
+    }
+
+    public boolean hasUpdate() {
+        return update;
+    }
+
+    @Override
+    public String toString() {
+        return "[" + pos + "=" + value + " (" + value.getClass().getName().split("\\.")[value.getClass().getName().split("\\.").length - 1] + ")],";
+    }
+
+    public int getTypeId(BigClientVersion version) {
+        return 0;
+    }
 }
diff --git a/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_10_DataWatcher.java b/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_10_DataWatcher.java
index 891681e..6da6fea 100644
--- a/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_10_DataWatcher.java
+++ b/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_10_DataWatcher.java
@@ -23,255 +23,265 @@ import dev.wolveringer.api.position.Vector3f;
 import dev.wolveringer.chat.IChatBaseComponent;
 import dev.wolveringer.packet.PacketDataSerializer;
 
-@SuppressWarnings({ "rawtypes", "unchecked" })
-public class v1_10_DataWatcher extends DataWatcher{
-	private static final TObjectIntMap v1_10_classToId = new TObjectIntHashMap(10, 0.5F, -1);
-	
-	static {
-		v1_10_classToId.put(Byte.class, 0);
-		v1_10_classToId.put(Integer.class, 1);
-		v1_10_classToId.put(Float.class, 2);
-		v1_10_classToId.put(String.class, 3);
-		v1_10_classToId.put(IChatBaseComponent.class, 4);
-		v1_10_classToId.put(Item.class, 5);
-		v1_10_classToId.put(Boolean.class, 6);
-		v1_10_classToId.put(Vector3f.class, 7);
-		v1_10_classToId.put(BlockPosition.class, 8);
-		v1_10_classToId.put(OptionalBlockPosition.class, 9);
-		v1_10_classToId.put(Direction.class, 10);
-		v1_10_classToId.put(OptionalUUID.class, 11);
-		v1_10_classToId.put(BlockData.class, 12);
-		
-		v1_10_classToId.put(Short.class, 13); //old
-	}
-	
-	@SuppressWarnings("serial")
-	private List<DataWatcherObjekt> objekts = new ArrayList<DataWatcherObjekt>() {
-		public DataWatcherObjekt get(int index) {
-			return index >= size() ? null : super.get(index);
-		};
-		
-		public DataWatcherObjekt set(int index, DataWatcherObjekt element) {
-			while (size() <= index) {
-				add(null);
-			}
-			return super.set(index, element);
-		};
-	};
-	
-	@SuppressWarnings("serial")
-	private HashMap<Class, EntityDataWatcher> watchers = new HashMap<Class, EntityDataWatcher>() {
-		public EntityDataWatcher put(Class key, EntityDataWatcher value) {
-			Class _super = key.getSuperclass();
-			while (EntityDataWatcher.class.isAssignableFrom(_super) && super.get(_super) == null) {
-				super.put(_super, value);
-			}
-			return super.put(key, value);
-		};
-	};
-	
-	public v1_10_DataWatcher(PacketDataSerializer paramPacketDataSerializer) {
-		this();
-		if(paramPacketDataSerializer != null)
-		this.objekts = read(paramPacketDataSerializer);
-	}
-	
-	public v1_10_DataWatcher() {
-	}
-	
-	public void write(PacketDataSerializer packetdataserializer) {
-		Iterator iterator = objekts.iterator();
-		while (iterator.hasNext()) {
-			DataWatcherObjekt watchableobject = (DataWatcherObjekt) iterator.next();
-			if (watchableobject == null) continue;
-			write(packetdataserializer, watchableobject);
-		}
-		packetdataserializer.writeByte(255); // end
-	}
-	
-	private void write(PacketDataSerializer s, DataWatcherObjekt o) {
-			s.writeByte(o.getPostition());
-			int typeId = v1_10_classToId.get(o.getType());
-			if (typeId == 13) s.writeByte(v1_10_classToId.get(Integer.class));
-			else s.writeByte(typeId);
-			
-			switch (typeId) {
-				case 0:
-					s.writeByte((byte) o.getValue());
-					break;
-				case 1:
-					s.writeVarInt((int) o.getValue());
-					break;
-				case 2:
-					s.writeFloat((float) o.getValue());
-					break;
-				case 3:
-					s.writeString((String) o.getValue());
-					break;
-				case 4:
-					s.writeRawString((IChatBaseComponent) o.getValue());
-					break;
-				case 5:
-					s.writeItem((Item) o.getValue());
-					break;
-				case 6:
-					s.writeBoolean((boolean) o.getValue());
-					break;
-				case 7:
-					Vector3f v = (Vector3f) o.getValue();
-					s.writeFloat(v.getX());
-					s.writeFloat(v.getY());
-					s.writeFloat(v.getZ());
-					break;
-				case 8:
-					s.writeBlockPosition((BlockPosition) o.getValue());
-					break;
-				case 9:
-					OptionalBlockPosition p = (OptionalBlockPosition) o.getValue(); // Optional
-					s.writeBoolean(p.getPosition() != null);
-					if (p != null) s.writeBlockPosition(p.getPosition());
-					break;
-				case 10:
-					s.writeVarInt(((Direction) o.getValue()).getDirection()); // Direction
-					break;
-				case 11:
-					OptionalUUID uuid = (OptionalUUID) o.getValue(); // Optional
-					s.writeBoolean(uuid.getUuid() != null);
-					if (uuid != null) s.writeUUID(uuid.getUuid());
-					break;
-				case 12:
-					s.writeVarInt(((BlockData) o.getValue()).getData()); // Block
-					break; // Data
-				case 13: // Short will write as an interger
-					s.writeVarInt((Short) o.getValue());
-					break;
-				default:
-					System.out.println("Type not found ("+typeId+") ("+o.getType()+")");
-					break;
-			}
-	}
-	
-	private List read(PacketDataSerializer packetdataserializer) {
-		ArrayList arraylist = new ArrayList();
-			for (int data = packetdataserializer.readUnsignedByte(); data != 255; data = packetdataserializer.readUnsignedByte()) {
-				int pos = data;
-				int type = packetdataserializer.readUnsignedByte();
-				Object value = null;
-				switch (type) {
-					case 0:
-						value = packetdataserializer.readByte();
-						break;
-					case 1:
-						value = packetdataserializer.readVarInt();
-						break;
-					case 2:
-						value = packetdataserializer.readFloat();
-						break;
-					case 3:
-						value = packetdataserializer.readString(-1);
-						break;
-					case 4:
-						value = packetdataserializer.readRawString();
-						break;
-					case 5:
-						value = packetdataserializer.readItem();
-						break;
-					case 6:
-						value = packetdataserializer.readBoolean();
-						break;
-					case 7:
-						value = new Vector3f(packetdataserializer.readFloat(), packetdataserializer.readFloat(), packetdataserializer.readFloat());
-						break;
-					case 8:
-						value = packetdataserializer.readBlockPosition();
-						break;
-					case 9:
-						if (packetdataserializer.readBoolean()) value = new OptionalBlockPosition(packetdataserializer.readBlockPosition());
-						else value = new OptionalBlockPosition(null);
-						break;
-					case 10:
-						value = new Direction(packetdataserializer.readVarInt());
-						break;
-					case 11:
-						if (packetdataserializer.readBoolean()) value = new OptionalUUID(packetdataserializer.readUUID());
-						else value = new OptionalUUID(null);
-						break;
-					case 12:
-						value = new BlockData(packetdataserializer.readVarInt());
-						break;
-				}
-				arraylist.add(new DataWatcherObjekt(getTypeId(type), pos, value));
-		}
-		return arraylist;
-	}
-	
-	public void setValue(int pos, Object object) {
-		if (pos > 254) { throw new IllegalArgumentException("Data value id is too big with " + pos + "! (Max is " + 254 + ")"); }
-		if (objekts.get(pos) == null) objekts.set(pos, new DataWatcherObjekt(object.getClass(), pos, null));
-		objekts.get(pos).setValue(object);
-	}
-	
-	private static Class<?> getTypeId(int type) {
-			for (Object o : v1_10_classToId.keys())
-				if (v1_10_classToId.get(o) == type) return (Class<?>) o;
-		return null;
-	}
-	
-	@Override
-	public String toString() {
-		return "DataWatcher [v1_10] [objekts=" + objekts + "]";
-	}
-	
-	public DataWatcher copy() {
-		v1_10_DataWatcher watcher = new v1_10_DataWatcher();
-		watcher.objekts = new ArrayList<DataWatcherObjekt>(this.objekts);
-		return watcher;
-	}
-	
-	public EntityDataWatcher getEntityDataWatcher() {
-		return getSpecialDataWatcher(EntityDataWatcher.class);
-	}
-	
-	public <T extends EntityDataWatcher> T getSpecialDataWatcher(Class<T> clazz) {
-		if(clazz.isAssignableFrom(EntityDataWatcher.class))
-			clazz = (Class<T>) v1_10_EntityDataWatcher.class;
-		else if(clazz.isAssignableFrom(LivingEntityDataWatcher.class))
-			clazz = (Class<T>) v1_10_LivingEntityDataWatcher.class;
-		else if(clazz.isAssignableFrom(HumanDataWatcher.class))
-			clazz = (Class<T>) v1_10_HumanEntityDataWatcher.class;
-		if (watchers.get(clazz) == null) {
-			try {
-				watchers.put(clazz, clazz.getConstructor(DataWatcher.class).newInstance(this));
-			}
-			catch (InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException | NoSuchMethodException | SecurityException e) {
-				e.printStackTrace();
-			}
-		}
-		return (T) watchers.get(clazz);
-	}
-	
-	public Object get(int i) {
-		if (objekts.get(i) == null) return null;
-		return objekts.get(i).getValue();
-	}
-	
-	public byte getByte(int i) {
-		return (byte) get(i);
-	}
-	
-	public short getShort(int i) {
-		return (short) get(i);
-	}
-	
-	public int getInt(int i) {
-		return (int) get(i);
-	}
-	
-	public String getString(int i) {
-		return (String) get(i);
-	}
-	
-	public float getFloat(int i) {
-		return (float) get(i);
-	}
+@SuppressWarnings({"rawtypes", "unchecked"})
+public class v1_10_DataWatcher extends DataWatcher {
+    private static final TObjectIntMap v1_10_classToId = new TObjectIntHashMap(10, 0.5F, -1);
+
+    static {
+        v1_10_classToId.put(Byte.class, 0);
+        v1_10_classToId.put(Integer.class, 1);
+        v1_10_classToId.put(Float.class, 2);
+        v1_10_classToId.put(String.class, 3);
+        v1_10_classToId.put(IChatBaseComponent.class, 4);
+        v1_10_classToId.put(Item.class, 5);
+        v1_10_classToId.put(Boolean.class, 6);
+        v1_10_classToId.put(Vector3f.class, 7);
+        v1_10_classToId.put(BlockPosition.class, 8);
+        v1_10_classToId.put(OptionalBlockPosition.class, 9);
+        v1_10_classToId.put(Direction.class, 10);
+        v1_10_classToId.put(OptionalUUID.class, 11);
+        v1_10_classToId.put(BlockData.class, 12);
+
+        v1_10_classToId.put(Short.class, 13); //old
+    }
+
+    @SuppressWarnings("serial")
+    private List<DataWatcherObjekt> objekts = new ArrayList<DataWatcherObjekt>() {
+        public DataWatcherObjekt get(int index) {
+            return index >= size() ? null : super.get(index);
+        }
+
+        ;
+
+        public DataWatcherObjekt set(int index, DataWatcherObjekt element) {
+            while (size() <= index) {
+                add(null);
+            }
+            return super.set(index, element);
+        }
+
+        ;
+    };
+
+    @SuppressWarnings("serial")
+    private HashMap<Class, EntityDataWatcher> watchers = new HashMap<Class, EntityDataWatcher>() {
+        public EntityDataWatcher put(Class key, EntityDataWatcher value) {
+            Class _super = key.getSuperclass();
+            while (EntityDataWatcher.class.isAssignableFrom(_super) && super.get(_super) == null) {
+                super.put(_super, value);
+            }
+            return super.put(key, value);
+        }
+
+        ;
+    };
+
+    public v1_10_DataWatcher(PacketDataSerializer paramPacketDataSerializer) {
+        this();
+        if (paramPacketDataSerializer != null)
+            this.objekts = read(paramPacketDataSerializer);
+    }
+
+    public v1_10_DataWatcher() {
+    }
+
+    private static Class<?> getTypeId(int type) {
+        for (Object o : v1_10_classToId.keys())
+            if (v1_10_classToId.get(o) == type) return (Class<?>) o;
+        return null;
+    }
+
+    public void write(PacketDataSerializer packetdataserializer) {
+        Iterator iterator = objekts.iterator();
+        while (iterator.hasNext()) {
+            DataWatcherObjekt watchableobject = (DataWatcherObjekt) iterator.next();
+            if (watchableobject == null) continue;
+            write(packetdataserializer, watchableobject);
+        }
+        packetdataserializer.writeByte(255); // end
+    }
+
+    private void write(PacketDataSerializer s, DataWatcherObjekt o) {
+        s.writeByte(o.getPostition());
+        int typeId = v1_10_classToId.get(o.getType());
+        if (typeId == 13) s.writeByte(v1_10_classToId.get(Integer.class));
+        else s.writeByte(typeId);
+
+        switch (typeId) {
+            case 0:
+                s.writeByte((byte) o.getValue());
+                break;
+            case 1:
+                s.writeVarInt((int) o.getValue());
+                break;
+            case 2:
+                s.writeFloat((float) o.getValue());
+                break;
+            case 3:
+                s.writeString((String) o.getValue());
+                break;
+            case 4:
+                s.writeRawString((IChatBaseComponent) o.getValue());
+                break;
+            case 5:
+                s.writeItem((Item) o.getValue());
+                break;
+            case 6:
+                s.writeBoolean((boolean) o.getValue());
+                break;
+            case 7:
+                Vector3f v = (Vector3f) o.getValue();
+                s.writeFloat(v.getX());
+                s.writeFloat(v.getY());
+                s.writeFloat(v.getZ());
+                break;
+            case 8:
+                s.writeBlockPosition((BlockPosition) o.getValue());
+                break;
+            case 9:
+                OptionalBlockPosition p = (OptionalBlockPosition) o.getValue(); // Optional
+                s.writeBoolean(p.getPosition() != null);
+                if (p != null) s.writeBlockPosition(p.getPosition());
+                break;
+            case 10:
+                s.writeVarInt(((Direction) o.getValue()).getDirection()); // Direction
+                break;
+            case 11:
+                OptionalUUID uuid = (OptionalUUID) o.getValue(); // Optional
+                s.writeBoolean(uuid.getUuid() != null);
+                if (uuid != null) s.writeUUID(uuid.getUuid());
+                break;
+            case 12:
+                s.writeVarInt(((BlockData) o.getValue()).getData()); // Block
+                break; // Data
+            case 13: // Short will write as an interger
+                s.writeVarInt((Short) o.getValue());
+                break;
+            default:
+                System.out.println("Type not found (" + typeId + ") (" + o.getType() + ")");
+                break;
+        }
+    }
+
+    private List read(PacketDataSerializer packetdataserializer) {
+        ArrayList arraylist = new ArrayList();
+        for (int data = packetdataserializer.readUnsignedByte(); data != 255; data = packetdataserializer.readUnsignedByte()) {
+            int pos = data;
+            int type = packetdataserializer.readUnsignedByte();
+            Object value = null;
+            switch (type) {
+                case 0:
+                    value = packetdataserializer.readByte();
+                    break;
+                case 1:
+                    value = packetdataserializer.readVarInt();
+                    break;
+                case 2:
+                    value = packetdataserializer.readFloat();
+                    break;
+                case 3:
+                    value = packetdataserializer.readString(-1);
+                    break;
+                case 4:
+                    value = packetdataserializer.readRawString();
+                    break;
+                case 5:
+                    value = packetdataserializer.readItem();
+                    break;
+                case 6:
+                    value = packetdataserializer.readBoolean();
+                    break;
+                case 7:
+                    value = new Vector3f(packetdataserializer.readFloat(), packetdataserializer.readFloat(), packetdataserializer.readFloat());
+                    break;
+                case 8:
+                    value = packetdataserializer.readBlockPosition();
+                    break;
+                case 9:
+                    if (packetdataserializer.readBoolean())
+                        value = new OptionalBlockPosition(packetdataserializer.readBlockPosition());
+                    else value = new OptionalBlockPosition(null);
+                    break;
+                case 10:
+                    value = new Direction(packetdataserializer.readVarInt());
+                    break;
+                case 11:
+                    if (packetdataserializer.readBoolean())
+                        value = new OptionalUUID(packetdataserializer.readUUID());
+                    else value = new OptionalUUID(null);
+                    break;
+                case 12:
+                    value = new BlockData(packetdataserializer.readVarInt());
+                    break;
+            }
+            arraylist.add(new DataWatcherObjekt(getTypeId(type), pos, value));
+        }
+        return arraylist;
+    }
+
+    public void setValue(int pos, Object object) {
+        if (pos > 254) {
+            throw new IllegalArgumentException("Data value id is too big with " + pos + "! (Max is " + 254 + ")");
+        }
+        if (objekts.get(pos) == null)
+            objekts.set(pos, new DataWatcherObjekt(object.getClass(), pos, null));
+        objekts.get(pos).setValue(object);
+    }
+
+    @Override
+    public String toString() {
+        return "DataWatcher [v1_10] [objekts=" + objekts + "]";
+    }
+
+    public DataWatcher copy() {
+        v1_10_DataWatcher watcher = new v1_10_DataWatcher();
+        watcher.objekts = new ArrayList<DataWatcherObjekt>(this.objekts);
+        return watcher;
+    }
+
+    public EntityDataWatcher getEntityDataWatcher() {
+        return getSpecialDataWatcher(EntityDataWatcher.class);
+    }
+
+    public <T extends EntityDataWatcher> T getSpecialDataWatcher(Class<T> clazz) {
+        if (clazz.isAssignableFrom(EntityDataWatcher.class))
+            clazz = (Class<T>) v1_10_EntityDataWatcher.class;
+        else if (clazz.isAssignableFrom(LivingEntityDataWatcher.class))
+            clazz = (Class<T>) v1_10_LivingEntityDataWatcher.class;
+        else if (clazz.isAssignableFrom(HumanDataWatcher.class))
+            clazz = (Class<T>) v1_10_HumanEntityDataWatcher.class;
+        if (watchers.get(clazz) == null) {
+            try {
+                watchers.put(clazz, clazz.getConstructor(DataWatcher.class).newInstance(this));
+            } catch (InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException | NoSuchMethodException | SecurityException e) {
+                e.printStackTrace();
+            }
+        }
+        return (T) watchers.get(clazz);
+    }
+
+    public Object get(int i) {
+        if (objekts.get(i) == null) return null;
+        return objekts.get(i).getValue();
+    }
+
+    public byte getByte(int i) {
+        return (byte) get(i);
+    }
+
+    public short getShort(int i) {
+        return (short) get(i);
+    }
+
+    public int getInt(int i) {
+        return (int) get(i);
+    }
+
+    public String getString(int i) {
+        return (String) get(i);
+    }
+
+    public float getFloat(int i) {
+        return (float) get(i);
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_10_EntityDataWatcher.java b/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_10_EntityDataWatcher.java
index 0c7026c..4bc48ce 100644
--- a/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_10_EntityDataWatcher.java
+++ b/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_10_EntityDataWatcher.java
@@ -3,158 +3,159 @@ package dev.wolveringer.api.datawatcher.impl;
 import dev.wolveringer.api.datawatcher.DataWatcher;
 import dev.wolveringer.api.datawatcher.EntityDataWatcher;
 
-public class v1_10_EntityDataWatcher implements EntityDataWatcher{
-	
-	protected DataWatcher watcher;
-	
-	protected v1_10_EntityDataWatcher(DataWatcher dataWatcher) {
-		this.watcher = dataWatcher;
-	}
-	
-	private boolean getPropety(int pos) {
-		return (this.watcher.getByte(0) & 1 << pos) != 0;
-	}
-	
-	private void setPropety(int pos, boolean flag) {
-		if (this.watcher.get(0) == null)
-			this.watcher.setValue(0, (byte) 0);
-		byte b0 = this.watcher.getByte(0);
-		
-		if (flag) {
-			this.watcher.setValue(0, Byte.valueOf((byte) (b0 | 1 << pos)));
-		} else {
-			this.watcher.setValue(0, Byte.valueOf((byte) (b0 & (1 << pos ^ 0xFFFFFFFF))));
-		}
-	}
-	
-	public boolean isSneaking() {
-		return getPropety(1);
-	}
-	
-	public void setSneaking(boolean flag) {
-		setPropety(1, flag);
-	}
-	
-	public boolean isSprinting() {
-		return getPropety(2);
-	}
-	
-	public void setSprinting(boolean flag) {
-		setPropety(2, flag);
-	}
-	
-	public boolean isInvisible() {
-		return getPropety(4);
-	}
-	
-	public void setInvisible(boolean flag) {
-		setPropety(4, flag);
-	}
-	
-	public EntityDataWatcher injektDefault() {
-		if (this.watcher.get(0) == null)
-			this.watcher.setValue(0, Byte.valueOf((byte) 0));
-		if (this.watcher.get(1) == null)
-			this.watcher.setValue(1, (Integer)((int) 300));
-		if (this.watcher.get(2) == null)
-			this.watcher.setValue(2, "");
-		if (this.watcher.get(3) == null)
-			this.watcher.setValue(3,false);
-		if (this.watcher.get(4) == null)
-			this.watcher.setValue(4,false);
-		return this;
-	}
-	
-	public DataWatcher getWatcher() {
-		return watcher;
-	}
-
-	@Override
-	public boolean isOnFire() {
-		return getPropety(0);
-	}
-
-	@Override
-	public void setOnFire(boolean fire) {
-		setPropety(0, fire);
-	}
-
-	@Override
-	public boolean isBlocking() {
-		return getPropety(3);
-	}
-
-	@Override
-	public void setBlocking(boolean block) {
-		setPropety(3, block);
-	}
-
-	@Override
-	public boolean isGlowing() {
-		return getPropety(6);
-	}
-
-	@Override
-	public void setGlowing(boolean glow) {
-		setPropety(6, glow);
-	}
-
-	@Override
-	public boolean isElytra() {
-		return getPropety(7);
-	}
-
-	@Override
-	public void setElytra(boolean elytra) {
-		setPropety(7, elytra);
-	}
-
-	@Override
-	public int getAir() {
-		return watcher.getInt(1);
-	}
-
-	@Override
-	public void setAir(int air) {
-		watcher.setValue(1, air);
-	}
-
-	@Override
-	public void setCostumName(String name) {
-		watcher.setValue(2, name);
-	}
-
-	@Override
-	public String getCostumName() {
-		return watcher.getString(2);
-	}
-
-	@Override
-	public boolean isCostumNameVisiable() {
-		return (boolean) watcher.get(3);
-	}
-
-	@Override
-	public void setCostumNameVisiable(boolean flag) {
-		watcher.setValue(3, flag);
-	}
-
-	@Override
-	public boolean isSlient() {
-		return (boolean) watcher.get(4);
-	}
-
-	@Override
-	public void setSlient(boolean flag) {
-		watcher.setValue(4, flag);
-	}
-	
-	@Override
-	public boolean hasGravity() {
-		return watcher.getByte(5) == 1;
-	}
-	@Override
-	public void setApplayGravity(boolean flag) {
-		watcher.setValue(5, flag ? 1 : 0);
-	}
+public class v1_10_EntityDataWatcher implements EntityDataWatcher {
+
+    protected DataWatcher watcher;
+
+    protected v1_10_EntityDataWatcher(DataWatcher dataWatcher) {
+        this.watcher = dataWatcher;
+    }
+
+    private boolean getPropety(int pos) {
+        return (this.watcher.getByte(0) & 1 << pos) != 0;
+    }
+
+    private void setPropety(int pos, boolean flag) {
+        if (this.watcher.get(0) == null)
+            this.watcher.setValue(0, (byte) 0);
+        byte b0 = this.watcher.getByte(0);
+
+        if (flag) {
+            this.watcher.setValue(0, Byte.valueOf((byte) (b0 | 1 << pos)));
+        } else {
+            this.watcher.setValue(0, Byte.valueOf((byte) (b0 & (1 << pos ^ 0xFFFFFFFF))));
+        }
+    }
+
+    public boolean isSneaking() {
+        return getPropety(1);
+    }
+
+    public void setSneaking(boolean flag) {
+        setPropety(1, flag);
+    }
+
+    public boolean isSprinting() {
+        return getPropety(2);
+    }
+
+    public void setSprinting(boolean flag) {
+        setPropety(2, flag);
+    }
+
+    public boolean isInvisible() {
+        return getPropety(4);
+    }
+
+    public void setInvisible(boolean flag) {
+        setPropety(4, flag);
+    }
+
+    public EntityDataWatcher injektDefault() {
+        if (this.watcher.get(0) == null)
+            this.watcher.setValue(0, Byte.valueOf((byte) 0));
+        if (this.watcher.get(1) == null)
+            this.watcher.setValue(1, (Integer) ((int) 300));
+        if (this.watcher.get(2) == null)
+            this.watcher.setValue(2, "");
+        if (this.watcher.get(3) == null)
+            this.watcher.setValue(3, false);
+        if (this.watcher.get(4) == null)
+            this.watcher.setValue(4, false);
+        return this;
+    }
+
+    public DataWatcher getWatcher() {
+        return watcher;
+    }
+
+    @Override
+    public boolean isOnFire() {
+        return getPropety(0);
+    }
+
+    @Override
+    public void setOnFire(boolean fire) {
+        setPropety(0, fire);
+    }
+
+    @Override
+    public boolean isBlocking() {
+        return getPropety(3);
+    }
+
+    @Override
+    public void setBlocking(boolean block) {
+        setPropety(3, block);
+    }
+
+    @Override
+    public boolean isGlowing() {
+        return getPropety(6);
+    }
+
+    @Override
+    public void setGlowing(boolean glow) {
+        setPropety(6, glow);
+    }
+
+    @Override
+    public boolean isElytra() {
+        return getPropety(7);
+    }
+
+    @Override
+    public void setElytra(boolean elytra) {
+        setPropety(7, elytra);
+    }
+
+    @Override
+    public int getAir() {
+        return watcher.getInt(1);
+    }
+
+    @Override
+    public void setAir(int air) {
+        watcher.setValue(1, air);
+    }
+
+    @Override
+    public String getCostumName() {
+        return watcher.getString(2);
+    }
+
+    @Override
+    public void setCostumName(String name) {
+        watcher.setValue(2, name);
+    }
+
+    @Override
+    public boolean isCostumNameVisiable() {
+        return (boolean) watcher.get(3);
+    }
+
+    @Override
+    public void setCostumNameVisiable(boolean flag) {
+        watcher.setValue(3, flag);
+    }
+
+    @Override
+    public boolean isSlient() {
+        return (boolean) watcher.get(4);
+    }
+
+    @Override
+    public void setSlient(boolean flag) {
+        watcher.setValue(4, flag);
+    }
+
+    @Override
+    public boolean hasGravity() {
+        return watcher.getByte(5) == 1;
+    }
+
+    @Override
+    public void setApplayGravity(boolean flag) {
+        watcher.setValue(5, flag ? 1 : 0);
+    }
 }
diff --git a/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_10_HumanEntityDataWatcher.java b/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_10_HumanEntityDataWatcher.java
index 342829a..6f1a22d 100644
--- a/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_10_HumanEntityDataWatcher.java
+++ b/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_10_HumanEntityDataWatcher.java
@@ -4,52 +4,52 @@ import dev.wolveringer.api.datawatcher.DataWatcher;
 import dev.wolveringer.api.datawatcher.HumanDataWatcher;
 
 public class v1_10_HumanEntityDataWatcher extends v1_10_LivingEntityDataWatcher implements HumanDataWatcher {
-	
-	public v1_10_HumanEntityDataWatcher(DataWatcher watcher) {
-		super(watcher);
-	}
-	
-	public void setSkinFlags(byte flag) {
-		watcher.setValue(13, flag);
-	}
-	
-	public byte getSkinFlag() {
-		return watcher.getByte(13);
-	}
-	
-	public void setCapeActive(boolean b) {
-	}
-	
-	public boolean isCapeActive() {
-		return false;
-	}
-	
-	public void setAbsorptionHearts(float f) {
-		watcher.setValue(11, f);
-	}
-	
-	public float getAbsorptionHearts() {
-		return watcher.getFloat(11);
-	}
-	
-	public void setScore(int score) {
-		watcher.setValue(12, score);
-	}
-	
-	public int getScore() {
-		return watcher.getInt(12);
-	}
-	
-	public v1_10_HumanEntityDataWatcher injektDefault() {
-		super.injektDefault();
-		if (watcher.get(11) == null)
-			watcher.setValue(11, (float) 0F);
-		if (watcher.get(12) == null)
-			watcher.setValue(12, (int) 0);
-		if (watcher.get(13) == null)
-			watcher.setValue(13, (byte) 0);
-		if (watcher.get(14) == null)
-			watcher.setValue(14, (byte) 0);
-		return this;
-	}
+
+    public v1_10_HumanEntityDataWatcher(DataWatcher watcher) {
+        super(watcher);
+    }
+
+    public void setSkinFlags(byte flag) {
+        watcher.setValue(13, flag);
+    }
+
+    public byte getSkinFlag() {
+        return watcher.getByte(13);
+    }
+
+    public boolean isCapeActive() {
+        return false;
+    }
+
+    public void setCapeActive(boolean b) {
+    }
+
+    public float getAbsorptionHearts() {
+        return watcher.getFloat(11);
+    }
+
+    public void setAbsorptionHearts(float f) {
+        watcher.setValue(11, f);
+    }
+
+    public int getScore() {
+        return watcher.getInt(12);
+    }
+
+    public void setScore(int score) {
+        watcher.setValue(12, score);
+    }
+
+    public v1_10_HumanEntityDataWatcher injektDefault() {
+        super.injektDefault();
+        if (watcher.get(11) == null)
+            watcher.setValue(11, (float) 0F);
+        if (watcher.get(12) == null)
+            watcher.setValue(12, (int) 0);
+        if (watcher.get(13) == null)
+            watcher.setValue(13, (byte) 0);
+        if (watcher.get(14) == null)
+            watcher.setValue(14, (byte) 0);
+        return this;
+    }
 }
diff --git a/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_10_LivingEntityDataWatcher.java b/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_10_LivingEntityDataWatcher.java
index b9647c9..d6f67f2 100644
--- a/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_10_LivingEntityDataWatcher.java
+++ b/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_10_LivingEntityDataWatcher.java
@@ -2,66 +2,67 @@ package dev.wolveringer.api.datawatcher.impl;
 
 import dev.wolveringer.api.datawatcher.DataWatcher;
 import dev.wolveringer.api.datawatcher.LivingEntityDataWatcher;
-import net.md_5.bungee.api.connection.ProxiedPlayer;
 
-public class v1_10_LivingEntityDataWatcher extends v1_10_EntityDataWatcher implements LivingEntityDataWatcher{
-	
-	public v1_10_LivingEntityDataWatcher(DataWatcher dataWatcher) {
-		super(dataWatcher);
-	}
-	
-	public void setHealth(float h) {
-		this.watcher.setValue(7, h);
-	}
+public class v1_10_LivingEntityDataWatcher extends v1_10_EntityDataWatcher implements LivingEntityDataWatcher {
 
-	public float getHealth() {
-		return this.watcher.getFloat(7);
-	}
+    public v1_10_LivingEntityDataWatcher(DataWatcher dataWatcher) {
+        super(dataWatcher);
+    }
 
-	public void setArrows(int amauth) {
-		this.watcher.setValue(10, (byte) amauth);
-	}
+    public float getHealth() {
+        return this.watcher.getFloat(7);
+    }
 
-	public int getArrows() {
-		return this.watcher.getByte(10);
-	}
+    public void setHealth(float h) {
+        this.watcher.setValue(7, h);
+    }
 
-	public void setParicelColor(int color){
-		this.watcher.setValue(8, color);
-	}
-	public int getParicelColor(){
-		return this.watcher.getInt(8);
-	}
-	
-	public void setParticelVisiable(boolean flag) {
-		this.watcher.setValue(9, (byte) (flag == true ? 1 : 0));
-	}
-	public boolean isParticelVisiable(){
-		return this.watcher.getByte(9) == 1;
-	}
+    public int getArrows() {
+        return this.watcher.getByte(10);
+    }
 
-	public void setAI(boolean flag) {
-		throw new RuntimeException("Methode not implimented in 1.10");
-	}
+    public void setArrows(int amauth) {
+        this.watcher.setValue(10, (byte) amauth);
+    }
 
-	public boolean hasAI() {
-		throw new RuntimeException("Methode not implimented in 1.10");
-	}
+    public int getParicelColor() {
+        return this.watcher.getInt(8);
+    }
 
-	@Override
-	public v1_10_LivingEntityDataWatcher injektDefault() {
-		super.injektDefault();
-		if(this.watcher.get(6) == null)
-			this.watcher.setValue(6, Byte.valueOf((byte)0));
-		if(this.watcher.get(7) == null)
-			this.watcher.setValue(7, Float.valueOf(20.0F));
-		if(this.watcher.get(8) == null)
-			this.watcher.setValue(8, Integer.valueOf(0));
-		if(this.watcher.get(9) == null)
-			this.watcher.setValue(9, false);
-		if(this.watcher.get(10) == null)
-			this.watcher.setValue(10, (int) 0);
-		return this;
-	}
+    public void setParicelColor(int color) {
+        this.watcher.setValue(8, color);
+    }
+
+    public boolean isParticelVisiable() {
+        return this.watcher.getByte(9) == 1;
+    }
+
+    public void setParticelVisiable(boolean flag) {
+        this.watcher.setValue(9, (byte) (flag == true ? 1 : 0));
+    }
+
+    public void setAI(boolean flag) {
+        throw new RuntimeException("Methode not implimented in 1.10");
+    }
+
+    public boolean hasAI() {
+        throw new RuntimeException("Methode not implimented in 1.10");
+    }
+
+    @Override
+    public v1_10_LivingEntityDataWatcher injektDefault() {
+        super.injektDefault();
+        if (this.watcher.get(6) == null)
+            this.watcher.setValue(6, Byte.valueOf((byte) 0));
+        if (this.watcher.get(7) == null)
+            this.watcher.setValue(7, Float.valueOf(20.0F));
+        if (this.watcher.get(8) == null)
+            this.watcher.setValue(8, Integer.valueOf(0));
+        if (this.watcher.get(9) == null)
+            this.watcher.setValue(9, false);
+        if (this.watcher.get(10) == null)
+            this.watcher.setValue(10, (int) 0);
+        return this;
+    }
 
 }
diff --git a/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_8_DataWatcher.java b/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_8_DataWatcher.java
index 4413510..3424e8a 100644
--- a/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_8_DataWatcher.java
+++ b/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_8_DataWatcher.java
@@ -18,223 +18,230 @@ import dev.wolveringer.api.position.BlockPosition;
 import dev.wolveringer.api.position.Vector3f;
 import dev.wolveringer.packet.PacketDataSerializer;
 
-@SuppressWarnings({ "rawtypes", "unchecked" })
-public class v1_8_DataWatcher extends DataWatcher{
-	private static final TObjectIntMap v1_8_classToId = new TObjectIntHashMap(10, 0.5F, -1);
-	
-	static {
-		v1_8_classToId.put(Byte.class, 0);
-		v1_8_classToId.put(Short.class, 1);
-		v1_8_classToId.put(Integer.class, 2);
-		v1_8_classToId.put(Float.class, 3);
-		v1_8_classToId.put(String.class, 4);
-		v1_8_classToId.put(Item.class, 5);
-		v1_8_classToId.put(BlockPosition.class, 6);
-		v1_8_classToId.put(Vector3f.class, 7);
-	}
-	
-	@SuppressWarnings("serial")
-	private List<DataWatcherObjekt> objekts = new ArrayList<DataWatcherObjekt>() {
-		public DataWatcherObjekt get(int index) {
-			return index >= size() ? null : super.get(index);
-		};
-		
-		public DataWatcherObjekt set(int index, DataWatcherObjekt element) {
-			while (size() <= index) {
-				add(null);
-			}
-			return super.set(index, element);
-		};
-	};
-	
-	@SuppressWarnings("serial")
-	private HashMap<Class, EntityDataWatcher> watchers = new HashMap<Class, EntityDataWatcher>() {
-		public EntityDataWatcher put(Class key, EntityDataWatcher value) {
-			Class _super = key.getSuperclass();
-			while (EntityDataWatcher.class.isAssignableFrom(_super) && super.get(_super) == null) {
-				super.put(_super, value);
-			}
-			return super.put(key, value);
-		};
-	};
-	
-	public v1_8_DataWatcher(PacketDataSerializer paramPacketDataSerializer) {
-		this();
-		if(paramPacketDataSerializer != null)
-		this.objekts = read(paramPacketDataSerializer);
-	}
-	
-	public v1_8_DataWatcher() {}
-	
-	public void write(PacketDataSerializer packetdataserializer) {
-		Iterator iterator = objekts.iterator();
-		while (iterator.hasNext()) {
-			DataWatcherObjekt watchableobject = (DataWatcherObjekt) iterator.next();
-			if (watchableobject == null)
-				continue;
-			write(packetdataserializer, watchableobject);
-		}
-		packetdataserializer.writeByte(127);
-	}
-	
-	private void write(PacketDataSerializer s, DataWatcherObjekt o) {
-		int data = (v1_8_classToId.get(o.getType()) << 5 | o.getPostition() & 0x1F) & 0xFF;
-		s.writeByte(data);
-		switch (v1_8_classToId.get(o.getType())) {
-			case 0:
-				s.writeByte(((Byte) o.getValue()).byteValue());
-				break;
-			case 1:
-				s.writeShort(((Short) o.getValue()).shortValue());
-				break;
-			case 2:
-				s.writeInt(((Integer) o.getValue()).intValue());
-				break;
-			case 3:
-				s.writeFloat(((Float) o.getValue()).floatValue());
-				break;
-			case 4:
-				s.writeString((String) o.getValue());
-				break;
-			case 5:
-				Item itemstack = (Item) o.getValue();
-				s.writeItem(itemstack);
-				break;
-			case 6:
-				BlockPosition blockposition = (BlockPosition) o.getValue();
-				s.writeInt(blockposition.getX());
-				s.writeInt(blockposition.getY());
-				s.writeInt(blockposition.getZ());
-				break;
-			case 7:
-				Vector3f vector3f = (Vector3f) o.getValue();
-				s.writeFloat(vector3f.getX());
-				s.writeFloat(vector3f.getY());
-				s.writeFloat(vector3f.getZ());
-				break;
-			default:
-				System.out.println("Error 02");
-		}
-	}
-	
-	private List read(PacketDataSerializer packetdataserializer) {
-		ArrayList arraylist = new ArrayList();
-		for (byte data = packetdataserializer.readByte(); data != 127; data = packetdataserializer.readByte()) {
-			int type = (data & 0xE0) >> 5;
-			int position = data & 0x1F;
-			DataWatcherObjekt objekt = null;
-			switch (type) {
-				case 0:
-					objekt = new DataWatcherObjekt(getTypeId(type), position, Byte.valueOf(packetdataserializer.readByte()));
-					break;
-				
-				case 1:
-					objekt = new DataWatcherObjekt(getTypeId(type), position, Short.valueOf(packetdataserializer.readShort()));
-					break;
-				
-				case 2:
-					objekt = new DataWatcherObjekt(getTypeId(type), position, Integer.valueOf(packetdataserializer.readInt()));
-					break;
-				
-				case 3:
-					objekt = new DataWatcherObjekt(getTypeId(type), position, Float.valueOf(packetdataserializer.readFloat()));
-					break;
-				
-				case 4:
-					objekt = new DataWatcherObjekt(getTypeId(type), position, packetdataserializer.readString(32767));
-					break;
-				
-				case 5:
-					objekt = new DataWatcherObjekt(getTypeId(type), position, packetdataserializer.readItem());
-					break;
-				
-				case 6:
-					objekt = new DataWatcherObjekt(getTypeId(type), position, new BlockPosition(packetdataserializer.readInt(), packetdataserializer.readInt(), packetdataserializer.readInt()));
-					break;
-				
-				case 7:
-					objekt = new DataWatcherObjekt(getTypeId(type), position, new Vector3f(packetdataserializer.readFloat(), packetdataserializer.readFloat(), packetdataserializer.readFloat()));
-					break;
-				default:
-					System.out.println("Error 01");
-			}
-			
-			arraylist.add(objekt);
-		}
-		return arraylist;
-	}
-	
-	public void setValue(int pos, Object object) {
-		if (pos > 31) {
-			throw new IllegalArgumentException("Data value id is too big with " + pos + "! (Max is " + 31 + ")");
-		}
-		if (objekts.get(pos) == null)
-			objekts.set(pos, new DataWatcherObjekt(object.getClass(), pos, null));
-		objekts.get(pos).setValue(object);
-	}
-	
-	private static Class<?> getTypeId(int type) {
-		for (Object o : v1_8_classToId.keys())
-			if (v1_8_classToId.get(o) == type)
-				return (Class<?>) o;
-		return null;
-	}
-	
-	@Override
-	public String toString() {
-		return "DataWatcher [v1_8] [objekts=" + objekts + "]";
-	}
-	
-	public v1_8_DataWatcher copy() {
-		v1_8_DataWatcher watcher = new v1_8_DataWatcher();
-		watcher.objekts = new ArrayList<DataWatcherObjekt>(this.objekts);
-		return watcher;
-	}
-	
-	public EntityDataWatcher getEntityDataWatcher() {
-		return getSpecialDataWatcher(EntityDataWatcher.class);
-	}
-	
-	public <T extends EntityDataWatcher> T getSpecialDataWatcher(Class<T> clazz) {
-		if(clazz.isAssignableFrom(EntityDataWatcher.class))
-			clazz = (Class<T>) v1_8_EntityDataWatcher.class;
-		else if(clazz.isAssignableFrom(LivingEntityDataWatcher.class))
-			clazz = (Class<T>) v1_8_LivingEntityDataWatcher.class;
-		else if(clazz.isAssignableFrom(HumanDataWatcher.class))
-			clazz = (Class<T>) v1_8_HumanEntityDataWatcher.class;
-		if (watchers.get(clazz) == null) {
-			try {
-				watchers.put(clazz, clazz.getConstructor(DataWatcher.class).newInstance(this));
-			} catch (InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException | NoSuchMethodException | SecurityException e) {
-				e.printStackTrace();
-			}
-		}
-		return (T) watchers.get(clazz);
-	}
-	
-	public Object get(int i) {
-		if (objekts.get(i) == null)
-			return null;
-		return objekts.get(i).getValue();
-	}
-	
-	public byte getByte(int i) {
-		return (byte) get(i);
-	}
-	
-	public short getShort(int i) {
-		return (short) get(i);
-	}
-	
-	public int getInt(int i) {
-		return (int) get(i);
-	}
-	
-	public String getString(int i) {
-		return (String) get(i);
-	}
-	
-	public float getFloat(int i) {
-		return (float) get(i);
-	}
+@SuppressWarnings({"rawtypes", "unchecked"})
+public class v1_8_DataWatcher extends DataWatcher {
+    private static final TObjectIntMap v1_8_classToId = new TObjectIntHashMap(10, 0.5F, -1);
+
+    static {
+        v1_8_classToId.put(Byte.class, 0);
+        v1_8_classToId.put(Short.class, 1);
+        v1_8_classToId.put(Integer.class, 2);
+        v1_8_classToId.put(Float.class, 3);
+        v1_8_classToId.put(String.class, 4);
+        v1_8_classToId.put(Item.class, 5);
+        v1_8_classToId.put(BlockPosition.class, 6);
+        v1_8_classToId.put(Vector3f.class, 7);
+    }
+
+    @SuppressWarnings("serial")
+    private List<DataWatcherObjekt> objekts = new ArrayList<DataWatcherObjekt>() {
+        public DataWatcherObjekt get(int index) {
+            return index >= size() ? null : super.get(index);
+        }
+
+        ;
+
+        public DataWatcherObjekt set(int index, DataWatcherObjekt element) {
+            while (size() <= index) {
+                add(null);
+            }
+            return super.set(index, element);
+        }
+
+        ;
+    };
+
+    @SuppressWarnings("serial")
+    private HashMap<Class, EntityDataWatcher> watchers = new HashMap<Class, EntityDataWatcher>() {
+        public EntityDataWatcher put(Class key, EntityDataWatcher value) {
+            Class _super = key.getSuperclass();
+            while (EntityDataWatcher.class.isAssignableFrom(_super) && super.get(_super) == null) {
+                super.put(_super, value);
+            }
+            return super.put(key, value);
+        }
+
+        ;
+    };
+
+    public v1_8_DataWatcher(PacketDataSerializer paramPacketDataSerializer) {
+        this();
+        if (paramPacketDataSerializer != null)
+            this.objekts = read(paramPacketDataSerializer);
+    }
+
+    public v1_8_DataWatcher() {
+    }
+
+    private static Class<?> getTypeId(int type) {
+        for (Object o : v1_8_classToId.keys())
+            if (v1_8_classToId.get(o) == type)
+                return (Class<?>) o;
+        return null;
+    }
+
+    public void write(PacketDataSerializer packetdataserializer) {
+        Iterator iterator = objekts.iterator();
+        while (iterator.hasNext()) {
+            DataWatcherObjekt watchableobject = (DataWatcherObjekt) iterator.next();
+            if (watchableobject == null)
+                continue;
+            write(packetdataserializer, watchableobject);
+        }
+        packetdataserializer.writeByte(127);
+    }
+
+    private void write(PacketDataSerializer s, DataWatcherObjekt o) {
+        int data = (v1_8_classToId.get(o.getType()) << 5 | o.getPostition() & 0x1F) & 0xFF;
+        s.writeByte(data);
+        switch (v1_8_classToId.get(o.getType())) {
+            case 0:
+                s.writeByte(((Byte) o.getValue()).byteValue());
+                break;
+            case 1:
+                s.writeShort(((Short) o.getValue()).shortValue());
+                break;
+            case 2:
+                s.writeInt(((Integer) o.getValue()).intValue());
+                break;
+            case 3:
+                s.writeFloat(((Float) o.getValue()).floatValue());
+                break;
+            case 4:
+                s.writeString((String) o.getValue());
+                break;
+            case 5:
+                Item itemstack = (Item) o.getValue();
+                s.writeItem(itemstack);
+                break;
+            case 6:
+                BlockPosition blockposition = (BlockPosition) o.getValue();
+                s.writeInt(blockposition.getX());
+                s.writeInt(blockposition.getY());
+                s.writeInt(blockposition.getZ());
+                break;
+            case 7:
+                Vector3f vector3f = (Vector3f) o.getValue();
+                s.writeFloat(vector3f.getX());
+                s.writeFloat(vector3f.getY());
+                s.writeFloat(vector3f.getZ());
+                break;
+            default:
+                System.out.println("Error 02");
+        }
+    }
+
+    private List read(PacketDataSerializer packetdataserializer) {
+        ArrayList arraylist = new ArrayList();
+        for (byte data = packetdataserializer.readByte(); data != 127; data = packetdataserializer.readByte()) {
+            int type = (data & 0xE0) >> 5;
+            int position = data & 0x1F;
+            DataWatcherObjekt objekt = null;
+            switch (type) {
+                case 0:
+                    objekt = new DataWatcherObjekt(getTypeId(type), position, Byte.valueOf(packetdataserializer.readByte()));
+                    break;
+
+                case 1:
+                    objekt = new DataWatcherObjekt(getTypeId(type), position, Short.valueOf(packetdataserializer.readShort()));
+                    break;
+
+                case 2:
+                    objekt = new DataWatcherObjekt(getTypeId(type), position, Integer.valueOf(packetdataserializer.readInt()));
+                    break;
+
+                case 3:
+                    objekt = new DataWatcherObjekt(getTypeId(type), position, Float.valueOf(packetdataserializer.readFloat()));
+                    break;
+
+                case 4:
+                    objekt = new DataWatcherObjekt(getTypeId(type), position, packetdataserializer.readString(32767));
+                    break;
+
+                case 5:
+                    objekt = new DataWatcherObjekt(getTypeId(type), position, packetdataserializer.readItem());
+                    break;
+
+                case 6:
+                    objekt = new DataWatcherObjekt(getTypeId(type), position, new BlockPosition(packetdataserializer.readInt(), packetdataserializer.readInt(), packetdataserializer.readInt()));
+                    break;
+
+                case 7:
+                    objekt = new DataWatcherObjekt(getTypeId(type), position, new Vector3f(packetdataserializer.readFloat(), packetdataserializer.readFloat(), packetdataserializer.readFloat()));
+                    break;
+                default:
+                    System.out.println("Error 01");
+            }
+
+            arraylist.add(objekt);
+        }
+        return arraylist;
+    }
+
+    public void setValue(int pos, Object object) {
+        if (pos > 31) {
+            throw new IllegalArgumentException("Data value id is too big with " + pos + "! (Max is " + 31 + ")");
+        }
+        if (objekts.get(pos) == null)
+            objekts.set(pos, new DataWatcherObjekt(object.getClass(), pos, null));
+        objekts.get(pos).setValue(object);
+    }
+
+    @Override
+    public String toString() {
+        return "DataWatcher [v1_8] [objekts=" + objekts + "]";
+    }
+
+    public v1_8_DataWatcher copy() {
+        v1_8_DataWatcher watcher = new v1_8_DataWatcher();
+        watcher.objekts = new ArrayList<DataWatcherObjekt>(this.objekts);
+        return watcher;
+    }
+
+    public EntityDataWatcher getEntityDataWatcher() {
+        return getSpecialDataWatcher(EntityDataWatcher.class);
+    }
+
+    public <T extends EntityDataWatcher> T getSpecialDataWatcher(Class<T> clazz) {
+        if (clazz.isAssignableFrom(EntityDataWatcher.class))
+            clazz = (Class<T>) v1_8_EntityDataWatcher.class;
+        else if (clazz.isAssignableFrom(LivingEntityDataWatcher.class))
+            clazz = (Class<T>) v1_8_LivingEntityDataWatcher.class;
+        else if (clazz.isAssignableFrom(HumanDataWatcher.class))
+            clazz = (Class<T>) v1_8_HumanEntityDataWatcher.class;
+        if (watchers.get(clazz) == null) {
+            try {
+                watchers.put(clazz, clazz.getConstructor(DataWatcher.class).newInstance(this));
+            } catch (InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException | NoSuchMethodException | SecurityException e) {
+                e.printStackTrace();
+            }
+        }
+        return (T) watchers.get(clazz);
+    }
+
+    public Object get(int i) {
+        if (objekts.get(i) == null)
+            return null;
+        return objekts.get(i).getValue();
+    }
+
+    public byte getByte(int i) {
+        return (byte) get(i);
+    }
+
+    public short getShort(int i) {
+        return (short) get(i);
+    }
+
+    public int getInt(int i) {
+        return (int) get(i);
+    }
+
+    public String getString(int i) {
+        return (String) get(i);
+    }
+
+    public float getFloat(int i) {
+        return (float) get(i);
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_8_EntityDataWatcher.java b/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_8_EntityDataWatcher.java
index 69df0a0..490a579 100644
--- a/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_8_EntityDataWatcher.java
+++ b/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_8_EntityDataWatcher.java
@@ -3,150 +3,152 @@ package dev.wolveringer.api.datawatcher.impl;
 import dev.wolveringer.api.datawatcher.DataWatcher;
 import dev.wolveringer.api.datawatcher.EntityDataWatcher;
 
-public class v1_8_EntityDataWatcher implements EntityDataWatcher{
-	
-	protected DataWatcher watcher;
-	
-	protected v1_8_EntityDataWatcher(DataWatcher dataWatcher) {
-		this.watcher = dataWatcher;
-	}
-	
-	private boolean getPropety(int pos) {
-		return (this.watcher.getByte(0) & 1 << pos) != 0;
-	}
-	
-	private void setPropety(int pos, boolean flag) {
-		if (this.watcher.get(0) == null)
-			this.watcher.setValue(0, (byte) 0);
-		byte b0 = this.watcher.getByte(0);
-		
-		if (flag) {
-			this.watcher.setValue(0, Byte.valueOf((byte) (b0 | 1 << pos)));
-		} else {
-			this.watcher.setValue(0, Byte.valueOf((byte) (b0 & (1 << pos ^ 0xFFFFFFFF))));
-		}
-	}
-	
-	public boolean isSneaking() {
-		return getPropety(1);
-	}
-	
-	public void setSneaking(boolean flag) {
-		setPropety(1, flag);
-	}
-	
-	public boolean isSprinting() {
-		return getPropety(3);
-	}
-	
-	public void setSprinting(boolean flag) {
-		setPropety(3, flag);
-	}
-	
-	public boolean isInvisible() {
-		return getPropety(5);
-	}
-	
-	public void setInvisible(boolean flag) {
-		setPropety(5, flag);
-	}
-	
-	public EntityDataWatcher injektDefault() {
-		if (this.watcher.get(0) == null)
-			this.watcher.setValue(0, Byte.valueOf((byte) 0));
-		if (this.watcher.get(1) == null)
-			this.watcher.setValue(1, Short.valueOf((short) 300));
-		return this;
-	}
-	
-	public DataWatcher getWatcher() {
-		return watcher;
-	}
-
-	@Override
-	public boolean isOnFire() {
-		throw new RuntimeException("Methode not implimented in 1.8");
-	}
-
-	@Override
-	public void setOnFire(boolean fire) {
-		throw new RuntimeException("Methode not implimented in 1.8");
-	}
-
-	@Override
-	public boolean isBlocking() {
-		throw new RuntimeException("Methode not implimented in 1.8");
-	}
-
-	@Override
-	public void setBlocking(boolean block) {
-		throw new RuntimeException("Methode not implimented in 1.8");
-	}
-
-	@Override
-	public boolean isGlowing() {
-		throw new RuntimeException("Methode not implimented in 1.8");
-	}
-
-	@Override
-	public void setGlowing(boolean glow) {
-		throw new RuntimeException("Methode not implimented in 1.8");
-	}
-
-	@Override
-	public boolean isElytra() {
-		throw new RuntimeException("Methode not implimented in 1.8");
-	}
-
-	@Override
-	public void setElytra(boolean elytra) {
-		throw new RuntimeException("Methode not implimented in 1.8");
-	}
-
-	@Override
-	public int getAir() {
-		throw new RuntimeException("Methode not implimented in 1.8");
-	}
-
-	@Override
-	public void setAir(int air) {
-		throw new RuntimeException("Methode not implimented in 1.8");
-	}
-
-	@Override
-	public void setCostumName(String name) {
-		throw new RuntimeException("Methode not implimented in 1.8");
-	}
-
-	@Override
-	public String getCostumName() {
-		throw new RuntimeException("Methode not implimented in 1.8");
-	}
-
-	@Override
-	public boolean isCostumNameVisiable() {
-		throw new RuntimeException("Methode not implimented in 1.8");
-	}
-
-	@Override
-	public void setCostumNameVisiable(boolean flag) {
-		throw new RuntimeException("Methode not implimented in 1.8");
-	}
-
-	@Override
-	public boolean isSlient() {
-		throw new RuntimeException("Methode not implimented in 1.8");
-	}
-
-	@Override
-	public void setSlient(boolean flag) {
-		throw new RuntimeException("Methode not implimented in 1.8");
-	}
-	
-	@Override
-	public boolean hasGravity() {
-		return true;
-	}
-	@Override
-	public void setApplayGravity(boolean flag) {}
+public class v1_8_EntityDataWatcher implements EntityDataWatcher {
+
+    protected DataWatcher watcher;
+
+    protected v1_8_EntityDataWatcher(DataWatcher dataWatcher) {
+        this.watcher = dataWatcher;
+    }
+
+    private boolean getPropety(int pos) {
+        return (this.watcher.getByte(0) & 1 << pos) != 0;
+    }
+
+    private void setPropety(int pos, boolean flag) {
+        if (this.watcher.get(0) == null)
+            this.watcher.setValue(0, (byte) 0);
+        byte b0 = this.watcher.getByte(0);
+
+        if (flag) {
+            this.watcher.setValue(0, Byte.valueOf((byte) (b0 | 1 << pos)));
+        } else {
+            this.watcher.setValue(0, Byte.valueOf((byte) (b0 & (1 << pos ^ 0xFFFFFFFF))));
+        }
+    }
+
+    public boolean isSneaking() {
+        return getPropety(1);
+    }
+
+    public void setSneaking(boolean flag) {
+        setPropety(1, flag);
+    }
+
+    public boolean isSprinting() {
+        return getPropety(3);
+    }
+
+    public void setSprinting(boolean flag) {
+        setPropety(3, flag);
+    }
+
+    public boolean isInvisible() {
+        return getPropety(5);
+    }
+
+    public void setInvisible(boolean flag) {
+        setPropety(5, flag);
+    }
+
+    public EntityDataWatcher injektDefault() {
+        if (this.watcher.get(0) == null)
+            this.watcher.setValue(0, Byte.valueOf((byte) 0));
+        if (this.watcher.get(1) == null)
+            this.watcher.setValue(1, Short.valueOf((short) 300));
+        return this;
+    }
+
+    public DataWatcher getWatcher() {
+        return watcher;
+    }
+
+    @Override
+    public boolean isOnFire() {
+        throw new RuntimeException("Methode not implimented in 1.8");
+    }
+
+    @Override
+    public void setOnFire(boolean fire) {
+        throw new RuntimeException("Methode not implimented in 1.8");
+    }
+
+    @Override
+    public boolean isBlocking() {
+        throw new RuntimeException("Methode not implimented in 1.8");
+    }
+
+    @Override
+    public void setBlocking(boolean block) {
+        throw new RuntimeException("Methode not implimented in 1.8");
+    }
+
+    @Override
+    public boolean isGlowing() {
+        throw new RuntimeException("Methode not implimented in 1.8");
+    }
+
+    @Override
+    public void setGlowing(boolean glow) {
+        throw new RuntimeException("Methode not implimented in 1.8");
+    }
+
+    @Override
+    public boolean isElytra() {
+        throw new RuntimeException("Methode not implimented in 1.8");
+    }
+
+    @Override
+    public void setElytra(boolean elytra) {
+        throw new RuntimeException("Methode not implimented in 1.8");
+    }
+
+    @Override
+    public int getAir() {
+        throw new RuntimeException("Methode not implimented in 1.8");
+    }
+
+    @Override
+    public void setAir(int air) {
+        throw new RuntimeException("Methode not implimented in 1.8");
+    }
+
+    @Override
+    public String getCostumName() {
+        throw new RuntimeException("Methode not implimented in 1.8");
+    }
+
+    @Override
+    public void setCostumName(String name) {
+        throw new RuntimeException("Methode not implimented in 1.8");
+    }
+
+    @Override
+    public boolean isCostumNameVisiable() {
+        throw new RuntimeException("Methode not implimented in 1.8");
+    }
+
+    @Override
+    public void setCostumNameVisiable(boolean flag) {
+        throw new RuntimeException("Methode not implimented in 1.8");
+    }
+
+    @Override
+    public boolean isSlient() {
+        throw new RuntimeException("Methode not implimented in 1.8");
+    }
+
+    @Override
+    public void setSlient(boolean flag) {
+        throw new RuntimeException("Methode not implimented in 1.8");
+    }
+
+    @Override
+    public boolean hasGravity() {
+        return true;
+    }
+
+    @Override
+    public void setApplayGravity(boolean flag) {
+    }
 }
diff --git a/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_8_HumanEntityDataWatcher.java b/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_8_HumanEntityDataWatcher.java
index f49e21a..e272272 100644
--- a/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_8_HumanEntityDataWatcher.java
+++ b/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_8_HumanEntityDataWatcher.java
@@ -2,58 +2,57 @@ package dev.wolveringer.api.datawatcher.impl;
 
 import dev.wolveringer.api.datawatcher.DataWatcher;
 import dev.wolveringer.api.datawatcher.HumanDataWatcher;
-import dev.wolveringer.api.datawatcher.LivingEntityDataWatcher;
-
-public class v1_8_HumanEntityDataWatcher extends v1_8_LivingEntityDataWatcher implements HumanDataWatcher{
-
-	public v1_8_HumanEntityDataWatcher(DataWatcher watcher) {
-		super(watcher);
-	}
-
-	public void setSkinFlags(byte flag) {
-		watcher.setValue(10, flag);
-	}
-
-	public byte getSkinFlag() {
-		return watcher.getByte(10);
-	}
-
-	public void setCapeActive(boolean b) {
-		watcher.setValue(16, (byte) (b == true ? 1 : 0));
-	}
-
-	public boolean isCapeActive() {
-		return watcher.getByte(16) == 1;
-	}
-
-	public void setAbsorptionHearts(float f) {
-		watcher.setValue(17, f);
-	}
-
-	public float getAbsorptionHearts() {
-		return watcher.getFloat(17);
-	}
-
-	public void setScore(int score) {
-		watcher.setValue(18, score);
-	}
-
-	public int getScore() {
-		return watcher.getInt(18);
-	}
-
-	@Override
-	public v1_8_HumanEntityDataWatcher injektDefault() {
-		super.injektDefault();
-		if(watcher.get(10) == null)
-			watcher.setValue(10, (byte) 0);
-		if(watcher.get(16) == null)
-			watcher.setValue(16, (byte) 0);
-		if(watcher.get(17) == null)
-			watcher.setValue(17, (float) 0F);
-		if(watcher.get(18) == null)
-			watcher.setValue(18, (int) 0);
-		return this;
-	}
+
+public class v1_8_HumanEntityDataWatcher extends v1_8_LivingEntityDataWatcher implements HumanDataWatcher {
+
+    public v1_8_HumanEntityDataWatcher(DataWatcher watcher) {
+        super(watcher);
+    }
+
+    public void setSkinFlags(byte flag) {
+        watcher.setValue(10, flag);
+    }
+
+    public byte getSkinFlag() {
+        return watcher.getByte(10);
+    }
+
+    public boolean isCapeActive() {
+        return watcher.getByte(16) == 1;
+    }
+
+    public void setCapeActive(boolean b) {
+        watcher.setValue(16, (byte) (b == true ? 1 : 0));
+    }
+
+    public float getAbsorptionHearts() {
+        return watcher.getFloat(17);
+    }
+
+    public void setAbsorptionHearts(float f) {
+        watcher.setValue(17, f);
+    }
+
+    public int getScore() {
+        return watcher.getInt(18);
+    }
+
+    public void setScore(int score) {
+        watcher.setValue(18, score);
+    }
+
+    @Override
+    public v1_8_HumanEntityDataWatcher injektDefault() {
+        super.injektDefault();
+        if (watcher.get(10) == null)
+            watcher.setValue(10, (byte) 0);
+        if (watcher.get(16) == null)
+            watcher.setValue(16, (byte) 0);
+        if (watcher.get(17) == null)
+            watcher.setValue(17, (float) 0F);
+        if (watcher.get(18) == null)
+            watcher.setValue(18, (int) 0);
+        return this;
+    }
 
 }
diff --git a/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_8_LivingEntityDataWatcher.java b/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_8_LivingEntityDataWatcher.java
index 0d73289..a04b9b1 100644
--- a/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_8_LivingEntityDataWatcher.java
+++ b/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_8_LivingEntityDataWatcher.java
@@ -3,93 +3,95 @@ package dev.wolveringer.api.datawatcher.impl;
 import dev.wolveringer.api.datawatcher.DataWatcher;
 import dev.wolveringer.api.datawatcher.LivingEntityDataWatcher;
 
-public class v1_8_LivingEntityDataWatcher extends v1_8_EntityDataWatcher implements LivingEntityDataWatcher{
-	
-	public v1_8_LivingEntityDataWatcher(DataWatcher dataWatcher) {
-		super(dataWatcher);
-
-	}
-
-	public void setCustomName(String s) {
-		this.watcher.setValue(2, s);
-	}
-
-	public String getCustomName() {
-		return this.watcher.getString(2);
-	}
-
-	public boolean hasCustomName() {
-		return this.watcher.getString(2).length() > 0;
-	}
-
-	public void setCustomNameVisible(boolean flag) {
-		this.watcher.setValue(3, Byte.valueOf((byte) (flag ? 1 : 0)));
-	}
-
-	public boolean getCustomNameVisible() {
-		return this.watcher.getByte(3) == 1;
-	}
-
-	public void setHealth(float h) {
-		this.watcher.setValue(6, h);
-	}
-
-	public float getHealth() {
-		return this.watcher.getFloat(6);
-	}
-
-	public void setArrows(int amauth) {
-		this.watcher.setValue(9, (byte) amauth);
-	}
-
-	public int getArrows() {
-		return this.watcher.getByte(9);
-	}
-
-	public void setParicelColor(int color){
-		this.watcher.setValue(7, color);
-	}
-	public int getParicelColor(){
-		return this.watcher.getInt(7);
-	}
-	
-	public void setParticelVisiable(boolean flag) {
-		this.watcher.setValue(8, (byte) (flag == true ? 1 : 0));
-	}
-	public boolean isParticelVisiable(){
-		return this.watcher.getByte(8) == 1;
-	}
-
-	public void setAI(boolean flag) {
-		this.watcher.setValue(15, Byte.valueOf((byte) (flag == true ? 0 : 1)));
-	}
-
-	public boolean hasAI() {
-		return this.watcher.getByte(15) == 0;
-	}
-
-	@Override
-	public v1_8_LivingEntityDataWatcher injektDefault() {
-		super.injektDefault();
-		if(this.watcher.get(2) == null)
-			this.watcher.setValue(2, "");
-		if(this.watcher.get(3) == null)
-			this.watcher.setValue(3, Byte.valueOf((byte) 0));
-		if(this.watcher.get(4) == null)
-			this.watcher.setValue(4, Byte.valueOf((byte) 0));
-
-		if(this.watcher.get(6) == null)
-			this.watcher.setValue(6, Float.valueOf(10.0F));
-		if(this.watcher.get(7) == null)
-			this.watcher.setValue(7, Integer.valueOf(0));
-		if(this.watcher.get(8) == null)
-			this.watcher.setValue(8, Byte.valueOf((byte) 0));
-		if(this.watcher.get(9) == null)
-			this.watcher.setValue(9, Byte.valueOf((byte) 0));
-
-		if(this.watcher.get(15) == null)
-			this.watcher.setValue(15, Byte.valueOf((byte) 0));
-		return this;
-	}
+public class v1_8_LivingEntityDataWatcher extends v1_8_EntityDataWatcher implements LivingEntityDataWatcher {
+
+    public v1_8_LivingEntityDataWatcher(DataWatcher dataWatcher) {
+        super(dataWatcher);
+
+    }
+
+    public String getCustomName() {
+        return this.watcher.getString(2);
+    }
+
+    public void setCustomName(String s) {
+        this.watcher.setValue(2, s);
+    }
+
+    public boolean hasCustomName() {
+        return this.watcher.getString(2).length() > 0;
+    }
+
+    public boolean getCustomNameVisible() {
+        return this.watcher.getByte(3) == 1;
+    }
+
+    public void setCustomNameVisible(boolean flag) {
+        this.watcher.setValue(3, Byte.valueOf((byte) (flag ? 1 : 0)));
+    }
+
+    public float getHealth() {
+        return this.watcher.getFloat(6);
+    }
+
+    public void setHealth(float h) {
+        this.watcher.setValue(6, h);
+    }
+
+    public int getArrows() {
+        return this.watcher.getByte(9);
+    }
+
+    public void setArrows(int amauth) {
+        this.watcher.setValue(9, (byte) amauth);
+    }
+
+    public int getParicelColor() {
+        return this.watcher.getInt(7);
+    }
+
+    public void setParicelColor(int color) {
+        this.watcher.setValue(7, color);
+    }
+
+    public boolean isParticelVisiable() {
+        return this.watcher.getByte(8) == 1;
+    }
+
+    public void setParticelVisiable(boolean flag) {
+        this.watcher.setValue(8, (byte) (flag == true ? 1 : 0));
+    }
+
+    public void setAI(boolean flag) {
+        this.watcher.setValue(15, Byte.valueOf((byte) (flag == true ? 0 : 1)));
+    }
+
+    public boolean hasAI() {
+        return this.watcher.getByte(15) == 0;
+    }
+
+    @Override
+    public v1_8_LivingEntityDataWatcher injektDefault() {
+        super.injektDefault();
+        if (this.watcher.get(2) == null)
+            this.watcher.setValue(2, "");
+        if (this.watcher.get(3) == null)
+            this.watcher.setValue(3, Byte.valueOf((byte) 0));
+        if (this.watcher.get(4) == null)
+            this.watcher.setValue(4, Byte.valueOf((byte) 0));
+
+        if (this.watcher.get(6) == null)
+            this.watcher.setValue(6, Float.valueOf(10.0F));
+        if (this.watcher.get(7) == null)
+            this.watcher.setValue(7, Integer.valueOf(0));
+        if (this.watcher.get(8) == null)
+            this.watcher.setValue(8, Byte.valueOf((byte) 0));
+        if (this.watcher.get(9) == null)
+            this.watcher.setValue(9, Byte.valueOf((byte) 0));
+
+        if (this.watcher.get(15) == null)
+            this.watcher.setValue(15, Byte.valueOf((byte) 0));
+        return this;
+    }
 
 }
diff --git a/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_9_DataWatcher.java b/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_9_DataWatcher.java
index 8699aee..e6abf81 100644
--- a/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_9_DataWatcher.java
+++ b/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_9_DataWatcher.java
@@ -23,254 +23,264 @@ import dev.wolveringer.api.position.Vector3f;
 import dev.wolveringer.chat.IChatBaseComponent;
 import dev.wolveringer.packet.PacketDataSerializer;
 
-@SuppressWarnings({ "rawtypes", "unchecked" })
-public class v1_9_DataWatcher extends DataWatcher{
-	private static final TObjectIntMap v1_9_classToId = new TObjectIntHashMap(10, 0.5F, -1);
-	
-	static {
-		v1_9_classToId.put(Byte.class, 0);
-		v1_9_classToId.put(Integer.class, 1);
-		v1_9_classToId.put(Float.class, 2);
-		v1_9_classToId.put(String.class, 3);
-		v1_9_classToId.put(IChatBaseComponent.class, 4);
-		v1_9_classToId.put(Item.class, 5);
-		v1_9_classToId.put(Boolean.class, 6);
-		v1_9_classToId.put(Vector3f.class, 7);
-		v1_9_classToId.put(BlockPosition.class, 8);
-		v1_9_classToId.put(OptionalBlockPosition.class, 9);
-		v1_9_classToId.put(Direction.class, 10);
-		v1_9_classToId.put(OptionalUUID.class, 11);
-		v1_9_classToId.put(BlockData.class, 12);
-		v1_9_classToId.put(Short.class, 13);
-	}
-	
-	@SuppressWarnings("serial")
-	private List<DataWatcherObjekt> objekts = new ArrayList<DataWatcherObjekt>() {
-		public DataWatcherObjekt get(int index) {
-			return index >= size() ? null : super.get(index);
-		};
-		
-		public DataWatcherObjekt set(int index, DataWatcherObjekt element) {
-			while (size() <= index) {
-				add(null);
-			}
-			return super.set(index, element);
-		};
-	};
-	
-	@SuppressWarnings("serial")
-	private HashMap<Class, EntityDataWatcher> watchers = new HashMap<Class, EntityDataWatcher>() {
-		public EntityDataWatcher put(Class key, EntityDataWatcher value) {
-			Class _super = key.getSuperclass();
-			while (EntityDataWatcher.class.isAssignableFrom(_super) && super.get(_super) == null) {
-				super.put(_super, value);
-			}
-			return super.put(key, value);
-		};
-	};
-	
-	public v1_9_DataWatcher(PacketDataSerializer paramPacketDataSerializer) {
-		this();
-		if(paramPacketDataSerializer != null)
-		this.objekts = read(paramPacketDataSerializer);
-	}
-	
-	public v1_9_DataWatcher() {
-	}
-	
-	public void write(PacketDataSerializer packetdataserializer) {
-		Iterator iterator = objekts.iterator();
-		while (iterator.hasNext()) {
-			DataWatcherObjekt watchableobject = (DataWatcherObjekt) iterator.next();
-			if (watchableobject == null) continue;
-			write(packetdataserializer, watchableobject);
-		}
-		packetdataserializer.writeByte(255); // end
-	}
-	
-	private void write(PacketDataSerializer s, DataWatcherObjekt o) {
-			s.writeByte(o.getPostition());
-			int typeId = v1_9_classToId.get(o.getType());
-			if (typeId == 13) s.writeByte(v1_9_classToId.get(Integer.class));
-			else s.writeByte(typeId);
-			
-			switch (typeId) {
-				case 0:
-					s.writeByte((byte) o.getValue());
-					break;
-				case 1:
-					s.writeVarInt((int) o.getValue());
-					break;
-				case 2:
-					s.writeFloat((float) o.getValue());
-					break;
-				case 3:
-					s.writeString((String) o.getValue());
-					break;
-				case 4:
-					s.writeRawString((IChatBaseComponent) o.getValue());
-					break;
-				case 5:
-					s.writeItem((Item) o.getValue());
-					break;
-				case 6:
-					s.writeBoolean((boolean) o.getValue());
-					break;
-				case 7:
-					Vector3f v = (Vector3f) o.getValue();
-					s.writeFloat(v.getX());
-					s.writeFloat(v.getY());
-					s.writeFloat(v.getZ());
-					break;
-				case 8:
-					s.writeBlockPosition((BlockPosition) o.getValue());
-					break;
-				case 9:
-					OptionalBlockPosition p = (OptionalBlockPosition) o.getValue(); // Optional
-					s.writeBoolean(p.getPosition() != null);
-					if (p != null) s.writeBlockPosition(p.getPosition());
-					break;
-				case 10:
-					s.writeVarInt(((Direction) o.getValue()).getDirection()); // Direction
-					break;
-				case 11:
-					OptionalUUID uuid = (OptionalUUID) o.getValue(); // Optional
-					s.writeBoolean(uuid.getUuid() != null);
-					if (uuid != null) s.writeUUID(uuid.getUuid());
-					break;
-				case 12:
-					s.writeVarInt(((BlockData) o.getValue()).getData()); // Block
-					break; // Data
-				case 13: // Short will write as an interger
-					s.writeVarInt((Short) o.getValue());
-					break;
-				default:
-					System.out.println("Type not found ("+typeId+") ("+o.getType()+")");
-					break;
-			}
-	}
-	
-	private List read(PacketDataSerializer packetdataserializer) {
-		ArrayList arraylist = new ArrayList();
-			for (int data = packetdataserializer.readUnsignedByte(); data != 255; data = packetdataserializer.readUnsignedByte()) {
-				int pos = data;
-				int type = packetdataserializer.readUnsignedByte();
-				Object value = null;
-				switch (type) {
-					case 0:
-						value = packetdataserializer.readByte();
-						break;
-					case 1:
-						value = packetdataserializer.readVarInt();
-						break;
-					case 2:
-						value = packetdataserializer.readFloat();
-						break;
-					case 3:
-						value = packetdataserializer.readString(-1);
-						break;
-					case 4:
-						value = packetdataserializer.readRawString();
-						break;
-					case 5:
-						value = packetdataserializer.readItem();
-						break;
-					case 6:
-						value = packetdataserializer.readBoolean();
-						break;
-					case 7:
-						value = new Vector3f(packetdataserializer.readFloat(), packetdataserializer.readFloat(), packetdataserializer.readFloat());
-						break;
-					case 8:
-						value = packetdataserializer.readBlockPosition();
-						break;
-					case 9:
-						if (packetdataserializer.readBoolean()) value = new OptionalBlockPosition(packetdataserializer.readBlockPosition());
-						else value = new OptionalBlockPosition(null);
-						break;
-					case 10:
-						value = new Direction(packetdataserializer.readVarInt());
-						break;
-					case 11:
-						if (packetdataserializer.readBoolean()) value = new OptionalUUID(packetdataserializer.readUUID());
-						else value = new OptionalUUID(null);
-						break;
-					case 12:
-						value = new BlockData(packetdataserializer.readVarInt());
-						break;
-				}
-				arraylist.add(new DataWatcherObjekt(getTypeId(type), pos, value));
-		}
-		return arraylist;
-	}
-	
-	public void setValue(int pos, Object object) {
-		if (pos > 254) { throw new IllegalArgumentException("Data value id is too big with " + pos + "! (Max is " + 254 + ")"); }
-		if (objekts.get(pos) == null) objekts.set(pos, new DataWatcherObjekt(object.getClass(), pos, null));
-		objekts.get(pos).setValue(object);
-	}
-	
-	private static Class<?> getTypeId(int type) {
-			for (Object o : v1_9_classToId.keys())
-				if (v1_9_classToId.get(o) == type) return (Class<?>) o;
-		return null;
-	}
-	
-	@Override
-	public String toString() {
-		return "DataWatcher [v1_9] [objekts=" + objekts + "]";
-	}
-	
-	public DataWatcher copy() {
-		v1_9_DataWatcher watcher = new v1_9_DataWatcher();
-		watcher.objekts = new ArrayList<DataWatcherObjekt>(this.objekts);
-		return watcher;
-	}
-	
-	public EntityDataWatcher getEntityDataWatcher() {
-		return getSpecialDataWatcher(EntityDataWatcher.class);
-	}
-	
-	public <T extends EntityDataWatcher> T getSpecialDataWatcher(Class<T> clazz) {
-		if(clazz.isAssignableFrom(EntityDataWatcher.class))
-			clazz = (Class<T>) v1_9_EntityDataWatcher.class;
-		else if(clazz.isAssignableFrom(LivingEntityDataWatcher.class))
-			clazz = (Class<T>) v1_9_LivingEntityDataWatcher.class;
-		else if(clazz.isAssignableFrom(HumanDataWatcher.class))
-			clazz = (Class<T>) v1_9_HumanEntityDataWatcher.class;
-		if (watchers.get(clazz) == null) {
-			try {
-				watchers.put(clazz, clazz.getConstructor(DataWatcher.class).newInstance(this));
-			}
-			catch (InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException | NoSuchMethodException | SecurityException e) {
-				e.printStackTrace();
-			}
-		}
-		return (T) watchers.get(clazz);
-	}
-	
-	public Object get(int i) {
-		if (objekts.get(i) == null) return null;
-		return objekts.get(i).getValue();
-	}
-	
-	public byte getByte(int i) {
-		return (byte) get(i);
-	}
-	
-	public short getShort(int i) {
-		return (short) get(i);
-	}
-	
-	public int getInt(int i) {
-		return (int) get(i);
-	}
-	
-	public String getString(int i) {
-		return (String) get(i);
-	}
-	
-	public float getFloat(int i) {
-		return (float) get(i);
-	}
+@SuppressWarnings({"rawtypes", "unchecked"})
+public class v1_9_DataWatcher extends DataWatcher {
+    private static final TObjectIntMap v1_9_classToId = new TObjectIntHashMap(10, 0.5F, -1);
+
+    static {
+        v1_9_classToId.put(Byte.class, 0);
+        v1_9_classToId.put(Integer.class, 1);
+        v1_9_classToId.put(Float.class, 2);
+        v1_9_classToId.put(String.class, 3);
+        v1_9_classToId.put(IChatBaseComponent.class, 4);
+        v1_9_classToId.put(Item.class, 5);
+        v1_9_classToId.put(Boolean.class, 6);
+        v1_9_classToId.put(Vector3f.class, 7);
+        v1_9_classToId.put(BlockPosition.class, 8);
+        v1_9_classToId.put(OptionalBlockPosition.class, 9);
+        v1_9_classToId.put(Direction.class, 10);
+        v1_9_classToId.put(OptionalUUID.class, 11);
+        v1_9_classToId.put(BlockData.class, 12);
+        v1_9_classToId.put(Short.class, 13);
+    }
+
+    @SuppressWarnings("serial")
+    private List<DataWatcherObjekt> objekts = new ArrayList<DataWatcherObjekt>() {
+        public DataWatcherObjekt get(int index) {
+            return index >= size() ? null : super.get(index);
+        }
+
+        ;
+
+        public DataWatcherObjekt set(int index, DataWatcherObjekt element) {
+            while (size() <= index) {
+                add(null);
+            }
+            return super.set(index, element);
+        }
+
+        ;
+    };
+
+    @SuppressWarnings("serial")
+    private HashMap<Class, EntityDataWatcher> watchers = new HashMap<Class, EntityDataWatcher>() {
+        public EntityDataWatcher put(Class key, EntityDataWatcher value) {
+            Class _super = key.getSuperclass();
+            while (EntityDataWatcher.class.isAssignableFrom(_super) && super.get(_super) == null) {
+                super.put(_super, value);
+            }
+            return super.put(key, value);
+        }
+
+        ;
+    };
+
+    public v1_9_DataWatcher(PacketDataSerializer paramPacketDataSerializer) {
+        this();
+        if (paramPacketDataSerializer != null)
+            this.objekts = read(paramPacketDataSerializer);
+    }
+
+    public v1_9_DataWatcher() {
+    }
+
+    private static Class<?> getTypeId(int type) {
+        for (Object o : v1_9_classToId.keys())
+            if (v1_9_classToId.get(o) == type) return (Class<?>) o;
+        return null;
+    }
+
+    public void write(PacketDataSerializer packetdataserializer) {
+        Iterator iterator = objekts.iterator();
+        while (iterator.hasNext()) {
+            DataWatcherObjekt watchableobject = (DataWatcherObjekt) iterator.next();
+            if (watchableobject == null) continue;
+            write(packetdataserializer, watchableobject);
+        }
+        packetdataserializer.writeByte(255); // end
+    }
+
+    private void write(PacketDataSerializer s, DataWatcherObjekt o) {
+        s.writeByte(o.getPostition());
+        int typeId = v1_9_classToId.get(o.getType());
+        if (typeId == 13) s.writeByte(v1_9_classToId.get(Integer.class));
+        else s.writeByte(typeId);
+
+        switch (typeId) {
+            case 0:
+                s.writeByte((byte) o.getValue());
+                break;
+            case 1:
+                s.writeVarInt((int) o.getValue());
+                break;
+            case 2:
+                s.writeFloat((float) o.getValue());
+                break;
+            case 3:
+                s.writeString((String) o.getValue());
+                break;
+            case 4:
+                s.writeRawString((IChatBaseComponent) o.getValue());
+                break;
+            case 5:
+                s.writeItem((Item) o.getValue());
+                break;
+            case 6:
+                s.writeBoolean((boolean) o.getValue());
+                break;
+            case 7:
+                Vector3f v = (Vector3f) o.getValue();
+                s.writeFloat(v.getX());
+                s.writeFloat(v.getY());
+                s.writeFloat(v.getZ());
+                break;
+            case 8:
+                s.writeBlockPosition((BlockPosition) o.getValue());
+                break;
+            case 9:
+                OptionalBlockPosition p = (OptionalBlockPosition) o.getValue(); // Optional
+                s.writeBoolean(p.getPosition() != null);
+                if (p != null) s.writeBlockPosition(p.getPosition());
+                break;
+            case 10:
+                s.writeVarInt(((Direction) o.getValue()).getDirection()); // Direction
+                break;
+            case 11:
+                OptionalUUID uuid = (OptionalUUID) o.getValue(); // Optional
+                s.writeBoolean(uuid.getUuid() != null);
+                if (uuid != null) s.writeUUID(uuid.getUuid());
+                break;
+            case 12:
+                s.writeVarInt(((BlockData) o.getValue()).getData()); // Block
+                break; // Data
+            case 13: // Short will write as an interger
+                s.writeVarInt((Short) o.getValue());
+                break;
+            default:
+                System.out.println("Type not found (" + typeId + ") (" + o.getType() + ")");
+                break;
+        }
+    }
+
+    private List read(PacketDataSerializer packetdataserializer) {
+        ArrayList arraylist = new ArrayList();
+        for (int data = packetdataserializer.readUnsignedByte(); data != 255; data = packetdataserializer.readUnsignedByte()) {
+            int pos = data;
+            int type = packetdataserializer.readUnsignedByte();
+            Object value = null;
+            switch (type) {
+                case 0:
+                    value = packetdataserializer.readByte();
+                    break;
+                case 1:
+                    value = packetdataserializer.readVarInt();
+                    break;
+                case 2:
+                    value = packetdataserializer.readFloat();
+                    break;
+                case 3:
+                    value = packetdataserializer.readString(-1);
+                    break;
+                case 4:
+                    value = packetdataserializer.readRawString();
+                    break;
+                case 5:
+                    value = packetdataserializer.readItem();
+                    break;
+                case 6:
+                    value = packetdataserializer.readBoolean();
+                    break;
+                case 7:
+                    value = new Vector3f(packetdataserializer.readFloat(), packetdataserializer.readFloat(), packetdataserializer.readFloat());
+                    break;
+                case 8:
+                    value = packetdataserializer.readBlockPosition();
+                    break;
+                case 9:
+                    if (packetdataserializer.readBoolean())
+                        value = new OptionalBlockPosition(packetdataserializer.readBlockPosition());
+                    else value = new OptionalBlockPosition(null);
+                    break;
+                case 10:
+                    value = new Direction(packetdataserializer.readVarInt());
+                    break;
+                case 11:
+                    if (packetdataserializer.readBoolean())
+                        value = new OptionalUUID(packetdataserializer.readUUID());
+                    else value = new OptionalUUID(null);
+                    break;
+                case 12:
+                    value = new BlockData(packetdataserializer.readVarInt());
+                    break;
+            }
+            arraylist.add(new DataWatcherObjekt(getTypeId(type), pos, value));
+        }
+        return arraylist;
+    }
+
+    public void setValue(int pos, Object object) {
+        if (pos > 254) {
+            throw new IllegalArgumentException("Data value id is too big with " + pos + "! (Max is " + 254 + ")");
+        }
+        if (objekts.get(pos) == null)
+            objekts.set(pos, new DataWatcherObjekt(object.getClass(), pos, null));
+        objekts.get(pos).setValue(object);
+    }
+
+    @Override
+    public String toString() {
+        return "DataWatcher [v1_9] [objekts=" + objekts + "]";
+    }
+
+    public DataWatcher copy() {
+        v1_9_DataWatcher watcher = new v1_9_DataWatcher();
+        watcher.objekts = new ArrayList<DataWatcherObjekt>(this.objekts);
+        return watcher;
+    }
+
+    public EntityDataWatcher getEntityDataWatcher() {
+        return getSpecialDataWatcher(EntityDataWatcher.class);
+    }
+
+    public <T extends EntityDataWatcher> T getSpecialDataWatcher(Class<T> clazz) {
+        if (clazz.isAssignableFrom(EntityDataWatcher.class))
+            clazz = (Class<T>) v1_9_EntityDataWatcher.class;
+        else if (clazz.isAssignableFrom(LivingEntityDataWatcher.class))
+            clazz = (Class<T>) v1_9_LivingEntityDataWatcher.class;
+        else if (clazz.isAssignableFrom(HumanDataWatcher.class))
+            clazz = (Class<T>) v1_9_HumanEntityDataWatcher.class;
+        if (watchers.get(clazz) == null) {
+            try {
+                watchers.put(clazz, clazz.getConstructor(DataWatcher.class).newInstance(this));
+            } catch (InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException | NoSuchMethodException | SecurityException e) {
+                e.printStackTrace();
+            }
+        }
+        return (T) watchers.get(clazz);
+    }
+
+    public Object get(int i) {
+        if (objekts.get(i) == null) return null;
+        return objekts.get(i).getValue();
+    }
+
+    public byte getByte(int i) {
+        return (byte) get(i);
+    }
+
+    public short getShort(int i) {
+        return (short) get(i);
+    }
+
+    public int getInt(int i) {
+        return (int) get(i);
+    }
+
+    public String getString(int i) {
+        return (String) get(i);
+    }
+
+    public float getFloat(int i) {
+        return (float) get(i);
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_9_EntityDataWatcher.java b/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_9_EntityDataWatcher.java
index 90e1bc0..90ac197 100644
--- a/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_9_EntityDataWatcher.java
+++ b/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_9_EntityDataWatcher.java
@@ -3,156 +3,158 @@ package dev.wolveringer.api.datawatcher.impl;
 import dev.wolveringer.api.datawatcher.DataWatcher;
 import dev.wolveringer.api.datawatcher.EntityDataWatcher;
 
-public class v1_9_EntityDataWatcher implements EntityDataWatcher{
-	
-	protected DataWatcher watcher;
-	
-	protected v1_9_EntityDataWatcher(DataWatcher dataWatcher) {
-		this.watcher = dataWatcher;
-	}
-	
-	private boolean getPropety(int pos) {
-		return (this.watcher.getByte(0) & 1 << pos) != 0;
-	}
-	
-	private void setPropety(int pos, boolean flag) {
-		if (this.watcher.get(0) == null)
-			this.watcher.setValue(0, (byte) 0);
-		byte b0 = this.watcher.getByte(0);
-		
-		if (flag) {
-			this.watcher.setValue(0, Byte.valueOf((byte) (b0 | 1 << pos)));
-		} else {
-			this.watcher.setValue(0, Byte.valueOf((byte) (b0 & (1 << pos ^ 0xFFFFFFFF))));
-		}
-	}
-	
-	public boolean isSneaking() {
-		return getPropety(1);
-	}
-	
-	public void setSneaking(boolean flag) {
-		setPropety(1, flag);
-	}
-	
-	public boolean isSprinting() {
-		return getPropety(2);
-	}
-	
-	public void setSprinting(boolean flag) {
-		setPropety(2, flag);
-	}
-	
-	public boolean isInvisible() {
-		return getPropety(4);
-	}
-	
-	public void setInvisible(boolean flag) {
-		setPropety(4, flag);
-	}
-	
-	public EntityDataWatcher injektDefault() {
-		if (this.watcher.get(0) == null)
-			this.watcher.setValue(0, Byte.valueOf((byte) 0));
-		if (this.watcher.get(1) == null)
-			this.watcher.setValue(1, (Integer)((int) 300));
-		if (this.watcher.get(2) == null)
-			this.watcher.setValue(2, "");
-		if (this.watcher.get(3) == null)
-			this.watcher.setValue(3,false);
-		if (this.watcher.get(4) == null)
-			this.watcher.setValue(4,false);
-		return this;
-	}
-	
-	public DataWatcher getWatcher() {
-		return watcher;
-	}
-
-	@Override
-	public boolean isOnFire() {
-		return getPropety(0);
-	}
-
-	@Override
-	public void setOnFire(boolean fire) {
-		setPropety(0, fire);
-	}
-
-	@Override
-	public boolean isBlocking() {
-		return getPropety(3);
-	}
-
-	@Override
-	public void setBlocking(boolean block) {
-		setPropety(3, block);
-	}
-
-	@Override
-	public boolean isGlowing() {
-		return getPropety(6);
-	}
-
-	@Override
-	public void setGlowing(boolean glow) {
-		setPropety(6, glow);
-	}
-
-	@Override
-	public boolean isElytra() {
-		return getPropety(7);
-	}
-
-	@Override
-	public void setElytra(boolean elytra) {
-		setPropety(7, elytra);
-	}
-
-	@Override
-	public int getAir() {
-		return watcher.getInt(1);
-	}
-
-	@Override
-	public void setAir(int air) {
-		watcher.setValue(1, air);
-	}
-
-	@Override
-	public void setCostumName(String name) {
-		watcher.setValue(2, name);
-	}
-
-	@Override
-	public String getCostumName() {
-		return watcher.getString(2);
-	}
-
-	@Override
-	public boolean isCostumNameVisiable() {
-		return (boolean) watcher.get(3);
-	}
-
-	@Override
-	public void setCostumNameVisiable(boolean flag) {
-		watcher.setValue(3, flag);
-	}
-
-	@Override
-	public boolean isSlient() {
-		return (boolean) watcher.get(4);
-	}
-
-	@Override
-	public void setSlient(boolean flag) {
-		watcher.setValue(4, flag);
-	}
-	
-	@Override
-	public boolean hasGravity() {
-		return true;
-	}
-	@Override
-	public void setApplayGravity(boolean flag) {}
+public class v1_9_EntityDataWatcher implements EntityDataWatcher {
+
+    protected DataWatcher watcher;
+
+    protected v1_9_EntityDataWatcher(DataWatcher dataWatcher) {
+        this.watcher = dataWatcher;
+    }
+
+    private boolean getPropety(int pos) {
+        return (this.watcher.getByte(0) & 1 << pos) != 0;
+    }
+
+    private void setPropety(int pos, boolean flag) {
+        if (this.watcher.get(0) == null)
+            this.watcher.setValue(0, (byte) 0);
+        byte b0 = this.watcher.getByte(0);
+
+        if (flag) {
+            this.watcher.setValue(0, Byte.valueOf((byte) (b0 | 1 << pos)));
+        } else {
+            this.watcher.setValue(0, Byte.valueOf((byte) (b0 & (1 << pos ^ 0xFFFFFFFF))));
+        }
+    }
+
+    public boolean isSneaking() {
+        return getPropety(1);
+    }
+
+    public void setSneaking(boolean flag) {
+        setPropety(1, flag);
+    }
+
+    public boolean isSprinting() {
+        return getPropety(2);
+    }
+
+    public void setSprinting(boolean flag) {
+        setPropety(2, flag);
+    }
+
+    public boolean isInvisible() {
+        return getPropety(4);
+    }
+
+    public void setInvisible(boolean flag) {
+        setPropety(4, flag);
+    }
+
+    public EntityDataWatcher injektDefault() {
+        if (this.watcher.get(0) == null)
+            this.watcher.setValue(0, Byte.valueOf((byte) 0));
+        if (this.watcher.get(1) == null)
+            this.watcher.setValue(1, (Integer) ((int) 300));
+        if (this.watcher.get(2) == null)
+            this.watcher.setValue(2, "");
+        if (this.watcher.get(3) == null)
+            this.watcher.setValue(3, false);
+        if (this.watcher.get(4) == null)
+            this.watcher.setValue(4, false);
+        return this;
+    }
+
+    public DataWatcher getWatcher() {
+        return watcher;
+    }
+
+    @Override
+    public boolean isOnFire() {
+        return getPropety(0);
+    }
+
+    @Override
+    public void setOnFire(boolean fire) {
+        setPropety(0, fire);
+    }
+
+    @Override
+    public boolean isBlocking() {
+        return getPropety(3);
+    }
+
+    @Override
+    public void setBlocking(boolean block) {
+        setPropety(3, block);
+    }
+
+    @Override
+    public boolean isGlowing() {
+        return getPropety(6);
+    }
+
+    @Override
+    public void setGlowing(boolean glow) {
+        setPropety(6, glow);
+    }
+
+    @Override
+    public boolean isElytra() {
+        return getPropety(7);
+    }
+
+    @Override
+    public void setElytra(boolean elytra) {
+        setPropety(7, elytra);
+    }
+
+    @Override
+    public int getAir() {
+        return watcher.getInt(1);
+    }
+
+    @Override
+    public void setAir(int air) {
+        watcher.setValue(1, air);
+    }
+
+    @Override
+    public String getCostumName() {
+        return watcher.getString(2);
+    }
+
+    @Override
+    public void setCostumName(String name) {
+        watcher.setValue(2, name);
+    }
+
+    @Override
+    public boolean isCostumNameVisiable() {
+        return (boolean) watcher.get(3);
+    }
+
+    @Override
+    public void setCostumNameVisiable(boolean flag) {
+        watcher.setValue(3, flag);
+    }
+
+    @Override
+    public boolean isSlient() {
+        return (boolean) watcher.get(4);
+    }
+
+    @Override
+    public void setSlient(boolean flag) {
+        watcher.setValue(4, flag);
+    }
+
+    @Override
+    public boolean hasGravity() {
+        return true;
+    }
+
+    @Override
+    public void setApplayGravity(boolean flag) {
+    }
 }
diff --git a/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_9_HumanEntityDataWatcher.java b/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_9_HumanEntityDataWatcher.java
index 1706466..be95287 100644
--- a/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_9_HumanEntityDataWatcher.java
+++ b/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_9_HumanEntityDataWatcher.java
@@ -4,52 +4,52 @@ import dev.wolveringer.api.datawatcher.DataWatcher;
 import dev.wolveringer.api.datawatcher.HumanDataWatcher;
 
 public class v1_9_HumanEntityDataWatcher extends v1_9_LivingEntityDataWatcher implements HumanDataWatcher {
-	
-	public v1_9_HumanEntityDataWatcher(DataWatcher watcher) {
-		super(watcher);
-	}
-	
-	public void setSkinFlags(byte flag) {
-		watcher.setValue(12, flag);
-	}
-	
-	public byte getSkinFlag() {
-		return watcher.getByte(12);
-	}
-	
-	public void setCapeActive(boolean b) {
-	}
-	
-	public boolean isCapeActive() {
-		return false;
-	}
-	
-	public void setAbsorptionHearts(float f) {
-		watcher.setValue(10, f);
-	}
-	
-	public float getAbsorptionHearts() {
-		return watcher.getFloat(10);
-	}
-	
-	public void setScore(int score) {
-		watcher.setValue(11, score);
-	}
-	
-	public int getScore() {
-		return watcher.getInt(11);
-	}
-	
-	public v1_9_HumanEntityDataWatcher injektDefault() {
-		super.injektDefault();
-		if (watcher.get(10) == null)
-			watcher.setValue(10, (float) 0F);
-		if (watcher.get(11) == null)
-			watcher.setValue(11, (int) 0);
-		if (watcher.get(12) == null)
-			watcher.setValue(12, (byte) 0);
-		if (watcher.get(13) == null)
-			watcher.setValue(13, (byte) 0);
-		return this;
-	}
+
+    public v1_9_HumanEntityDataWatcher(DataWatcher watcher) {
+        super(watcher);
+    }
+
+    public void setSkinFlags(byte flag) {
+        watcher.setValue(12, flag);
+    }
+
+    public byte getSkinFlag() {
+        return watcher.getByte(12);
+    }
+
+    public boolean isCapeActive() {
+        return false;
+    }
+
+    public void setCapeActive(boolean b) {
+    }
+
+    public float getAbsorptionHearts() {
+        return watcher.getFloat(10);
+    }
+
+    public void setAbsorptionHearts(float f) {
+        watcher.setValue(10, f);
+    }
+
+    public int getScore() {
+        return watcher.getInt(11);
+    }
+
+    public void setScore(int score) {
+        watcher.setValue(11, score);
+    }
+
+    public v1_9_HumanEntityDataWatcher injektDefault() {
+        super.injektDefault();
+        if (watcher.get(10) == null)
+            watcher.setValue(10, (float) 0F);
+        if (watcher.get(11) == null)
+            watcher.setValue(11, (int) 0);
+        if (watcher.get(12) == null)
+            watcher.setValue(12, (byte) 0);
+        if (watcher.get(13) == null)
+            watcher.setValue(13, (byte) 0);
+        return this;
+    }
 }
diff --git a/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_9_LivingEntityDataWatcher.java b/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_9_LivingEntityDataWatcher.java
index 30368e9..f25f3f9 100644
--- a/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_9_LivingEntityDataWatcher.java
+++ b/src/main/java/dev/wolveringer/api/datawatcher/impl/v1_9_LivingEntityDataWatcher.java
@@ -3,63 +3,65 @@ package dev.wolveringer.api.datawatcher.impl;
 import dev.wolveringer.api.datawatcher.DataWatcher;
 import dev.wolveringer.api.datawatcher.LivingEntityDataWatcher;
 
-public class v1_9_LivingEntityDataWatcher extends v1_9_EntityDataWatcher implements LivingEntityDataWatcher{
-	
-	public v1_9_LivingEntityDataWatcher(DataWatcher dataWatcher) {
-		super(dataWatcher);
-
-	}
-	
-	public void setHealth(float h) {
-		this.watcher.setValue(6, h);
-	}
-
-	public float getHealth() {
-		return this.watcher.getFloat(6);
-	}
-
-	public void setArrows(int amauth) {
-		this.watcher.setValue(9, (byte) amauth);
-	}
-
-	public int getArrows() {
-		return this.watcher.getByte(9);
-	}
-
-	public void setParicelColor(int color){
-		this.watcher.setValue(7, color);
-	}
-	public int getParicelColor(){
-		return this.watcher.getInt(7);
-	}
-	
-	public void setParticelVisiable(boolean flag) {
-		this.watcher.setValue(8, (byte) (flag == true ? 1 : 0));
-	}
-	public boolean isParticelVisiable(){
-		return this.watcher.getByte(8) == 1;
-	}
-
-	public void setAI(boolean flag) {
-		throw new RuntimeException("Methode not implimented in 1.9");
-	}
-
-	public boolean hasAI() {
-		throw new RuntimeException("Methode not implimented in 1.8");
-	}
-
-	@Override
-	public v1_9_LivingEntityDataWatcher injektDefault() {
-		super.injektDefault();
-		if(this.watcher.get(6) == null)
-			this.watcher.setValue(6, Float.valueOf(20.0F));
-		if(this.watcher.get(7) == null)
-			this.watcher.setValue(7, Integer.valueOf(0));
-		if(this.watcher.get(8) == null)
-			this.watcher.setValue(8, false);
-		if(this.watcher.get(9) == null)
-			this.watcher.setValue(9, (int) 0);
-		return this;
-	}
+public class v1_9_LivingEntityDataWatcher extends v1_9_EntityDataWatcher implements LivingEntityDataWatcher {
+
+    public v1_9_LivingEntityDataWatcher(DataWatcher dataWatcher) {
+        super(dataWatcher);
+
+    }
+
+    public float getHealth() {
+        return this.watcher.getFloat(6);
+    }
+
+    public void setHealth(float h) {
+        this.watcher.setValue(6, h);
+    }
+
+    public int getArrows() {
+        return this.watcher.getByte(9);
+    }
+
+    public void setArrows(int amauth) {
+        this.watcher.setValue(9, (byte) amauth);
+    }
+
+    public int getParicelColor() {
+        return this.watcher.getInt(7);
+    }
+
+    public void setParicelColor(int color) {
+        this.watcher.setValue(7, color);
+    }
+
+    public boolean isParticelVisiable() {
+        return this.watcher.getByte(8) == 1;
+    }
+
+    public void setParticelVisiable(boolean flag) {
+        this.watcher.setValue(8, (byte) (flag == true ? 1 : 0));
+    }
+
+    public void setAI(boolean flag) {
+        throw new RuntimeException("Methode not implimented in 1.9");
+    }
+
+    public boolean hasAI() {
+        throw new RuntimeException("Methode not implimented in 1.8");
+    }
+
+    @Override
+    public v1_9_LivingEntityDataWatcher injektDefault() {
+        super.injektDefault();
+        if (this.watcher.get(6) == null)
+            this.watcher.setValue(6, Float.valueOf(20.0F));
+        if (this.watcher.get(7) == null)
+            this.watcher.setValue(7, Integer.valueOf(0));
+        if (this.watcher.get(8) == null)
+            this.watcher.setValue(8, false);
+        if (this.watcher.get(9) == null)
+            this.watcher.setValue(9, (int) 0);
+        return this;
+    }
 
 }
diff --git a/src/main/java/dev/wolveringer/api/gui/AnvilGui.java b/src/main/java/dev/wolveringer/api/gui/AnvilGui.java
index c13305d..f79248e 100644
--- a/src/main/java/dev/wolveringer/api/gui/AnvilGui.java
+++ b/src/main/java/dev/wolveringer/api/gui/AnvilGui.java
@@ -1,5 +1,7 @@
 package dev.wolveringer.api.gui;
 
+import net.md_5.bungee.protocol.DefinedPacket;
+
 import java.util.ArrayList;
 import java.util.HashMap;
 
@@ -16,135 +18,94 @@ import dev.wolveringer.BungeeUtil.packets.PacketPlayInPluginMessage;
 import dev.wolveringer.api.inventory.Inventory;
 import dev.wolveringer.api.inventory.InventoryType;
 import dev.wolveringer.chat.ChatColor.ChatColorUtils;
-import net.md_5.bungee.protocol.DefinedPacket;
 
 public class AnvilGui {
-	
-	private static class AnvilWindowSizeStringCalculator {
-		private static HashMap<Character, Double> charLength = new HashMap<>(); //Length = 1 = X
-		private static final int BOX_SIZE = 18;
-		static {
-			for(int i = 0;i<Character.MAX_VALUE;i++)
-				charLength.put((char) i, 1D);
-			charLength.put('I', 18D/26D); //26 in 
-			charLength.put('i', 18D/52D); //Todo
-			charLength.put('j', 18D/28D); 
-			charLength.put('l', 18D/34D);//Todo
-		}
-		
-		private String message;
-		
-		public AnvilWindowSizeStringCalculator(String message) {
-			this.message = message;
-		}
-		
-		public boolean boarderReached(){
-			return reachBoarder(BOX_SIZE);
-		}
-		
-		public boolean reachBoarder(int length){
-			double out = 0;
-			for(char c : message.toCharArray())
-				out+=charLength.get(c);
-			return out+1>length;
-		}
-		
-		
-	}
-	
-	private static final Item DEFAULT_CENTER_ITEM;
-	private static final Item DEFAULT_OUTPUT_ITEM;
-	
-	static {
-		DEFAULT_CENTER_ITEM = new Item(Material.BARRIER);
-		DEFAULT_CENTER_ITEM.getItemMeta().setDisplayName(ChatColorUtils.COLOR_CHAR+"r");
-		
-		DEFAULT_OUTPUT_ITEM = new Item(Material.NAME_TAG);
-		DEFAULT_OUTPUT_ITEM.getItemMeta().setDisplayName(ChatColorUtils.COLOR_CHAR+"aClick to finish");
-	}
-	
-	private Player owner;
-	private Inventory inv;
-	private String curruntMessage = "";
-	private String backgroundString = "Message here: ";
-	private Material backgroundMaterial = Material.STONE;
-	private String colorPrefix = "\u00A7a";
-	private Item centerItem = DEFAULT_CENTER_ITEM;
-	private Item outputItem = DEFAULT_OUTPUT_ITEM;
-	
-	private String curruntItemDisplayName = "";
-	
-	private boolean noBackground = false;
-	
-	private String curruntDisplayString = "";
-	
-	private ArrayList<AnvilGuiListener> listener = new ArrayList<>();
-	
-	private PacketHandler<Packet> packet = new PacketHandler<Packet>() {
-		int backgroundCount = 0;
-		
-		@Override
-		public void handle(PacketHandleEvent<Packet> e) {
-			if (e.getPacket() instanceof PacketPlayInPluginMessage) { //Message changed
-				PacketPlayInPluginMessage packet = (PacketPlayInPluginMessage) e.getPacket();
-				if (packet.getChannel().equalsIgnoreCase("MC|ItemName")) {
-					if (e.getPlayer().equals(owner) && inv != null) {
-						String message = DefinedPacket.readString(packet.getCopiedbyteBuff());
-						if(curruntItemDisplayName.equalsIgnoreCase(message) && false)
-							return;
-						curruntItemDisplayName = message;
-						if(colorPrefix.length() > message.length()) //Backspace (color prefix deleted!)
-							message = colorPrefix;
-						message = message.substring(colorPrefix.length(), message.length()); // replace
-	                                                                                         // color
-	                                                                                         // prefix
-						String handleMessage = message;
-						if (message.length() == 0 && noBackground) {
-							ItemStack item = new ItemStack(backgroundMaterial) {
-								@Override
-								public void click(Click click) {
-									click.setCancelled(true);
-								}
-							};
-							item.getItemMeta().setDisplayName(curruntItemDisplayName = colorPrefix + backgroundString);
-							inv.setItem(0, item);
-							noBackground = false;
-							handleMessage = "";
-							return;
-						}
-						
-						if (buildOutString(message, backgroundString).length() <= 1 && noBackground == false) {// Checking
-	                                                                                                           // for
-	                                                                                                           // background
-							if ((backgroundCount++ > 0)) {
-								handleMessage = "";
-								noBackground = true;
-								backgroundCount = 0;
-								String newMessage = buildOutString(backgroundString, backgroundString.substring(0, Math.min(backgroundString.length(), message.length())));
-								if (newMessage.length() == 0) {// No extra chars
-	                                                           // found!
-									if (message.length() < backgroundString.length()) {// Char
-	                                                                                   // removed!
-										newMessage = "";
-									}
-									else { // Char added at the end
-										newMessage = message.substring(backgroundString.length(), message.length());
-									}
-								}
-								ItemStack item = new ItemStack(backgroundMaterial) {
-									@Override
-									public void click(Click click) {
-										click.setCancelled(true);
-									}
-								};
-								item.getItemMeta().setDisplayName(curruntItemDisplayName = colorPrefix + newMessage);
-								inv.setItem(0, item);
-							}
-						}
-						else
-						{
-							/*
-							ItemStack item = new ItemStack(backgroundMaterial) {
+
+    private static final Item DEFAULT_CENTER_ITEM;
+    private static final Item DEFAULT_OUTPUT_ITEM;
+
+    static {
+        DEFAULT_CENTER_ITEM = new Item(Material.BARRIER);
+        DEFAULT_CENTER_ITEM.getItemMeta().setDisplayName(ChatColorUtils.COLOR_CHAR + "r");
+
+        DEFAULT_OUTPUT_ITEM = new Item(Material.NAME_TAG);
+        DEFAULT_OUTPUT_ITEM.getItemMeta().setDisplayName(ChatColorUtils.COLOR_CHAR + "aClick to finish");
+    }
+
+    private Player owner;
+    private Inventory inv;
+    private String curruntMessage = "";
+    private String backgroundString = "Message here: ";
+    private Material backgroundMaterial = Material.STONE;
+    private String colorPrefix = "\u00A7a";
+    private Item centerItem = DEFAULT_CENTER_ITEM;
+    private Item outputItem = DEFAULT_OUTPUT_ITEM;
+    private String curruntItemDisplayName = "";
+    private boolean noBackground = false;
+    private String curruntDisplayString = "";
+    private ArrayList<AnvilGuiListener> listener = new ArrayList<>();
+    private PacketHandler<Packet> packet = new PacketHandler<Packet>() {
+        int backgroundCount = 0;
+
+        @Override
+        public void handle(PacketHandleEvent<Packet> e) {
+            if (e.getPacket() instanceof PacketPlayInPluginMessage) { //Message changed
+                PacketPlayInPluginMessage packet = (PacketPlayInPluginMessage) e.getPacket();
+                if (packet.getChannel().equalsIgnoreCase("MC|ItemName")) {
+                    if (e.getPlayer().equals(owner) && inv != null) {
+                        String message = DefinedPacket.readString(packet.getCopiedbyteBuff());
+                        if (curruntItemDisplayName.equalsIgnoreCase(message) && false)
+                            return;
+                        curruntItemDisplayName = message;
+                        if (colorPrefix.length() > message.length()) //Backspace (color prefix deleted!)
+                            message = colorPrefix;
+                        message = message.substring(colorPrefix.length(), message.length()); // replace
+                        // color
+                        // prefix
+                        String handleMessage = message;
+                        if (message.length() == 0 && noBackground) {
+                            ItemStack item = new ItemStack(backgroundMaterial) {
+                                @Override
+                                public void click(Click click) {
+                                    click.setCancelled(true);
+                                }
+                            };
+                            item.getItemMeta().setDisplayName(curruntItemDisplayName = colorPrefix + backgroundString);
+                            inv.setItem(0, item);
+                            noBackground = false;
+                            handleMessage = "";
+                            return;
+                        }
+
+                        if (buildOutString(message, backgroundString).length() <= 1 && noBackground == false) {// Checking
+                            // for
+                            // background
+                            if ((backgroundCount++ > 0)) {
+                                handleMessage = "";
+                                noBackground = true;
+                                backgroundCount = 0;
+                                String newMessage = buildOutString(backgroundString, backgroundString.substring(0, Math.min(backgroundString.length(), message.length())));
+                                if (newMessage.length() == 0) {// No extra chars
+                                    // found!
+                                    if (message.length() < backgroundString.length()) {// Char
+                                        // removed!
+                                        newMessage = "";
+                                    } else { // Char added at the end
+                                        newMessage = message.substring(backgroundString.length(), message.length());
+                                    }
+                                }
+                                ItemStack item = new ItemStack(backgroundMaterial) {
+                                    @Override
+                                    public void click(Click click) {
+                                        click.setCancelled(true);
+                                    }
+                                };
+                                item.getItemMeta().setDisplayName(curruntItemDisplayName = colorPrefix + newMessage);
+                                inv.setItem(0, item);
+                            }
+                        } else {
+                            /*
+                            ItemStack item = new ItemStack(backgroundMaterial) {
 								@Override
 								public void click(Click click) {
 									click.setCancelled(true);
@@ -153,212 +114,241 @@ public class AnvilGui {
 							item.getItemMeta().setDisplayName(curruntItemDisplayName);
 							inv.setItem(0, item);
 							*/
-						}
-						
-						handleMessage = handleMessage.replaceFirst(backgroundString, ""); // For safty
-						handleMessage = ChatColorUtils.stripColor(handleMessage);
-						if (handleMessage.startsWith(" ")) handleMessage = handleMessage.substring(1);
-						curruntMessage = handleMessage;
-						for(AnvilGuiListener listener : new ArrayList<>(AnvilGui.this.listener))
-							listener.onMessageChange(AnvilGui.this, handleMessage);
-						if(!inv.equals(owner.getInventoryView())){
-							PacketLib.removeHandler(this);
-						}
-					//	System.out.println("Boarderreach: "+new AnvilWindowSizeStringCalculator(handleMessage).reachBoarder(18)); 
-					}
-				}
-			}
-			else if(e.getPacket() instanceof PacketPlayInCloseWindow){
-				PacketPlayInCloseWindow packet = (PacketPlayInCloseWindow) e.getPacket();
-				if(owner.equals(e.getPlayer()) && (packet.getWindow() == Inventory.ID || inv.getViewer().isEmpty())){
-					for(AnvilGuiListener listener : new ArrayList<>(AnvilGui.this.listener))
-						listener.onClose(AnvilGui.this);
-					PacketLib.removeHandler(this);
-					System.out.println("Removing this. ("+this+"/"+")");
-					PacketLib.printListener();
-				}
-			}
-		}
-		/**
-		 * 
-		 * @param in
-		 *            XXXXX
-		 * @param in2
-		 *            YYXYY
-		 * @return
-		 */
-		
-		private String buildOutString(String in, String in2) {
-			char[] ca = in.toCharArray();
-			int cpa = 0;
-			char[] cb = in2.toCharArray();
-			int cpb = 0;
-			String out = "";
-			for (; Math.max(cpa, cpb) < Math.min(ca.length, cb.length);) {
-				if (ca[cpa] == cb[cpb]) {
-					cpa++;
-					cpb++;
-				}
-				else if (cpb + 1 < cb.length && ca[cpa] == cb[cpb + 1]) {
-					out = out += new String(new char[] { cb[cpb] });
-					cpb++;
-				}
-				else if (cpa + 1 < ca.length && ca[cpa + 1] == cb[cpb]) {
-					cpa++;
-				}
-				else {
-					// System.out.print("Non one char added!");
-					break;
-				}
-			}
-			return out;
-		}
-	};
-	
-	public AnvilGui(Player owner) {
-		this.owner = owner;
-		PacketLib.addHandler(packet);
-		backgroundMaterial = Material.ENCHANTED_BOOK;
-	}
-	
-	public void addListener(AnvilGuiListener listener){
-		this.listener.add(listener);
-	}
-	public void removeListener(AnvilGuiListener listener){
-		this.listener.remove(listener);
-	}
-	
-	public void open() {
-		inv = new Inventory(InventoryType.Anvil, "This is an AnvilGuy by WolverinDEV");
-		
-		ItemStack item = new ItemStack(backgroundMaterial) {
-			@Override
-			public void click(Click click) {
-				click.setCancelled(true);
-				handleSuccessClick();
-			}
-		};
-		item.getItemMeta().setDisplayName(curruntItemDisplayName = colorPrefix + backgroundString);
-		inv.setItem(0, item);
-		
-		inv.setItem(1, new ItemStack(centerItem) {
-			@Override
-			public void click(Click click) {
-				click.setCancelled(true);
-			}
-		});
-		
-		inv.setItem(2, new ItemStack(outputItem){
-			@Override
-			public void click(Click click) {
-				click.setCancelled(true);
-				handleSuccessClick();
-			}
-		});
-		
-		owner.openInventory(inv);
-	}
-	
-	public void setBackgroundMaterial(Material backgroundMaterial) {
-		this.backgroundMaterial = backgroundMaterial;
-		ItemStack item = new ItemStack(backgroundMaterial) {
-			@Override
-			public void click(Click click) {
-				click.setCancelled(true);
-			}
-		};
-		item.getItemMeta().setDisplayName(colorPrefix+curruntMessage);
-		inv.setItem(0, item);
-	}
-	
-	public void setBackgroundMessage(String backgroundString) {
-		this.backgroundString = backgroundString;
-		if(!noBackground){
-			ItemStack item = new ItemStack(backgroundMaterial) {
-				@Override
-				public void click(Click click) {
-					click.setCancelled(true);
-				}
-			};
-			item.getItemMeta().setDisplayName(colorPrefix+backgroundString);
-			inv.setItem(0, item);
-		}
-	}
-	
-	public void setCenterItem(Item centerItem) {
-		this.centerItem = centerItem;
-		this.inv.setItem(1, centerItem);
-	}
-	
-	public Item getCenterItem() {
-		return centerItem;
-	}
-	
-	public String getBackgroundMessage() {
-		return backgroundString;
-	}
-	
-	public String getCurruntInput() {
-		return curruntMessage;
-	}
-	
-	public void setCurruntInput(String curruntName) {
-		this.curruntMessage = curruntName;
-		ItemStack item = new ItemStack(backgroundMaterial) {
-			@Override
-			public void click(Click click) {
-				click.setCancelled(true);
-			}
-		};
-		item.getItemMeta().setDisplayName(colorPrefix+curruntName);
-		inv.setItem(0, item);
-	}
-	
-	public void setColorPrefix(String prefix) {
-		if (colorPrefix.equalsIgnoreCase(prefix)) return;
-		String rawMeta = curruntItemDisplayName.substring(Math.min(colorPrefix.length(), curruntItemDisplayName.length())); //Backspace a color prefix code... fix
-		colorPrefix = prefix;
-		ItemStack item = new ItemStack(backgroundMaterial) {
-			@Override
-			public void click(Click click) {
-				click.setCancelled(true);
-			}
-		};
-		item.getItemMeta().setDisplayName(curruntItemDisplayName = colorPrefix + rawMeta);
-		inv.setItem(0, item);
-	}
-	
-	protected void handleSuccessClick(){
-		for(AnvilGuiListener listener : new ArrayList<>(AnvilGui.this.listener))
-			if(listener != null)
-			listener.onConfirmInput(AnvilGui.this, this.curruntMessage);
-		if(owner.getInventoryView() != null)
-			if(owner.getInventoryView().equals(this.inv))
-				owner.closeInventory();
-		PacketLib.removeHandler(packet);
-	}
-	
-	public void close(){
-		for(AnvilGuiListener listener : new ArrayList<>(AnvilGui.this.listener))
-			if(listener != null)
-				listener.onClose(AnvilGui.this);
-		
-		if(owner.getInventoryView() != null)
-			if(owner.getInventoryView().equals(this.inv))
-				owner.closeInventory();
-		PacketLib.removeHandler(packet);
-	}
-	
-	public void setOutputItem(Item item){
-		inv.setItem(2, new ItemStack(outputItem = item){
-			@Override
-			public void click(Click click) {
-				click.setCancelled(true);
-				handleSuccessClick();
-			}
-		});
-	}
-	public Item getOutputItem() {
-		return outputItem;
-	}
+                        }
+
+                        handleMessage = handleMessage.replaceFirst(backgroundString, ""); // For safty
+                        handleMessage = ChatColorUtils.stripColor(handleMessage);
+                        if (handleMessage.startsWith(" "))
+                            handleMessage = handleMessage.substring(1);
+                        curruntMessage = handleMessage;
+                        for (AnvilGuiListener listener : new ArrayList<>(AnvilGui.this.listener))
+                            listener.onMessageChange(AnvilGui.this, handleMessage);
+                        if (!inv.equals(owner.getInventoryView())) {
+                            PacketLib.removeHandler(this);
+                        }
+                        //	System.out.println("Boarderreach: "+new AnvilWindowSizeStringCalculator(handleMessage).reachBoarder(18));
+                    }
+                }
+            } else if (e.getPacket() instanceof PacketPlayInCloseWindow) {
+                PacketPlayInCloseWindow packet = (PacketPlayInCloseWindow) e.getPacket();
+                if (owner.equals(e.getPlayer()) && (packet.getWindow() == Inventory.ID || inv.getViewer().isEmpty())) {
+                    for (AnvilGuiListener listener : new ArrayList<>(AnvilGui.this.listener))
+                        listener.onClose(AnvilGui.this);
+                    PacketLib.removeHandler(this);
+                    System.out.println("Removing this. (" + this + "/" + ")");
+                    PacketLib.printListener();
+                }
+            }
+        }
+
+        /**
+         * @param in  XXXXX
+         * @param in2 YYXYY
+         */
+
+        private String buildOutString(String in, String in2) {
+            char[] ca = in.toCharArray();
+            int cpa = 0;
+            char[] cb = in2.toCharArray();
+            int cpb = 0;
+            String out = "";
+            for (; Math.max(cpa, cpb) < Math.min(ca.length, cb.length); ) {
+                if (ca[cpa] == cb[cpb]) {
+                    cpa++;
+                    cpb++;
+                } else if (cpb + 1 < cb.length && ca[cpa] == cb[cpb + 1]) {
+                    out = out += new String(new char[]{cb[cpb]});
+                    cpb++;
+                } else if (cpa + 1 < ca.length && ca[cpa + 1] == cb[cpb]) {
+                    cpa++;
+                } else {
+                    // System.out.print("Non one char added!");
+                    break;
+                }
+            }
+            return out;
+        }
+    };
+
+    public AnvilGui(Player owner) {
+        this.owner = owner;
+        PacketLib.addHandler(packet);
+        backgroundMaterial = Material.ENCHANTED_BOOK;
+    }
+
+    public void addListener(AnvilGuiListener listener) {
+        this.listener.add(listener);
+    }
+
+    public void removeListener(AnvilGuiListener listener) {
+        this.listener.remove(listener);
+    }
+
+    public void open() {
+        inv = new Inventory(InventoryType.Anvil, "This is an AnvilGuy by WolverinDEV");
+
+        ItemStack item = new ItemStack(backgroundMaterial) {
+            @Override
+            public void click(Click click) {
+                click.setCancelled(true);
+                handleSuccessClick();
+            }
+        };
+        item.getItemMeta().setDisplayName(curruntItemDisplayName = colorPrefix + backgroundString);
+        inv.setItem(0, item);
+
+        inv.setItem(1, new ItemStack(centerItem) {
+            @Override
+            public void click(Click click) {
+                click.setCancelled(true);
+            }
+        });
+
+        inv.setItem(2, new ItemStack(outputItem) {
+            @Override
+            public void click(Click click) {
+                click.setCancelled(true);
+                handleSuccessClick();
+            }
+        });
+
+        owner.openInventory(inv);
+    }
+
+    public void setBackgroundMaterial(Material backgroundMaterial) {
+        this.backgroundMaterial = backgroundMaterial;
+        ItemStack item = new ItemStack(backgroundMaterial) {
+            @Override
+            public void click(Click click) {
+                click.setCancelled(true);
+            }
+        };
+        item.getItemMeta().setDisplayName(colorPrefix + curruntMessage);
+        inv.setItem(0, item);
+    }
+
+    public Item getCenterItem() {
+        return centerItem;
+    }
+
+    public void setCenterItem(Item centerItem) {
+        this.centerItem = centerItem;
+        this.inv.setItem(1, centerItem);
+    }
+
+    public String getBackgroundMessage() {
+        return backgroundString;
+    }
+
+    public void setBackgroundMessage(String backgroundString) {
+        this.backgroundString = backgroundString;
+        if (!noBackground) {
+            ItemStack item = new ItemStack(backgroundMaterial) {
+                @Override
+                public void click(Click click) {
+                    click.setCancelled(true);
+                }
+            };
+            item.getItemMeta().setDisplayName(colorPrefix + backgroundString);
+            inv.setItem(0, item);
+        }
+    }
+
+    public String getCurruntInput() {
+        return curruntMessage;
+    }
+
+    public void setCurruntInput(String curruntName) {
+        this.curruntMessage = curruntName;
+        ItemStack item = new ItemStack(backgroundMaterial) {
+            @Override
+            public void click(Click click) {
+                click.setCancelled(true);
+            }
+        };
+        item.getItemMeta().setDisplayName(colorPrefix + curruntName);
+        inv.setItem(0, item);
+    }
+
+    public void setColorPrefix(String prefix) {
+        if (colorPrefix.equalsIgnoreCase(prefix)) return;
+        String rawMeta = curruntItemDisplayName.substring(Math.min(colorPrefix.length(), curruntItemDisplayName.length())); //Backspace a color prefix code... fix
+        colorPrefix = prefix;
+        ItemStack item = new ItemStack(backgroundMaterial) {
+            @Override
+            public void click(Click click) {
+                click.setCancelled(true);
+            }
+        };
+        item.getItemMeta().setDisplayName(curruntItemDisplayName = colorPrefix + rawMeta);
+        inv.setItem(0, item);
+    }
+
+    protected void handleSuccessClick() {
+        for (AnvilGuiListener listener : new ArrayList<>(AnvilGui.this.listener))
+            if (listener != null)
+                listener.onConfirmInput(AnvilGui.this, this.curruntMessage);
+        if (owner.getInventoryView() != null)
+            if (owner.getInventoryView().equals(this.inv))
+                owner.closeInventory();
+        PacketLib.removeHandler(packet);
+    }
+
+    public void close() {
+        for (AnvilGuiListener listener : new ArrayList<>(AnvilGui.this.listener))
+            if (listener != null)
+                listener.onClose(AnvilGui.this);
+
+        if (owner.getInventoryView() != null)
+            if (owner.getInventoryView().equals(this.inv))
+                owner.closeInventory();
+        PacketLib.removeHandler(packet);
+    }
+
+    public Item getOutputItem() {
+        return outputItem;
+    }
+
+    public void setOutputItem(Item item) {
+        inv.setItem(2, new ItemStack(outputItem = item) {
+            @Override
+            public void click(Click click) {
+                click.setCancelled(true);
+                handleSuccessClick();
+            }
+        });
+    }
+
+    private static class AnvilWindowSizeStringCalculator {
+        private static final int BOX_SIZE = 18;
+        private static HashMap<Character, Double> charLength = new HashMap<>(); //Length = 1 = X
+
+        static {
+            for (int i = 0; i < Character.MAX_VALUE; i++)
+                charLength.put((char) i, 1D);
+            charLength.put('I', 18D / 26D); //26 in
+            charLength.put('i', 18D / 52D); //Todo
+            charLength.put('j', 18D / 28D);
+            charLength.put('l', 18D / 34D);//Todo
+        }
+
+        private String message;
+
+        public AnvilWindowSizeStringCalculator(String message) {
+            this.message = message;
+        }
+
+        public boolean boarderReached() {
+            return reachBoarder(BOX_SIZE);
+        }
+
+        public boolean reachBoarder(int length) {
+            double out = 0;
+            for (char c : message.toCharArray())
+                out += charLength.get(c);
+            return out + 1 > length;
+        }
+
+
+    }
 }
diff --git a/src/main/java/dev/wolveringer/api/gui/AnvilGuiListener.java b/src/main/java/dev/wolveringer/api/gui/AnvilGuiListener.java
index c483fb9..c01158f 100644
--- a/src/main/java/dev/wolveringer/api/gui/AnvilGuiListener.java
+++ b/src/main/java/dev/wolveringer/api/gui/AnvilGuiListener.java
@@ -1,19 +1,15 @@
 package dev.wolveringer.api.gui;
 
 public interface AnvilGuiListener {
-	/**
-	 * 
-	 * @param guy
-	 * @param newMessage
-	 * 
-	 * this event will be triggered when a player changes the displayname
-	 */
-	public void onMessageChange(AnvilGui guy, String newMessage);
-	/**
-	 * @param cuy
-	 * @param message
-	 * This methode will run when a player entered the message
-	 */
-	public void onConfirmInput(AnvilGui guy, String message);
-	public void onClose(AnvilGui guy);
+    /**
+     * @param newMessage this event will be triggered when a player changes the displayname
+     */
+    public void onMessageChange(AnvilGui guy, String newMessage);
+
+    /**
+     * @param message This methode will run when a player entered the message
+     */
+    public void onConfirmInput(AnvilGui guy, String message);
+
+    public void onClose(AnvilGui guy);
 }
diff --git a/src/main/java/dev/wolveringer/api/inventory/Inventory.java b/src/main/java/dev/wolveringer/api/inventory/Inventory.java
index bb57b5b..4a01453 100644
--- a/src/main/java/dev/wolveringer/api/inventory/Inventory.java
+++ b/src/main/java/dev/wolveringer/api/inventory/Inventory.java
@@ -9,293 +9,298 @@ import dev.wolveringer.BungeeUtil.item.Item;
 import dev.wolveringer.BungeeUtil.item.ItemStack;
 import dev.wolveringer.BungeeUtil.item.itemmeta.CraftItemMeta;
 import dev.wolveringer.BungeeUtil.item.itemmeta.MetaListener;
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
 import dev.wolveringer.BungeeUtil.packets.Packet;
 import dev.wolveringer.BungeeUtil.packets.PacketPlayOutOpenWindow;
 import dev.wolveringer.BungeeUtil.packets.PacketPlayOutSetSlot;
 import dev.wolveringer.BungeeUtil.packets.PacketPlayOutWindowItems;
-import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
 
 /**
  * @author WolveinGER
- *
  */
 public class Inventory {
-	public static interface Unsave {
-		public ItemContainer getItemContainer();
-		public List<Player> getModificableViewerList();
-		public MetaListener getItemMetaListener();
-	}
-	public static final int ID = 99;
-
-	protected ItemContainer container;
-	protected String name;
-	protected List<Player> viewer = (List<Player>) Collections.synchronizedList(new ArrayList<Player>());
-	protected InventoryType type;
-	protected boolean autoUpdate = true;
-	protected boolean clickable = true;
-	protected boolean resend_inventory = false;
-	private MetaListener imcil;
-	private Unsave unsave = new Unsave() {
-		@Override
-		public List<Player> getModificableViewerList() {
-			return viewer;
-		}
-		
-		@Override
-		public MetaListener getItemMetaListener() {
-			return imcil;
-		}
-		
-		@Override
-		public ItemContainer getItemContainer() {
-			return container;
-		}
-	};
-	public Unsave unsave() {
-		return unsave;
-	}
-	
-	public Inventory(int size, String name) {
-		this(size, name, true);
-	}
-
-	private Inventory(ItemStack[] items, String name, ArrayList<Player> viewer, InventoryType type) {
-		super();
-		this.container = new ItemContainer(items);
-		this.name = name;
-		this.viewer = viewer;
-		this.type = type;
-		this.imcil = new MetaListener() {
-			@Override
-			public void onUpdate(Item is) {
-				if(autoUpdate){
-					int slot = getSlot(is);
-					if(slot != -1)
-						broadcast(new PacketPlayOutSetSlot(is, ID, slot));
-				}
-			}
-		};
-	}
-
-	public Inventory(int size, String name, boolean check) {
-		if(size % 9 != 0 && check)
-			throw new RuntimeException(size + " % 9 != 0");
-		this.type = InventoryType.Chest;
-		this.name = name;
-		this.container = new ItemContainer(size);
-		this.imcil = new MetaListener() {
-			@Override
-			public void onUpdate(Item is) {
-				if(autoUpdate)
-					updateInventory();
-			}
-		};
-	}
-
-	public Inventory(InventoryType type, String name) {
-		this.name = name;
-		this.type = type;
-		this.container = new ItemContainer(type.getSlots());
-		this.imcil = new MetaListener() {
-			@Override
-			public void onUpdate(Item is) {
-				if(autoUpdate)
-					updateInventory();
-			}
-		};
-	}
-
-	public void addItem(ItemStack is) {
-		Item[] items = container.getContains();
-		for(int i = 0;i < items.length;i++)
-			if(items[i] == null){
-				setItem(i, is);
-				break;
-			}else if(items[i].isSimilar(is)){
-				if(items[i].getAmount() + is.getAmount() > 64){
-					is.setAmount(64 - items[i].getAmount());
-					items[i].setAmount(64);
-					setItem(i, getItemStack(items[i]));
-					addItem(is);
-				}else{
-					items[i].setAmount(items[i].getAmount() + is.getAmount());
-					setItem(i, getItemStack(items[i]));
-					break;
-				}
-			}
-	}
-	
-	/**
-	 * Contains spelling mistake
-	 * @deprecated Use {@link #broadcast(Packet a)} instead.  
-	 */
-	@Deprecated
-	private void brotcast(Packet a) {
-		broadcast(a);
-	}
-	
-	private void broadcast(Packet a) {
-		for(Player p : viewer)
-			p.sendPacket((PacketPlayOut) a);
-	}
-
-	public ItemStack[] getContains() {
-		return container.getContainsAsItemStack();
-	}
-
-	public ItemStack getItem(int slot) {
-		return getItemStack(container.getItem(slot));
-	}
-
-	public boolean hasItem(Item i) {
-		return container.hasItem(i);
-	}
-
-	public String getName() {
-		return name;
-	}
-
-	public void setName(String name) {
-		this.name = name;
-		if(autoUpdate){
-			for(Player p : viewer){
-				PacketPlayOutOpenWindow e = new PacketPlayOutOpenWindow(Inventory.ID, getType().getType(p.getVersion()), getName(), getType() == InventoryType.Chest ? getSlots() : getType().getDefaultSlots(), false);
-				e.UTF_8 = true;
-				p.sendPacket(e);
-			}
-			updateInventory();
-		}else{
-			resend_inventory = true;
-		}
-	}
-
-	public int getSlots() {
-		return container.getSize();
-	}
-	
-	public int getSlot(Item is){
-		return container.getSlot(is);
-	}
-
-	public InventoryType getType() {
-		return type;
-	}
-
-	public synchronized void setItem(int slot, ItemStack is) {
-		if(getItem(slot) != null)
-			if((CraftItemMeta) getItem(slot).getItemMeta() != null)
-				((CraftItemMeta) getItem(slot).getItemMeta()).removeMetaListener(this.imcil);
-		container.setItem(slot, is);
-		if(is != null)
-			((CraftItemMeta) is.getItemMeta()).addMetaListener(this.imcil);
-		if(autoUpdate)
-			broadcast(new PacketPlayOutSetSlot(is, ID, slot));
-	}
-
-	public void setItem(int i, Item item) {
-		setItem(i, getItemStack(item));
-	}
-
-	public List<Player> getViewer() {
-		return Collections.unmodifiableList(viewer);
-	}
-
-	public void clear() {
-		for(Item i : container.getContains())
-			if(i != null)
-			((CraftItemMeta)i.getItemMeta()).removeMetaListener(imcil);
-		container.clear();
-	}
-
-	public void resize(int size) {
-		if(type != InventoryType.Chest)
-			throw new IllegalStateException("Inventorytype isnt a Chest!");
-		container.resize(size);
-		if(autoUpdate){
-			Item[] items = container.getContains();
-			for(Player p : viewer)
-				p.sendPacket(new PacketPlayOutOpenWindow(ID, type.getType(p.getVersion()), name, items.length, false));
-			updateInventory();
-		}else{
-			resend_inventory = true;
-		}
-	}
-
-	public void fill(ItemStack is) {
-		for(int i = 0;i < getSlots();i++){
-			if(getItem(i) == null)
-				setItem(i, is);
-		}
-	}
-
-	public void replace(Item item, ItemStack replace) {
-		for(int i = 0;i < getSlots();i++){
-			if(getItem(i).equals(item))
-				setItem(i, replace);
-		}
-	}
-
-	public void updateInventory() {
-		autoUpdate = true;
-		if(resend_inventory){
-			for(Player p : viewer){
-				PacketPlayOutOpenWindow e = new PacketPlayOutOpenWindow(Inventory.ID, getType().getType(p.getVersion()), getName(), getType() == InventoryType.Chest ? getSlots() : getType().getDefaultSlots(), false);
-				e.UTF_8 = true;
-				p.sendPacket(e);
-			}
-			broadcast(new PacketPlayOutWindowItems(ID, this.container.getContains()));
-		}else{
-			broadcast(new PacketPlayOutWindowItems(ID, this.container.getContains()));
-		}
-	}
-
-	public Inventory clone() {
-		return new Inventory(container.getContainsAsItemStack(), name, new ArrayList<Player>(), type);
-	}
-
-	@Override
-	public String toString() {
-		return "Inventory{name=\""+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"r" + getName() + ""+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"r\" viewer=" + getViewer() + " ObjektID=\"" + super.toString().split("@")[1] + "\"}";
-	}
-
-	public void setContains(ItemStack[] contains) {
-		for(Item i : container.getContains())
-			((CraftItemMeta)i.getItemMeta()).removeMetaListener(imcil);
-		container.setContains(contains);
-		for(ItemStack is : contains)
-			((CraftItemMeta)is.getItemMeta()).addMetaListener(imcil);
-		if(autoUpdate)
-			updateInventory();
-	}
-
-	@Deprecated
-	public void disableUpdate() {
-		autoUpdate = false;
-	}
-
-	@Deprecated
-	public void enableUpdate() {
-		autoUpdate = true;
-		updateInventory();
-	}
-
-	public void setClickable(boolean clickable) {
-		this.clickable = clickable;
-	}
-
-	public boolean isClickable() {
-		return this.clickable;
-	}
-
-	private ItemStack getItemStack(Item is) {
-		if(is == null)
-			return null;
-		else if(is instanceof ItemStack)
-			return (ItemStack) is;
-		else
-			return new ItemStack(is) {
-				public void click(Click click) {
-				};
-			};
-	}
+    public static final int ID = 99;
+    protected ItemContainer container;
+    protected String name;
+    protected List<Player> viewer = (List<Player>) Collections.synchronizedList(new ArrayList<Player>());
+    protected InventoryType type;
+    protected boolean autoUpdate = true;
+    protected boolean clickable = true;
+    protected boolean resend_inventory = false;
+    private MetaListener imcil;
+    private Unsave unsave = new Unsave() {
+        @Override
+        public List<Player> getModificableViewerList() {
+            return viewer;
+        }
+
+        @Override
+        public MetaListener getItemMetaListener() {
+            return imcil;
+        }
+
+        @Override
+        public ItemContainer getItemContainer() {
+            return container;
+        }
+    };
+
+    public Inventory(int size, String name) {
+        this(size, name, true);
+    }
+
+    private Inventory(ItemStack[] items, String name, ArrayList<Player> viewer, InventoryType type) {
+        super();
+        this.container = new ItemContainer(items);
+        this.name = name;
+        this.viewer = viewer;
+        this.type = type;
+        this.imcil = new MetaListener() {
+            @Override
+            public void onUpdate(Item is) {
+                if (autoUpdate) {
+                    int slot = getSlot(is);
+                    if (slot != -1)
+                        broadcast(new PacketPlayOutSetSlot(is, ID, slot));
+                }
+            }
+        };
+    }
+
+    public Inventory(int size, String name, boolean check) {
+        if (size % 9 != 0 && check)
+            throw new RuntimeException(size + " % 9 != 0");
+        this.type = InventoryType.Chest;
+        this.name = name;
+        this.container = new ItemContainer(size);
+        this.imcil = new MetaListener() {
+            @Override
+            public void onUpdate(Item is) {
+                if (autoUpdate)
+                    updateInventory();
+            }
+        };
+    }
+
+    public Inventory(InventoryType type, String name) {
+        this.name = name;
+        this.type = type;
+        this.container = new ItemContainer(type.getSlots());
+        this.imcil = new MetaListener() {
+            @Override
+            public void onUpdate(Item is) {
+                if (autoUpdate)
+                    updateInventory();
+            }
+        };
+    }
+
+    public Unsave unsave() {
+        return unsave;
+    }
+
+    public void addItem(ItemStack is) {
+        Item[] items = container.getContains();
+        for (int i = 0; i < items.length; i++)
+            if (items[i] == null) {
+                setItem(i, is);
+                break;
+            } else if (items[i].isSimilar(is)) {
+                if (items[i].getAmount() + is.getAmount() > 64) {
+                    is.setAmount(64 - items[i].getAmount());
+                    items[i].setAmount(64);
+                    setItem(i, getItemStack(items[i]));
+                    addItem(is);
+                } else {
+                    items[i].setAmount(items[i].getAmount() + is.getAmount());
+                    setItem(i, getItemStack(items[i]));
+                    break;
+                }
+            }
+    }
+
+    /**
+     * Contains spelling mistake
+     *
+     * @deprecated Use {@link #broadcast(Packet a)} instead.
+     */
+    @Deprecated
+    private void brotcast(Packet a) {
+        broadcast(a);
+    }
+
+    private void broadcast(Packet a) {
+        for (Player p : viewer)
+            p.sendPacket((PacketPlayOut) a);
+    }
+
+    public ItemStack[] getContains() {
+        return container.getContainsAsItemStack();
+    }
+
+    public void setContains(ItemStack[] contains) {
+        for (Item i : container.getContains())
+            ((CraftItemMeta) i.getItemMeta()).removeMetaListener(imcil);
+        container.setContains(contains);
+        for (ItemStack is : contains)
+            ((CraftItemMeta) is.getItemMeta()).addMetaListener(imcil);
+        if (autoUpdate)
+            updateInventory();
+    }
+
+    public ItemStack getItem(int slot) {
+        return getItemStack(container.getItem(slot));
+    }
+
+    public boolean hasItem(Item i) {
+        return container.hasItem(i);
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+        if (autoUpdate) {
+            for (Player p : viewer) {
+                PacketPlayOutOpenWindow e = new PacketPlayOutOpenWindow(Inventory.ID, getType().getType(p.getVersion()), getName(), getType() == InventoryType.Chest ? getSlots() : getType().getDefaultSlots(), false);
+                e.UTF_8 = true;
+                p.sendPacket(e);
+            }
+            updateInventory();
+        } else {
+            resend_inventory = true;
+        }
+    }
+
+    public int getSlots() {
+        return container.getSize();
+    }
+
+    public int getSlot(Item is) {
+        return container.getSlot(is);
+    }
+
+    public InventoryType getType() {
+        return type;
+    }
+
+    public synchronized void setItem(int slot, ItemStack is) {
+        if (getItem(slot) != null)
+            if ((CraftItemMeta) getItem(slot).getItemMeta() != null)
+                ((CraftItemMeta) getItem(slot).getItemMeta()).removeMetaListener(this.imcil);
+        container.setItem(slot, is);
+        if (is != null)
+            ((CraftItemMeta) is.getItemMeta()).addMetaListener(this.imcil);
+        if (autoUpdate)
+            broadcast(new PacketPlayOutSetSlot(is, ID, slot));
+    }
+
+    public void setItem(int i, Item item) {
+        setItem(i, getItemStack(item));
+    }
+
+    public List<Player> getViewer() {
+        return Collections.unmodifiableList(viewer);
+    }
+
+    public void clear() {
+        for (Item i : container.getContains())
+            if (i != null)
+                ((CraftItemMeta) i.getItemMeta()).removeMetaListener(imcil);
+        container.clear();
+    }
+
+    public void resize(int size) {
+        if (type != InventoryType.Chest)
+            throw new IllegalStateException("Inventorytype isnt a Chest!");
+        container.resize(size);
+        if (autoUpdate) {
+            Item[] items = container.getContains();
+            for (Player p : viewer)
+                p.sendPacket(new PacketPlayOutOpenWindow(ID, type.getType(p.getVersion()), name, items.length, false));
+            updateInventory();
+        } else {
+            resend_inventory = true;
+        }
+    }
+
+    public void fill(ItemStack is) {
+        for (int i = 0; i < getSlots(); i++) {
+            if (getItem(i) == null)
+                setItem(i, is);
+        }
+    }
+
+    public void replace(Item item, ItemStack replace) {
+        for (int i = 0; i < getSlots(); i++) {
+            if (getItem(i).equals(item))
+                setItem(i, replace);
+        }
+    }
+
+    public void updateInventory() {
+        autoUpdate = true;
+        if (resend_inventory) {
+            for (Player p : viewer) {
+                PacketPlayOutOpenWindow e = new PacketPlayOutOpenWindow(Inventory.ID, getType().getType(p.getVersion()), getName(), getType() == InventoryType.Chest ? getSlots() : getType().getDefaultSlots(), false);
+                e.UTF_8 = true;
+                p.sendPacket(e);
+            }
+            broadcast(new PacketPlayOutWindowItems(ID, this.container.getContains()));
+        } else {
+            broadcast(new PacketPlayOutWindowItems(ID, this.container.getContains()));
+        }
+    }
+
+    public Inventory clone() {
+        return new Inventory(container.getContainsAsItemStack(), name, new ArrayList<Player>(), type);
+    }
+
+    @Override
+    public String toString() {
+        return "Inventory{name=\"" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "r" + getName() + "" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "r\" viewer=" + getViewer() + " ObjektID=\"" + super.toString().split("@")[1] + "\"}";
+    }
+
+    @Deprecated
+    public void disableUpdate() {
+        autoUpdate = false;
+    }
+
+    @Deprecated
+    public void enableUpdate() {
+        autoUpdate = true;
+        updateInventory();
+    }
+
+    public boolean isClickable() {
+        return this.clickable;
+    }
+
+    public void setClickable(boolean clickable) {
+        this.clickable = clickable;
+    }
+
+    private ItemStack getItemStack(Item is) {
+        if (is == null)
+            return null;
+        else if (is instanceof ItemStack)
+            return (ItemStack) is;
+        else
+            return new ItemStack(is) {
+                public void click(Click click) {
+                }
+
+                ;
+            };
+    }
+
+    public static interface Unsave {
+        public ItemContainer getItemContainer();
+
+        public List<Player> getModificableViewerList();
+
+        public MetaListener getItemMetaListener();
+    }
 }
diff --git a/src/main/java/dev/wolveringer/api/inventory/InventoryType.java b/src/main/java/dev/wolveringer/api/inventory/InventoryType.java
index 3492f1f..e10e444 100644
--- a/src/main/java/dev/wolveringer/api/inventory/InventoryType.java
+++ b/src/main/java/dev/wolveringer/api/inventory/InventoryType.java
@@ -4,36 +4,39 @@ import dev.wolveringer.BungeeUtil.ClientVersion;
 import dev.wolveringer.BungeeUtil.ClientVersion.BigClientVersion;
 
 public enum InventoryType {
-	Chest("0","minecraft:chest",36,36),
-	Workbench("1","minecraft:crafting_table",0,9),
-	Furnace("2","minecraft:furnace",3,3),
-	Dispenser("3","minecraft:dispenser",9,9),
-	EnchantmentTable("4","minecraft:enchanting_table",0,2),
-	BrewingStand("5","minecraft:brewing_stand",4,4),
-	Villager("6","minecraft:villager",3,3),
-	Beacon("7","minecraft:beacon",1,1),
-	Anvil("8","minecraft:anvil",0,3),
-	Hopper("9","minecraft:hopper",5,5),
-	Dropper("10","minecraft:dropper",9,9);
-	
-	private String type_v1_7;
-	private String type_v1_8;
-	private int aslots;
-	private int islots;
-	private InventoryType(String a,String b,int s,int i) {
-		this.type_v1_7=a;
-		this.type_v1_8=b;
-		this.aslots=s;
-		this.islots=i;
-	}
-	
-	public String getType(ClientVersion v){
-		return v.getBigVersion() == BigClientVersion.v1_7?type_v1_7:type_v1_8;
-	}
-	public int getDefaultSlots(){
-		return aslots;
-	}
-	public int getSlots(){
-		return islots;
-	}
+    Chest("0", "minecraft:chest", 36, 36),
+    Workbench("1", "minecraft:crafting_table", 0, 9),
+    Furnace("2", "minecraft:furnace", 3, 3),
+    Dispenser("3", "minecraft:dispenser", 9, 9),
+    EnchantmentTable("4", "minecraft:enchanting_table", 0, 2),
+    BrewingStand("5", "minecraft:brewing_stand", 4, 4),
+    Villager("6", "minecraft:villager", 3, 3),
+    Beacon("7", "minecraft:beacon", 1, 1),
+    Anvil("8", "minecraft:anvil", 0, 3),
+    Hopper("9", "minecraft:hopper", 5, 5),
+    Dropper("10", "minecraft:dropper", 9, 9);
+
+    private String type_v1_7;
+    private String type_v1_8;
+    private int aslots;
+    private int islots;
+
+    private InventoryType(String a, String b, int s, int i) {
+        this.type_v1_7 = a;
+        this.type_v1_8 = b;
+        this.aslots = s;
+        this.islots = i;
+    }
+
+    public String getType(ClientVersion v) {
+        return v.getBigVersion() == BigClientVersion.v1_7 ? type_v1_7 : type_v1_8;
+    }
+
+    public int getDefaultSlots() {
+        return aslots;
+    }
+
+    public int getSlots() {
+        return islots;
+    }
 }
diff --git a/src/main/java/dev/wolveringer/api/inventory/ItemContainer.java b/src/main/java/dev/wolveringer/api/inventory/ItemContainer.java
index 28fce2e..d14c8a2 100644
--- a/src/main/java/dev/wolveringer/api/inventory/ItemContainer.java
+++ b/src/main/java/dev/wolveringer/api/inventory/ItemContainer.java
@@ -2,135 +2,137 @@ package dev.wolveringer.api.inventory;
 
 import java.util.Arrays;
 
-import dev.wolveringer.BungeeUtil.Material;
 import dev.wolveringer.BungeeUtil.item.Item;
 import dev.wolveringer.BungeeUtil.item.ItemStack;
 
 public class ItemContainer {
-	private static Item[] convert(ItemStack... items) {
-		Item[] out = new Item[items.length];
-		for(int i = 0;i < items.length;i++){
-			out[i] = items[i];
-		}
-		return out;
-	}
-
-	private static ItemStack[] convert(Item... items) {
-		ItemStack[] out = new ItemStack[items.length];
-		for(int i = 0;i < items.length;i++){
-			out[i] = convert(items[i]);
-		}
-		return out;
-	}
-
-	private static ItemStack convert(Item is) {
-		if(is == null)
-			return null;
-		else if(is instanceof ItemStack)
-			return (ItemStack) is;
-		else
-			return new ItemStack(is) {
-				public void click(Click click) {
-				};
-			};
-	}
-
-	private Item[] items;
-
-	public ItemContainer(ItemStack[] items) {
-		this.items = convert(items);
-	}
-
-	public ItemContainer(int size) {
-		this.items = new Item[size];
-	}
-
-	public void addItem(Item is) {
-		for(int i = 0;i < items.length;i++)
-			if(items[i] == null){
-				setItem(i, is);
-				break;
-			}else if(items[i].isSimilar(is)){
-				if(items[i].getAmount() + is.getAmount() > 64){
-					is.setAmount(64 - items[i].getAmount());
-					items[i].setAmount(64);
-					setItem(i, items[i]);
-					addItem(is);
-				}else{
-					items[i].setAmount(items[i].getAmount() + is.getAmount());
-					setItem(i, items[i]);
-					break;
-				}
-			}
-	}
-
-	public Item[] getContains() {
-		return items;
-	}
-
-	public ItemStack[] getContainsAsItemStack() {
-		return convert(items);
-	}
-	
-	public Item getItem(int slot) {
-		return items[slot];
-	}
-
-	public boolean hasItem(Item i) {
-		for(Item is : items)
-			if(is != null)
-				if(is.equals(i))
-					return true;
-		return false;
-	}
-
-	public int getSize() {
-		return items.length;
-	}
-
-	public void setItem(int slot, Item is) {
-		if(is == null || is.getTypeId() == 0)
-			items[slot] = null;
-		else
-			items[slot] = is;
-	}
-
-	public void clear() {
-		items = new Item[items.length];
-	}
-
-	public void resize(int size) {
-		items = Arrays.copyOf(items, size);
-	}
-
-	public void fill(Item is) {
-		for(int i = 0;i < getSize();i++){
-			if(getItem(i) == null)
-				setItem(i, is);
-		}
-	}
-
-	public void replace(Item item, Item replace) {
-		for(int i = 0;i < getSize();i++){
-			if(getItem(i).equals(item))
-				setItem(i, replace);
-		}
-	}
-
-	public void setContains(Item[] contains) {
-		this.items = contains;
-	}
-	public void setContains(ItemStack[] contains) {
-		this.items = contains;
-	}
-
-	public int getSlot(Item is) {
-		for(int i = 0;i < items.length;i++){
-			if(items[i] == null && is == null)
-				return i;
-			else if(items[i] != null && items[i].equals(is))
-				return i;
-		}
-		return -1;
-	}
+    private Item[] items;
+
+    public ItemContainer(ItemStack[] items) {
+        this.items = convert(items);
+    }
+
+    public ItemContainer(int size) {
+        this.items = new Item[size];
+    }
+
+    private static Item[] convert(ItemStack... items) {
+        Item[] out = new Item[items.length];
+        for (int i = 0; i < items.length; i++) {
+            out[i] = items[i];
+        }
+        return out;
+    }
+
+    private static ItemStack[] convert(Item... items) {
+        ItemStack[] out = new ItemStack[items.length];
+        for (int i = 0; i < items.length; i++) {
+            out[i] = convert(items[i]);
+        }
+        return out;
+    }
+
+    private static ItemStack convert(Item is) {
+        if (is == null)
+            return null;
+        else if (is instanceof ItemStack)
+            return (ItemStack) is;
+        else
+            return new ItemStack(is) {
+                public void click(Click click) {
+                }
+
+                ;
+            };
+    }
+
+    public void addItem(Item is) {
+        for (int i = 0; i < items.length; i++)
+            if (items[i] == null) {
+                setItem(i, is);
+                break;
+            } else if (items[i].isSimilar(is)) {
+                if (items[i].getAmount() + is.getAmount() > 64) {
+                    is.setAmount(64 - items[i].getAmount());
+                    items[i].setAmount(64);
+                    setItem(i, items[i]);
+                    addItem(is);
+                } else {
+                    items[i].setAmount(items[i].getAmount() + is.getAmount());
+                    setItem(i, items[i]);
+                    break;
+                }
+            }
+    }
+
+    public Item[] getContains() {
+        return items;
+    }
+
+    public void setContains(Item[] contains) {
+        this.items = contains;
+    }
+
+    public void setContains(ItemStack[] contains) {
+        this.items = contains;
+    }
+
+    public ItemStack[] getContainsAsItemStack() {
+        return convert(items);
+    }
+
+    public Item getItem(int slot) {
+        return items[slot];
+    }
+
+    public boolean hasItem(Item i) {
+        for (Item is : items)
+            if (is != null)
+                if (is.equals(i))
+                    return true;
+        return false;
+    }
+
+    public int getSize() {
+        return items.length;
+    }
+
+    public void setItem(int slot, Item is) {
+        if (is == null || is.getTypeId() == 0)
+            items[slot] = null;
+        else
+            items[slot] = is;
+    }
+
+    public void clear() {
+        items = new Item[items.length];
+    }
+
+    public void resize(int size) {
+        items = Arrays.copyOf(items, size);
+    }
+
+    public void fill(Item is) {
+        for (int i = 0; i < getSize(); i++) {
+            if (getItem(i) == null)
+                setItem(i, is);
+        }
+    }
+
+    public void replace(Item item, Item replace) {
+        for (int i = 0; i < getSize(); i++) {
+            if (getItem(i).equals(item))
+                setItem(i, replace);
+        }
+    }
+
+    public int getSlot(Item is) {
+        for (int i = 0; i < items.length; i++) {
+            if (items[i] == null && is == null)
+                return i;
+            else if (items[i] != null && items[i].equals(is))
+                return i;
+        }
+        return -1;
+    }
 }
diff --git a/src/main/java/dev/wolveringer/api/inventory/PlayerInventory.java b/src/main/java/dev/wolveringer/api/inventory/PlayerInventory.java
index 77ab5e3..f3ab52f 100644
--- a/src/main/java/dev/wolveringer/api/inventory/PlayerInventory.java
+++ b/src/main/java/dev/wolveringer/api/inventory/PlayerInventory.java
@@ -3,117 +3,121 @@ package dev.wolveringer.api.inventory;
 import java.util.ArrayList;
 
 import dev.wolveringer.BungeeUtil.ClientVersion.BigClientVersion;
-import dev.wolveringer.BungeeUtil.Material;
 import dev.wolveringer.BungeeUtil.Player;
 import dev.wolveringer.BungeeUtil.item.Item;
 import dev.wolveringer.BungeeUtil.item.ItemStack;
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
 import dev.wolveringer.BungeeUtil.packets.Packet;
 import dev.wolveringer.BungeeUtil.packets.PacketPlayOutSetSlot;
-import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
 
 public final class PlayerInventory {
-	@SuppressWarnings("serial")
-	private ArrayList<Item> items = new ArrayList<Item>() {
-		public Item get(int index) {
-			while (super.size() <= index){
-				super.add(null);
-			}
-			return super.get(index);
-		};
-
-		public Item set(int index, Item element) {
-			while (super.size() <= index){
-				super.add(null);
-			}
-			return super.set(index, element);
-		};
-	};
-	private String name;
-	private ArrayList<Player> viewer = new ArrayList<Player>();
-	private int ID;
-	private Player player;
-	public PlayerInventory(Player player,int ID, String name) {
-		this.name = name;
-		this.ID = ID;
-		this.player = player;
-		getItem(45);
-	}
-
-	public PlayerInventory(Player player) {
-		this(player,0,"");
-	}
-
-	/**
-	 * Contains spelling mistake
-	 * @deprecated Use {@link #broadcast(Packet a)} instead.  
-	 */
-	@Deprecated
-	private void brotcast(Packet a) {
-		broadcast(a);
-	}
-
-	private void broadcast(Packet a) {
-		player.sendPacket((PacketPlayOut)a);
-	}
-
-	public Item[] getContains() {
-		return items.toArray(new Item[Math.min(items.size(), player.getVersion().getBigVersion() == BigClientVersion.v1_9 ? 46 : 45)]); //46/45=Max slots
-	}
-
-	public Item getItem(int slot) {
-		return items.get(slot);
-	}
-
-	public String getName() {
-		return name;
-	}
-
-	public int getSlots() {
-		return items.size();
-	}
-
-	public int getType() {
-		return 0;
-	}
-
-	public void setItem(int slot, Item is) {
-		items.set(slot, is);
-		if(player.isInventoryOpened()){
-			if(slot > 8){
-				broadcast(new PacketPlayOutSetSlot(is, Inventory.ID, slot-9+player.getInventoryView().getSlots()));
-			}
-		}
-		else
-			broadcast(new PacketPlayOutSetSlot(is, ID, slot));
-	}
-
-	public ArrayList<Player> getViewer() {
-		return viewer;
-	}
-
-	public void reset() {
-		items.clear();
-	}
-	
-	public int getFirstSlot(ItemStack is) {
-		for(int i = 0;i < items.size();i++)
-			if(items.get(i) == null){
-				return i;
-			}else if(items.get(i).isSimilar(is)){
-				if(is.getAmount() != 64)
-					return i;
-			}
-		return -1;
-	}
-	
-	@Override
-	protected void finalize() throws Throwable {
-		reset();
-	}
-
-	public void clear() {
-		int s = getSlots();
-		items.clear();
-		items.get(s);
-	}
+    @SuppressWarnings("serial")
+    private ArrayList<Item> items = new ArrayList<Item>() {
+        public Item get(int index) {
+            while (super.size() <= index) {
+                super.add(null);
+            }
+            return super.get(index);
+        }
+
+        ;
+
+        public Item set(int index, Item element) {
+            while (super.size() <= index) {
+                super.add(null);
+            }
+            return super.set(index, element);
+        }
+
+        ;
+    };
+    private String name;
+    private ArrayList<Player> viewer = new ArrayList<Player>();
+    private int ID;
+    private Player player;
+
+    public PlayerInventory(Player player, int ID, String name) {
+        this.name = name;
+        this.ID = ID;
+        this.player = player;
+        getItem(45);
+    }
+
+    public PlayerInventory(Player player) {
+        this(player, 0, "");
+    }
+
+    /**
+     * Contains spelling mistake
+     *
+     * @deprecated Use {@link #broadcast(Packet a)} instead.
+     */
+    @Deprecated
+    private void brotcast(Packet a) {
+        broadcast(a);
+    }
+
+    private void broadcast(Packet a) {
+        player.sendPacket((PacketPlayOut) a);
+    }
+
+    public Item[] getContains() {
+        return items.toArray(new Item[Math.min(items.size(), player.getVersion().getBigVersion() == BigClientVersion.v1_9 ? 46 : 45)]); //46/45=Max slots
+    }
+
+    public Item getItem(int slot) {
+        return items.get(slot);
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public int getSlots() {
+        return items.size();
+    }
+
+    public int getType() {
+        return 0;
+    }
+
+    public void setItem(int slot, Item is) {
+        items.set(slot, is);
+        if (player.isInventoryOpened()) {
+            if (slot > 8) {
+                broadcast(new PacketPlayOutSetSlot(is, Inventory.ID, slot - 9 + player.getInventoryView().getSlots()));
+            }
+        } else
+            broadcast(new PacketPlayOutSetSlot(is, ID, slot));
+    }
+
+    public ArrayList<Player> getViewer() {
+        return viewer;
+    }
+
+    public void reset() {
+        items.clear();
+    }
+
+    public int getFirstSlot(ItemStack is) {
+        for (int i = 0; i < items.size(); i++)
+            if (items.get(i) == null) {
+                return i;
+            } else if (items.get(i).isSimilar(is)) {
+                if (is.getAmount() != 64)
+                    return i;
+            }
+        return -1;
+    }
+
+    @Override
+    protected void finalize() throws Throwable {
+        reset();
+    }
+
+    public void clear() {
+        int s = getSlots();
+        items.clear();
+        items.get(s);
+    }
 }
diff --git a/src/main/java/dev/wolveringer/api/inventory/ScrolingInventory.java b/src/main/java/dev/wolveringer/api/inventory/ScrolingInventory.java
index 89a1cbb..ad79ff5 100644
--- a/src/main/java/dev/wolveringer/api/inventory/ScrolingInventory.java
+++ b/src/main/java/dev/wolveringer/api/inventory/ScrolingInventory.java
@@ -11,174 +11,176 @@ import dev.wolveringer.chat.ChatColor.ChatColorUtils;
 
 public class ScrolingInventory extends Inventory {
 
-	public ScrolingInventory(int rows, String name) {
-		super(rows * 9 + 18, name);
-		this.rows = rows;
-		nextitem.getItemMeta().setDisplayName(ChatColorUtils.COLOR_CHAR+"7next Side "+ChatColorUtils.COLOR_CHAR+"b-->");
-		backitem.getItemMeta().setDisplayName(ChatColorUtils.COLOR_CHAR+"b<-- "+ChatColorUtils.COLOR_CHAR+"7previous Side");
-		lineitem.getItemMeta().setDisplayName(ChatColorUtils.COLOR_CHAR+"a");
-		lineitem.getItemMeta().setGlow(true);
-		nothinkitem.getItemMeta().setDisplayName(ChatColorUtils.COLOR_CHAR+"cKein Item verf"+ChatColorUtils.COLOR_CHAR+"gbar");
-		update();
-	}
-
-	private List<ItemStack> items =Collections.synchronizedList(new ArrayList<ItemStack>());
-	private ItemStack[] toolitem = new ItemStack[7];
-	private int side = 0;
-	private int rows = -1;
-	private boolean autoUpdate = true;
-	private ItemStack fill;
-	private ItemStack nextitem = new ItemStack(Material.STICK) {
-		@Override
-		public void click(Click p) {
-			if(!getItemMeta().hasGlow())
-				nextSide();
-		}
-	};
-	private ItemStack backitem = new ItemStack(Material.STICK) {
-		@Override
-		public void click(Click p) {
-			if(!getItemMeta().hasGlow())
-				backSide();
-		}
-	};
-	@SuppressWarnings("deprecation")
-	private ItemStack lineitem = new ItemStack(Material.getMaterial(160), 1, (short) 15) {
-		public void click(Click p) {
-		}
-	};
-	private ItemStack nothinkitem = new ItemStack(Material.FENCE) {
-		public void click(Click p) {
-		};
-	};
-
-	public void setItem(int slot, ItemStack is) {
-		throw new RuntimeException("This Inventory is not static!");
-	}
-
-	@Override
-	public void addItem(ItemStack is) {
-		items.add(is);
-		if(autoUpdate)
-			update();
-	}
-
-	public void removeItem(ItemStack is) {
-		items.remove(is);
-		if(autoUpdate)
-			update();
-	}
-
-	public void setNextItem(Item i) {
-		nextitem = new ItemStack(i) {
-			@Override
-			public void click(Click p) {
-				nextSide();
-			}
-		};
-	}
-
-	public void setBackItem(Item i) {
-		backitem = new ItemStack(i) {
-			@Override
-			public void click(Click p) {
-				backSide();
-			}
-		};
-		update();
-	}
-
-	public void setLineItem(Item i) {
-		lineitem = new ItemStack(i) {
-			@Override
-			public void click(Click p) {
-			}
-		};
-		update();
-	}
-
-	public void setNothinkitem(Item nothinkitem) {
-		this.nothinkitem = new ItemStack(nothinkitem) {
-			@Override
-			public void click(Click c) {}
-		};
-		update();
-	}
-
-	/**
-	 * @param slot
-	 *            <=7
-	 * @param is
-	 */
-	public void setToolItem(int slot, ItemStack is) {
-		if(slot > 7)
-			throw new RuntimeException("Slot is to big!");
-		toolitem[slot] = is;
-		if(autoUpdate)
-			update();
-	}
-
-	public void nextSide() {
-		side++;
-		update();
-	}
-
-	public void backSide() {
-		side--;
-		update();
-	}
-
-	@Override
-	public void clear() {
-		items.clear();
-		if(autoUpdate)
-			update();
-	}
-
-	private void update() {
-		super.disableUpdate();
-		super.clear();
-		List<ItemStack> i = (side * (rows * 9) < items.size() ? items.subList(side * (rows * 9), (side + 1) * (rows * 9) < items.size() ? (side + 1) * (rows * 9) : items.size()) : new ArrayList<ItemStack>());
-		for(int x = 0;x < i.size();x++)
-			super.setItem(x, i.get(x));
-		if(i.size() == 0)
-			super.setItem(((rows / 2) * 9) + 4, nothinkitem);
-		for(int x = 0;x < 9;x++){
-			super.setItem((rows * 9) + x, lineitem);
-		}
-		nextitem.getItemMeta().setGlow((side + 1) * (rows * 9) >= items.size());
-		super.setItem(getSlots() - 1, nextitem);
-		backitem.getItemMeta().setGlow(side == 0);
-		super.setItem(getSlots() - 9, backitem);
-		for(int x = 0;x < 7;x++)
-			super.setItem(getSlots() - 8 + x, toolitem[x]);
-		fill(fill);
-		autoUpdate = true;
-		super.updateInventory();
-	}
-
-	@Override
-	public void disableUpdate() {
-		autoUpdate = false;
-	}
-
-	@Override
-	public void enableUpdate() {
-		autoUpdate = true;
-		update();
-	}
-
-	@Override
-	public void updateInventory() {
-		this.update();
-	}
-	@Override
-	public void fill(ItemStack is) {
-		fill = is;
-		if(fill != null)
-		for(int i = 0;i<getSlots();i++){
-			if(super.getItem(i) == null)
-				super.setItem(i, is);
-		}
-	}
+    private List<ItemStack> items = Collections.synchronizedList(new ArrayList<ItemStack>());
+    private ItemStack[] toolitem = new ItemStack[7];
+    private int side = 0;
+    private int rows = -1;
+    private boolean autoUpdate = true;
+    private ItemStack fill;
+    @SuppressWarnings("deprecation")
+    private ItemStack lineitem = new ItemStack(Material.getMaterial(160), 1, (short) 15) {
+        public void click(Click p) {
+        }
+    };
+    private ItemStack nothinkitem = new ItemStack(Material.FENCE) {
+        public void click(Click p) {
+        }
+
+        ;
+    };
+    private ItemStack nextitem = new ItemStack(Material.STICK) {
+        @Override
+        public void click(Click p) {
+            if (!getItemMeta().hasGlow())
+                nextSide();
+        }
+    };
+    private ItemStack backitem = new ItemStack(Material.STICK) {
+        @Override
+        public void click(Click p) {
+            if (!getItemMeta().hasGlow())
+                backSide();
+        }
+    };
+
+    public ScrolingInventory(int rows, String name) {
+        super(rows * 9 + 18, name);
+        this.rows = rows;
+        nextitem.getItemMeta().setDisplayName(ChatColorUtils.COLOR_CHAR + "7next Side " + ChatColorUtils.COLOR_CHAR + "b-->");
+        backitem.getItemMeta().setDisplayName(ChatColorUtils.COLOR_CHAR + "b<-- " + ChatColorUtils.COLOR_CHAR + "7previous Side");
+        lineitem.getItemMeta().setDisplayName(ChatColorUtils.COLOR_CHAR + "a");
+        lineitem.getItemMeta().setGlow(true);
+        nothinkitem.getItemMeta().setDisplayName(ChatColorUtils.COLOR_CHAR + "cKein Item verf" + ChatColorUtils.COLOR_CHAR + "gbar");
+        update();
+    }
+
+    public void setItem(int slot, ItemStack is) {
+        throw new RuntimeException("This Inventory is not static!");
+    }
+
+    @Override
+    public void addItem(ItemStack is) {
+        items.add(is);
+        if (autoUpdate)
+            update();
+    }
+
+    public void removeItem(ItemStack is) {
+        items.remove(is);
+        if (autoUpdate)
+            update();
+    }
+
+    public void setNextItem(Item i) {
+        nextitem = new ItemStack(i) {
+            @Override
+            public void click(Click p) {
+                nextSide();
+            }
+        };
+    }
+
+    public void setBackItem(Item i) {
+        backitem = new ItemStack(i) {
+            @Override
+            public void click(Click p) {
+                backSide();
+            }
+        };
+        update();
+    }
+
+    public void setLineItem(Item i) {
+        lineitem = new ItemStack(i) {
+            @Override
+            public void click(Click p) {
+            }
+        };
+        update();
+    }
+
+    public void setNothinkitem(Item nothinkitem) {
+        this.nothinkitem = new ItemStack(nothinkitem) {
+            @Override
+            public void click(Click c) {
+            }
+        };
+        update();
+    }
+
+    /**
+     * @param slot <=7
+     */
+    public void setToolItem(int slot, ItemStack is) {
+        if (slot > 7)
+            throw new RuntimeException("Slot is to big!");
+        toolitem[slot] = is;
+        if (autoUpdate)
+            update();
+    }
+
+    public void nextSide() {
+        side++;
+        update();
+    }
+
+    public void backSide() {
+        side--;
+        update();
+    }
+
+    @Override
+    public void clear() {
+        items.clear();
+        if (autoUpdate)
+            update();
+    }
+
+    private void update() {
+        super.disableUpdate();
+        super.clear();
+        List<ItemStack> i = (side * (rows * 9) < items.size() ? items.subList(side * (rows * 9), (side + 1) * (rows * 9) < items.size() ? (side + 1) * (rows * 9) : items.size()) : new ArrayList<ItemStack>());
+        for (int x = 0; x < i.size(); x++)
+            super.setItem(x, i.get(x));
+        if (i.size() == 0)
+            super.setItem(((rows / 2) * 9) + 4, nothinkitem);
+        for (int x = 0; x < 9; x++) {
+            super.setItem((rows * 9) + x, lineitem);
+        }
+        nextitem.getItemMeta().setGlow((side + 1) * (rows * 9) >= items.size());
+        super.setItem(getSlots() - 1, nextitem);
+        backitem.getItemMeta().setGlow(side == 0);
+        super.setItem(getSlots() - 9, backitem);
+        for (int x = 0; x < 7; x++)
+            super.setItem(getSlots() - 8 + x, toolitem[x]);
+        fill(fill);
+        autoUpdate = true;
+        super.updateInventory();
+    }
+
+    @Override
+    public void disableUpdate() {
+        autoUpdate = false;
+    }
+
+    @Override
+    public void enableUpdate() {
+        autoUpdate = true;
+        update();
+    }
+
+    @Override
+    public void updateInventory() {
+        this.update();
+    }
+
+    @Override
+    public void fill(ItemStack is) {
+        fill = is;
+        if (fill != null)
+            for (int i = 0; i < getSlots(); i++) {
+                if (super.getItem(i) == null)
+                    super.setItem(i, is);
+            }
+    }
 }
diff --git a/src/main/java/dev/wolveringer/api/particel/ParticleEffect.java b/src/main/java/dev/wolveringer/api/particel/ParticleEffect.java
index 305ac22..9fbc5d1 100644
--- a/src/main/java/dev/wolveringer/api/particel/ParticleEffect.java
+++ b/src/main/java/dev/wolveringer/api/particel/ParticleEffect.java
@@ -1,6 +1,6 @@
 package dev.wolveringer.api.particel;
 
-import java.awt.Color;
+import java.awt.*;
 import java.util.Arrays;
 import java.util.HashMap;
 import java.util.List;
@@ -10,1202 +10,1208 @@ import java.util.Map.Entry;
 import dev.wolveringer.BungeeUtil.Material;
 import dev.wolveringer.BungeeUtil.Player;
 import dev.wolveringer.BungeeUtil.packets.PacketPlayOutWorldParticles;
-import dev.wolveringer.api.particel.ParticleEffect.ParticleData;
 import dev.wolveringer.api.position.Location;
 import dev.wolveringer.api.position.Vector;
+
 /**
- * <b>ParticleEffect Library</b>
- * <p>
- * This library was created by @DarkBlade12 and allows you to display all Minecraft particle effects on a Bukkit server
- * <p>
- * You are welcome to use it, modify it and redistribute it under the following conditions:
- * <ul>
- * <li>Don't claim this class as your own
- * <li>Don't remove this disclaimer
- * </ul>
- * <p>
- * Special thanks:
- * <ul>
- * <li>@microgeek (original idea, names and packet parameters)
- * <li>@ShadyPotato (1.8 names, ids and packet parameters)
- * <li>@RingOfStorms (particle behavior)
- * <li>@Cybermaxke (particle behavior)
- * </ul>
- * <p>
- * <i>It would be nice if you provide credit to me if you use this class in a published project</i>
- * 
+ * <b>ParticleEffect Library</b> <p> This library was created by @DarkBlade12 and allows you to
+ * display all Minecraft particle effects on a Bukkit server <p> You are welcome to use it, modify
+ * it and redistribute it under the following conditions: <ul> <li>Don't claim this class as your
+ * own <li>Don't remove this disclaimer </ul> <p> Special thanks: <ul> <li>@microgeek (original
+ * idea, names and packet parameters) <li>@ShadyPotato (1.8 names, ids and packet parameters)
+ * <li>@RingOfStorms (particle behavior) <li>@Cybermaxke (particle behavior) </ul> <p> <i>It would
+ * be nice if you provide credit to me if you use this class in a published project</i>
+ *
  * @author DarkBlade12
  * @version 1.7
  */
 public enum ParticleEffect {
-	/**
-	 * A particle effect which is displayed by exploding tnt and creepers:
-	 * <ul>
-	 * <li>It looks like a white cloud
-	 * <li>The speed value influences the velocity at which the particle flies off
-	 * </ul>
-	 */
-	EXPLOSION_NORMAL("explode", 0, -1, ParticleProperty.DIRECTIONAL),
-	/**
-	 * A particle effect which is displayed by exploding ghast fireballs and wither skulls:
-	 * <ul>
-	 * <li>It looks like a gray ball which is fading away
-	 * <li>The speed value slightly influences the size of this particle effect
-	 * </ul>
-	 */
-	EXPLOSION_LARGE("largeexplode", 1, -1),
-	/**
-	 * A particle effect which is displayed by exploding tnt and creepers:
-	 * <ul>
-	 * <li>It looks like a crowd of gray balls which are fading away
-	 * <li>The speed value has no influence on this particle effect
-	 * </ul>
-	 */
-	EXPLOSION_HUGE("hugeexplosion", 2, -1),
-	/**
-	 * A particle effect which is displayed by launching fireworks:
-	 * <ul>
-	 * <li>It looks like a white star which is sparkling
-	 * <li>The speed value influences the velocity at which the particle flies off
-	 * </ul>
-	 */
-	FIREWORKS_SPARK("fireworksSpark", 3, -1, ParticleProperty.DIRECTIONAL),
-	/**
-	 * A particle effect which is displayed by swimming entities and arrows in water:
-	 * <ul>
-	 * <li>It looks like a bubble
-	 * <li>The speed value influences the velocity at which the particle flies off
-	 * </ul>
-	 */
-	WATER_BUBBLE("bubble", 4, -1, ParticleProperty.DIRECTIONAL, ParticleProperty.REQUIRES_WATER),
-	/**
-	 * A particle effect which is displayed by swimming entities and shaking wolves:
-	 * <ul>
-	 * <li>It looks like a blue drop
-	 * <li>The speed value has no influence on this particle effect
-	 * </ul>
-	 */
-	WATER_SPLASH("splash", 5, -1, ParticleProperty.DIRECTIONAL),
-	/**
-	 * A particle effect which is displayed on water when fishing:
-	 * <ul>
-	 * <li>It looks like a blue droplet
-	 * <li>The speed value influences the velocity at which the particle flies off
-	 * </ul>
-	 */
-	WATER_WAKE("wake", 6, 7, ParticleProperty.DIRECTIONAL),
-	/**
-	 * A particle effect which is displayed by water:
-	 * <ul>
-	 * <li>It looks like a tiny blue square
-	 * <li>The speed value has no influence on this particle effect
-	 * </ul>
-	 */
-	SUSPENDED("suspended", 7, -1, ParticleProperty.REQUIRES_WATER),
-	/**
-	 * A particle effect which is displayed by air when close to bedrock and the in the void:
-	 * <ul>
-	 * <li>It looks like a tiny gray square
-	 * <li>The speed value has no influence on this particle effect
-	 * </ul>
-	 */
-	SUSPENDED_DEPTH("depthSuspend", 8, -1, ParticleProperty.DIRECTIONAL),
-	/**
-	 * A particle effect which is displayed when landing a critical hit and by arrows:
-	 * <ul>
-	 * <li>It looks like a light brown cross
-	 * <li>The speed value influences the velocity at which the particle flies off
-	 * </ul>
-	 */
-	CRIT("crit", 9, -1, ParticleProperty.DIRECTIONAL),
-	/**
-	 * A particle effect which is displayed when landing a hit with an enchanted weapon:
-	 * <ul>
-	 * <li>It looks like a cyan star
-	 * <li>The speed value influences the velocity at which the particle flies off
-	 * </ul>
-	 */
-	CRIT_MAGIC("magicCrit", 10, -1, ParticleProperty.DIRECTIONAL),
-	/**
-	 * A particle effect which is displayed by primed tnt, torches, droppers, dispensers, end portals, brewing stands and monster spawners:
-	 * <ul>
-	 * <li>It looks like a little gray cloud
-	 * <li>The speed value influences the velocity at which the particle flies off
-	 * </ul>
-	 */
-	SMOKE_NORMAL("smoke", 11, -1, ParticleProperty.DIRECTIONAL),
-	/**
-	 * A particle effect which is displayed by fire, minecarts with furnace and blazes:
-	 * <ul>
-	 * <li>It looks like a large gray cloud
-	 * <li>The speed value influences the velocity at which the particle flies off
-	 * </ul>
-	 */
-	SMOKE_LARGE("largesmoke", 12, -1, ParticleProperty.DIRECTIONAL),
-	/**
-	 * A particle effect which is displayed when splash potions or bottles o' enchanting hit something:
-	 * <ul>
-	 * <li>It looks like a white swirl
-	 * <li>The speed value causes the particle to only move upwards when set to 0
-	 * <li>Only the motion on the y-axis can be controlled, the motion on the x- and z-axis are multiplied by 0.1 when setting the values to 0
-	 * </ul>
-	 */
-	SPELL("spell", 13, -1),
-	/**
-	 * A particle effect which is displayed when instant splash potions hit something:
-	 * <ul>
-	 * <li>It looks like a white cross
-	 * <li>The speed value causes the particle to only move upwards when set to 0
-	 * <li>Only the motion on the y-axis can be controlled, the motion on the x- and z-axis are multiplied by 0.1 when setting the values to 0
-	 * </ul>
-	 */
-	SPELL_INSTANT("instantSpell", 14, -1),
-	/**
-	 * A particle effect which is displayed by entities with active potion effects:
-	 * <ul>
-	 * <li>It looks like a colored swirl
-	 * <li>The speed value causes the particle to be colored black when set to 0
-	 * <li>The particle color gets lighter when increasing the speed and darker when decreasing the speed
-	 * </ul>
-	 */
-	SPELL_MOB("mobSpell", 15, -1, ParticleProperty.COLORABLE),
-	/**
-	 * A particle effect which is displayed by entities with active potion effects applied through a beacon:
-	 * <ul>
-	 * <li>It looks like a transparent colored swirl
-	 * <li>The speed value causes the particle to be always colored black when set to 0
-	 * <li>The particle color gets lighter when increasing the speed and darker when decreasing the speed
-	 * </ul>
-	 */
-	SPELL_MOB_AMBIENT("mobSpellAmbient", 16, -1, ParticleProperty.COLORABLE),
-	/**
-	 * A particle effect which is displayed by witches:
-	 * <ul>
-	 * <li>It looks like a purple cross
-	 * <li>The speed value causes the particle to only move upwards when set to 0
-	 * <li>Only the motion on the y-axis can be controlled, the motion on the x- and z-axis are multiplied by 0.1 when setting the values to 0
-	 * </ul>
-	 */
-	SPELL_WITCH("witchMagic", 17, -1),
-	/**
-	 * A particle effect which is displayed by blocks beneath a water source:
-	 * <ul>
-	 * <li>It looks like a blue drip
-	 * <li>The speed value has no influence on this particle effect
-	 * </ul>
-	 */
-	DRIP_WATER("dripWater", 18, -1),
-	/**
-	 * A particle effect which is displayed by blocks beneath a lava source:
-	 * <ul>
-	 * <li>It looks like an orange drip
-	 * <li>The speed value has no influence on this particle effect
-	 * </ul>
-	 */
-	DRIP_LAVA("dripLava", 19, -1),
-	/**
-	 * A particle effect which is displayed when attacking a villager in a village:
-	 * <ul>
-	 * <li>It looks like a cracked gray heart
-	 * <li>The speed value has no influence on this particle effect
-	 * </ul>
-	 */
-	VILLAGER_ANGRY("angryVillager", 20, -1),
-	/**
-	 * A particle effect which is displayed when using bone meal and trading with a villager in a village:
-	 * <ul>
-	 * <li>It looks like a green star
-	 * <li>The speed value has no influence on this particle effect
-	 * </ul>
-	 */
-	VILLAGER_HAPPY("happyVillager", 21, -1, ParticleProperty.DIRECTIONAL),
-	/**
-	 * A particle effect which is displayed by mycelium:
-	 * <ul>
-	 * <li>It looks like a tiny gray square
-	 * <li>The speed value has no influence on this particle effect
-	 * </ul>
-	 */
-	TOWN_AURA("townaura", 22, -1, ParticleProperty.DIRECTIONAL),
-	/**
-	 * A particle effect which is displayed by note blocks:
-	 * <ul>
-	 * <li>It looks like a colored note
-	 * <li>The speed value causes the particle to be colored green when set to 0
-	 * </ul>
-	 */
-	NOTE("note", 23, -1, ParticleProperty.COLORABLE),
-	/**
-	 * A particle effect which is displayed by nether portals, endermen, ender pearls, eyes of ender, ender chests and dragon eggs:
-	 * <ul>
-	 * <li>It looks like a purple cloud
-	 * <li>The speed value influences the spread of this particle effect
-	 * </ul>
-	 */
-	PORTAL("portal", 24, -1, ParticleProperty.DIRECTIONAL),
-	/**
-	 * A particle effect which is displayed by enchantment tables which are nearby bookshelves:
-	 * <ul>
-	 * <li>It looks like a cryptic white letter
-	 * <li>The speed value influences the spread of this particle effect
-	 * </ul>
-	 */
-	ENCHANTMENT_TABLE("enchantmenttable", 25, -1, ParticleProperty.DIRECTIONAL),
-	/**
-	 * A particle effect which is displayed by torches, active furnaces, magma cubes and monster spawners:
-	 * <ul>
-	 * <li>It looks like a tiny flame
-	 * <li>The speed value influences the velocity at which the particle flies off
-	 * </ul>
-	 */
-	FLAME("flame", 26, -1, ParticleProperty.DIRECTIONAL),
-	/**
-	 * A particle effect which is displayed by lava:
-	 * <ul>
-	 * <li>It looks like a spark
-	 * <li>The speed value has no influence on this particle effect
-	 * </ul>
-	 */
-	LAVA("lava", 27, -1),
-	/**
-	 * A particle effect which is currently unused:
-	 * <ul>
-	 * <li>It looks like a transparent gray square
-	 * <li>The speed value has no influence on this particle effect
-	 * </ul>
-	 */
-	FOOTSTEP("footstep", 28, -1),
-	/**
-	 * A particle effect which is displayed when a mob dies:
-	 * <ul>
-	 * <li>It looks like a large white cloud
-	 * <li>The speed value influences the velocity at which the particle flies off
-	 * </ul>
-	 */
-	CLOUD("cloud", 29, -1, ParticleProperty.DIRECTIONAL),
-	/**
-	 * A particle effect which is displayed by redstone ore, powered redstone, redstone torches and redstone repeaters:
-	 * <ul>
-	 * <li>It looks like a tiny colored cloud
-	 * <li>The speed value causes the particle to be colored red when set to 0
-	 * </ul>
-	 */
-	REDSTONE("reddust", 30, -1, ParticleProperty.COLORABLE),
-	/**
-	 * A particle effect which is displayed when snowballs hit a block:
-	 * <ul>
-	 * <li>It looks like a little piece with the snowball texture
-	 * <li>The speed value has no influence on this particle effect
-	 * </ul>
-	 */
-	SNOWBALL("snowballpoof", 31, -1),
-	/**
-	 * A particle effect which is currently unused:
-	 * <ul>
-	 * <li>It looks like a tiny white cloud
-	 * <li>The speed value influences the velocity at which the particle flies off
-	 * </ul>
-	 */
-	SNOW_SHOVEL("snowshovel", 32, -1, ParticleProperty.DIRECTIONAL),
-	/**
-	 * A particle effect which is displayed by slimes:
-	 * <ul>
-	 * <li>It looks like a tiny part of the slimeball icon
-	 * <li>The speed value has no influence on this particle effect
-	 * </ul>
-	 */
-	SLIME("slime", 33, -1),
-	/**
-	 * A particle effect which is displayed when breeding and taming animals:
-	 * <ul>
-	 * <li>It looks like a red heart
-	 * <li>The speed value has no influence on this particle effect
-	 * </ul>
-	 */
-	HEART("heart", 34, -1),
-	/**
-	 * A particle effect which is displayed by barriers:
-	 * <ul>
-	 * <li>It looks like a red box with a slash through it
-	 * <li>The speed value has no influence on this particle effect
-	 * </ul>
-	 */
-	BARRIER("barrier", 35, 8),
-	/**
-	 * A particle effect which is displayed when breaking a tool or eggs hit a block:
-	 * <ul>
-	 * <li>It looks like a little piece with an item texture
-	 * </ul>
-	 */
-	ITEM_CRACK("iconcrack", 36, -1, ParticleProperty.DIRECTIONAL, ParticleProperty.REQUIRES_DATA),
-	/**
-	 * A particle effect which is displayed when breaking blocks or sprinting:
-	 * <ul>
-	 * <li>It looks like a little piece with a block texture
-	 * <li>The speed value has no influence on this particle effect
-	 * </ul>
-	 */
-	BLOCK_CRACK("blockcrack", 37, -1, ParticleProperty.REQUIRES_DATA),
-	/**
-	 * A particle effect which is displayed when falling:
-	 * <ul>
-	 * <li>It looks like a little piece with a block texture
-	 * </ul>
-	 */
-	BLOCK_DUST("blockdust", 38, 7, ParticleProperty.DIRECTIONAL, ParticleProperty.REQUIRES_DATA),
-	/**
-	 * A particle effect which is displayed when rain hits the ground:
-	 * <ul>
-	 * <li>It looks like a blue droplet
-	 * <li>The speed value has no influence on this particle effect
-	 * </ul>
-	 */
-	WATER_DROP("droplet", 39, 8),
-	/**
-	 * A particle effect which is currently unused:
-	 * <ul>
-	 * <li>It has no visual effect
-	 * </ul>
-	 */
-	ITEM_TAKE("take", 40, 8),
-	/**
-	 * A particle effect which is displayed by elder guardians:
-	 * <ul>
-	 * <li>It looks like the shape of the elder guardian
-	 * <li>The speed value has no influence on this particle effect
-	 * <li>The offset values have no influence on this particle effect
-	 * </ul>
-	 */
-	MOB_APPEARANCE("mobappearance", 41, 8),
-
-	DRAGON_BREATH("dragonbreath", 42, 9),
-	
-	END_ROD("endrod", 43, 9),
-	
-	DAMAGE_INDICATOR("damageindicator", 44, 9),
-	
-	SWEEP_ATTACK("sweepattack", 45, 9);
-	
-	private static final Map<String, ParticleEffect> NAME_MAP = new HashMap<String, ParticleEffect>();
-	private static final Map<Integer, ParticleEffect> ID_MAP = new HashMap<Integer, ParticleEffect>();
-	private final String name;
-	private final int id;
-	private final int requiredVersion;
-	private final List<ParticleProperty> properties;
-
-	// Initialize map for quick name and id lookup
-	static {
-		for (ParticleEffect effect : values()) {
-			NAME_MAP.put(effect.name, effect);
-			ID_MAP.put(effect.id, effect);
-		}
-	}
-
-	/**
-	 * Construct a new particle effect
-	 * 
-	 * @param name Name of this particle effect
-	 * @param id Id of this particle effect
-	 * @param requiredVersion Version which is required (1.x)
-	 * @param properties Properties of this particle effect
-	 */
-	private ParticleEffect(String name, int id, int requiredVersion, ParticleProperty... properties) {
-		this.name = name;
-		this.id = id;
-		this.requiredVersion = requiredVersion;
-		this.properties = Arrays.asList(properties);
-	}
-
-	/**
-	 * Returns the name of this particle effect
-	 * 
-	 * @return The name
-	 */
-	public String getName() {
-		return name;
-	}
-
-	/**
-	 * Returns the id of this particle effect
-	 * 
-	 * @return The id
-	 */
-	public int getId() {
-		return id;
-	}
-
-	/**
-	 * Returns the required version for this particle effect (1.x)
-	 * 
-	 * @return The required version
-	 */
-	public int getRequiredVersion() {
-		return requiredVersion;
-	}
-
-	/**
-	 * Determine if this particle effect has a specific property
-	 * 
-	 * @return Whether it has the property or not
-	 */
-	public boolean hasProperty(ParticleProperty property) {
-		return properties.contains(property);
-	}
-	
-	/**
-	 * Returns the particle effect with the given name
-	 * 
-	 * @param name Name of the particle effect
-	 * @return The particle effect
-	 */
-	public static ParticleEffect fromName(String name) {
-		for (Entry<String, ParticleEffect> entry : NAME_MAP.entrySet()) {
-			if (!entry.getKey().equalsIgnoreCase(name)) {
-				continue;
-			}
-			return entry.getValue();
-		}
-		return null;
-	}
-
-	/**
-	 * Returns the particle effect with the given id
-	 * 
-	 * @param id Id of the particle effect
-	 * @return The particle effect
-	 */
-	public static ParticleEffect fromId(int id) {
-		for (Entry<Integer, ParticleEffect> entry : ID_MAP.entrySet()) {
-			if (entry.getKey() != id) {
-				continue;
-			}
-			return entry.getValue();
-		}
-		return null;
-	}
-	/**
-	 * Determine if the data type for a particle effect is correct
-	 * 
-	 * @param effect Particle effect
-	 * @param data Particle data
-	 * @return Whether the data type is correct or not
-	 */
-	private static boolean isDataCorrect(ParticleEffect effect, ParticleData data) {
-		return ((effect == BLOCK_CRACK || effect == BLOCK_DUST) && data instanceof BlockData) || (effect == ITEM_CRACK && data instanceof ItemData);
-	}
-
-	/**
-	 * Determine if the color type for a particle effect is correct
-	 * 
-	 * @param effect Particle effect
-	 * @param color Particle color
-	 * @return Whether the color type is correct or not
-	 */
-	private static boolean isColorCorrect(ParticleEffect effect, ParticleColor color) {
-		return ((effect == SPELL_MOB || effect == SPELL_MOB_AMBIENT || effect == REDSTONE) && color instanceof OrdinaryColor) || (effect == NOTE && color instanceof NoteColor);
-	}
-
-	/**
-	 * Displays a particle effect which is only visible for the specified players
-	 * 
-	 * @param offsetX Maximum distance particles can fly away from the center on the x-axis
-	 * @param offsetY Maximum distance particles can fly away from the center on the y-axis
-	 * @param offsetZ Maximum distance particles can fly away from the center on the z-axis
-	 * @param speed Display speed of the particles
-	 * @param amount Amount of particles
-	 * @param center Center location of the effect
-	 * @param players Receivers of the effect
-	 * @throws ParticleVersionException If the particle effect is not supported by the server version
-	 * @throws ParticleDataException If the particle effect requires additional data
-	 * @throws IllegalArgumentException If the particle effect requires water and none is at the center location
-	 * @see ParticlePacket
-	 * @see ParticlePacket#sendTo(Location, List)
-	 */
-	public void display(float offsetX, float offsetY, float offsetZ, float speed, int amount, Location center, List<Player> players) throws  ParticleDataException, IllegalArgumentException {
-		if (hasProperty(ParticleProperty.REQUIRES_DATA)) {
-			throw new ParticleDataException("This particle effect requires additional data");
-		}
-		new ParticlePacket(this, offsetX, offsetY, offsetZ, speed, amount, true, null).sendTo(center, players);
-	}
-
-	/**
-	 * Displays a particle effect which is only visible for the specified players
-	 * 
-	 * @param offsetX Maximum distance particles can fly away from the center on the x-axis
-	 * @param offsetY Maximum distance particles can fly away from the center on the y-axis
-	 * @param offsetZ Maximum distance particles can fly away from the center on the z-axis
-	 * @param speed Display speed of the particles
-	 * @param amount Amount of particles
-	 * @param center Center location of the effect
-	 * @param players Receivers of the effect
-	 * @throws ParticleVersionException If the particle effect is not supported by the server version
-	 * @throws ParticleDataException If the particle effect requires additional data
-	 * @throws IllegalArgumentException If the particle effect requires water and none is at the center location
-	 * @see #display(float, float, float, float, int, Location, List)
-	 */
-	public void display(float offsetX, float offsetY, float offsetZ, float speed, int amount, Location center, Player... players) throws  ParticleDataException, IllegalArgumentException {
-		display(offsetX, offsetY, offsetZ, speed, amount, center, Arrays.asList(players));
-	}
-
-	/**
-	 * Displays a single particle which flies into a determined direction and is only visible for the specified players
-	 * 
-	 * @param direction Direction of the particle
-	 * @param speed Display speed of the particle
-	 * @param center Center location of the effect
-	 * @param players Receivers of the effect
-	 * @throws ParticleVersionException If the particle effect is not supported by the server version
-	 * @throws ParticleDataException If the particle effect requires additional data
-	 * @throws IllegalArgumentException If the particle effect is not directional or if it requires water and none is at the center location
-	 * @see ParticlePacket#ParticlePacket(ParticleEffect, Vector, float, boolean, ParticleData)
-	 * @see ParticlePacket#sendTo(Location, List)
-	 */
-	public void display(Vector direction, float speed, Location center, List<Player> players) throws  ParticleDataException, IllegalArgumentException {
-		if (hasProperty(ParticleProperty.REQUIRES_DATA)) {
-			throw new ParticleDataException("This particle effect requires additional data");
-		}
-		if (!hasProperty(ParticleProperty.DIRECTIONAL)) {
-			throw new IllegalArgumentException("This particle effect is not directional");
-		}
-		new ParticlePacket(this, direction, speed, true, null).sendTo(center, players);
-	}
-
-	/**
-	 * Displays a single particle which flies into a determined direction and is only visible for the specified players
-	 * 
-	 * @param direction Direction of the particle
-	 * @param speed Display speed of the particle
-	 * @param center Center location of the effect
-	 * @param players Receivers of the effect
-	 * @throws ParticleVersionException If the particle effect is not supported by the server version
-	 * @throws ParticleDataException If the particle effect requires additional data
-	 * @throws IllegalArgumentException If the particle effect is not directional or if it requires water and none is at the center location
-	 * @see #display(Vector, float, Location, List)
-	 */
-	public void display(Vector direction, float speed, Location center, Player... players) throws  ParticleDataException, IllegalArgumentException {
-		display(direction, speed, center, Arrays.asList(players));
-	}
-	/**
-	 * Displays a single particle which is colored and only visible for the specified players
-	 * 
-	 * @param color Color of the particle
-	 * @param center Center location of the effect
-	 * @param players Receivers of the effect
-	 * @throws ParticleVersionException If the particle effect is not supported by the server version
-	 * @throws ParticleColorException If the particle effect is not colorable or the color type is incorrect
-	 * @see ParticlePacket#ParticlePacket(ParticleEffect, ParticleColor, boolean)
-	 * @see ParticlePacket#sendTo(Location, List)
-	 */
-	public void display(ParticleColor color, Location center, List<Player> players) throws  ParticleColorException {
-		if (!hasProperty(ParticleProperty.COLORABLE)) {
-			throw new ParticleColorException("This particle effect is not colorable");
-		}
-		if (!isColorCorrect(this, color)) {
-			throw new ParticleColorException("The particle color type is incorrect");
-		}
-		new ParticlePacket(this, color, true).sendTo(center, players);
-	}
-
-	/**
-	 * Displays a single particle which is colored and only visible for the specified players
-	 * 
-	 * @param color Color of the particle
-	 * @param center Center location of the effect
-	 * @param players Receivers of the effect
-	 * @throws ParticleVersionException If the particle effect is not supported by the server version
-	 * @throws ParticleColorException If the particle effect is not colorable or the color type is incorrect
-	 * @see #display(ParticleColor, Location, List)
-	 */
-	public void display(ParticleColor color, Location center, Player... players) throws  ParticleColorException {
-		display(color, center, Arrays.asList(players));
-	}
-
-	/**
-	 * Displays a particle effect which requires additional data and is only visible for the specified players
-	 * 
-	 * @param data Data of the effect
-	 * @param offsetX Maximum distance particles can fly away from the center on the x-axis
-	 * @param offsetY Maximum distance particles can fly away from the center on the y-axis
-	 * @param offsetZ Maximum distance particles can fly away from the center on the z-axis
-	 * @param speed Display speed of the particles
-	 * @param amount Amount of particles
-	 * @param center Center location of the effect
-	 * @param players Receivers of the effect
-	 * @throws ParticleVersionException If the particle effect is not supported by the server version
-	 * @throws ParticleDataException If the particle effect does not require additional data or if the data type is incorrect
-	 * @see ParticlePacket
-	 * @see ParticlePacket#sendTo(Location, List)
-	 */
-	public void display(ParticleData data, float offsetX, float offsetY, float offsetZ, float speed, int amount, Location center, List<Player> players) throws  ParticleDataException {
-		if (!hasProperty(ParticleProperty.REQUIRES_DATA)) {
-			throw new ParticleDataException("This particle effect does not require additional data");
-		}
-		if (!isDataCorrect(this, data)) {
-			throw new ParticleDataException("The particle data type is incorrect");
-		}
-		new ParticlePacket(this, offsetX, offsetY, offsetZ, speed, amount, true, data).sendTo(center, players);
-	}
-
-	/**
-	 * Displays a particle effect which requires additional data and is only visible for the specified players
-	 * 
-	 * @param data Data of the effect
-	 * @param offsetX Maximum distance particles can fly away from the center on the x-axis
-	 * @param offsetY Maximum distance particles can fly away from the center on the y-axis
-	 * @param offsetZ Maximum distance particles can fly away from the center on the z-axis
-	 * @param speed Display speed of the particles
-	 * @param amount Amount of particles
-	 * @param center Center location of the effect
-	 * @param players Receivers of the effect
-	 * @throws ParticleVersionException If the particle effect is not supported by the server version
-	 * @throws ParticleDataException If the particle effect does not require additional data or if the data type is incorrect
-	 * @see #display(ParticleData, float, float, float, float, int, Location, List)
-	 */
-	public void display(ParticleData data, float offsetX, float offsetY, float offsetZ, float speed, int amount, Location center, Player... players) throws  ParticleDataException {
-		display(data, offsetX, offsetY, offsetZ, speed, amount, center, Arrays.asList(players));
-	}
-
-	/**
-	 * Displays a single particle which requires additional data that flies into a determined direction and is only visible for the specified players
-	 * 
-	 * @param data Data of the effect
-	 * @param direction Direction of the particle
-	 * @param speed Display speed of the particles
-	 * @param center Center location of the effect
-	 * @param players Receivers of the effect
-	 * @throws ParticleVersionException If the particle effect is not supported by the server version
-	 * @throws ParticleDataException If the particle effect does not require additional data or if the data type is incorrect
-	 * @see ParticlePacket
-	 * @see ParticlePacket#sendTo(Location, List)
-	 */
-	public void display(ParticleData data, Vector direction, float speed, Location center, List<Player> players) throws  ParticleDataException {
-		if (!hasProperty(ParticleProperty.REQUIRES_DATA)) {
-			throw new ParticleDataException("This particle effect does not require additional data");
-		}
-		if (!isDataCorrect(this, data)) {
-			throw new ParticleDataException("The particle data type is incorrect");
-		}
-		new ParticlePacket(this, direction, speed, true, data).sendTo(center, players);
-	}
-
-	/**
-	 * Displays a single particle which requires additional data that flies into a determined direction and is only visible for the specified players
-	 * 
-	 * @param data Data of the effect
-	 * @param direction Direction of the particle
-	 * @param speed Display speed of the particles
-	 * @param center Center location of the effect
-	 * @param players Receivers of the effect
-	 * @throws ParticleVersionException If the particle effect is not supported by the server version
-	 * @throws ParticleDataException If the particle effect does not require additional data or if the data type is incorrect
-	 * @see #display(ParticleData, Vector, float, Location, List)
-	 */
-	public void display(ParticleData data, Vector direction, float speed, Location center, Player... players) throws  ParticleDataException {
-		display(data, direction, speed, center, Arrays.asList(players));
-	}
-
-	/**
-	 * Represents the property of a particle effect
-	 * <p>
-	 * This class is part of the <b>ParticleEffect Library</b> and follows the same usage conditions
-	 * 
-	 * @author DarkBlade12
-	 * @since 1.7
-	 */
-	public static enum ParticleProperty {
-		/**
-		 * The particle effect requires water to be displayed
-		 */
-		REQUIRES_WATER,
-		/**
-		 * The particle effect requires block or item data to be displayed
-		 */
-		REQUIRES_DATA,
-		/**
-		 * The particle effect uses the offsets as direction values
-		 */
-		DIRECTIONAL,
-		/**
-		 * The particle effect uses the offsets as color values
-		 */
-		COLORABLE;
-	}
-
-	/**
-	 * Represents the particle data for effects like {@link ParticleEffect#ITEM_CRACK}, {@link ParticleEffect#BLOCK_CRACK} and {@link ParticleEffect#BLOCK_DUST}
-	 * <p>
-	 * This class is part of the <b>ParticleEffect Library</b> and follows the same usage conditions
-	 * 
-	 * @author DarkBlade12
-	 * @since 1.6
-	 */
-	public static abstract class ParticleData {
-		private final Material material;
-		private final byte data;
-		private final int[] packetData;
-
-		/**
-		 * Construct a new particle data
-		 * 
-		 * @param material Material of the item/block
-		 * @param data Data value of the item/block
-		 */
-		@SuppressWarnings("deprecation")
-		public ParticleData(Material material, byte data) {
-			this.material = material;
-			this.data = data;
-			this.packetData = new int[] { material.getId(), data };
-		}
-
-		/**
-		 * Returns the material of this data
-		 * 
-		 * @return The material
-		 */
-		public Material getMaterial() {
-			return material;
-		}
-
-		/**
-		 * Returns the data value of this data
-		 * 
-		 * @return The data value
-		 */
-		public byte getData() {
-			return data;
-		}
-
-		/**
-		 * Returns the data as an int array for packet construction
-		 * 
-		 * @return The data for the packet
-		 */
-		public int[] getPacketData() {
-			return packetData;
-		}
-
-		/**
-		 * Returns the data as a string for pre 1.8 versions
-		 * 
-		 * @return The data string for the packet
-		 */
-		public String getPacketDataString() {
-			return "_" + packetData[0] + "_" + packetData[1];
-		}
-	}
-
-	/**
-	 * Represents the item data for the {@link ParticleEffect#ITEM_CRACK} effect
-	 * <p>
-	 * This class is part of the <b>ParticleEffect Library</b> and follows the same usage conditions
-	 * 
-	 * @author DarkBlade12
-	 * @since 1.6
-	 */
-	public static class ItemData extends ParticleData {
-		/**
-		 * Construct a new item data
-		 * 
-		 * @param material Material of the item
-		 * @param data Data value of the item
-		 * @see ParticleData#ParticleData(Material, byte)
-		 */
-		public ItemData(Material material, byte data) {
-			super(material, data);
-		}
-	}
-
-	/**
-	 * Represents the block data for the {@link ParticleEffect#BLOCK_CRACK} and {@link ParticleEffect#BLOCK_DUST} effects
-	 * <p>
-	 * This class is part of the <b>ParticleEffect Library</b> and follows the same usage conditions
-	 * 
-	 * @author DarkBlade12
-	 * @since 1.6
-	 */
-	public static class BlockData extends ParticleData {
-		/**
-		 * Construct a new block data
-		 * 
-		 * @param material Material of the block
-		 * @param data Data value of the block
-		 * @throws IllegalArgumentException If the material is not a block
-		 * @see ParticleData#ParticleData(Material, byte)
-		 */
-		public BlockData(Material material, byte data) throws IllegalArgumentException {
-			super(material, data);
-			if (!material.isBlock()) {
-				throw new IllegalArgumentException("The material is not a block");
-			}
-		}
-	}
-
-	/**
-	 * Represents the color for effects like {@link ParticleEffect#SPELL_MOB}, {@link ParticleEffect#SPELL_MOB_AMBIENT}, {@link ParticleEffect#REDSTONE} and {@link ParticleEffect#NOTE}
-	 * <p>
-	 * This class is part of the <b>ParticleEffect Library</b> and follows the same usage conditions
-	 * 
-	 * @author DarkBlade12
-	 * @since 1.7
-	 */
-	public static abstract class ParticleColor {
-		/**
-		 * Returns the value for the offsetX field
-		 * 
-		 * @return The offsetX value
-		 */
-		public abstract float getValueX();
-
-		/**
-		 * Returns the value for the offsetY field
-		 * 
-		 * @return The offsetY value
-		 */
-		public abstract float getValueY();
-
-		/**
-		 * Returns the value for the offsetZ field
-		 * 
-		 * @return The offsetZ value
-		 */
-		public abstract float getValueZ();
-	}
-
-	/**
-	 * Represents the color for effects like {@link ParticleEffect#SPELL_MOB}, {@link ParticleEffect#SPELL_MOB_AMBIENT} and {@link ParticleEffect#NOTE}
-	 * <p>
-	 * This class is part of the <b>ParticleEffect Library</b> and follows the same usage conditions
-	 * 
-	 * @author DarkBlade12
-	 * @since 1.7
-	 */
-	public static class OrdinaryColor extends ParticleColor {
-		private final int red;
-		private final int green;
-		private final int blue;
-
-		/**
-		 * Construct a new ordinary color
-		 * 
-		 * @param red Red value of the RGB format
-		 * @param green Green value of the RGB format
-		 * @param blue Blue value of the RGB format
-		 * @throws IllegalArgumentException If one of the values is lower than 0 or higher than 255
-		 */
-		public OrdinaryColor(int red, int green, int blue) {
-			if (red < 0) {
-				throw new IllegalArgumentException("The red value is lower than 0");
-			}
-			if (red > 255) {
-				throw new IllegalArgumentException("The red value is higher than 255");
-			}
-			this.red = red;
-			if (green < 0) {
-				throw new IllegalArgumentException("The green value is lower than 0");
-			}
-			if (green > 255) {
-				throw new IllegalArgumentException("The green value is higher than 255");
-			}
-			this.green = green;
-			if (blue < 0) {
-				throw new IllegalArgumentException("The blue value is lower than 0");
-			}
-			if (blue > 255) {
-				throw new IllegalArgumentException("The blue value is higher than 255");
-			}
-			this.blue = blue;
-		}
-
-		/**
-		 * Construct a new ordinary color
-		 * 
-		 * @param color Bukkit color
-		 */
-		public OrdinaryColor(Color color) {
-			this(color.getRed(), color.getGreen(), color.getBlue());
-		}
-
-		/**
-		 * Returns the red value of the RGB format
-		 * 
-		 * @return The red value
-		 */
-		public int getRed() {
-			return red;
-		}
-
-		/**
-		 * Returns the green value of the RGB format
-		 * 
-		 * @return The green value
-		 */
-		public int getGreen() {
-			return green;
-		}
-
-		/**
-		 * Returns the blue value of the RGB format
-		 * 
-		 * @return The blue value
-		 */
-		public int getBlue() {
-			return blue;
-		}
-
-		/**
-		 * Returns the red value divided by 255
-		 * 
-		 * @return The offsetX value
-		 */
-		@Override
-		public float getValueX() {
-			return (float) red / 255F;
-		}
-
-		/**
-		 * Returns the green value divided by 255
-		 * 
-		 * @return The offsetY value
-		 */
-		@Override
-		public float getValueY() {
-			return (float) green / 255F;
-		}
-
-		/**
-		 * Returns the blue value divided by 255
-		 * 
-		 * @return The offsetZ value
-		 */
-		@Override
-		public float getValueZ() {
-			return (float) blue / 255F;
-		}
-	}
-
-	/**
-	 * Represents the color for the {@link ParticleEffect#NOTE} effect
-	 * <p>
-	 * This class is part of the <b>ParticleEffect Library</b> and follows the same usage conditions
-	 * 
-	 * @author DarkBlade12
-	 * @since 1.7
-	 */
-	public static class NoteColor extends ParticleColor {
-		private final int note;
-
-		/**
-		 * Construct a new note color
-		 * 
-		 * @param note Note id which determines color
-		 * @throws IllegalArgumentException If the note value is lower than 0 or higher than 24
-		 */
-		public NoteColor(int note) throws IllegalArgumentException {
-			if (note < 0) {
-				throw new IllegalArgumentException("The note value is lower than 0");
-			}
-			if (note > 24) {
-				throw new IllegalArgumentException("The note value is higher than 24");
-			}
-			this.note = note;
-		}
-
-		/**
-		 * Returns the note value divided by 24
-		 * 
-		 * @return The offsetX value
-		 */
-		@Override
-		public float getValueX() {
-			return (float) note / 24F;
-		}
-
-		/**
-		 * Returns zero because the offsetY value is unused
-		 * 
-		 * @return zero
-		 */
-		@Override
-		public float getValueY() {
-			return 0;
-		}
-
-		/**
-		 * Returns zero because the offsetZ value is unused
-		 * 
-		 * @return zero
-		 */
-		@Override
-		public float getValueZ() {
-			return 0;
-		}
-
-	}
-
-	/**
-	 * Represents a runtime exception that is thrown either if the displayed particle effect requires data and has none or vice-versa or if the data type is incorrect
-	 * <p>
-	 * This class is part of the <b>ParticleEffect Library</b> and follows the same usage conditions
-	 * 
-	 * @author DarkBlade12
-	 * @since 1.6
-	 */
-	private static final class ParticleDataException extends RuntimeException {
-		private static final long serialVersionUID = 3203085387160737484L;
-
-		/**
-		 * Construct a new particle data exception
-		 * 
-		 * @param message Message that will be logged
-		 */
-		public ParticleDataException(String message) {
-			super(message);
-		}
-	}
-
-	/**
-	 * Represents a runtime exception that is thrown either if the displayed particle effect is not colorable or if the particle color type is incorrect
-	 * <p>
-	 * This class is part of the <b>ParticleEffect Library</b> and follows the same usage conditions
-	 * 
-	 * @author DarkBlade12
-	 * @since 1.7
-	 */
-	private static final class ParticleColorException extends RuntimeException {
-		private static final long serialVersionUID = 3203085387160737484L;
-
-		/**
-		 * Construct a new particle color exception
-		 * 
-		 * @param message Message that will be logged
-		 */
-		public ParticleColorException(String message) {
-			super(message);
-		}
-	}
-
-	/**
-	 * Represents a particle effect packet with all attributes which is used for sending packets to the players
-	 * <p>
-	 * This class is part of the <b>ParticleEffect Library</b> and follows the same usage conditions
-	 * 
-	 * @author DarkBlade12
-	 * @since 1.5
-	 */
-	public static final class ParticlePacket {
-		private final ParticleEffect effect;
-		private float offsetX;
-		private final float offsetY;
-		private final float offsetZ;
-		private final float speed;
-		private final int amount;
-		private final boolean longDistance;
-		private final ParticleData data;
-		private PacketPlayOutWorldParticles packet;
-
-		/**
-		 * Construct a new particle packet
-		 * 
-		 * @param effect Particle effect
-		 * @param offsetX Maximum distance particles can fly away from the center on the x-axis
-		 * @param offsetY Maximum distance particles can fly away from the center on the y-axis
-		 * @param offsetZ Maximum distance particles can fly away from the center on the z-axis
-		 * @param speed Display speed of the particles
-		 * @param amount Amount of particles
-		 * @param longDistance Indicates whether the maximum distance is increased from 256 to 65536
-		 * @param data Data of the effect
-		 * @throws IllegalArgumentException If the speed or amount is lower than 0
-		 * @see #initialize()
-		 */
-		public ParticlePacket(ParticleEffect effect, float offsetX, float offsetY, float offsetZ, float speed, int amount, boolean longDistance, ParticleData data) throws IllegalArgumentException {
-			if (speed < 0) {
-				throw new IllegalArgumentException("The speed is lower than 0");
-			}
-			if (amount < 0) {
-				throw new IllegalArgumentException("The amount is lower than 0");
-			}
-			this.effect = effect;
-			this.offsetX = offsetX;
-			this.offsetY = offsetY;
-			this.offsetZ = offsetZ;
-			this.speed = speed;
-			this.amount = amount;
-			this.longDistance = longDistance;
-			this.data = data;
-		}
-
-		/**
-		 * Construct a new particle packet of a single particle flying into a determined direction
-		 * 
-		 * @param effect Particle effect
-		 * @param direction Direction of the particle
-		 * @param speed Display speed of the particle
-		 * @param longDistance Indicates whether the maximum distance is increased from 256 to 65536
-		 * @param data Data of the effect
-		 * @throws IllegalArgumentException If the speed is lower than 0
-		 * @see #ParticleEffect(ParticleEffect, float, float, float, float, int, boolean, ParticleData)
-		 */
-		public ParticlePacket(ParticleEffect effect, Vector direction, float speed, boolean longDistance, ParticleData data) throws IllegalArgumentException {
-			this(effect, (float) direction.getX(), (float) direction.getY(), (float) direction.getZ(), speed, 0, longDistance, data);
-		}
-
-		/**
-		 * Construct a new particle packet of a single colored particle
-		 * 
-		 * @param effect Particle effect
-		 * @param color Color of the particle
-		 * @param longDistance Indicates whether the maximum distance is increased from 256 to 65536
-		 * @see #ParticleEffect(ParticleEffect, float, float, float, float, int, boolean, ParticleData)
-		 */
-		public ParticlePacket(ParticleEffect effect, ParticleColor color, boolean longDistance) {
-			this(effect, color.getValueX(), color.getValueY(), color.getValueZ(), 1, 0, longDistance, null);
-			if (effect == ParticleEffect.REDSTONE && color instanceof OrdinaryColor && ((OrdinaryColor) color).getRed() == 0) {
-				offsetX = (float) 1 / 255F;
-			}
-		}
-
-		/**
-		 * Initializes {@link #packet} with all set values
-		 * 
-		 * @param center Center location of the effect
-		 * @throws PacketInstantiationException If instantion fails due to an unknown error
-		 */
-		private void initializePacket(Location center) {
-			if (packet != null) {
-				return;
-			}
-			packet = new PacketPlayOutWorldParticles(this.effect, center, new Vector(offsetX, offsetY, offsetZ), this.speed, this.amount,this.longDistance , data==null?new int[0]:effect == ParticleEffect.ITEM_CRACK ? data.getPacketData() : new int[] { data.getPacketData()[0] | (data.getPacketData()[1] << 12)});
-		}
-
-		/**
-		 * Sends the packet to a single player and caches it
-		 * 
-		 * @param center Center location of the effect
-		 * @param player Receiver of the packet
-		 * @throws PacketInstantiationException If instantion fails due to an unknown error
-		 * @throws PacketSendingException If sending fails due to an unknown error
-		 * @see #initializePacket(Location)
-		 */
-		public void sendTo(Location center, Player player) {
-			initializePacket(center);
-			player.sendPacket(packet);
-		}
-
-		/**
-		 * Sends the packet to all players in the list
-		 * 
-		 * @param center Center location of the effect
-		 * @param players Receivers of the packet
-		 * @throws IllegalArgumentException If the player list is empty
-		 * @see #sendTo(Location center, Player player)
-		 */
-		public void sendTo(Location center, List<Player> players) throws IllegalArgumentException {
-			if (players.isEmpty()) {
-				throw new IllegalArgumentException("The player list is empty");
-			}
-			for (Player player : players) {
-				sendTo(center, player);
-			}
-		}
-	}
+    /**
+     * A particle effect which is displayed by exploding tnt and creepers:
+     * <ul>
+     * <li>It looks like a white cloud
+     * <li>The speed value influences the velocity at which the particle flies off
+     * </ul>
+     */
+    EXPLOSION_NORMAL("explode", 0, -1, ParticleProperty.DIRECTIONAL),
+    /**
+     * A particle effect which is displayed by exploding ghast fireballs and wither skulls:
+     * <ul>
+     * <li>It looks like a gray ball which is fading away
+     * <li>The speed value slightly influences the size of this particle effect
+     * </ul>
+     */
+    EXPLOSION_LARGE("largeexplode", 1, -1),
+    /**
+     * A particle effect which is displayed by exploding tnt and creepers:
+     * <ul>
+     * <li>It looks like a crowd of gray balls which are fading away
+     * <li>The speed value has no influence on this particle effect
+     * </ul>
+     */
+    EXPLOSION_HUGE("hugeexplosion", 2, -1),
+    /**
+     * A particle effect which is displayed by launching fireworks:
+     * <ul>
+     * <li>It looks like a white star which is sparkling
+     * <li>The speed value influences the velocity at which the particle flies off
+     * </ul>
+     */
+    FIREWORKS_SPARK("fireworksSpark", 3, -1, ParticleProperty.DIRECTIONAL),
+    /**
+     * A particle effect which is displayed by swimming entities and arrows in water:
+     * <ul>
+     * <li>It looks like a bubble
+     * <li>The speed value influences the velocity at which the particle flies off
+     * </ul>
+     */
+    WATER_BUBBLE("bubble", 4, -1, ParticleProperty.DIRECTIONAL, ParticleProperty.REQUIRES_WATER),
+    /**
+     * A particle effect which is displayed by swimming entities and shaking wolves:
+     * <ul>
+     * <li>It looks like a blue drop
+     * <li>The speed value has no influence on this particle effect
+     * </ul>
+     */
+    WATER_SPLASH("splash", 5, -1, ParticleProperty.DIRECTIONAL),
+    /**
+     * A particle effect which is displayed on water when fishing:
+     * <ul>
+     * <li>It looks like a blue droplet
+     * <li>The speed value influences the velocity at which the particle flies off
+     * </ul>
+     */
+    WATER_WAKE("wake", 6, 7, ParticleProperty.DIRECTIONAL),
+    /**
+     * A particle effect which is displayed by water:
+     * <ul>
+     * <li>It looks like a tiny blue square
+     * <li>The speed value has no influence on this particle effect
+     * </ul>
+     */
+    SUSPENDED("suspended", 7, -1, ParticleProperty.REQUIRES_WATER),
+    /**
+     * A particle effect which is displayed by air when close to bedrock and the in the void:
+     * <ul>
+     * <li>It looks like a tiny gray square
+     * <li>The speed value has no influence on this particle effect
+     * </ul>
+     */
+    SUSPENDED_DEPTH("depthSuspend", 8, -1, ParticleProperty.DIRECTIONAL),
+    /**
+     * A particle effect which is displayed when landing a critical hit and by arrows:
+     * <ul>
+     * <li>It looks like a light brown cross
+     * <li>The speed value influences the velocity at which the particle flies off
+     * </ul>
+     */
+    CRIT("crit", 9, -1, ParticleProperty.DIRECTIONAL),
+    /**
+     * A particle effect which is displayed when landing a hit with an enchanted weapon:
+     * <ul>
+     * <li>It looks like a cyan star
+     * <li>The speed value influences the velocity at which the particle flies off
+     * </ul>
+     */
+    CRIT_MAGIC("magicCrit", 10, -1, ParticleProperty.DIRECTIONAL),
+    /**
+     * A particle effect which is displayed by primed tnt, torches, droppers, dispensers, end
+     * portals, brewing stands and monster spawners: <ul> <li>It looks like a little gray cloud
+     * <li>The speed value influences the velocity at which the particle flies off </ul>
+     */
+    SMOKE_NORMAL("smoke", 11, -1, ParticleProperty.DIRECTIONAL),
+    /**
+     * A particle effect which is displayed by fire, minecarts with furnace and blazes:
+     * <ul>
+     * <li>It looks like a large gray cloud
+     * <li>The speed value influences the velocity at which the particle flies off
+     * </ul>
+     */
+    SMOKE_LARGE("largesmoke", 12, -1, ParticleProperty.DIRECTIONAL),
+    /**
+     * A particle effect which is displayed when splash potions or bottles o' enchanting hit
+     * something: <ul> <li>It looks like a white swirl <li>The speed value causes the particle to
+     * only move upwards when set to 0 <li>Only the motion on the y-axis can be controlled, the
+     * motion on the x- and z-axis are multiplied by 0.1 when setting the values to 0 </ul>
+     */
+    SPELL("spell", 13, -1),
+    /**
+     * A particle effect which is displayed when instant splash potions hit something: <ul> <li>It
+     * looks like a white cross <li>The speed value causes the particle to only move upwards when
+     * set to 0 <li>Only the motion on the y-axis can be controlled, the motion on the x- and z-axis
+     * are multiplied by 0.1 when setting the values to 0 </ul>
+     */
+    SPELL_INSTANT("instantSpell", 14, -1),
+    /**
+     * A particle effect which is displayed by entities with active potion effects: <ul> <li>It
+     * looks like a colored swirl <li>The speed value causes the particle to be colored black when
+     * set to 0 <li>The particle color gets lighter when increasing the speed and darker when
+     * decreasing the speed </ul>
+     */
+    SPELL_MOB("mobSpell", 15, -1, ParticleProperty.COLORABLE),
+    /**
+     * A particle effect which is displayed by entities with active potion effects applied through a
+     * beacon: <ul> <li>It looks like a transparent colored swirl <li>The speed value causes the
+     * particle to be always colored black when set to 0 <li>The particle color gets lighter when
+     * increasing the speed and darker when decreasing the speed </ul>
+     */
+    SPELL_MOB_AMBIENT("mobSpellAmbient", 16, -1, ParticleProperty.COLORABLE),
+    /**
+     * A particle effect which is displayed by witches: <ul> <li>It looks like a purple cross
+     * <li>The speed value causes the particle to only move upwards when set to 0 <li>Only the
+     * motion on the y-axis can be controlled, the motion on the x- and z-axis are multiplied by 0.1
+     * when setting the values to 0 </ul>
+     */
+    SPELL_WITCH("witchMagic", 17, -1),
+    /**
+     * A particle effect which is displayed by blocks beneath a water source:
+     * <ul>
+     * <li>It looks like a blue drip
+     * <li>The speed value has no influence on this particle effect
+     * </ul>
+     */
+    DRIP_WATER("dripWater", 18, -1),
+    /**
+     * A particle effect which is displayed by blocks beneath a lava source:
+     * <ul>
+     * <li>It looks like an orange drip
+     * <li>The speed value has no influence on this particle effect
+     * </ul>
+     */
+    DRIP_LAVA("dripLava", 19, -1),
+    /**
+     * A particle effect which is displayed when attacking a villager in a village:
+     * <ul>
+     * <li>It looks like a cracked gray heart
+     * <li>The speed value has no influence on this particle effect
+     * </ul>
+     */
+    VILLAGER_ANGRY("angryVillager", 20, -1),
+    /**
+     * A particle effect which is displayed when using bone meal and trading with a villager in a
+     * village: <ul> <li>It looks like a green star <li>The speed value has no influence on this
+     * particle effect </ul>
+     */
+    VILLAGER_HAPPY("happyVillager", 21, -1, ParticleProperty.DIRECTIONAL),
+    /**
+     * A particle effect which is displayed by mycelium:
+     * <ul>
+     * <li>It looks like a tiny gray square
+     * <li>The speed value has no influence on this particle effect
+     * </ul>
+     */
+    TOWN_AURA("townaura", 22, -1, ParticleProperty.DIRECTIONAL),
+    /**
+     * A particle effect which is displayed by note blocks:
+     * <ul>
+     * <li>It looks like a colored note
+     * <li>The speed value causes the particle to be colored green when set to 0
+     * </ul>
+     */
+    NOTE("note", 23, -1, ParticleProperty.COLORABLE),
+    /**
+     * A particle effect which is displayed by nether portals, endermen, ender pearls, eyes of
+     * ender, ender chests and dragon eggs: <ul> <li>It looks like a purple cloud <li>The speed
+     * value influences the spread of this particle effect </ul>
+     */
+    PORTAL("portal", 24, -1, ParticleProperty.DIRECTIONAL),
+    /**
+     * A particle effect which is displayed by enchantment tables which are nearby bookshelves:
+     * <ul>
+     * <li>It looks like a cryptic white letter
+     * <li>The speed value influences the spread of this particle effect
+     * </ul>
+     */
+    ENCHANTMENT_TABLE("enchantmenttable", 25, -1, ParticleProperty.DIRECTIONAL),
+    /**
+     * A particle effect which is displayed by torches, active furnaces, magma cubes and monster
+     * spawners: <ul> <li>It looks like a tiny flame <li>The speed value influences the velocity at
+     * which the particle flies off </ul>
+     */
+    FLAME("flame", 26, -1, ParticleProperty.DIRECTIONAL),
+    /**
+     * A particle effect which is displayed by lava:
+     * <ul>
+     * <li>It looks like a spark
+     * <li>The speed value has no influence on this particle effect
+     * </ul>
+     */
+    LAVA("lava", 27, -1),
+    /**
+     * A particle effect which is currently unused:
+     * <ul>
+     * <li>It looks like a transparent gray square
+     * <li>The speed value has no influence on this particle effect
+     * </ul>
+     */
+    FOOTSTEP("footstep", 28, -1),
+    /**
+     * A particle effect which is displayed when a mob dies:
+     * <ul>
+     * <li>It looks like a large white cloud
+     * <li>The speed value influences the velocity at which the particle flies off
+     * </ul>
+     */
+    CLOUD("cloud", 29, -1, ParticleProperty.DIRECTIONAL),
+    /**
+     * A particle effect which is displayed by redstone ore, powered redstone, redstone torches and
+     * redstone repeaters: <ul> <li>It looks like a tiny colored cloud <li>The speed value causes
+     * the particle to be colored red when set to 0 </ul>
+     */
+    REDSTONE("reddust", 30, -1, ParticleProperty.COLORABLE),
+    /**
+     * A particle effect which is displayed when snowballs hit a block:
+     * <ul>
+     * <li>It looks like a little piece with the snowball texture
+     * <li>The speed value has no influence on this particle effect
+     * </ul>
+     */
+    SNOWBALL("snowballpoof", 31, -1),
+    /**
+     * A particle effect which is currently unused:
+     * <ul>
+     * <li>It looks like a tiny white cloud
+     * <li>The speed value influences the velocity at which the particle flies off
+     * </ul>
+     */
+    SNOW_SHOVEL("snowshovel", 32, -1, ParticleProperty.DIRECTIONAL),
+    /**
+     * A particle effect which is displayed by slimes:
+     * <ul>
+     * <li>It looks like a tiny part of the slimeball icon
+     * <li>The speed value has no influence on this particle effect
+     * </ul>
+     */
+    SLIME("slime", 33, -1),
+    /**
+     * A particle effect which is displayed when breeding and taming animals:
+     * <ul>
+     * <li>It looks like a red heart
+     * <li>The speed value has no influence on this particle effect
+     * </ul>
+     */
+    HEART("heart", 34, -1),
+    /**
+     * A particle effect which is displayed by barriers:
+     * <ul>
+     * <li>It looks like a red box with a slash through it
+     * <li>The speed value has no influence on this particle effect
+     * </ul>
+     */
+    BARRIER("barrier", 35, 8),
+    /**
+     * A particle effect which is displayed when breaking a tool or eggs hit a block:
+     * <ul>
+     * <li>It looks like a little piece with an item texture
+     * </ul>
+     */
+    ITEM_CRACK("iconcrack", 36, -1, ParticleProperty.DIRECTIONAL, ParticleProperty.REQUIRES_DATA),
+    /**
+     * A particle effect which is displayed when breaking blocks or sprinting:
+     * <ul>
+     * <li>It looks like a little piece with a block texture
+     * <li>The speed value has no influence on this particle effect
+     * </ul>
+     */
+    BLOCK_CRACK("blockcrack", 37, -1, ParticleProperty.REQUIRES_DATA),
+    /**
+     * A particle effect which is displayed when falling:
+     * <ul>
+     * <li>It looks like a little piece with a block texture
+     * </ul>
+     */
+    BLOCK_DUST("blockdust", 38, 7, ParticleProperty.DIRECTIONAL, ParticleProperty.REQUIRES_DATA),
+    /**
+     * A particle effect which is displayed when rain hits the ground:
+     * <ul>
+     * <li>It looks like a blue droplet
+     * <li>The speed value has no influence on this particle effect
+     * </ul>
+     */
+    WATER_DROP("droplet", 39, 8),
+    /**
+     * A particle effect which is currently unused:
+     * <ul>
+     * <li>It has no visual effect
+     * </ul>
+     */
+    ITEM_TAKE("take", 40, 8),
+    /**
+     * A particle effect which is displayed by elder guardians:
+     * <ul>
+     * <li>It looks like the shape of the elder guardian
+     * <li>The speed value has no influence on this particle effect
+     * <li>The offset values have no influence on this particle effect
+     * </ul>
+     */
+    MOB_APPEARANCE("mobappearance", 41, 8),
+
+    DRAGON_BREATH("dragonbreath", 42, 9),
+
+    END_ROD("endrod", 43, 9),
+
+    DAMAGE_INDICATOR("damageindicator", 44, 9),
+
+    SWEEP_ATTACK("sweepattack", 45, 9);
+
+    private static final Map<String, ParticleEffect> NAME_MAP = new HashMap<String, ParticleEffect>();
+    private static final Map<Integer, ParticleEffect> ID_MAP = new HashMap<Integer, ParticleEffect>();
+
+    // Initialize map for quick name and id lookup
+    static {
+        for (ParticleEffect effect : values()) {
+            NAME_MAP.put(effect.name, effect);
+            ID_MAP.put(effect.id, effect);
+        }
+    }
+
+    private final String name;
+    private final int id;
+    private final int requiredVersion;
+    private final List<ParticleProperty> properties;
+
+    /**
+     * Construct a new particle effect
+     *
+     * @param name            Name of this particle effect
+     * @param id              Id of this particle effect
+     * @param requiredVersion Version which is required (1.x)
+     * @param properties      Properties of this particle effect
+     */
+    private ParticleEffect(String name, int id, int requiredVersion, ParticleProperty... properties) {
+        this.name = name;
+        this.id = id;
+        this.requiredVersion = requiredVersion;
+        this.properties = Arrays.asList(properties);
+    }
+
+    /**
+     * Returns the particle effect with the given name
+     *
+     * @param name Name of the particle effect
+     * @return The particle effect
+     */
+    public static ParticleEffect fromName(String name) {
+        for (Entry<String, ParticleEffect> entry : NAME_MAP.entrySet()) {
+            if (!entry.getKey().equalsIgnoreCase(name)) {
+                continue;
+            }
+            return entry.getValue();
+        }
+        return null;
+    }
+
+    /**
+     * Returns the particle effect with the given id
+     *
+     * @param id Id of the particle effect
+     * @return The particle effect
+     */
+    public static ParticleEffect fromId(int id) {
+        for (Entry<Integer, ParticleEffect> entry : ID_MAP.entrySet()) {
+            if (entry.getKey() != id) {
+                continue;
+            }
+            return entry.getValue();
+        }
+        return null;
+    }
+
+    /**
+     * Determine if the data type for a particle effect is correct
+     *
+     * @param effect Particle effect
+     * @param data   Particle data
+     * @return Whether the data type is correct or not
+     */
+    private static boolean isDataCorrect(ParticleEffect effect, ParticleData data) {
+        return ((effect == BLOCK_CRACK || effect == BLOCK_DUST) && data instanceof BlockData) || (effect == ITEM_CRACK && data instanceof ItemData);
+    }
+
+    /**
+     * Determine if the color type for a particle effect is correct
+     *
+     * @param effect Particle effect
+     * @param color  Particle color
+     * @return Whether the color type is correct or not
+     */
+    private static boolean isColorCorrect(ParticleEffect effect, ParticleColor color) {
+        return ((effect == SPELL_MOB || effect == SPELL_MOB_AMBIENT || effect == REDSTONE) && color instanceof OrdinaryColor) || (effect == NOTE && color instanceof NoteColor);
+    }
+
+    /**
+     * Returns the name of this particle effect
+     *
+     * @return The name
+     */
+    public String getName() {
+        return name;
+    }
+
+    /**
+     * Returns the id of this particle effect
+     *
+     * @return The id
+     */
+    public int getId() {
+        return id;
+    }
+
+    /**
+     * Returns the required version for this particle effect (1.x)
+     *
+     * @return The required version
+     */
+    public int getRequiredVersion() {
+        return requiredVersion;
+    }
+
+    /**
+     * Determine if this particle effect has a specific property
+     *
+     * @return Whether it has the property or not
+     */
+    public boolean hasProperty(ParticleProperty property) {
+        return properties.contains(property);
+    }
+
+    /**
+     * Displays a particle effect which is only visible for the specified players
+     *
+     * @param offsetX Maximum distance particles can fly away from the center on the x-axis
+     * @param offsetY Maximum distance particles can fly away from the center on the y-axis
+     * @param offsetZ Maximum distance particles can fly away from the center on the z-axis
+     * @param speed   Display speed of the particles
+     * @param amount  Amount of particles
+     * @param center  Center location of the effect
+     * @param players Receivers of the effect
+     * @throws ParticleVersionException If the particle effect is not supported by the server
+     *                                  version
+     * @throws ParticleDataException    If the particle effect requires additional data
+     * @throws IllegalArgumentException If the particle effect requires water and none is at the
+     *                                  center location
+     * @see ParticlePacket
+     * @see ParticlePacket#sendTo(Location, List)
+     */
+    public void display(float offsetX, float offsetY, float offsetZ, float speed, int amount, Location center, List<Player> players) throws ParticleDataException, IllegalArgumentException {
+        if (hasProperty(ParticleProperty.REQUIRES_DATA)) {
+            throw new ParticleDataException("This particle effect requires additional data");
+        }
+        new ParticlePacket(this, offsetX, offsetY, offsetZ, speed, amount, true, null).sendTo(center, players);
+    }
+
+    /**
+     * Displays a particle effect which is only visible for the specified players
+     *
+     * @param offsetX Maximum distance particles can fly away from the center on the x-axis
+     * @param offsetY Maximum distance particles can fly away from the center on the y-axis
+     * @param offsetZ Maximum distance particles can fly away from the center on the z-axis
+     * @param speed   Display speed of the particles
+     * @param amount  Amount of particles
+     * @param center  Center location of the effect
+     * @param players Receivers of the effect
+     * @throws ParticleVersionException If the particle effect is not supported by the server
+     *                                  version
+     * @throws ParticleDataException    If the particle effect requires additional data
+     * @throws IllegalArgumentException If the particle effect requires water and none is at the
+     *                                  center location
+     * @see #display(float, float, float, float, int, Location, List)
+     */
+    public void display(float offsetX, float offsetY, float offsetZ, float speed, int amount, Location center, Player... players) throws ParticleDataException, IllegalArgumentException {
+        display(offsetX, offsetY, offsetZ, speed, amount, center, Arrays.asList(players));
+    }
+
+    /**
+     * Displays a single particle which flies into a determined direction and is only visible for
+     * the specified players
+     *
+     * @param direction Direction of the particle
+     * @param speed     Display speed of the particle
+     * @param center    Center location of the effect
+     * @param players   Receivers of the effect
+     * @throws ParticleVersionException If the particle effect is not supported by the server
+     *                                  version
+     * @throws ParticleDataException    If the particle effect requires additional data
+     * @throws IllegalArgumentException If the particle effect is not directional or if it requires
+     *                                  water and none is at the center location
+     * @see ParticlePacket#ParticlePacket(ParticleEffect, Vector, float, boolean, ParticleData)
+     * @see ParticlePacket#sendTo(Location, List)
+     */
+    public void display(Vector direction, float speed, Location center, List<Player> players) throws ParticleDataException, IllegalArgumentException {
+        if (hasProperty(ParticleProperty.REQUIRES_DATA)) {
+            throw new ParticleDataException("This particle effect requires additional data");
+        }
+        if (!hasProperty(ParticleProperty.DIRECTIONAL)) {
+            throw new IllegalArgumentException("This particle effect is not directional");
+        }
+        new ParticlePacket(this, direction, speed, true, null).sendTo(center, players);
+    }
+
+    /**
+     * Displays a single particle which flies into a determined direction and is only visible for
+     * the specified players
+     *
+     * @param direction Direction of the particle
+     * @param speed     Display speed of the particle
+     * @param center    Center location of the effect
+     * @param players   Receivers of the effect
+     * @throws ParticleVersionException If the particle effect is not supported by the server
+     *                                  version
+     * @throws ParticleDataException    If the particle effect requires additional data
+     * @throws IllegalArgumentException If the particle effect is not directional or if it requires
+     *                                  water and none is at the center location
+     * @see #display(Vector, float, Location, List)
+     */
+    public void display(Vector direction, float speed, Location center, Player... players) throws ParticleDataException, IllegalArgumentException {
+        display(direction, speed, center, Arrays.asList(players));
+    }
+
+    /**
+     * Displays a single particle which is colored and only visible for the specified players
+     *
+     * @param color   Color of the particle
+     * @param center  Center location of the effect
+     * @param players Receivers of the effect
+     * @throws ParticleVersionException If the particle effect is not supported by the server
+     *                                  version
+     * @throws ParticleColorException   If the particle effect is not colorable or the color type is
+     *                                  incorrect
+     * @see ParticlePacket#ParticlePacket(ParticleEffect, ParticleColor, boolean)
+     * @see ParticlePacket#sendTo(Location, List)
+     */
+    public void display(ParticleColor color, Location center, List<Player> players) throws ParticleColorException {
+        if (!hasProperty(ParticleProperty.COLORABLE)) {
+            throw new ParticleColorException("This particle effect is not colorable");
+        }
+        if (!isColorCorrect(this, color)) {
+            throw new ParticleColorException("The particle color type is incorrect");
+        }
+        new ParticlePacket(this, color, true).sendTo(center, players);
+    }
+
+    /**
+     * Displays a single particle which is colored and only visible for the specified players
+     *
+     * @param color   Color of the particle
+     * @param center  Center location of the effect
+     * @param players Receivers of the effect
+     * @throws ParticleVersionException If the particle effect is not supported by the server
+     *                                  version
+     * @throws ParticleColorException   If the particle effect is not colorable or the color type is
+     *                                  incorrect
+     * @see #display(ParticleColor, Location, List)
+     */
+    public void display(ParticleColor color, Location center, Player... players) throws ParticleColorException {
+        display(color, center, Arrays.asList(players));
+    }
+
+    /**
+     * Displays a particle effect which requires additional data and is only visible for the
+     * specified players
+     *
+     * @param data    Data of the effect
+     * @param offsetX Maximum distance particles can fly away from the center on the x-axis
+     * @param offsetY Maximum distance particles can fly away from the center on the y-axis
+     * @param offsetZ Maximum distance particles can fly away from the center on the z-axis
+     * @param speed   Display speed of the particles
+     * @param amount  Amount of particles
+     * @param center  Center location of the effect
+     * @param players Receivers of the effect
+     * @throws ParticleVersionException If the particle effect is not supported by the server
+     *                                  version
+     * @throws ParticleDataException    If the particle effect does not require additional data or
+     *                                  if the data type is incorrect
+     * @see ParticlePacket
+     * @see ParticlePacket#sendTo(Location, List)
+     */
+    public void display(ParticleData data, float offsetX, float offsetY, float offsetZ, float speed, int amount, Location center, List<Player> players) throws ParticleDataException {
+        if (!hasProperty(ParticleProperty.REQUIRES_DATA)) {
+            throw new ParticleDataException("This particle effect does not require additional data");
+        }
+        if (!isDataCorrect(this, data)) {
+            throw new ParticleDataException("The particle data type is incorrect");
+        }
+        new ParticlePacket(this, offsetX, offsetY, offsetZ, speed, amount, true, data).sendTo(center, players);
+    }
+
+    /**
+     * Displays a particle effect which requires additional data and is only visible for the
+     * specified players
+     *
+     * @param data    Data of the effect
+     * @param offsetX Maximum distance particles can fly away from the center on the x-axis
+     * @param offsetY Maximum distance particles can fly away from the center on the y-axis
+     * @param offsetZ Maximum distance particles can fly away from the center on the z-axis
+     * @param speed   Display speed of the particles
+     * @param amount  Amount of particles
+     * @param center  Center location of the effect
+     * @param players Receivers of the effect
+     * @throws ParticleVersionException If the particle effect is not supported by the server
+     *                                  version
+     * @throws ParticleDataException    If the particle effect does not require additional data or
+     *                                  if the data type is incorrect
+     * @see #display(ParticleData, float, float, float, float, int, Location, List)
+     */
+    public void display(ParticleData data, float offsetX, float offsetY, float offsetZ, float speed, int amount, Location center, Player... players) throws ParticleDataException {
+        display(data, offsetX, offsetY, offsetZ, speed, amount, center, Arrays.asList(players));
+    }
+
+    /**
+     * Displays a single particle which requires additional data that flies into a determined
+     * direction and is only visible for the specified players
+     *
+     * @param data      Data of the effect
+     * @param direction Direction of the particle
+     * @param speed     Display speed of the particles
+     * @param center    Center location of the effect
+     * @param players   Receivers of the effect
+     * @throws ParticleVersionException If the particle effect is not supported by the server
+     *                                  version
+     * @throws ParticleDataException    If the particle effect does not require additional data or
+     *                                  if the data type is incorrect
+     * @see ParticlePacket
+     * @see ParticlePacket#sendTo(Location, List)
+     */
+    public void display(ParticleData data, Vector direction, float speed, Location center, List<Player> players) throws ParticleDataException {
+        if (!hasProperty(ParticleProperty.REQUIRES_DATA)) {
+            throw new ParticleDataException("This particle effect does not require additional data");
+        }
+        if (!isDataCorrect(this, data)) {
+            throw new ParticleDataException("The particle data type is incorrect");
+        }
+        new ParticlePacket(this, direction, speed, true, data).sendTo(center, players);
+    }
+
+    /**
+     * Displays a single particle which requires additional data that flies into a determined
+     * direction and is only visible for the specified players
+     *
+     * @param data      Data of the effect
+     * @param direction Direction of the particle
+     * @param speed     Display speed of the particles
+     * @param center    Center location of the effect
+     * @param players   Receivers of the effect
+     * @throws ParticleVersionException If the particle effect is not supported by the server
+     *                                  version
+     * @throws ParticleDataException    If the particle effect does not require additional data or
+     *                                  if the data type is incorrect
+     * @see #display(ParticleData, Vector, float, Location, List)
+     */
+    public void display(ParticleData data, Vector direction, float speed, Location center, Player... players) throws ParticleDataException {
+        display(data, direction, speed, center, Arrays.asList(players));
+    }
+
+    /**
+     * Represents the property of a particle effect
+     * <p>
+     * This class is part of the <b>ParticleEffect Library</b> and follows the same usage conditions
+     *
+     * @author DarkBlade12
+     * @since 1.7
+     */
+    public static enum ParticleProperty {
+        /**
+         * The particle effect requires water to be displayed
+         */
+        REQUIRES_WATER,
+        /**
+         * The particle effect requires block or item data to be displayed
+         */
+        REQUIRES_DATA,
+        /**
+         * The particle effect uses the offsets as direction values
+         */
+        DIRECTIONAL,
+        /**
+         * The particle effect uses the offsets as color values
+         */
+        COLORABLE;
+    }
+
+    /**
+     * Represents the particle data for effects like {@link ParticleEffect#ITEM_CRACK}, {@link
+     * ParticleEffect#BLOCK_CRACK} and {@link ParticleEffect#BLOCK_DUST} <p> This class is part of
+     * the <b>ParticleEffect Library</b> and follows the same usage conditions
+     *
+     * @author DarkBlade12
+     * @since 1.6
+     */
+    public static abstract class ParticleData {
+        private final Material material;
+        private final byte data;
+        private final int[] packetData;
+
+        /**
+         * Construct a new particle data
+         *
+         * @param material Material of the item/block
+         * @param data     Data value of the item/block
+         */
+        @SuppressWarnings("deprecation")
+        public ParticleData(Material material, byte data) {
+            this.material = material;
+            this.data = data;
+            this.packetData = new int[]{material.getId(), data};
+        }
+
+        /**
+         * Returns the material of this data
+         *
+         * @return The material
+         */
+        public Material getMaterial() {
+            return material;
+        }
+
+        /**
+         * Returns the data value of this data
+         *
+         * @return The data value
+         */
+        public byte getData() {
+            return data;
+        }
+
+        /**
+         * Returns the data as an int array for packet construction
+         *
+         * @return The data for the packet
+         */
+        public int[] getPacketData() {
+            return packetData;
+        }
+
+        /**
+         * Returns the data as a string for pre 1.8 versions
+         *
+         * @return The data string for the packet
+         */
+        public String getPacketDataString() {
+            return "_" + packetData[0] + "_" + packetData[1];
+        }
+    }
+
+    /**
+     * Represents the item data for the {@link ParticleEffect#ITEM_CRACK} effect
+     * <p>
+     * This class is part of the <b>ParticleEffect Library</b> and follows the same usage conditions
+     *
+     * @author DarkBlade12
+     * @since 1.6
+     */
+    public static class ItemData extends ParticleData {
+        /**
+         * Construct a new item data
+         *
+         * @param material Material of the item
+         * @param data     Data value of the item
+         * @see ParticleData#ParticleData(Material, byte)
+         */
+        public ItemData(Material material, byte data) {
+            super(material, data);
+        }
+    }
+
+    /**
+     * Represents the block data for the {@link ParticleEffect#BLOCK_CRACK} and {@link
+     * ParticleEffect#BLOCK_DUST} effects <p> This class is part of the <b>ParticleEffect
+     * Library</b> and follows the same usage conditions
+     *
+     * @author DarkBlade12
+     * @since 1.6
+     */
+    public static class BlockData extends ParticleData {
+        /**
+         * Construct a new block data
+         *
+         * @param material Material of the block
+         * @param data     Data value of the block
+         * @throws IllegalArgumentException If the material is not a block
+         * @see ParticleData#ParticleData(Material, byte)
+         */
+        public BlockData(Material material, byte data) throws IllegalArgumentException {
+            super(material, data);
+            if (!material.isBlock()) {
+                throw new IllegalArgumentException("The material is not a block");
+            }
+        }
+    }
+
+    /**
+     * Represents the color for effects like {@link ParticleEffect#SPELL_MOB}, {@link
+     * ParticleEffect#SPELL_MOB_AMBIENT}, {@link ParticleEffect#REDSTONE} and {@link
+     * ParticleEffect#NOTE} <p> This class is part of the <b>ParticleEffect Library</b> and follows
+     * the same usage conditions
+     *
+     * @author DarkBlade12
+     * @since 1.7
+     */
+    public static abstract class ParticleColor {
+        /**
+         * Returns the value for the offsetX field
+         *
+         * @return The offsetX value
+         */
+        public abstract float getValueX();
+
+        /**
+         * Returns the value for the offsetY field
+         *
+         * @return The offsetY value
+         */
+        public abstract float getValueY();
+
+        /**
+         * Returns the value for the offsetZ field
+         *
+         * @return The offsetZ value
+         */
+        public abstract float getValueZ();
+    }
+
+    /**
+     * Represents the color for effects like {@link ParticleEffect#SPELL_MOB}, {@link
+     * ParticleEffect#SPELL_MOB_AMBIENT} and {@link ParticleEffect#NOTE} <p> This class is part of
+     * the <b>ParticleEffect Library</b> and follows the same usage conditions
+     *
+     * @author DarkBlade12
+     * @since 1.7
+     */
+    public static class OrdinaryColor extends ParticleColor {
+        private final int red;
+        private final int green;
+        private final int blue;
+
+        /**
+         * Construct a new ordinary color
+         *
+         * @param red   Red value of the RGB format
+         * @param green Green value of the RGB format
+         * @param blue  Blue value of the RGB format
+         * @throws IllegalArgumentException If one of the values is lower than 0 or higher than 255
+         */
+        public OrdinaryColor(int red, int green, int blue) {
+            if (red < 0) {
+                throw new IllegalArgumentException("The red value is lower than 0");
+            }
+            if (red > 255) {
+                throw new IllegalArgumentException("The red value is higher than 255");
+            }
+            this.red = red;
+            if (green < 0) {
+                throw new IllegalArgumentException("The green value is lower than 0");
+            }
+            if (green > 255) {
+                throw new IllegalArgumentException("The green value is higher than 255");
+            }
+            this.green = green;
+            if (blue < 0) {
+                throw new IllegalArgumentException("The blue value is lower than 0");
+            }
+            if (blue > 255) {
+                throw new IllegalArgumentException("The blue value is higher than 255");
+            }
+            this.blue = blue;
+        }
+
+        /**
+         * Construct a new ordinary color
+         *
+         * @param color Bukkit color
+         */
+        public OrdinaryColor(Color color) {
+            this(color.getRed(), color.getGreen(), color.getBlue());
+        }
+
+        /**
+         * Returns the red value of the RGB format
+         *
+         * @return The red value
+         */
+        public int getRed() {
+            return red;
+        }
+
+        /**
+         * Returns the green value of the RGB format
+         *
+         * @return The green value
+         */
+        public int getGreen() {
+            return green;
+        }
+
+        /**
+         * Returns the blue value of the RGB format
+         *
+         * @return The blue value
+         */
+        public int getBlue() {
+            return blue;
+        }
+
+        /**
+         * Returns the red value divided by 255
+         *
+         * @return The offsetX value
+         */
+        @Override
+        public float getValueX() {
+            return (float) red / 255F;
+        }
+
+        /**
+         * Returns the green value divided by 255
+         *
+         * @return The offsetY value
+         */
+        @Override
+        public float getValueY() {
+            return (float) green / 255F;
+        }
+
+        /**
+         * Returns the blue value divided by 255
+         *
+         * @return The offsetZ value
+         */
+        @Override
+        public float getValueZ() {
+            return (float) blue / 255F;
+        }
+    }
+
+    /**
+     * Represents the color for the {@link ParticleEffect#NOTE} effect
+     * <p>
+     * This class is part of the <b>ParticleEffect Library</b> and follows the same usage conditions
+     *
+     * @author DarkBlade12
+     * @since 1.7
+     */
+    public static class NoteColor extends ParticleColor {
+        private final int note;
+
+        /**
+         * Construct a new note color
+         *
+         * @param note Note id which determines color
+         * @throws IllegalArgumentException If the note value is lower than 0 or higher than 24
+         */
+        public NoteColor(int note) throws IllegalArgumentException {
+            if (note < 0) {
+                throw new IllegalArgumentException("The note value is lower than 0");
+            }
+            if (note > 24) {
+                throw new IllegalArgumentException("The note value is higher than 24");
+            }
+            this.note = note;
+        }
+
+        /**
+         * Returns the note value divided by 24
+         *
+         * @return The offsetX value
+         */
+        @Override
+        public float getValueX() {
+            return (float) note / 24F;
+        }
+
+        /**
+         * Returns zero because the offsetY value is unused
+         *
+         * @return zero
+         */
+        @Override
+        public float getValueY() {
+            return 0;
+        }
+
+        /**
+         * Returns zero because the offsetZ value is unused
+         *
+         * @return zero
+         */
+        @Override
+        public float getValueZ() {
+            return 0;
+        }
+
+    }
+
+    /**
+     * Represents a runtime exception that is thrown either if the displayed particle effect
+     * requires data and has none or vice-versa or if the data type is incorrect <p> This class is
+     * part of the <b>ParticleEffect Library</b> and follows the same usage conditions
+     *
+     * @author DarkBlade12
+     * @since 1.6
+     */
+    private static final class ParticleDataException extends RuntimeException {
+        private static final long serialVersionUID = 3203085387160737484L;
+
+        /**
+         * Construct a new particle data exception
+         *
+         * @param message Message that will be logged
+         */
+        public ParticleDataException(String message) {
+            super(message);
+        }
+    }
+
+    /**
+     * Represents a runtime exception that is thrown either if the displayed particle effect is not
+     * colorable or if the particle color type is incorrect <p> This class is part of the
+     * <b>ParticleEffect Library</b> and follows the same usage conditions
+     *
+     * @author DarkBlade12
+     * @since 1.7
+     */
+    private static final class ParticleColorException extends RuntimeException {
+        private static final long serialVersionUID = 3203085387160737484L;
+
+        /**
+         * Construct a new particle color exception
+         *
+         * @param message Message that will be logged
+         */
+        public ParticleColorException(String message) {
+            super(message);
+        }
+    }
+
+    /**
+     * Represents a particle effect packet with all attributes which is used for sending packets to
+     * the players <p> This class is part of the <b>ParticleEffect Library</b> and follows the same
+     * usage conditions
+     *
+     * @author DarkBlade12
+     * @since 1.5
+     */
+    public static final class ParticlePacket {
+        private final ParticleEffect effect;
+        private final float offsetY;
+        private final float offsetZ;
+        private final float speed;
+        private final int amount;
+        private final boolean longDistance;
+        private final ParticleData data;
+        private float offsetX;
+        private PacketPlayOutWorldParticles packet;
+
+        /**
+         * Construct a new particle packet
+         *
+         * @param effect       Particle effect
+         * @param offsetX      Maximum distance particles can fly away from the center on the
+         *                     x-axis
+         * @param offsetY      Maximum distance particles can fly away from the center on the
+         *                     y-axis
+         * @param offsetZ      Maximum distance particles can fly away from the center on the
+         *                     z-axis
+         * @param speed        Display speed of the particles
+         * @param amount       Amount of particles
+         * @param longDistance Indicates whether the maximum distance is increased from 256 to
+         *                     65536
+         * @param data         Data of the effect
+         * @throws IllegalArgumentException If the speed or amount is lower than 0
+         * @see #initialize()
+         */
+        public ParticlePacket(ParticleEffect effect, float offsetX, float offsetY, float offsetZ, float speed, int amount, boolean longDistance, ParticleData data) throws IllegalArgumentException {
+            if (speed < 0) {
+                throw new IllegalArgumentException("The speed is lower than 0");
+            }
+            if (amount < 0) {
+                throw new IllegalArgumentException("The amount is lower than 0");
+            }
+            this.effect = effect;
+            this.offsetX = offsetX;
+            this.offsetY = offsetY;
+            this.offsetZ = offsetZ;
+            this.speed = speed;
+            this.amount = amount;
+            this.longDistance = longDistance;
+            this.data = data;
+        }
+
+        /**
+         * Construct a new particle packet of a single particle flying into a determined direction
+         *
+         * @param effect       Particle effect
+         * @param direction    Direction of the particle
+         * @param speed        Display speed of the particle
+         * @param longDistance Indicates whether the maximum distance is increased from 256 to
+         *                     65536
+         * @param data         Data of the effect
+         * @throws IllegalArgumentException If the speed is lower than 0
+         * @see #ParticleEffect(ParticleEffect, float, float, float, float, int, boolean,
+         * ParticleData)
+         */
+        public ParticlePacket(ParticleEffect effect, Vector direction, float speed, boolean longDistance, ParticleData data) throws IllegalArgumentException {
+            this(effect, (float) direction.getX(), (float) direction.getY(), (float) direction.getZ(), speed, 0, longDistance, data);
+        }
+
+        /**
+         * Construct a new particle packet of a single colored particle
+         *
+         * @param effect       Particle effect
+         * @param color        Color of the particle
+         * @param longDistance Indicates whether the maximum distance is increased from 256 to
+         *                     65536
+         * @see #ParticleEffect(ParticleEffect, float, float, float, float, int, boolean,
+         * ParticleData)
+         */
+        public ParticlePacket(ParticleEffect effect, ParticleColor color, boolean longDistance) {
+            this(effect, color.getValueX(), color.getValueY(), color.getValueZ(), 1, 0, longDistance, null);
+            if (effect == ParticleEffect.REDSTONE && color instanceof OrdinaryColor && ((OrdinaryColor) color).getRed() == 0) {
+                offsetX = (float) 1 / 255F;
+            }
+        }
+
+        /**
+         * Initializes {@link #packet} with all set values
+         *
+         * @param center Center location of the effect
+         * @throws PacketInstantiationException If instantion fails due to an unknown error
+         */
+        private void initializePacket(Location center) {
+            if (packet != null) {
+                return;
+            }
+            packet = new PacketPlayOutWorldParticles(this.effect, center, new Vector(offsetX, offsetY, offsetZ), this.speed, this.amount, this.longDistance, data == null ? new int[0] : effect == ParticleEffect.ITEM_CRACK ? data.getPacketData() : new int[]{data.getPacketData()[0] | (data.getPacketData()[1] << 12)});
+        }
+
+        /**
+         * Sends the packet to a single player and caches it
+         *
+         * @param center Center location of the effect
+         * @param player Receiver of the packet
+         * @throws PacketInstantiationException If instantion fails due to an unknown error
+         * @throws PacketSendingException       If sending fails due to an unknown error
+         * @see #initializePacket(Location)
+         */
+        public void sendTo(Location center, Player player) {
+            initializePacket(center);
+            player.sendPacket(packet);
+        }
+
+        /**
+         * Sends the packet to all players in the list
+         *
+         * @param center  Center location of the effect
+         * @param players Receivers of the packet
+         * @throws IllegalArgumentException If the player list is empty
+         * @see #sendTo(Location center, Player player)
+         */
+        public void sendTo(Location center, List<Player> players) throws IllegalArgumentException {
+            if (players.isEmpty()) {
+                throw new IllegalArgumentException("The player list is empty");
+            }
+            for (Player player : players) {
+                sendTo(center, player);
+            }
+        }
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/api/position/BlockPosition.java b/src/main/java/dev/wolveringer/api/position/BlockPosition.java
index 3426246..12a1357 100644
--- a/src/main/java/dev/wolveringer/api/position/BlockPosition.java
+++ b/src/main/java/dev/wolveringer/api/position/BlockPosition.java
@@ -1,10 +1,11 @@
 package dev.wolveringer.api.position;
 
 public class BlockPosition extends Potision<Integer> {
-	public BlockPosition(int x, int y, int z) {
-		super(x, y, z);
-	}
-	public long toLong(){
-		return (x & 67108863L) << 38L | (y & 4095L) << 26L | (z & 67108863L) << 0;
-	}
+    public BlockPosition(int x, int y, int z) {
+        super(x, y, z);
+    }
+
+    public long toLong() {
+        return (x & 67108863L) << 38L | (y & 4095L) << 26L | (z & 67108863L) << 0;
+    }
 }
diff --git a/src/main/java/dev/wolveringer/api/position/Location.java b/src/main/java/dev/wolveringer/api/position/Location.java
index 09cc9c1..2cde760 100644
--- a/src/main/java/dev/wolveringer/api/position/Location.java
+++ b/src/main/java/dev/wolveringer/api/position/Location.java
@@ -6,487 +6,456 @@ import dev.wolveringer.BungeeUtil.NumberConversions;
  * Represents a 3-dimensional position in a world
  */
 public class Location extends Potision<Double> implements Cloneable {
-	/**
-	 * Safely converts a double (location coordinate) to an int (block
-	 * coordinate)
-	 *
-	 * @param loc
-	 *            Precise coordinate
-	 * @return Block coordinate
-	 */
-	public static int locToBlock(double loc) {
-		return NumberConversions.floor(loc);
-	}
-
-	private float pitch;
-	private float yaw;
-
-	/**
-	 * Constructs a new Location with the given coordinates
-	 *
-	 * @param world
-	 *            The world in which this location resides
-	 * @param x
-	 *            The x-coordinate of this new location
-	 * @param y
-	 *            The y-coordinate of this new location
-	 * @param z
-	 *            The z-coordinate of this new location
-	 */
-	public Location(final double x, final double y, final double z) {
-		this(x, y, z, 0, 0);
-	}
-
-	/**
-	 * Constructs a new Location with the given coordinates and direction
-	 *
-	 * @param world
-	 *            The world in which this location resides
-	 * @param x
-	 *            The x-coordinate of this new location
-	 * @param y
-	 *            The y-coordinate of this new location
-	 * @param z
-	 *            The z-coordinate of this new location
-	 * @param yaw
-	 *            The absolute rotation on the x-plane, in degrees
-	 * @param pitch
-	 *            The absolute rotation on the y-plane, in degrees
-	 */
-	public Location(final double x, final double y, final double z, final float yaw, final float pitch) {
-		super(x,y,z);
-		this.pitch = pitch;
-		this.yaw = yaw;
-	}
-
-	/**
-	 * Adds the location by another. Not world-aware.
-	 *
-	 * @see Vector
-	 * @param x
-	 *            X coordinate
-	 * @param y
-	 *            Y coordinate
-	 * @param z
-	 *            Z coordinate
-	 * @return the same location
-	 */
-	public Location add(double x, double y, double z) {
-		this.x += x;
-		this.y += y;
-		this.z += z;
-		return this;
-	}
-
-	/**
-	 * Adds the location by another.
-	 *
-	 * @see Vector
-	 * @param vec
-	 *            The other location
-	 * @return the same location
-	 * @throws IllegalArgumentException
-	 *             for differing worlds
-	 */
-	public Location add(Location vec) {
-		if(vec == null){
-			throw new IllegalArgumentException("Cannot add Locations of differing worlds");
-		}
-
-		x += vec.x;
-		y += vec.y;
-		z += vec.z;
-		return this;
-	}
-
-	/**
-	 * Adds the location by a vector.
-	 *
-	 * @see Vector
-	 * @param vec
-	 *            Vector to use
-	 * @return the same location
-	 */
-	public Location add(Vector vec) {
-		this.x += vec.getX();
-		this.y += vec.getY();
-		this.z += vec.getZ();
-		return this;
-	}
-
-	@Override
-	public Location clone() {
-		try{
-			return (Location) super.clone();
-		}catch (CloneNotSupportedException e){
-			throw new Error(e);
-		}
-	}
-
-	/**
-	 * Get the distance between this location and another. The value of this
-	 * method is not cached and uses a costly square-root function, so do not
-	 * repeatedly call this method to get the location's magnitude. NaN will
-	 * be returned if the inner result of the sqrt() function overflows, which
-	 * will be caused if the distance is too long.
-	 *
-	 * @see Vector
-	 * @param o
-	 *            The other location
-	 * @return the distance
-	**/
-	public double distance(Location o) {
-		return Math.sqrt(distanceSquared(o));
-	}
-
-	/**
-	 * Get the squared distance between this location and another.
-	 *
-	 * @see Vector
-	 * @param o
-	 *            The other location
-	 * @return the distance
-	 * @throws IllegalArgumentException
-	 *             for differing worlds
-	 */
-	public double distanceSquared(Location o) {
-		if(o == null){
-			throw new IllegalArgumentException("Cannot measure distance to a null location");
-		}
-
-		return NumberConversions.square(x - o.x) + NumberConversions.square(y - o.y) + NumberConversions.square(z - o.z);
-	}
-
-	@Override
-	public boolean equals(Object obj) {
-		if(obj == null){
-			return false;
-		}
-		if(getClass() != obj.getClass()){
-			return false;
-		}
-		final Location other = (Location) obj;
-		if(Double.doubleToLongBits(this.x) != Double.doubleToLongBits(other.x)){
-			return false;
-		}
-		if(Double.doubleToLongBits(this.y) != Double.doubleToLongBits(other.y)){
-			return false;
-		}
-		if(Double.doubleToLongBits(this.z) != Double.doubleToLongBits(other.z)){
-			return false;
-		}
-		if(Float.floatToIntBits(this.pitch) != Float.floatToIntBits(other.pitch)){
-			return false;
-		}
-		if(Float.floatToIntBits(this.yaw) != Float.floatToIntBits(other.yaw)){
-			return false;
-		}
-		return true;
-	}
-
-	/**
-	 * Gets the floored value of the X component, indicating the block that
-	 * this location is contained with.
-	 *
-	 * @return block X
-	 */
-	public int getBlockX() {
-		return locToBlock(x);
-	}
-
-	/**
-	 * Gets the floored value of the Y component, indicating the block that
-	 * this location is contained with.
-	 *
-	 * @return block y
-	 */
-	public int getBlockY() {
-		return locToBlock(y);
-	}
-
-	/**
-	 * Gets the floored value of the Z component, indicating the block that
-	 * this location is contained with.
-	 *
-	 * @return block z
-	 */
-	public int getBlockZ() {
-		return locToBlock(z);
-	}
-
-	/**
-	 * Gets a unit-vector pointing in the direction that this Location is
-	 * facing.
-	 *
-	 * @return a vector pointing the direction of this location's
-	 *         {@link #getPitch() pitch} and {@link #getYaw() yaw}
-	 */
-	public Vector getDirection() {
-		Vector vector = new Vector();
-
-		double rotX = this.getYaw();
-		double rotY = this.getPitch();
-
-		vector.setY(-Math.sin(Math.toRadians(rotY)));
-
-		double xz = Math.cos(Math.toRadians(rotY));
-
-		vector.setX(-xz * Math.sin(Math.toRadians(rotX)));
-		vector.setZ(xz * Math.cos(Math.toRadians(rotX)));
-
-		return vector;
-	}
-
-	/**
-	 * Gets the pitch of this location, measured in degrees.
-	 * <ul>
-	 * <li>A pitch of 0 represents level forward facing.
-	 * <li>A pitch of 90 represents downward facing, or negative y direction.
-	 * <li>A pitch of -90 represents upward facing, or positive y direction.
-	 * <ul>
-	 * Increasing pitch values the equivalent of looking down.
-	 *
-	 * @return the incline's pitch
-	 */
-	public float getPitch() {
-		return pitch;
-	}
-
-	/**
-	 * Gets the yaw of this location, measured in degrees.
-	 * <ul>
-	 * <li>A yaw of 0 or 360 represents the positive z direction.
-	 * <li>A yaw of 180 represents the negative z direction.
-	 * <li>A yaw of 90 represents the negative x direction.
-	 * <li>A yaw of 270 represents the positive x direction.
-	 * </ul>
-	 * Increasing yaw values are the equivalent of turning to your
-	 * right-facing, increasing the scale of the next respective axis, and
-	 * decreasing the scale of the previous axis.
-	 *
-	 * @return the rotation's yaw
-	 */
-	public float getYaw() {
-		return yaw;
-	}
-
-	/**
-	 * Gets the magnitude of the location, defined as sqrt(x^2+y^2+z^2). The
-	 * value of this method is not cached and uses a costly square-root
-	 * function, so do not repeatedly call this method to get the location's
-	 * magnitude. NaN will be returned if the inner result of the sqrt()
-	 * function overflows, which will be caused if the length is too long. Not
-	 * world-aware and orientation independent.
-	 *
-	 * @see Vector
-	 * @return the magnitude
-	 */
-	public double length() {
-		return Math.sqrt(NumberConversions.square(x) + NumberConversions.square(y) + NumberConversions.square(z));
-	}
-
-	/**
-	 * Gets the magnitude of the location squared. Not world-aware and
-	 * orientation independent.
-	 *
-	 * @see Vector
-	 * @return the magnitude
-	 */
-	public double lengthSquared() {
-		return NumberConversions.square(x) + NumberConversions.square(y) + NumberConversions.square(z);
-	}
-
-	/**
-	 * Performs scalar multiplication, multiplying all components with a
-	 * scalar. Not world-aware.
-	 *
-	 * @param m
-	 *            The factor
-	 * @see Vector
-	 * @return the same location
-	 */
-	public Location multiply(double m) {
-		x *= m;
-		y *= m;
-		z *= m;
-		return this;
-	}
-
-	/**
-	 * @param m
-	 *            The factor
-	 * @see Vector
-	 * @return the same location
-	 */
-	public Location dividide(double m) {
-		x /= m;
-		y /= m;
-		z /= m;
-		return this;
-	}
-	
-	/**
-	 * Sets the {@link #getYaw() yaw} and {@link #getPitch() pitch} to point
-	 * in the direction of the vector.
-	 */
-	public Location setDirection(Vector vector) {
-		/*
-		 * Sin = Opp / Hyp
+    private float pitch;
+    private float yaw;
+
+    /**
+     * Constructs a new Location with the given coordinates
+     *
+     * @param world The world in which this location resides
+     * @param x     The x-coordinate of this new location
+     * @param y     The y-coordinate of this new location
+     * @param z     The z-coordinate of this new location
+     */
+    public Location(final double x, final double y, final double z) {
+        this(x, y, z, 0, 0);
+    }
+
+    /**
+     * Constructs a new Location with the given coordinates and direction
+     *
+     * @param world The world in which this location resides
+     * @param x     The x-coordinate of this new location
+     * @param y     The y-coordinate of this new location
+     * @param z     The z-coordinate of this new location
+     * @param yaw   The absolute rotation on the x-plane, in degrees
+     * @param pitch The absolute rotation on the y-plane, in degrees
+     */
+    public Location(final double x, final double y, final double z, final float yaw, final float pitch) {
+        super(x, y, z);
+        this.pitch = pitch;
+        this.yaw = yaw;
+    }
+
+    /**
+     * Safely converts a double (location coordinate) to an int (block
+     * coordinate)
+     *
+     * @param loc Precise coordinate
+     * @return Block coordinate
+     */
+    public static int locToBlock(double loc) {
+        return NumberConversions.floor(loc);
+    }
+
+    /**
+     * Adds the location by another. Not world-aware.
+     *
+     * @param x X coordinate
+     * @param y Y coordinate
+     * @param z Z coordinate
+     * @return the same location
+     * @see Vector
+     */
+    public Location add(double x, double y, double z) {
+        this.x += x;
+        this.y += y;
+        this.z += z;
+        return this;
+    }
+
+    /**
+     * Adds the location by another.
+     *
+     * @param vec The other location
+     * @return the same location
+     * @throws IllegalArgumentException for differing worlds
+     * @see Vector
+     */
+    public Location add(Location vec) {
+        if (vec == null) {
+            throw new IllegalArgumentException("Cannot add Locations of differing worlds");
+        }
+
+        x += vec.x;
+        y += vec.y;
+        z += vec.z;
+        return this;
+    }
+
+    /**
+     * Adds the location by a vector.
+     *
+     * @param vec Vector to use
+     * @return the same location
+     * @see Vector
+     */
+    public Location add(Vector vec) {
+        this.x += vec.getX();
+        this.y += vec.getY();
+        this.z += vec.getZ();
+        return this;
+    }
+
+    @Override
+    public Location clone() {
+        try {
+            return (Location) super.clone();
+        } catch (CloneNotSupportedException e) {
+            throw new Error(e);
+        }
+    }
+
+    /**
+     * Get the distance between this location and another. The value of this
+     * method is not cached and uses a costly square-root function, so do not
+     * repeatedly call this method to get the location's magnitude. NaN will
+     * be returned if the inner result of the sqrt() function overflows, which
+     * will be caused if the distance is too long.
+     *
+     * @param o The other location
+     * @return the distance
+     * @see Vector
+     **/
+    public double distance(Location o) {
+        return Math.sqrt(distanceSquared(o));
+    }
+
+    /**
+     * Get the squared distance between this location and another.
+     *
+     * @param o The other location
+     * @return the distance
+     * @throws IllegalArgumentException for differing worlds
+     * @see Vector
+     */
+    public double distanceSquared(Location o) {
+        if (o == null) {
+            throw new IllegalArgumentException("Cannot measure distance to a null location");
+        }
+
+        return NumberConversions.square(x - o.x) + NumberConversions.square(y - o.y) + NumberConversions.square(z - o.z);
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (obj == null) {
+            return false;
+        }
+        if (getClass() != obj.getClass()) {
+            return false;
+        }
+        final Location other = (Location) obj;
+        if (Double.doubleToLongBits(this.x) != Double.doubleToLongBits(other.x)) {
+            return false;
+        }
+        if (Double.doubleToLongBits(this.y) != Double.doubleToLongBits(other.y)) {
+            return false;
+        }
+        if (Double.doubleToLongBits(this.z) != Double.doubleToLongBits(other.z)) {
+            return false;
+        }
+        if (Float.floatToIntBits(this.pitch) != Float.floatToIntBits(other.pitch)) {
+            return false;
+        }
+        if (Float.floatToIntBits(this.yaw) != Float.floatToIntBits(other.yaw)) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * Gets the floored value of the X component, indicating the block that
+     * this location is contained with.
+     *
+     * @return block X
+     */
+    public int getBlockX() {
+        return locToBlock(x);
+    }
+
+    /**
+     * Gets the floored value of the Y component, indicating the block that
+     * this location is contained with.
+     *
+     * @return block y
+     */
+    public int getBlockY() {
+        return locToBlock(y);
+    }
+
+    /**
+     * Gets the floored value of the Z component, indicating the block that
+     * this location is contained with.
+     *
+     * @return block z
+     */
+    public int getBlockZ() {
+        return locToBlock(z);
+    }
+
+    /**
+     * Gets a unit-vector pointing in the direction that this Location is
+     * facing.
+     *
+     * @return a vector pointing the direction of this location's {@link #getPitch() pitch} and
+     * {@link #getYaw() yaw}
+     */
+    public Vector getDirection() {
+        Vector vector = new Vector();
+
+        double rotX = this.getYaw();
+        double rotY = this.getPitch();
+
+        vector.setY(-Math.sin(Math.toRadians(rotY)));
+
+        double xz = Math.cos(Math.toRadians(rotY));
+
+        vector.setX(-xz * Math.sin(Math.toRadians(rotX)));
+        vector.setZ(xz * Math.cos(Math.toRadians(rotX)));
+
+        return vector;
+    }
+
+    /**
+     * Sets the {@link #getYaw() yaw} and {@link #getPitch() pitch} to point
+     * in the direction of the vector.
+     */
+    public Location setDirection(Vector vector) {
+        /*
+         * Sin = Opp / Hyp
 		 * Cos = Adj / Hyp
 		 * Tan = Opp / Adj
 		 * x = -Opp
 		 * z = Adj
 		 */
-		final double _2PI = 2 * Math.PI;
-		final double x = vector.getX();
-		final double z = vector.getZ();
-
-		if(x == 0 && z == 0){
-			pitch = vector.getY() > 0 ? -90 : 90;
-			return this;
-		}
-
-		double theta = Math.atan2(-x, z);
-		yaw = (float) Math.toDegrees((theta + _2PI) % _2PI);
-
-		double x2 = NumberConversions.square(x);
-		double z2 = NumberConversions.square(z);
-		double xz = Math.sqrt(x2 + z2);
-		pitch = (float) Math.toDegrees(Math.atan(-vector.getY() / xz));
-
-		return this;
-	}
-
-	/**
-	 * Sets the pitch of this location, measured in degrees.
-	 * <ul>
-	 * <li>A pitch of 0 represents level forward facing.
-	 * <li>A pitch of 90 represents downward facing, or negative y direction.
-	 * <li>A pitch of -90 represents upward facing, or positive y direction.
-	 * <ul>
-	 * Increasing pitch values the equivalent of looking down.
-	 *
-	 * @param pitch
-	 *            new incline's pitch
-	 */
-	public Location setPitch(float pitch) {
-		this.pitch = pitch;
-		return this;
-	}
-
-	/**
-	 * Sets the yaw of this location, measured in degrees.
-	 * <ul>
-	 * <li>A yaw of 0 or 360 represents the positive z direction.
-	 * <li>A yaw of 180 represents the negative z direction.
-	 * <li>A yaw of 90 represents the negative x direction.
-	 * <li>A yaw of 270 represents the positive x direction.
-	 * </ul>
-	 * Increasing yaw values are the equivalent of turning to your
-	 * right-facing, increasing the scale of the next respective axis, and
-	 * decreasing the scale of the previous axis.
-	 *
-	 * @param yaw
-	 *            new rotation's yaw
-	 */
-	public Location setYaw(float yaw) {
-		this.yaw = yaw;
-		return this;
-	}
-
-	/**
-	 * Subtracts the location by another. Not world-aware and
-	 * orientation independent.
-	 *
-	 * @see Vector
-	 * @param x
-	 *            X coordinate
-	 * @param y
-	 *            Y coordinate
-	 * @param z
-	 *            Z coordinate
-	 * @return the same location
-	 */
-	public Location subtract(double x, double y, double z) {
-		this.x -= x;
-		this.y -= y;
-		this.z -= z;
-		return this;
-	}
-
-	/**
-	 * Subtracts the location by another.
-	 *
-	 * @see Vector
-	 * @param vec
-	 *            The other location
-	 * @return the same location
-	 * @throws IllegalArgumentException
-	 *             for differing worlds
-	 */
-	public Location subtract(Location vec) {
-		if(vec == null){
-			throw new IllegalArgumentException("Cannot add Locations of differing worlds");
-		}
-
-		x -= vec.x;
-		y -= vec.y;
-		z -= vec.z;
-		return this;
-	}
-
-	/**
-	 * Subtracts the location by a vector.
-	 *
-	 * @see Vector
-	 * @param vec
-	 *            The vector to use
-	 * @return the same location
-	 */
-	public Location subtract(Vector vec) {
-		this.x -= vec.getX();
-		this.y -= vec.getY();
-		this.z -= vec.getZ();
-		return this;
-	}
-
-	@Override
-	public String toString() {
-		return "Location{x=" + x + ",y=" + y + ",z=" + z + ",pitch=" + pitch + ",yaw=" + yaw + '}';
-	}
-
-	/**
-	 * Constructs a new {@link Vector} based on this Location
-	 *
-	 * @return New Vector containing the coordinates represented by this
-	 *         Location
-	 */
-	public Vector toVector() {
-		return new Vector(x, y, z);
-	}
-
-	/**
-	 * Zero this location's components. Not world-aware.
-	 *
-	 * @see Vector
-	 * @return the same location
-	 */
-	public Location zero() {
-		x = 0D;
-		y = 0D;
-		z = 0D;
-		return this;
-	}
-	
-	@Override
-	public int hashCode() {
-		int hash = 3;
-
-		hash = 19 * hash + (int) (Double.doubleToLongBits(this.x) ^ Double.doubleToLongBits(this.x) >>> 32);
-		hash = 19 * hash + (int) (Double.doubleToLongBits(this.y) ^ Double.doubleToLongBits(this.y) >>> 32);
-		hash = 19 * hash + (int) (Double.doubleToLongBits(this.z) ^ Double.doubleToLongBits(this.z) >>> 32);
-		hash = 19 * hash + Float.floatToIntBits(this.pitch);
-		hash = 19 * hash + Float.floatToIntBits(this.yaw);
-		return hash;
-	}
+        final double _2PI = 2 * Math.PI;
+        final double x = vector.getX();
+        final double z = vector.getZ();
+
+        if (x == 0 && z == 0) {
+            pitch = vector.getY() > 0 ? -90 : 90;
+            return this;
+        }
+
+        double theta = Math.atan2(-x, z);
+        yaw = (float) Math.toDegrees((theta + _2PI) % _2PI);
+
+        double x2 = NumberConversions.square(x);
+        double z2 = NumberConversions.square(z);
+        double xz = Math.sqrt(x2 + z2);
+        pitch = (float) Math.toDegrees(Math.atan(-vector.getY() / xz));
+
+        return this;
+    }
+
+    /**
+     * Gets the pitch of this location, measured in degrees.
+     * <ul>
+     * <li>A pitch of 0 represents level forward facing.
+     * <li>A pitch of 90 represents downward facing, or negative y direction.
+     * <li>A pitch of -90 represents upward facing, or positive y direction.
+     * <ul>
+     * Increasing pitch values the equivalent of looking down.
+     *
+     * @return the incline's pitch
+     */
+    public float getPitch() {
+        return pitch;
+    }
+
+    /**
+     * Sets the pitch of this location, measured in degrees.
+     * <ul>
+     * <li>A pitch of 0 represents level forward facing.
+     * <li>A pitch of 90 represents downward facing, or negative y direction.
+     * <li>A pitch of -90 represents upward facing, or positive y direction.
+     * <ul>
+     * Increasing pitch values the equivalent of looking down.
+     *
+     * @param pitch new incline's pitch
+     */
+    public Location setPitch(float pitch) {
+        this.pitch = pitch;
+        return this;
+    }
+
+    /**
+     * Gets the yaw of this location, measured in degrees.
+     * <ul>
+     * <li>A yaw of 0 or 360 represents the positive z direction.
+     * <li>A yaw of 180 represents the negative z direction.
+     * <li>A yaw of 90 represents the negative x direction.
+     * <li>A yaw of 270 represents the positive x direction.
+     * </ul>
+     * Increasing yaw values are the equivalent of turning to your
+     * right-facing, increasing the scale of the next respective axis, and
+     * decreasing the scale of the previous axis.
+     *
+     * @return the rotation's yaw
+     */
+    public float getYaw() {
+        return yaw;
+    }
+
+    /**
+     * Sets the yaw of this location, measured in degrees.
+     * <ul>
+     * <li>A yaw of 0 or 360 represents the positive z direction.
+     * <li>A yaw of 180 represents the negative z direction.
+     * <li>A yaw of 90 represents the negative x direction.
+     * <li>A yaw of 270 represents the positive x direction.
+     * </ul>
+     * Increasing yaw values are the equivalent of turning to your
+     * right-facing, increasing the scale of the next respective axis, and
+     * decreasing the scale of the previous axis.
+     *
+     * @param yaw new rotation's yaw
+     */
+    public Location setYaw(float yaw) {
+        this.yaw = yaw;
+        return this;
+    }
+
+    /**
+     * Gets the magnitude of the location, defined as sqrt(x^2+y^2+z^2). The
+     * value of this method is not cached and uses a costly square-root
+     * function, so do not repeatedly call this method to get the location's
+     * magnitude. NaN will be returned if the inner result of the sqrt()
+     * function overflows, which will be caused if the length is too long. Not
+     * world-aware and orientation independent.
+     *
+     * @return the magnitude
+     * @see Vector
+     */
+    public double length() {
+        return Math.sqrt(NumberConversions.square(x) + NumberConversions.square(y) + NumberConversions.square(z));
+    }
+
+    /**
+     * Gets the magnitude of the location squared. Not world-aware and
+     * orientation independent.
+     *
+     * @return the magnitude
+     * @see Vector
+     */
+    public double lengthSquared() {
+        return NumberConversions.square(x) + NumberConversions.square(y) + NumberConversions.square(z);
+    }
+
+    /**
+     * Performs scalar multiplication, multiplying all components with a
+     * scalar. Not world-aware.
+     *
+     * @param m The factor
+     * @return the same location
+     * @see Vector
+     */
+    public Location multiply(double m) {
+        x *= m;
+        y *= m;
+        z *= m;
+        return this;
+    }
+
+    /**
+     * @param m The factor
+     * @return the same location
+     * @see Vector
+     */
+    public Location dividide(double m) {
+        x /= m;
+        y /= m;
+        z /= m;
+        return this;
+    }
+
+    /**
+     * Subtracts the location by another. Not world-aware and
+     * orientation independent.
+     *
+     * @param x X coordinate
+     * @param y Y coordinate
+     * @param z Z coordinate
+     * @return the same location
+     * @see Vector
+     */
+    public Location subtract(double x, double y, double z) {
+        this.x -= x;
+        this.y -= y;
+        this.z -= z;
+        return this;
+    }
+
+    /**
+     * Subtracts the location by another.
+     *
+     * @param vec The other location
+     * @return the same location
+     * @throws IllegalArgumentException for differing worlds
+     * @see Vector
+     */
+    public Location subtract(Location vec) {
+        if (vec == null) {
+            throw new IllegalArgumentException("Cannot add Locations of differing worlds");
+        }
+
+        x -= vec.x;
+        y -= vec.y;
+        z -= vec.z;
+        return this;
+    }
+
+    /**
+     * Subtracts the location by a vector.
+     *
+     * @param vec The vector to use
+     * @return the same location
+     * @see Vector
+     */
+    public Location subtract(Vector vec) {
+        this.x -= vec.getX();
+        this.y -= vec.getY();
+        this.z -= vec.getZ();
+        return this;
+    }
+
+    @Override
+    public String toString() {
+        return "Location{x=" + x + ",y=" + y + ",z=" + z + ",pitch=" + pitch + ",yaw=" + yaw + '}';
+    }
+
+    /**
+     * Constructs a new {@link Vector} based on this Location
+     *
+     * @return New Vector containing the coordinates represented by this Location
+     */
+    public Vector toVector() {
+        return new Vector(x, y, z);
+    }
+
+    /**
+     * Zero this location's components. Not world-aware.
+     *
+     * @return the same location
+     * @see Vector
+     */
+    public Location zero() {
+        x = 0D;
+        y = 0D;
+        z = 0D;
+        return this;
+    }
+
+    @Override
+    public int hashCode() {
+        int hash = 3;
+
+        hash = 19 * hash + (int) (Double.doubleToLongBits(this.x) ^ Double.doubleToLongBits(this.x) >>> 32);
+        hash = 19 * hash + (int) (Double.doubleToLongBits(this.y) ^ Double.doubleToLongBits(this.y) >>> 32);
+        hash = 19 * hash + (int) (Double.doubleToLongBits(this.z) ^ Double.doubleToLongBits(this.z) >>> 32);
+        hash = 19 * hash + Float.floatToIntBits(this.pitch);
+        hash = 19 * hash + Float.floatToIntBits(this.yaw);
+        return hash;
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/api/position/Potision.java b/src/main/java/dev/wolveringer/api/position/Potision.java
index 725d1ee..0b9e3e1 100644
--- a/src/main/java/dev/wolveringer/api/position/Potision.java
+++ b/src/main/java/dev/wolveringer/api/position/Potision.java
@@ -1,68 +1,65 @@
 package dev.wolveringer.api.position;
 
 public class Potision<T> {
-	protected T x;
-	protected T y;
-	protected T z;
+    protected T x;
+    protected T y;
+    protected T z;
 
-	public Potision(T x, T y, T z) {
-		this.x = x;
-		this.y = y;
-		this.z = z;
-	}
+    public Potision(T x, T y, T z) {
+        this.x = x;
+        this.y = y;
+        this.z = z;
+    }
 
-	public T getX() {
-		return x;
-	}
+    public T getX() {
+        return x;
+    }
 
-	public void setX(T x) {
-		this.x = x;
-	}
+    public void setX(T x) {
+        this.x = x;
+    }
 
-	public T getY() {
-		return y;
-	}
+    public T getY() {
+        return y;
+    }
 
-	public void setY(T y) {
-		this.y = y;
-	}
+    public void setY(T y) {
+        this.y = y;
+    }
 
-	public T getZ() {
-		return z;
-	}
+    public T getZ() {
+        return z;
+    }
 
-	public void setZ(T z) {
-		this.z = z;
-	}
+    public void setZ(T z) {
+        this.z = z;
+    }
 
-	@Override
-	public int hashCode() {
-		final int prime = 31;
-		int result = 1;
-		result = prime * result + ((x == null) ? 0 : x.hashCode());
-		result = prime * result + ((y == null) ? 0 : y.hashCode());
-		result = prime * result + ((z == null) ? 0 : z.hashCode());
-		return result;
-	}
+    @Override
+    public int hashCode() {
+        final int prime = 31;
+        int result = 1;
+        result = prime * result + ((x == null) ? 0 : x.hashCode());
+        result = prime * result + ((y == null) ? 0 : y.hashCode());
+        result = prime * result + ((z == null) ? 0 : z.hashCode());
+        return result;
+    }
 
-	@Override
-	public boolean equals(Object obj) {
-		if (this == obj) return true;
-		if (obj == null) return false;
-		if (getClass() != obj.getClass()) return false;
-		Potision other = (Potision) obj;
-		if (x == null) {
-			if (other.x != null) return false;
-		}
-		else if (!x.equals(other.x)) return false;
-		if (y == null) {
-			if (other.y != null) return false;
-		}
-		else if (!y.equals(other.y)) return false;
-		if (z == null) {
-			if (other.z != null) return false;
-		}
-		else if (!z.equals(other.z)) return false;
-		return true;
-	}
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj) return true;
+        if (obj == null) return false;
+        if (getClass() != obj.getClass()) return false;
+        Potision other = (Potision) obj;
+        if (x == null) {
+            if (other.x != null) return false;
+        } else if (!x.equals(other.x)) return false;
+        if (y == null) {
+            if (other.y != null) return false;
+        } else if (!y.equals(other.y)) return false;
+        if (z == null) {
+            if (other.z != null) return false;
+        } else if (!z.equals(other.z)) return false;
+        return true;
+    }
 }
diff --git a/src/main/java/dev/wolveringer/api/position/Vector.java b/src/main/java/dev/wolveringer/api/position/Vector.java
index 792ce35..8a9b555 100644
--- a/src/main/java/dev/wolveringer/api/position/Vector.java
+++ b/src/main/java/dev/wolveringer/api/position/Vector.java
@@ -14,677 +14,630 @@ import dev.wolveringer.BungeeUtil.NumberConversions;
  */
 
 public class Vector implements Cloneable {
-	/**
-	 * Threshold for fuzzy equals().
-	 */
-	private static final double epsilon = 0.000001;
-
-	private static Random random = new Random();
-
-	public static Vector deserialize(Map<String, Object> args) {
-		double x = 0;
-		double y = 0;
-		double z = 0;
-
-		if(args.containsKey("x")){
-			x = (Double) args.get("x");
-		}
-		if(args.containsKey("y")){
-			y = (Double) args.get("y");
-		}
-		if(args.containsKey("z")){
-			z = (Double) args.get("z");
-		}
-
-		return new Vector(x, y, z);
-	}
-
-	/**
-	 * Get the threshold used for equals().
-	 *
-	 * @return The epsilon.
-	 */
-	public static double getEpsilon() {
-		return epsilon;
-	}
-
-	/**
-	 * Gets the maximum components of two vectors.
-	 *
-	 * @param v1
-	 *            The first vector.
-	 * @param v2
-	 *            The second vector.
-	 * @return maximum
-	 */
-	public static Vector getMaximum(Vector v1, Vector v2) {
-		return new Vector(Math.max(v1.x, v2.x), Math.max(v1.y, v2.y), Math.max(v1.z, v2.z));
-	}
-
-	/**
-	 * Gets the minimum components of two vectors.
-	 *
-	 * @param v1
-	 *            The first vector.
-	 * @param v2
-	 *            The second vector.
-	 * @return minimum
-	 */
-	public static Vector getMinimum(Vector v1, Vector v2) {
-		return new Vector(Math.min(v1.x, v2.x), Math.min(v1.y, v2.y), Math.min(v1.z, v2.z));
-	}
-
-	/**
-	 * Gets a random vector with components having a random value between 0
-	 * and 1.
-	 *
-	 * @return A random vector.
-	 */
-	public static Vector getRandom() {
-		return new Vector(random.nextDouble(), random.nextDouble(), random.nextDouble());
-	}
-
-	protected double x;
-
-	protected double y;
-
-	protected double z;
-
-	/**
-	 * Construct the vector with all components as 0.
-	 */
-	public Vector() {
-		this.x = 0;
-		this.y = 0;
-		this.z = 0;
-	}
-
-	/**
-	 * Construct the vector with provided double components.
-	 *
-	 * @param x
-	 *            X component
-	 * @param y
-	 *            Y component
-	 * @param z
-	 *            Z component
-	 */
-	public Vector(double x, double y, double z) {
-		this.x = x;
-		this.y = y;
-		this.z = z;
-	}
-
-	/**
-	 * Construct the vector with provided float components.
-	 *
-	 * @param x
-	 *            X component
-	 * @param y
-	 *            Y component
-	 * @param z
-	 *            Z component
-	 */
-	public Vector(float x, float y, float z) {
-		this.x = x;
-		this.y = y;
-		this.z = z;
-	}
-
-	/**
-	 * Construct the vector with provided integer components.
-	 *
-	 * @param x
-	 *            X component
-	 * @param y
-	 *            Y component
-	 * @param z
-	 *            Z component
-	 */
-	public Vector(int x, int y, int z) {
-		this.x = x;
-		this.y = y;
-		this.z = z;
-	}
-
-	/**
-	 * Adds a vector to this one
-	 *
-	 * @param vec
-	 *            The other vector
-	 * @return the same vector
-	 */
-	public Vector add(Vector vec) {
-		x += vec.x;
-		y += vec.y;
-		z += vec.z;
-		return this;
-	}
-
-	/**
-	 * Gets the angle between this vector and another in radians.
-	 *
-	 * @param other
-	 *            The other vector
-	 * @return angle in radians
-	 */
-	public float angle(Vector other) {
-		double dot = dot(other) / (length() * other.length());
-
-		return (float) Math.acos(dot);
-	}
-
-	/**
-	 * Get a new vector.
-	 *
-	 * @return vector
-	 */
-	@Override
-	public Vector clone() {
-		try{
-			return (Vector) super.clone();
-		}catch (CloneNotSupportedException e){
-			throw new Error(e);
-		}
-	}
-
-	/**
-	 * Copies another vector
-	 *
-	 * @param vec
-	 *            The other vector
-	 * @return the same vector
-	 */
-	public Vector copy(Vector vec) {
-		x = vec.x;
-		y = vec.y;
-		z = vec.z;
-		return this;
-	}
-
-	/**
-	 * Calculates the cross product of this vector with another. The cross
-	 * product is defined as:
-	 * <ul>
-	 * <li>x = y1 * z2 - y2 * z1
-	 * <li>y = z1 * x2 - z2 * x1
-	 * <li>z = x1 * y2 - x2 * y1
-	 * </ul>
-	 *
-	 * @param o
-	 *            The other vector
-	 * @return the same vector
-	 */
-	public Vector crossProduct(Vector o) {
-		double newX = y * o.z - o.y * z;
-		double newY = z * o.x - o.z * x;
-		double newZ = x * o.y - o.x * y;
-
-		x = newX;
-		y = newY;
-		z = newZ;
-		return this;
-	}
-
-	/**
-	 * Get the distance between this vector and another. The value of this
-	 * method is not cached and uses a costly square-root function, so do not
-	 * repeatedly call this method to get the vector's magnitude. NaN will be
-	 * returned if the inner result of the sqrt() function overflows, which
-	 * will be caused if the distance is too long.
-	 *
-	 * @param o
-	 *            The other vector
-	 * @return the distance
-	 */
-	public double distance(Vector o) {
-		return Math.sqrt(NumberConversions.square(x - o.x) + NumberConversions.square(y - o.y) + NumberConversions.square(z - o.z));
-	}
-
-	/**
-	 * Get the squared distance between this vector and another.
-	 *
-	 * @param o
-	 *            The other vector
-	 * @return the distance
-	 */
-	public double distanceSquared(Vector o) {
-		return NumberConversions.square(x - o.x) + NumberConversions.square(y - o.y) + NumberConversions.square(z - o.z);
-	}
-
-	/**
-	 * Divides the vector by another.
-	 *
-	 * @param vec
-	 *            The other vector
-	 * @return the same vector
-	 */
-	public Vector divide(Vector vec) {
-		x /= vec.x;
-		y /= vec.y;
-		z /= vec.z;
-		return this;
-	}
-
-	/**
-	 * Calculates the dot product of this vector with another. The dot product
-	 * is defined as x1*x2+y1*y2+z1*z2. The returned value is a scalar.
-	 *
-	 * @param other
-	 *            The other vector
-	 * @return dot product
-	 */
-	public double dot(Vector other) {
-		return x * other.x + y * other.y + z * other.z;
-	}
-
-	/**
-	 * Checks to see if two objects are equal.
-	 * <p>
-	 * Only two Vectors can ever return true. This method uses a fuzzy match to
-	 * account for floating point errors. The epsilon can be retrieved with
-	 * epsilon.
-	 */
-	@Override
-	public boolean equals(Object obj) {
-		if(!(obj instanceof Vector)){
-			return false;
-		}
-
-		Vector other = (Vector) obj;
-
-		return Math.abs(x - other.x) < epsilon && Math.abs(y - other.y) < epsilon && Math.abs(z - other.z) < epsilon && this.getClass().equals(obj.getClass());
-	}
-
-	/**
-	 * Gets the floored value of the X component, indicating the block that
-	 * this vector is contained with.
-	 *
-	 * @return block X
-	 */
-	public int getBlockX() {
-		return NumberConversions.floor(x);
-	}
-
-	/**
-	 * Gets the floored value of the Y component, indicating the block that
-	 * this vector is contained with.
-	 *
-	 * @return block y
-	 */
-	public int getBlockY() {
-		return NumberConversions.floor(y);
-	}
-
-	/**
-	 * Gets the floored value of the Z component, indicating the block that
-	 * this vector is contained with.
-	 *
-	 * @return block z
-	 */
-	public int getBlockZ() {
-		return NumberConversions.floor(z);
-	}
-
-	/**
-	 * Gets a new midpoint vector between this vector and another.
-	 *
-	 * @param other
-	 *            The other vector
-	 * @return a new midpoint vector
-	 */
-	public Vector getMidpoint(Vector other) {
-		double x = (this.x + other.x) / 2;
-		double y = (this.y + other.y) / 2;
-		double z = (this.z + other.z) / 2;
-		return new Vector(x, y, z);
-	}
-
-	/**
-	 * Gets the X component.
-	 *
-	 * @return The X component.
-	 */
-	public double getX() {
-		return x;
-	}
-
-	/**
-	 * Gets the Y component.
-	 *
-	 * @return The Y component.
-	 */
-	public double getY() {
-		return y;
-	}
-
-	/**
-	 * Gets the Z component.
-	 *
-	 * @return The Z component.
-	 */
-	public double getZ() {
-		return z;
-	}
-
-	/**
-	 * Returns a hash code for this vector
-	 *
-	 * @return hash code
-	 */
-	@Override
-	public int hashCode() {
-		int hash = 7;
-
-		hash = 79 * hash + (int) (Double.doubleToLongBits(this.x) ^ Double.doubleToLongBits(this.x) >>> 32);
-		hash = 79 * hash + (int) (Double.doubleToLongBits(this.y) ^ Double.doubleToLongBits(this.y) >>> 32);
-		hash = 79 * hash + (int) (Double.doubleToLongBits(this.z) ^ Double.doubleToLongBits(this.z) >>> 32);
-		return hash;
-	}
-
-	/**
-	 * Returns whether this vector is in an axis-aligned bounding box.
-	 * <p>
-	 * The minimum and maximum vectors given must be truly the minimum and
-	 * maximum X, Y and Z components.
-	 *
-	 * @param min
-	 *            Minimum vector
-	 * @param max
-	 *            Maximum vector
-	 * @return whether this vector is in the AABB
-	 */
-	public boolean isInAABB(Vector min, Vector max) {
-		return x >= min.x && x <= max.x && y >= min.y && y <= max.y && z >= min.z && z <= max.z;
-	}
-
-	/**
-	 * Returns whether this vector is within a sphere.
-	 *
-	 * @param origin
-	 *            Sphere origin.
-	 * @param radius
-	 *            Sphere radius
-	 * @return whether this vector is in the sphere
-	 */
-	public boolean isInSphere(Vector origin, double radius) {
-		return NumberConversions.square(origin.x - x) + NumberConversions.square(origin.y - y) + NumberConversions.square(origin.z - z) <= NumberConversions.square(radius);
-	}
-
-	/**
-	 * Gets the magnitude of the vector, defined as sqrt(x^2+y^2+z^2). The
-	 * value of this method is not cached and uses a costly square-root
-	 * function, so do not repeatedly call this method to get the vector's
-	 * magnitude. NaN will be returned if the inner result of the sqrt()
-	 * function overflows, which will be caused if the length is too long.
-	 *
-	 * @return the magnitude
-	 */
-	public double length() {
-		return Math.sqrt(NumberConversions.square(x) + NumberConversions.square(y) + NumberConversions.square(z));
-	}
-
-	/**
-	 * Gets the magnitude of the vector squared.
-	 *
-	 * @return the magnitude
-	 */
-	public double lengthSquared() {
-		return NumberConversions.square(x) + NumberConversions.square(y) + NumberConversions.square(z);
-	}
-
-	/**
-	 * Sets this vector to the midpoint between this vector and another.
-	 *
-	 * @param other
-	 *            The other vector
-	 * @return this same vector (now a midpoint)
-	 */
-	public Vector midpoint(Vector other) {
-		x = (x + other.x) / 2;
-		y = (y + other.y) / 2;
-		z = (z + other.z) / 2;
-		return this;
-	}
-
-	/**
-	 * Performs scalar multiplication, multiplying all components with a
-	 * scalar.
-	 *
-	 * @param m
-	 *            The factor
-	 * @return the same vector
-	 */
-	public Vector multiply(double m) {
-		x *= m;
-		y *= m;
-		z *= m;
-		return this;
-	}
-
-	/**
-	 * Performs scalar multiplication, multiplying all components with a
-	 * scalar.
-	 *
-	 * @param m
-	 *            The factor
-	 * @return the same vector
-	 */
-	public Vector multiply(float m) {
-		x *= m;
-		y *= m;
-		z *= m;
-		return this;
-	}
-
-	/**
-	 * Performs scalar multiplication, multiplying all components with a
-	 * scalar.
-	 *
-	 * @param m
-	 *            The factor
-	 * @return the same vector
-	 */
-	public Vector multiply(int m) {
-		x *= m;
-		y *= m;
-		z *= m;
-		return this;
-	}
-
-	/**
-	 * Multiplies the vector by another.
-	 *
-	 * @param vec
-	 *            The other vector
-	 * @return the same vector
-	 */
-	public Vector multiply(Vector vec) {
-		x *= vec.x;
-		y *= vec.y;
-		z *= vec.z;
-		return this;
-	}
-
-	/**
-	 * Converts this vector to a unit vector (a vector with length of 1).
-	 *
-	 * @return the same vector
-	 */
-	public Vector normalize() {
-		double length = length();
-
-		x /= length;
-		y /= length;
-		z /= length;
-
-		return this;
-	}
-
-	public Map<String, Object> serialize() {
-		Map<String, Object> result = new LinkedHashMap<String, Object>();
-
-		result.put("x", getX());
-		result.put("y", getY());
-		result.put("z", getZ());
-
-		return result;
-	}
-
-	/**
-	 * Set the X component.
-	 *
-	 * @param x
-	 *            The new X component.
-	 * @return This vector.
-	 */
-	public Vector setX(double x) {
-		this.x = x;
-		return this;
-	}
-
-	/**
-	 * Set the X component.
-	 *
-	 * @param x
-	 *            The new X component.
-	 * @return This vector.
-	 */
-	public Vector setX(float x) {
-		this.x = x;
-		return this;
-	}
-
-	/**
-	 * Set the X component.
-	 *
-	 * @param x
-	 *            The new X component.
-	 * @return This vector.
-	 */
-	public Vector setX(int x) {
-		this.x = x;
-		return this;
-	}
-
-	/**
-	 * Set the Y component.
-	 *
-	 * @param y
-	 *            The new Y component.
-	 * @return This vector.
-	 */
-	public Vector setY(double y) {
-		this.y = y;
-		return this;
-	}
-
-	/**
-	 * Set the Y component.
-	 *
-	 * @param y
-	 *            The new Y component.
-	 * @return This vector.
-	 */
-	public Vector setY(float y) {
-		this.y = y;
-		return this;
-	}
-
-	/**
-	 * Set the Y component.
-	 *
-	 * @param y
-	 *            The new Y component.
-	 * @return This vector.
-	 */
-	public Vector setY(int y) {
-		this.y = y;
-		return this;
-	}
-
-	/**
-	 * Set the Z component.
-	 *
-	 * @param z
-	 *            The new Z component.
-	 * @return This vector.
-	 */
-	public Vector setZ(double z) {
-		this.z = z;
-		return this;
-	}
-
-	/**
-	 * Set the Z component.
-	 *
-	 * @param z
-	 *            The new Z component.
-	 * @return This vector.
-	 */
-	public Vector setZ(float z) {
-		this.z = z;
-		return this;
-	}
-
-	/**
-	 * Set the Z component.
-	 *
-	 * @param z
-	 *            The new Z component.
-	 * @return This vector.
-	 */
-	public Vector setZ(int z) {
-		this.z = z;
-		return this;
-	}
-
-	/**
-	 * Subtracts a vector from this one.
-	 *
-	 * @param vec
-	 *            The other vector
-	 * @return the same vector
-	 */
-	public Vector subtract(Vector vec) {
-		x -= vec.x;
-		y -= vec.y;
-		z -= vec.z;
-		return this;
-	}
-
-	/**
-	 * Gets a Location version of this vector.
-	 *
-	 * @param world
-	 *            The world to link the location to.
-	 * @param yaw
-	 *            The desired yaw.
-	 * @param pitch
-	 *            The desired pitch.
-	 * @return the location
-	 */
-	public Location toLocation(float yaw, float pitch) {
-		return new Location(x, y, z, yaw, pitch);
-	}
-
-	/**
-	 * Returns this vector's components as x,y,z.
-	 */
-	@Override
-	public String toString() {
-		return x + "," + y + "," + z;
-	}
-
-	/**
-	 * Zero this vector's components.
-	 *
-	 * @return the same vector
-	 */
-	public Vector zero() {
-		x = 0;
-		y = 0;
-		z = 0;
-		return this;
-	}
+    /**
+     * Threshold for fuzzy equals().
+     */
+    private static final double epsilon = 0.000001;
+
+    private static Random random = new Random();
+    protected double x;
+    protected double y;
+    protected double z;
+
+    /**
+     * Construct the vector with all components as 0.
+     */
+    public Vector() {
+        this.x = 0;
+        this.y = 0;
+        this.z = 0;
+    }
+
+    /**
+     * Construct the vector with provided double components.
+     *
+     * @param x X component
+     * @param y Y component
+     * @param z Z component
+     */
+    public Vector(double x, double y, double z) {
+        this.x = x;
+        this.y = y;
+        this.z = z;
+    }
+
+    /**
+     * Construct the vector with provided float components.
+     *
+     * @param x X component
+     * @param y Y component
+     * @param z Z component
+     */
+    public Vector(float x, float y, float z) {
+        this.x = x;
+        this.y = y;
+        this.z = z;
+    }
+
+    /**
+     * Construct the vector with provided integer components.
+     *
+     * @param x X component
+     * @param y Y component
+     * @param z Z component
+     */
+    public Vector(int x, int y, int z) {
+        this.x = x;
+        this.y = y;
+        this.z = z;
+    }
+
+    public static Vector deserialize(Map<String, Object> args) {
+        double x = 0;
+        double y = 0;
+        double z = 0;
+
+        if (args.containsKey("x")) {
+            x = (Double) args.get("x");
+        }
+        if (args.containsKey("y")) {
+            y = (Double) args.get("y");
+        }
+        if (args.containsKey("z")) {
+            z = (Double) args.get("z");
+        }
+
+        return new Vector(x, y, z);
+    }
+
+    /**
+     * Get the threshold used for equals().
+     *
+     * @return The epsilon.
+     */
+    public static double getEpsilon() {
+        return epsilon;
+    }
+
+    /**
+     * Gets the maximum components of two vectors.
+     *
+     * @param v1 The first vector.
+     * @param v2 The second vector.
+     * @return maximum
+     */
+    public static Vector getMaximum(Vector v1, Vector v2) {
+        return new Vector(Math.max(v1.x, v2.x), Math.max(v1.y, v2.y), Math.max(v1.z, v2.z));
+    }
+
+    /**
+     * Gets the minimum components of two vectors.
+     *
+     * @param v1 The first vector.
+     * @param v2 The second vector.
+     * @return minimum
+     */
+    public static Vector getMinimum(Vector v1, Vector v2) {
+        return new Vector(Math.min(v1.x, v2.x), Math.min(v1.y, v2.y), Math.min(v1.z, v2.z));
+    }
+
+    /**
+     * Gets a random vector with components having a random value between 0
+     * and 1.
+     *
+     * @return A random vector.
+     */
+    public static Vector getRandom() {
+        return new Vector(random.nextDouble(), random.nextDouble(), random.nextDouble());
+    }
+
+    /**
+     * Adds a vector to this one
+     *
+     * @param vec The other vector
+     * @return the same vector
+     */
+    public Vector add(Vector vec) {
+        x += vec.x;
+        y += vec.y;
+        z += vec.z;
+        return this;
+    }
+
+    /**
+     * Gets the angle between this vector and another in radians.
+     *
+     * @param other The other vector
+     * @return angle in radians
+     */
+    public float angle(Vector other) {
+        double dot = dot(other) / (length() * other.length());
+
+        return (float) Math.acos(dot);
+    }
+
+    /**
+     * Get a new vector.
+     *
+     * @return vector
+     */
+    @Override
+    public Vector clone() {
+        try {
+            return (Vector) super.clone();
+        } catch (CloneNotSupportedException e) {
+            throw new Error(e);
+        }
+    }
+
+    /**
+     * Copies another vector
+     *
+     * @param vec The other vector
+     * @return the same vector
+     */
+    public Vector copy(Vector vec) {
+        x = vec.x;
+        y = vec.y;
+        z = vec.z;
+        return this;
+    }
+
+    /**
+     * Calculates the cross product of this vector with another. The cross
+     * product is defined as:
+     * <ul>
+     * <li>x = y1 * z2 - y2 * z1
+     * <li>y = z1 * x2 - z2 * x1
+     * <li>z = x1 * y2 - x2 * y1
+     * </ul>
+     *
+     * @param o The other vector
+     * @return the same vector
+     */
+    public Vector crossProduct(Vector o) {
+        double newX = y * o.z - o.y * z;
+        double newY = z * o.x - o.z * x;
+        double newZ = x * o.y - o.x * y;
+
+        x = newX;
+        y = newY;
+        z = newZ;
+        return this;
+    }
+
+    /**
+     * Get the distance between this vector and another. The value of this
+     * method is not cached and uses a costly square-root function, so do not
+     * repeatedly call this method to get the vector's magnitude. NaN will be
+     * returned if the inner result of the sqrt() function overflows, which
+     * will be caused if the distance is too long.
+     *
+     * @param o The other vector
+     * @return the distance
+     */
+    public double distance(Vector o) {
+        return Math.sqrt(NumberConversions.square(x - o.x) + NumberConversions.square(y - o.y) + NumberConversions.square(z - o.z));
+    }
+
+    /**
+     * Get the squared distance between this vector and another.
+     *
+     * @param o The other vector
+     * @return the distance
+     */
+    public double distanceSquared(Vector o) {
+        return NumberConversions.square(x - o.x) + NumberConversions.square(y - o.y) + NumberConversions.square(z - o.z);
+    }
+
+    /**
+     * Divides the vector by another.
+     *
+     * @param vec The other vector
+     * @return the same vector
+     */
+    public Vector divide(Vector vec) {
+        x /= vec.x;
+        y /= vec.y;
+        z /= vec.z;
+        return this;
+    }
+
+    /**
+     * Calculates the dot product of this vector with another. The dot product
+     * is defined as x1*x2+y1*y2+z1*z2. The returned value is a scalar.
+     *
+     * @param other The other vector
+     * @return dot product
+     */
+    public double dot(Vector other) {
+        return x * other.x + y * other.y + z * other.z;
+    }
+
+    /**
+     * Checks to see if two objects are equal.
+     * <p>
+     * Only two Vectors can ever return true. This method uses a fuzzy match to
+     * account for floating point errors. The epsilon can be retrieved with
+     * epsilon.
+     */
+    @Override
+    public boolean equals(Object obj) {
+        if (!(obj instanceof Vector)) {
+            return false;
+        }
+
+        Vector other = (Vector) obj;
+
+        return Math.abs(x - other.x) < epsilon && Math.abs(y - other.y) < epsilon && Math.abs(z - other.z) < epsilon && this.getClass().equals(obj.getClass());
+    }
+
+    /**
+     * Gets the floored value of the X component, indicating the block that
+     * this vector is contained with.
+     *
+     * @return block X
+     */
+    public int getBlockX() {
+        return NumberConversions.floor(x);
+    }
+
+    /**
+     * Gets the floored value of the Y component, indicating the block that
+     * this vector is contained with.
+     *
+     * @return block y
+     */
+    public int getBlockY() {
+        return NumberConversions.floor(y);
+    }
+
+    /**
+     * Gets the floored value of the Z component, indicating the block that
+     * this vector is contained with.
+     *
+     * @return block z
+     */
+    public int getBlockZ() {
+        return NumberConversions.floor(z);
+    }
+
+    /**
+     * Gets a new midpoint vector between this vector and another.
+     *
+     * @param other The other vector
+     * @return a new midpoint vector
+     */
+    public Vector getMidpoint(Vector other) {
+        double x = (this.x + other.x) / 2;
+        double y = (this.y + other.y) / 2;
+        double z = (this.z + other.z) / 2;
+        return new Vector(x, y, z);
+    }
+
+    /**
+     * Gets the X component.
+     *
+     * @return The X component.
+     */
+    public double getX() {
+        return x;
+    }
+
+    /**
+     * Set the X component.
+     *
+     * @param x The new X component.
+     * @return This vector.
+     */
+    public Vector setX(float x) {
+        this.x = x;
+        return this;
+    }
+
+    /**
+     * Set the X component.
+     *
+     * @param x The new X component.
+     * @return This vector.
+     */
+    public Vector setX(int x) {
+        this.x = x;
+        return this;
+    }
+
+    /**
+     * Gets the Y component.
+     *
+     * @return The Y component.
+     */
+    public double getY() {
+        return y;
+    }
+
+    /**
+     * Set the Y component.
+     *
+     * @param y The new Y component.
+     * @return This vector.
+     */
+    public Vector setY(float y) {
+        this.y = y;
+        return this;
+    }
+
+    /**
+     * Set the Y component.
+     *
+     * @param y The new Y component.
+     * @return This vector.
+     */
+    public Vector setY(int y) {
+        this.y = y;
+        return this;
+    }
+
+    /**
+     * Gets the Z component.
+     *
+     * @return The Z component.
+     */
+    public double getZ() {
+        return z;
+    }
+
+    /**
+     * Set the Z component.
+     *
+     * @param z The new Z component.
+     * @return This vector.
+     */
+    public Vector setZ(float z) {
+        this.z = z;
+        return this;
+    }
+
+    /**
+     * Set the Z component.
+     *
+     * @param z The new Z component.
+     * @return This vector.
+     */
+    public Vector setZ(int z) {
+        this.z = z;
+        return this;
+    }
+
+    /**
+     * Returns a hash code for this vector
+     *
+     * @return hash code
+     */
+    @Override
+    public int hashCode() {
+        int hash = 7;
+
+        hash = 79 * hash + (int) (Double.doubleToLongBits(this.x) ^ Double.doubleToLongBits(this.x) >>> 32);
+        hash = 79 * hash + (int) (Double.doubleToLongBits(this.y) ^ Double.doubleToLongBits(this.y) >>> 32);
+        hash = 79 * hash + (int) (Double.doubleToLongBits(this.z) ^ Double.doubleToLongBits(this.z) >>> 32);
+        return hash;
+    }
+
+    /**
+     * Returns whether this vector is in an axis-aligned bounding box.
+     * <p>
+     * The minimum and maximum vectors given must be truly the minimum and
+     * maximum X, Y and Z components.
+     *
+     * @param min Minimum vector
+     * @param max Maximum vector
+     * @return whether this vector is in the AABB
+     */
+    public boolean isInAABB(Vector min, Vector max) {
+        return x >= min.x && x <= max.x && y >= min.y && y <= max.y && z >= min.z && z <= max.z;
+    }
+
+    /**
+     * Returns whether this vector is within a sphere.
+     *
+     * @param origin Sphere origin.
+     * @param radius Sphere radius
+     * @return whether this vector is in the sphere
+     */
+    public boolean isInSphere(Vector origin, double radius) {
+        return NumberConversions.square(origin.x - x) + NumberConversions.square(origin.y - y) + NumberConversions.square(origin.z - z) <= NumberConversions.square(radius);
+    }
+
+    /**
+     * Gets the magnitude of the vector, defined as sqrt(x^2+y^2+z^2). The
+     * value of this method is not cached and uses a costly square-root
+     * function, so do not repeatedly call this method to get the vector's
+     * magnitude. NaN will be returned if the inner result of the sqrt()
+     * function overflows, which will be caused if the length is too long.
+     *
+     * @return the magnitude
+     */
+    public double length() {
+        return Math.sqrt(NumberConversions.square(x) + NumberConversions.square(y) + NumberConversions.square(z));
+    }
+
+    /**
+     * Gets the magnitude of the vector squared.
+     *
+     * @return the magnitude
+     */
+    public double lengthSquared() {
+        return NumberConversions.square(x) + NumberConversions.square(y) + NumberConversions.square(z);
+    }
+
+    /**
+     * Sets this vector to the midpoint between this vector and another.
+     *
+     * @param other The other vector
+     * @return this same vector (now a midpoint)
+     */
+    public Vector midpoint(Vector other) {
+        x = (x + other.x) / 2;
+        y = (y + other.y) / 2;
+        z = (z + other.z) / 2;
+        return this;
+    }
+
+    /**
+     * Performs scalar multiplication, multiplying all components with a
+     * scalar.
+     *
+     * @param m The factor
+     * @return the same vector
+     */
+    public Vector multiply(double m) {
+        x *= m;
+        y *= m;
+        z *= m;
+        return this;
+    }
+
+    /**
+     * Performs scalar multiplication, multiplying all components with a
+     * scalar.
+     *
+     * @param m The factor
+     * @return the same vector
+     */
+    public Vector multiply(float m) {
+        x *= m;
+        y *= m;
+        z *= m;
+        return this;
+    }
+
+    /**
+     * Performs scalar multiplication, multiplying all components with a
+     * scalar.
+     *
+     * @param m The factor
+     * @return the same vector
+     */
+    public Vector multiply(int m) {
+        x *= m;
+        y *= m;
+        z *= m;
+        return this;
+    }
+
+    /**
+     * Multiplies the vector by another.
+     *
+     * @param vec The other vector
+     * @return the same vector
+     */
+    public Vector multiply(Vector vec) {
+        x *= vec.x;
+        y *= vec.y;
+        z *= vec.z;
+        return this;
+    }
+
+    /**
+     * Converts this vector to a unit vector (a vector with length of 1).
+     *
+     * @return the same vector
+     */
+    public Vector normalize() {
+        double length = length();
+
+        x /= length;
+        y /= length;
+        z /= length;
+
+        return this;
+    }
+
+    public Map<String, Object> serialize() {
+        Map<String, Object> result = new LinkedHashMap<String, Object>();
+
+        result.put("x", getX());
+        result.put("y", getY());
+        result.put("z", getZ());
+
+        return result;
+    }
+
+    /**
+     * Set the X component.
+     *
+     * @param x The new X component.
+     * @return This vector.
+     */
+    public Vector setX(double x) {
+        this.x = x;
+        return this;
+    }
+
+    /**
+     * Set the Y component.
+     *
+     * @param y The new Y component.
+     * @return This vector.
+     */
+    public Vector setY(double y) {
+        this.y = y;
+        return this;
+    }
+
+    /**
+     * Set the Z component.
+     *
+     * @param z The new Z component.
+     * @return This vector.
+     */
+    public Vector setZ(double z) {
+        this.z = z;
+        return this;
+    }
+
+    /**
+     * Subtracts a vector from this one.
+     *
+     * @param vec The other vector
+     * @return the same vector
+     */
+    public Vector subtract(Vector vec) {
+        x -= vec.x;
+        y -= vec.y;
+        z -= vec.z;
+        return this;
+    }
+
+    /**
+     * Gets a Location version of this vector.
+     *
+     * @param world The world to link the location to.
+     * @param yaw   The desired yaw.
+     * @param pitch The desired pitch.
+     * @return the location
+     */
+    public Location toLocation(float yaw, float pitch) {
+        return new Location(x, y, z, yaw, pitch);
+    }
+
+    /**
+     * Returns this vector's components as x,y,z.
+     */
+    @Override
+    public String toString() {
+        return x + "," + y + "," + z;
+    }
+
+    /**
+     * Zero this vector's components.
+     *
+     * @return the same vector
+     */
+    public Vector zero() {
+        x = 0;
+        y = 0;
+        z = 0;
+        return this;
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/api/position/Vector3f.java b/src/main/java/dev/wolveringer/api/position/Vector3f.java
index 19016c5..d7c17e6 100644
--- a/src/main/java/dev/wolveringer/api/position/Vector3f.java
+++ b/src/main/java/dev/wolveringer/api/position/Vector3f.java
@@ -3,46 +3,48 @@ package dev.wolveringer.api.position;
 import dev.wolveringer.nbt.NBTTagFloat;
 import dev.wolveringer.nbt.NBTTagList;
 
-public class Vector3f extends Potision<Float>{
-	public Vector3f(float x, float y, float z) {
-		super(x, y, z);
-	}
-
-	public Vector3f(NBTTagList list) {
-		this(list.getFloat(0),list.getFloat(1),list.getFloat(2));
-	}
-
-	public NBTTagList toNBTTagList() {
-		NBTTagList localNBTTagList = new NBTTagList();
-		localNBTTagList.add(new NBTTagFloat(this.x));
-		localNBTTagList.add(new NBTTagFloat(this.y));
-		localNBTTagList.add(new NBTTagFloat(this.z));
-		return localNBTTagList;
-	}
-
-	public boolean equals(Object paramObject) {
-		if(!(paramObject instanceof Vector3f)){
-			return false;
-		}
-		Vector3f localVector3f = (Vector3f) paramObject;
-		return (this.x == localVector3f.x) && (this.y == localVector3f.y) && (this.z == localVector3f.z);
-	}
-
-	@Override
-	public void setX(Float x) {
-		throw new UnsupportedOperationException();
-	}
-	@Override
-	public void setY(Float y) {
-		throw new UnsupportedOperationException();
-	}
-	@Override
-	public void setZ(Float z) {
-		throw new UnsupportedOperationException();
-	}
-	
-	@Override
-	public String toString() {
-		return "Vector3f [x=" + x + ", y=" + y + ", z=" + z + "]";
-	}
+public class Vector3f extends Potision<Float> {
+    public Vector3f(float x, float y, float z) {
+        super(x, y, z);
+    }
+
+    public Vector3f(NBTTagList list) {
+        this(list.getFloat(0), list.getFloat(1), list.getFloat(2));
+    }
+
+    public NBTTagList toNBTTagList() {
+        NBTTagList localNBTTagList = new NBTTagList();
+        localNBTTagList.add(new NBTTagFloat(this.x));
+        localNBTTagList.add(new NBTTagFloat(this.y));
+        localNBTTagList.add(new NBTTagFloat(this.z));
+        return localNBTTagList;
+    }
+
+    public boolean equals(Object paramObject) {
+        if (!(paramObject instanceof Vector3f)) {
+            return false;
+        }
+        Vector3f localVector3f = (Vector3f) paramObject;
+        return (this.x == localVector3f.x) && (this.y == localVector3f.y) && (this.z == localVector3f.z);
+    }
+
+    @Override
+    public void setX(Float x) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void setY(Float y) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void setZ(Float z) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public String toString() {
+        return "Vector3f [x=" + x + ", y=" + y + ", z=" + z + "]";
+    }
 }
diff --git a/src/main/java/dev/wolveringer/api/scoreboard/Objektive.java b/src/main/java/dev/wolveringer/api/scoreboard/Objektive.java
index 9b959d4..69a20de 100644
--- a/src/main/java/dev/wolveringer/api/scoreboard/Objektive.java
+++ b/src/main/java/dev/wolveringer/api/scoreboard/Objektive.java
@@ -5,125 +5,125 @@ import java.util.Collections;
 import java.util.List;
 
 import dev.wolveringer.BungeeUtil.BungeeUtil;
-import dev.wolveringer.BungeeUtil.Main;
 import dev.wolveringer.BungeeUtil.packets.PacketPlayOutScoreboardDisplayObjective;
 import dev.wolveringer.BungeeUtil.packets.PacketPlayOutScoreboardDisplayObjective.Position;
 import dev.wolveringer.BungeeUtil.packets.PacketPlayOutScoreboardObjective;
 import dev.wolveringer.BungeeUtil.packets.PacketPlayOutScoreboardObjective.Action;
 import dev.wolveringer.BungeeUtil.packets.PacketPlayOutScoreboardObjective.Type;
-import dev.wolveringer.chat.ChatColor.ChatColorUtils;
 import dev.wolveringer.BungeeUtil.packets.PacketPlayOutScoreboardScore;
+import dev.wolveringer.chat.ChatColor.ChatColorUtils;
 
 public final class Objektive {
-	protected Scoreboard owner;
-	protected String name;
-	protected String displayName;
-	protected Type type;
-	protected ArrayList<Score> scores = new ArrayList<>();
-	protected Position pos;
-	
-	protected Objektive(Scoreboard owner, String name) {
-		this.owner = owner;
-		this.name = this.displayName = name;
-		type = Type.INTEGER;
-	}
-
-	public void setScore(String name, int value) {
-		for(Score s : scores)
-			if(s.getName().equals(name)){
-				s.setValue(value);
-				return;
-			}
-		scores.add(new Score(this, name, 0));
-		setScore(name, value);
-	}
-
-	public int getScore(String name) {
-		for(Score s : scores)
-			if(s.getName().equals(name)){
-				return s.getValue();
-			}
-		return 0;
-	}
-
-	public List<String> getScores(){
-		ArrayList<String> out = new ArrayList<>();
-		for(Score s : scores)
-			out.add(s.name);
-		return Collections.unmodifiableList(out);
-	}
-	
-	public void removeScore(String scoreName) {
-		Score x = null;
-		for(Score s : scores)
-			if(s.getName().equals(scoreName)){
-				x = s;
-			}
-		if(x == null){
-			BungeeUtil.getInstance().debug("Removing not existing score ("+scoreName+ChatColorUtils.COLOR_CHAR+"r)");
-			return;
-		}
-		scores.remove(x);
-		owner.player.sendPacket(new PacketPlayOutScoreboardScore(x.name, getName(), -1, PacketPlayOutScoreboardScore.Action.REMOVE));
-	}
-
-	public void setDisplayName(String displayName) {
-		this.displayName = displayName;
-		sendUpdate();
-	}
-
-	public void setType(Type type) {
-		this.type = type;
-		sendUpdate();
-	}
-
-	public void display(Position position) {
-		pos = position;
-		owner.player.sendPacket(new PacketPlayOutScoreboardDisplayObjective(name, position));
-	}
-	public Position getPosition() {
-		return this.pos;
-	}
-
-	public String getDisplayName() {
-		return this.displayName;
-	}
-
-	public String getName() {
-		return this.name;
-	}
-
-	private void sendUpdate() {
-		owner.player.sendPacket(new PacketPlayOutScoreboardObjective(name, Action.UPDATE, displayName, type));
-	}
-
-	protected static class Score {
-		private Objektive owner;
-		protected String name;
-		private int value;
-
-		Score(Objektive owner, String name, int value) {
-			this.owner = owner;
-			this.name = name;
-			this.value = value;
-			owner.owner.player.sendPacket(new PacketPlayOutScoreboardScore(name, owner.getName(), value, PacketPlayOutScoreboardScore.Action.CREATE));
-		}
-
-		public void setValue(int value) {
-			this.value = value;
-			sendUpdate();
-		}
-
-		public int getValue() {
-			return this.value;
-		}
-
-		public String getName() {
-			return this.name;
-		}
-
-		private void sendUpdate() {
-			owner.owner.player.sendPacket(new PacketPlayOutScoreboardScore(name, owner.getName(), value, PacketPlayOutScoreboardScore.Action.UPDATE));
-		}
-	}
+    protected Scoreboard owner;
+    protected String name;
+    protected String displayName;
+    protected Type type;
+    protected ArrayList<Score> scores = new ArrayList<>();
+    protected Position pos;
+
+    protected Objektive(Scoreboard owner, String name) {
+        this.owner = owner;
+        this.name = this.displayName = name;
+        type = Type.INTEGER;
+    }
+
+    public void setScore(String name, int value) {
+        for (Score s : scores)
+            if (s.getName().equals(name)) {
+                s.setValue(value);
+                return;
+            }
+        scores.add(new Score(this, name, 0));
+        setScore(name, value);
+    }
+
+    public int getScore(String name) {
+        for (Score s : scores)
+            if (s.getName().equals(name)) {
+                return s.getValue();
+            }
+        return 0;
+    }
+
+    public List<String> getScores() {
+        ArrayList<String> out = new ArrayList<>();
+        for (Score s : scores)
+            out.add(s.name);
+        return Collections.unmodifiableList(out);
+    }
+
+    public void removeScore(String scoreName) {
+        Score x = null;
+        for (Score s : scores)
+            if (s.getName().equals(scoreName)) {
+                x = s;
+            }
+        if (x == null) {
+            BungeeUtil.getInstance().debug("Removing not existing score (" + scoreName + ChatColorUtils.COLOR_CHAR + "r)");
+            return;
+        }
+        scores.remove(x);
+        owner.player.sendPacket(new PacketPlayOutScoreboardScore(x.name, getName(), -1, PacketPlayOutScoreboardScore.Action.REMOVE));
+    }
+
+    public void setType(Type type) {
+        this.type = type;
+        sendUpdate();
+    }
+
+    public void display(Position position) {
+        pos = position;
+        owner.player.sendPacket(new PacketPlayOutScoreboardDisplayObjective(name, position));
+    }
+
+    public Position getPosition() {
+        return this.pos;
+    }
+
+    public String getDisplayName() {
+        return this.displayName;
+    }
+
+    public void setDisplayName(String displayName) {
+        this.displayName = displayName;
+        sendUpdate();
+    }
+
+    public String getName() {
+        return this.name;
+    }
+
+    private void sendUpdate() {
+        owner.player.sendPacket(new PacketPlayOutScoreboardObjective(name, Action.UPDATE, displayName, type));
+    }
+
+    protected static class Score {
+        protected String name;
+        private Objektive owner;
+        private int value;
+
+        Score(Objektive owner, String name, int value) {
+            this.owner = owner;
+            this.name = name;
+            this.value = value;
+            owner.owner.player.sendPacket(new PacketPlayOutScoreboardScore(name, owner.getName(), value, PacketPlayOutScoreboardScore.Action.CREATE));
+        }
+
+        public int getValue() {
+            return this.value;
+        }
+
+        public void setValue(int value) {
+            this.value = value;
+            sendUpdate();
+        }
+
+        public String getName() {
+            return this.name;
+        }
+
+        private void sendUpdate() {
+            owner.owner.player.sendPacket(new PacketPlayOutScoreboardScore(name, owner.getName(), value, PacketPlayOutScoreboardScore.Action.UPDATE));
+        }
+    }
 }
diff --git a/src/main/java/dev/wolveringer/api/scoreboard/PacketListenerScoreboard.java b/src/main/java/dev/wolveringer/api/scoreboard/PacketListenerScoreboard.java
index 97af95c..ba91e19 100644
--- a/src/main/java/dev/wolveringer/api/scoreboard/PacketListenerScoreboard.java
+++ b/src/main/java/dev/wolveringer/api/scoreboard/PacketListenerScoreboard.java
@@ -4,7 +4,6 @@ import java.util.ArrayList;
 import java.util.Arrays;
 
 import dev.wolveringer.BungeeUtil.BungeeUtil;
-import dev.wolveringer.BungeeUtil.Main;
 import dev.wolveringer.BungeeUtil.PacketHandleEvent;
 import dev.wolveringer.BungeeUtil.PacketHandler;
 import dev.wolveringer.BungeeUtil.PacketLib;
@@ -18,123 +17,114 @@ import dev.wolveringer.BungeeUtil.packets.PacketPlayOutScoreboardTeam;
 import dev.wolveringer.api.scoreboard.Objektive.Score;
 
 public final class PacketListenerScoreboard implements PacketHandler<Packet> {
-	private static PacketListenerScoreboard listener;
-	
-	public static void init() {
-		if(Configuration.isScoreboardhandleEnabled())
-			PacketLib.addHandler(listener = new PacketListenerScoreboard());
-	}
-	
-	public static PacketListenerScoreboard getListener() {
-		return listener;
-	}
-	
-	@Override
-	public void handle(PacketHandleEvent<Packet> e) {
-		if (e.getPacket() instanceof PacketPlayOutScoreboardDisplayObjective) {
-			Scoreboard board = e.getPlayer().getScoreboard();
-			PacketPlayOutScoreboardDisplayObjective out = (PacketPlayOutScoreboardDisplayObjective) e.getPacket();
-			Objektive o = board.getObjektive(out.getName());
-			o.pos = out.getPosition();
-		}
-		else if (e.getPacket() instanceof PacketPlayOutScoreboardObjective) {
-			Scoreboard board = e.getPlayer().getScoreboard();
-			PacketPlayOutScoreboardObjective out = (PacketPlayOutScoreboardObjective) e.getPacket();
-			if (out.getAction() == Action.CREATE) {
-				Objektive obj;
-				board.server_objs.add(obj = new Objektive(board, out.getScorebordName()));
-				obj.displayName = out.getDisplayName();
-				obj.name = out.getScorebordName();
-				obj.type = out.getType();
-			}
-			else if (out.getAction() == Action.REMOVE) {
-				board.server_objs.remove(board.getObjektive(out.getScorebordName()));
-			}
-			else if (out.getAction() == Action.UPDATE) {
-				Objektive obj = board.getObjektive(out.getScorebordName());
-				if (obj == null) return;
-				obj.displayName = out.getDisplayName();
-				obj.type = out.getType();
-			}
-		}
-		else if (e.getPacket() instanceof PacketPlayOutScoreboardScore) {
-			Scoreboard board = e.getPlayer().getScoreboard();
-			PacketPlayOutScoreboardScore out = (PacketPlayOutScoreboardScore) e.getPacket();
-			if (out.getAction() == dev.wolveringer.BungeeUtil.packets.PacketPlayOutScoreboardScore.Action.CREATE || out.getAction() == dev.wolveringer.BungeeUtil.packets.PacketPlayOutScoreboardScore.Action.UPDATE) {
-				Objektive obj = board.getObjektive(out.getObjektiveName());
-				if (obj == null) board.server_objs.add(obj = new Objektive(board, out.getObjektiveName()));
-				if (obj == null) {
-					BungeeUtil.getInstance().debug("ScoreboardObjective " + out.getObjektiveName() + " for the player " + e.getPlayer().getName() + " not found!");
-					return;
-				}
-				Score x = null;
-				for (Score s : obj.scores)
-					if (s.getName().equals(out.getScoreName())) {
-						x = s;
-					}
-				if (x == null) return;
-				obj.scores.remove(x);
-				
-				obj.scores.add(new Score(obj, out.getScoreName(), out.getValue()));
-			}
-			else if (out.getAction() == dev.wolveringer.BungeeUtil.packets.PacketPlayOutScoreboardScore.Action.REMOVE) {
-				Objektive obj = board.getObjektive(out.getObjektiveName());
-				if (obj == null) {
-					BungeeUtil.getInstance().debug("ScoreboardObjective " + out.getObjektiveName() + " for the player " + e.getPlayer().getName() + " not found");
-					return;
-				}
-				Score x = null;
-				for (Score s : obj.scores)
-					if (s.getName().equals(out.getScoreName())) {
-						x = s;
-					}
-				if (x == null) return;
-				obj.scores.remove(x);
-			}
-		}
-		else if (e.getPacket() instanceof PacketPlayOutScoreboardTeam) {
-			Scoreboard board = e.getPlayer().getScoreboard();
-			PacketPlayOutScoreboardTeam out = (PacketPlayOutScoreboardTeam) e.getPacket();
-			if (out.getAction() == dev.wolveringer.BungeeUtil.packets.PacketPlayOutScoreboardTeam.Action.CREATE) {
-				Team t = new Team(board, out.getTeam());
-				if(t == null)
-					return;
-				t.color = out.getColor();
-				t.displayName = out.getDisplayName();
-				t.friendly_fire = out.isFriendlyFire();
-				t.prefix = out.getPrefix();
-				t.suffix = out.getSuffix();
-				t.tag = out.getTag();
-				t.member = new ArrayList<>(Arrays.asList(out.getPlayers()));
-				board.server_teams.add(t);
-			}
-			else if (out.getAction() == dev.wolveringer.BungeeUtil.packets.PacketPlayOutScoreboardTeam.Action.PLAYER_ADD) {
-				Team t = board.getTeam(out.getTeam());
-				if(t == null)
-					return;
-				t.member.addAll(new ArrayList<>(Arrays.asList(out.getPlayers())));
-			}
-			else if (out.getAction() == dev.wolveringer.BungeeUtil.packets.PacketPlayOutScoreboardTeam.Action.PLAYER_REMOVE) {
-				Team t = board.getTeam(out.getTeam());
-				if(t == null)
-					return;
-				t.member.removeAll(new ArrayList<>(Arrays.asList(out.getPlayers())));
-			}
-			else if (out.getAction() == dev.wolveringer.BungeeUtil.packets.PacketPlayOutScoreboardTeam.Action.REMOVE) {
-				Team t = board.getTeam(out.getTeam());
-				if(t == null)
-					return;
-				board.server_teams.remove(t);
-			}
-			else if (out.getAction() == dev.wolveringer.BungeeUtil.packets.PacketPlayOutScoreboardTeam.Action.UPDATE) {
-				Team t = board.getTeam(out.getTeam());
-				t.color = out.getColor();
-				t.displayName = out.getDisplayName();
-				t.friendly_fire = out.isFriendlyFire();
-				t.prefix = out.getPrefix();
-				t.suffix = out.getSuffix();
-				t.tag = out.getTag();
-			}
-		}
-	}
+    private static PacketListenerScoreboard listener;
+
+    public static void init() {
+        if (Configuration.isScoreboardhandleEnabled())
+            PacketLib.addHandler(listener = new PacketListenerScoreboard());
+    }
+
+    public static PacketListenerScoreboard getListener() {
+        return listener;
+    }
+
+    @Override
+    public void handle(PacketHandleEvent<Packet> e) {
+        if (e.getPacket() instanceof PacketPlayOutScoreboardDisplayObjective) {
+            Scoreboard board = e.getPlayer().getScoreboard();
+            PacketPlayOutScoreboardDisplayObjective out = (PacketPlayOutScoreboardDisplayObjective) e.getPacket();
+            Objektive o = board.getObjektive(out.getName());
+            o.pos = out.getPosition();
+        } else if (e.getPacket() instanceof PacketPlayOutScoreboardObjective) {
+            Scoreboard board = e.getPlayer().getScoreboard();
+            PacketPlayOutScoreboardObjective out = (PacketPlayOutScoreboardObjective) e.getPacket();
+            if (out.getAction() == Action.CREATE) {
+                Objektive obj;
+                board.server_objs.add(obj = new Objektive(board, out.getScorebordName()));
+                obj.displayName = out.getDisplayName();
+                obj.name = out.getScorebordName();
+                obj.type = out.getType();
+            } else if (out.getAction() == Action.REMOVE) {
+                board.server_objs.remove(board.getObjektive(out.getScorebordName()));
+            } else if (out.getAction() == Action.UPDATE) {
+                Objektive obj = board.getObjektive(out.getScorebordName());
+                if (obj == null) return;
+                obj.displayName = out.getDisplayName();
+                obj.type = out.getType();
+            }
+        } else if (e.getPacket() instanceof PacketPlayOutScoreboardScore) {
+            Scoreboard board = e.getPlayer().getScoreboard();
+            PacketPlayOutScoreboardScore out = (PacketPlayOutScoreboardScore) e.getPacket();
+            if (out.getAction() == dev.wolveringer.BungeeUtil.packets.PacketPlayOutScoreboardScore.Action.CREATE || out.getAction() == dev.wolveringer.BungeeUtil.packets.PacketPlayOutScoreboardScore.Action.UPDATE) {
+                Objektive obj = board.getObjektive(out.getObjektiveName());
+                if (obj == null)
+                    board.server_objs.add(obj = new Objektive(board, out.getObjektiveName()));
+                if (obj == null) {
+                    BungeeUtil.getInstance().debug("ScoreboardObjective " + out.getObjektiveName() + " for the player " + e.getPlayer().getName() + " not found!");
+                    return;
+                }
+                Score x = null;
+                for (Score s : obj.scores)
+                    if (s.getName().equals(out.getScoreName())) {
+                        x = s;
+                    }
+                if (x == null) return;
+                obj.scores.remove(x);
+
+                obj.scores.add(new Score(obj, out.getScoreName(), out.getValue()));
+            } else if (out.getAction() == dev.wolveringer.BungeeUtil.packets.PacketPlayOutScoreboardScore.Action.REMOVE) {
+                Objektive obj = board.getObjektive(out.getObjektiveName());
+                if (obj == null) {
+                    BungeeUtil.getInstance().debug("ScoreboardObjective " + out.getObjektiveName() + " for the player " + e.getPlayer().getName() + " not found");
+                    return;
+                }
+                Score x = null;
+                for (Score s : obj.scores)
+                    if (s.getName().equals(out.getScoreName())) {
+                        x = s;
+                    }
+                if (x == null) return;
+                obj.scores.remove(x);
+            }
+        } else if (e.getPacket() instanceof PacketPlayOutScoreboardTeam) {
+            Scoreboard board = e.getPlayer().getScoreboard();
+            PacketPlayOutScoreboardTeam out = (PacketPlayOutScoreboardTeam) e.getPacket();
+            if (out.getAction() == dev.wolveringer.BungeeUtil.packets.PacketPlayOutScoreboardTeam.Action.CREATE) {
+                Team t = new Team(board, out.getTeam());
+                if (t == null)
+                    return;
+                t.color = out.getColor();
+                t.displayName = out.getDisplayName();
+                t.friendly_fire = out.isFriendlyFire();
+                t.prefix = out.getPrefix();
+                t.suffix = out.getSuffix();
+                t.tag = out.getTag();
+                t.member = new ArrayList<>(Arrays.asList(out.getPlayers()));
+                board.server_teams.add(t);
+            } else if (out.getAction() == dev.wolveringer.BungeeUtil.packets.PacketPlayOutScoreboardTeam.Action.PLAYER_ADD) {
+                Team t = board.getTeam(out.getTeam());
+                if (t == null)
+                    return;
+                t.member.addAll(new ArrayList<>(Arrays.asList(out.getPlayers())));
+            } else if (out.getAction() == dev.wolveringer.BungeeUtil.packets.PacketPlayOutScoreboardTeam.Action.PLAYER_REMOVE) {
+                Team t = board.getTeam(out.getTeam());
+                if (t == null)
+                    return;
+                t.member.removeAll(new ArrayList<>(Arrays.asList(out.getPlayers())));
+            } else if (out.getAction() == dev.wolveringer.BungeeUtil.packets.PacketPlayOutScoreboardTeam.Action.REMOVE) {
+                Team t = board.getTeam(out.getTeam());
+                if (t == null)
+                    return;
+                board.server_teams.remove(t);
+            } else if (out.getAction() == dev.wolveringer.BungeeUtil.packets.PacketPlayOutScoreboardTeam.Action.UPDATE) {
+                Team t = board.getTeam(out.getTeam());
+                t.color = out.getColor();
+                t.displayName = out.getDisplayName();
+                t.friendly_fire = out.isFriendlyFire();
+                t.prefix = out.getPrefix();
+                t.suffix = out.getSuffix();
+                t.tag = out.getTag();
+            }
+        }
+    }
 }
diff --git a/src/main/java/dev/wolveringer/api/scoreboard/Scoreboard.java b/src/main/java/dev/wolveringer/api/scoreboard/Scoreboard.java
index 10b0eaf..8b0492b 100644
--- a/src/main/java/dev/wolveringer/api/scoreboard/Scoreboard.java
+++ b/src/main/java/dev/wolveringer/api/scoreboard/Scoreboard.java
@@ -12,98 +12,97 @@ import dev.wolveringer.BungeeUtil.packets.PacketPlayOutScoreboardObjective.Type;
 import dev.wolveringer.BungeeUtil.packets.PacketPlayOutScoreboardTeam;
 
 public final class Scoreboard {
-	@SuppressWarnings({ "serial", "unused" })
-	private static class ScoreboardAlredyExistException extends RuntimeException {
-		public ScoreboardAlredyExistException(String message) {
-			super(message);
-		}
-	}
+    protected Player player;
+    protected ArrayList<Team> server_teams = new ArrayList<>();
+    protected ArrayList<Objektive> server_objs = new ArrayList<>();
+    private ArrayList<Objektive> objs = new ArrayList<>();
+    private ArrayList<Team> teams = new ArrayList<>();
 
-	protected Player player;
-	private ArrayList<Objektive> objs = new ArrayList<>();
-	private ArrayList<Team> teams = new ArrayList<>();
+    public Scoreboard(Player player) {
+        //if(player.getScoreboard() != null)
+        //	throw new ScoreboardAlredyExistException("Player " + player.getName() + " has alredy a Scoreboard");
+        this.player = player;
+    }
 
-	protected ArrayList<Team> server_teams = new ArrayList<>();
-	protected ArrayList<Objektive> server_objs = new ArrayList<>();
-	
-	public Scoreboard(Player player) {
-		//if(player.getScoreboard() != null)
-		//	throw new ScoreboardAlredyExistException("Player " + player.getName() + " has alredy a Scoreboard");
-		this.player = player;
-	}
+    public Objektive createObjektive(String name, Type t) {
+        if (getObjektive(name) != null)
+            return getObjektive(name);
+        Objektive o = new Objektive(this, name);
+        objs.add(o);
+        player.sendPacket(new PacketPlayOutScoreboardObjective(name, Action.CREATE, o.getDisplayName(), t));
+        return o;
+    }
 
-	public Objektive createObjektive(String name, Type t) {
-		if(getObjektive(name) != null)
-			return getObjektive(name);
-		Objektive o = new Objektive(this, name);
-		objs.add(o);
-		player.sendPacket(new PacketPlayOutScoreboardObjective(name, Action.CREATE, o.getDisplayName(), t));
-		return o;
-	}
+    public Objektive getObjektive(String name) {
+        for (Objektive o : objs)
+            if (o.getName().equals(name))
+                return o;
+        for (Objektive o : server_objs)
+            if (o.getName().equals(name))
+                return o;
+        return null;
+    }
 
-	public Objektive getObjektive(String name) {
-		for(Objektive o : objs)
-			if(o.getName().equals(name))
-				return o;
-		for(Objektive o : server_objs)
-			if(o.getName().equals(name))
-				return o;
-		return null;
-	}
+    public void removeObjektive(String name) {
+        Objektive o = getObjektive(name);
+        if (o == null)
+            return;
+        AsyncCatcher.catchOp("Async scoreboard changing");
+        player.sendPacket(new PacketPlayOutScoreboardObjective(name, Action.REMOVE, o.getDisplayName(), Type.INTEGER));
+        if (objs.remove(o) && !server_objs.remove(o)) { //Check if proxy side board
+            for (Objektive var0 : server_objs)
+                if (var0.getPosition() == o.getPosition()) {
+                    var0.display(o.getPosition());
+                    break;
+                }
+        }
+    }
 
-	public void removeObjektive(String name) {
-		Objektive o = getObjektive(name);
-		if(o == null)
-			return;
-		AsyncCatcher.catchOp("Async scoreboard changing");
-		player.sendPacket(new PacketPlayOutScoreboardObjective(name, Action.REMOVE, o.getDisplayName(), Type.INTEGER));
-		if(objs.remove(o) && !server_objs.remove(o)){ //Check if proxy side board
-			for(Objektive var0 : server_objs)
-				if(var0.getPosition() == o.getPosition()){
-					var0.display(o.getPosition());
-					break;
-				}
-		}
-	}
-	
-	public List<Objektive> getObjektives(){
-		return Collections.unmodifiableList(objs);
-	}
+    public List<Objektive> getObjektives() {
+        return Collections.unmodifiableList(objs);
+    }
 
-	public Team createTeam(String name) {
-		if(getTeam(name) != null)
-			return getTeam(name);
-		Team t = new Team(this, name);
-		teams.add(t);
-		return t;
-	}
+    public Team createTeam(String name) {
+        if (getTeam(name) != null)
+            return getTeam(name);
+        Team t = new Team(this, name);
+        teams.add(t);
+        return t;
+    }
 
-	public void removeTeam(String name) {
-		Team t = getTeam(name);
-		if(t != null){
-			teams.remove(t);
-			PacketPlayOutScoreboardTeam x = new PacketPlayOutScoreboardTeam(t);
-			x.setAction(dev.wolveringer.BungeeUtil.packets.PacketPlayOutScoreboardTeam.Action.REMOVE);
-			player.sendPacket(x);
-		}
-	}
+    public void removeTeam(String name) {
+        Team t = getTeam(name);
+        if (t != null) {
+            teams.remove(t);
+            PacketPlayOutScoreboardTeam x = new PacketPlayOutScoreboardTeam(t);
+            x.setAction(dev.wolveringer.BungeeUtil.packets.PacketPlayOutScoreboardTeam.Action.REMOVE);
+            player.sendPacket(x);
+        }
+    }
 
-	public Team getTeam(String name) {
-		for(Team t : teams)
-			if(t.getName().equals(name))
-				return t;
-		for(Team t : server_teams)
-			if(t.getName().equals(name))
-				return t;
-		return null;
-	}
+    public Team getTeam(String name) {
+        for (Team t : teams)
+            if (t.getName().equals(name))
+                return t;
+        for (Team t : server_teams)
+            if (t.getName().equals(name))
+                return t;
+        return null;
+    }
 
-	public List<Team> getTeams(){
-		return Collections.unmodifiableList(teams);
-	}
-	
-	@Override
-	public String toString() {
-		return "Scoreboard [Owner="+player.getName()+",Objekt-Count="+(objs.size()+server_objs.size())+"(Bungee: "+objs.size()+"/Server: "+server_objs.size()+"),Team-Count="+(teams.size()+server_teams.size())+"(Bungee:"+teams.size()+"/Server:"+server_teams.size()+")]";
-	}
+    public List<Team> getTeams() {
+        return Collections.unmodifiableList(teams);
+    }
+
+    @Override
+    public String toString() {
+        return "Scoreboard [Owner=" + player.getName() + ",Objekt-Count=" + (objs.size() + server_objs.size()) + "(Bungee: " + objs.size() + "/Server: " + server_objs.size() + "),Team-Count=" + (teams.size() + server_teams.size()) + "(Bungee:" + teams.size() + "/Server:" + server_teams.size() + ")]";
+    }
+
+    @SuppressWarnings({"serial", "unused"})
+    private static class ScoreboardAlredyExistException extends RuntimeException {
+        public ScoreboardAlredyExistException(String message) {
+            super(message);
+        }
+    }
 }
diff --git a/src/main/java/dev/wolveringer/api/scoreboard/Team.java b/src/main/java/dev/wolveringer/api/scoreboard/Team.java
index 791d1b1..e0f0483 100644
--- a/src/main/java/dev/wolveringer/api/scoreboard/Team.java
+++ b/src/main/java/dev/wolveringer/api/scoreboard/Team.java
@@ -1,94 +1,110 @@
 package dev.wolveringer.api.scoreboard;
 
+import net.md_5.bungee.api.ChatColor;
+
 import java.util.ArrayList;
 
-import net.md_5.bungee.api.ChatColor;
 import dev.wolveringer.BungeeUtil.packets.PacketPlayOutScoreboardTeam;
 import dev.wolveringer.BungeeUtil.packets.PacketPlayOutScoreboardTeam.Action;
 import dev.wolveringer.BungeeUtil.packets.PacketPlayOutScoreboardTeam.NameTag;
 
 public final class Team {
-	protected Scoreboard owner;
-	protected ChatColor color = ChatColor.WHITE;
-	protected String name;
-	protected String displayName;
-	protected String prefix = "";
-	protected String suffix = "";
-	protected NameTag tag = NameTag.VISIABLE;
-	protected int friendly_fire = 0;
-	protected ArrayList<String> member = new ArrayList<>();
-	
-	public Team(Scoreboard owner,String name) {
-		this.owner = owner;
-		this.name = name;
-	}
-	
-	public void setColor(ChatColor color) {
-		this.color = color;
-		sendUpdate();
-	}
-	public void setDisplayName(String displayName) {
-		this.displayName = displayName;
-		sendUpdate();
-	}
-	public void addMember(String name){
-		member.add(name);
-		PacketPlayOutScoreboardTeam team = new PacketPlayOutScoreboardTeam(this);
-		team.setAction(Action.PLAYER_ADD);
-		team.setPlayers(new String[]{name});
-		owner.player.sendPacket(team);
-	}
-	public void removeMember(String name){
-		member.remove(name);
-		PacketPlayOutScoreboardTeam team = new PacketPlayOutScoreboardTeam(this);
-		team.setAction(Action.PLAYER_REMOVE);
-		team.setPlayers(new String[]{name});
-		owner.player.sendPacket(team);
-	}
-	public void setPrefix(String prefix) {
-		this.prefix = prefix;
-		sendUpdate();
-	}
-	public void setSuffix(String suffix) {
-		this.suffix = suffix;
-		sendUpdate();
-	}
-	public void setTagVisibility(NameTag tag) {
-		this.tag = tag;
-		sendUpdate();
-	}
-	public void setFriendlyFire(int friendly_fire) {
-		this.friendly_fire = friendly_fire;
-		sendUpdate();
-	}
-	
-	public ChatColor getColor() {
-		return this.color;
-	}
-	public String getDisplayName() {
-		return this.displayName;
-	}
-	public ArrayList<String> getMember() {
-		return this.member;
-	}
-	public String getName() {
-		return this.name;
-	}
-	public String getPrefix() {
-		return this.prefix;
-	}
-	public String getSuffix() {
-		return this.suffix;
-	}
-	public NameTag getTagVisibility() {
-		return this.tag;
-	}
-	public int getFriendlyFire() {
-		return this.friendly_fire;
-	}
-	private void sendUpdate(){
-		PacketPlayOutScoreboardTeam team = new PacketPlayOutScoreboardTeam(this);
-		team.setAction(Action.UPDATE);
-		owner.player.sendPacket(team);
-	}
+    protected Scoreboard owner;
+    protected ChatColor color = ChatColor.WHITE;
+    protected String name;
+    protected String displayName;
+    protected String prefix = "";
+    protected String suffix = "";
+    protected NameTag tag = NameTag.VISIABLE;
+    protected int friendly_fire = 0;
+    protected ArrayList<String> member = new ArrayList<>();
+
+    public Team(Scoreboard owner, String name) {
+        this.owner = owner;
+        this.name = name;
+    }
+
+    public void addMember(String name) {
+        member.add(name);
+        PacketPlayOutScoreboardTeam team = new PacketPlayOutScoreboardTeam(this);
+        team.setAction(Action.PLAYER_ADD);
+        team.setPlayers(new String[]{name});
+        owner.player.sendPacket(team);
+    }
+
+    public void removeMember(String name) {
+        member.remove(name);
+        PacketPlayOutScoreboardTeam team = new PacketPlayOutScoreboardTeam(this);
+        team.setAction(Action.PLAYER_REMOVE);
+        team.setPlayers(new String[]{name});
+        owner.player.sendPacket(team);
+    }
+
+    public ChatColor getColor() {
+        return this.color;
+    }
+
+    public void setColor(ChatColor color) {
+        this.color = color;
+        sendUpdate();
+    }
+
+    public String getDisplayName() {
+        return this.displayName;
+    }
+
+    public void setDisplayName(String displayName) {
+        this.displayName = displayName;
+        sendUpdate();
+    }
+
+    public ArrayList<String> getMember() {
+        return this.member;
+    }
+
+    public String getName() {
+        return this.name;
+    }
+
+    public String getPrefix() {
+        return this.prefix;
+    }
+
+    public void setPrefix(String prefix) {
+        this.prefix = prefix;
+        sendUpdate();
+    }
+
+    public String getSuffix() {
+        return this.suffix;
+    }
+
+    public void setSuffix(String suffix) {
+        this.suffix = suffix;
+        sendUpdate();
+    }
+
+    public NameTag getTagVisibility() {
+        return this.tag;
+    }
+
+    public void setTagVisibility(NameTag tag) {
+        this.tag = tag;
+        sendUpdate();
+    }
+
+    public int getFriendlyFire() {
+        return this.friendly_fire;
+    }
+
+    public void setFriendlyFire(int friendly_fire) {
+        this.friendly_fire = friendly_fire;
+        sendUpdate();
+    }
+
+    private void sendUpdate() {
+        PacketPlayOutScoreboardTeam team = new PacketPlayOutScoreboardTeam(this);
+        team.setAction(Action.UPDATE);
+        owner.player.sendPacket(team);
+    }
 }
diff --git a/src/main/java/dev/wolveringer/api/sound/SoundCategory.java b/src/main/java/dev/wolveringer/api/sound/SoundCategory.java
index 727eb8a..b003576 100644
--- a/src/main/java/dev/wolveringer/api/sound/SoundCategory.java
+++ b/src/main/java/dev/wolveringer/api/sound/SoundCategory.java
@@ -1,24 +1,24 @@
 package dev.wolveringer.api.sound;
 
 public enum SoundCategory {
-	MASTER("master"),
-	MUSIC("music"),
-	RECORDS("record"),
-	WEATHER("weather"),
-	BLOCKS("block"),
-	HOSTILE("hostile"),
-	NEUTRAL("neutral"),
-	PLAYERS("player"),
-	AMBIENT("ambient"),
-	VOICE("voice");
-	
-	private String name;
-	
-	private SoundCategory(String name) {
-		this.name = name;
-	}
-	
-	public String getName() {
-		return name;
-	}
+    MASTER("master"),
+    MUSIC("music"),
+    RECORDS("record"),
+    WEATHER("weather"),
+    BLOCKS("block"),
+    HOSTILE("hostile"),
+    NEUTRAL("neutral"),
+    PLAYERS("player"),
+    AMBIENT("ambient"),
+    VOICE("voice");
+
+    private String name;
+
+    private SoundCategory(String name) {
+        this.name = name;
+    }
+
+    public String getName() {
+        return name;
+    }
 }
diff --git a/src/main/java/dev/wolveringer/api/sound/SoundEffect.java b/src/main/java/dev/wolveringer/api/sound/SoundEffect.java
index 55d239e..87bd8f5 100644
--- a/src/main/java/dev/wolveringer/api/sound/SoundEffect.java
+++ b/src/main/java/dev/wolveringer/api/sound/SoundEffect.java
@@ -5,1419 +5,1419 @@ import java.util.HashMap;
 import dev.wolveringer.BungeeUtil.ClientVersion.BigClientVersion;
 
 public enum SoundEffect {
-	
-	/**
-	 * @author essem 
-	 * 
-	 */
-	
-	AMBIENT_CAVE,
-	BLOCK_ANVIL_BREAK,
-	BLOCK_ANVIL_DESTROY,
-	BLOCK_ANVIL_FALL,
-	BLOCK_ANVIL_HIT,
-	BLOCK_ANVIL_LAND,
-	BLOCK_ANVIL_PLACE,
-	BLOCK_ANVIL_STEP,
-	BLOCK_ANVIL_USE,
-	BLOCK_BREWING_STAND_BREW,
-	BLOCK_CHEST_CLOSE,
-	BLOCK_CHEST_LOCKED,
-	BLOCK_CHEST_OPEN,
-	BLOCK_CHORUS_FLOWER_DEATH,
-	BLOCK_CHORUS_FLOWER_GROW,
-	BLOCK_CLOTH_BREAK,
-	BLOCK_CLOTH_FALL,
-	BLOCK_CLOTH_HIT,
-	BLOCK_CLOTH_PLACE,
-	BLOCK_CLOTH_STEP,
-	BLOCK_COMPARATOR_CLICK,
-	BLOCK_DISPENSER_DISPENSE,
-	BLOCK_DISPENSER_FAIL,
-	BLOCK_DISPENSER_LAUNCH,
-	BLOCK_ENCHANTMENT_TABLE_USE,
-	BLOCK_END_GATEWAY_SPAWN,
-	BLOCK_ENDERCHEST_CLOSE,
-	BLOCK_ENDERCHEST_OPEN,
-	BLOCK_FENCE_GATE_CLOSE,
-	BLOCK_FENCE_GATE_OPEN,
-	BLOCK_FIRE_AMBIENT,
-	BLOCK_FIRE_EXTINGUISH,
-	BLOCK_FURNACE_FIRE_CRACKLE,
-	BLOCK_GLASS_BREAK,
-	BLOCK_GLASS_FALL,
-	BLOCK_GLASS_HIT,
-	BLOCK_GLASS_PLACE,
-	BLOCK_GLASS_STEP,
-	BLOCK_GRASS_BREAK,
-	BLOCK_GRASS_FALL,
-	BLOCK_GRASS_HIT,
-	BLOCK_GRASS_PLACE,
-	BLOCK_GRASS_STEP,
-	BLOCK_GRAVEL_BREAK,
-	BLOCK_GRAVEL_FALL,
-	BLOCK_GRAVEL_HIT,
-	BLOCK_GRAVEL_PLACE,
-	BLOCK_GRAVEL_STEP,
-	BLOCK_IRON_DOOR_CLOSE,
-	BLOCK_IRON_DOOR_OPEN,
-	BLOCK_IRON_TRAPDOOR_CLOSE,
-	BLOCK_IRON_TRAPDOOR_OPEN,
-	BLOCK_LADDER_BREAK,
-	BLOCK_LADDER_FALL,
-	BLOCK_LADDER_HIT,
-	BLOCK_LADDER_PLACE,
-	BLOCK_LADDER_STEP,
-	BLOCK_LAVA_AMBIENT,
-	BLOCK_LAVA_EXTINGUISH,
-	BLOCK_LAVA_POP,
-	BLOCK_LEVER_CLICK,
-	BLOCK_METAL_BREAK,
-	BLOCK_METAL_FALL,
-	BLOCK_METAL_HIT,
-	BLOCK_METAL_PLACE,
-	BLOCK_METAL_PRESSUREPLATE_CLICK_OFF,
-	BLOCK_METAL_PRESSUREPLATE_CLICK_ON,
-	BLOCK_METAL_STEP,
-	BLOCK_NOTE_BASEDRUM,
-	BLOCK_NOTE_BASS,
-	BLOCK_NOTE_HARP,
-	BLOCK_NOTE_HAT,
-	BLOCK_NOTE_PLING,
-	BLOCK_NOTE_SNARE,
-	BLOCK_PISTON_CONTRACT,
-	BLOCK_PISTON_EXTEND,
-	BLOCK_PORTAL_AMBIENT,
-	BLOCK_PORTAL_TRAVEL,
-	BLOCK_PORTAL_TRIGGER,
-	BLOCK_REDSTONE_TORCH_BURNOUT,
-	BLOCK_SAND_BREAK,
-	BLOCK_SAND_FALL,
-	BLOCK_SAND_HIT,
-	BLOCK_SAND_PLACE,
-	BLOCK_SAND_STEP,
-	BLOCK_SLIME_BREAK,
-	BLOCK_SLIME_FALL,
-	BLOCK_SLIME_HIT,
-	BLOCK_SLIME_PLACE,
-	BLOCK_SLIME_STEP,
-	BLOCK_SNOW_BREAK,
-	BLOCK_SNOW_FALL,
-	BLOCK_SNOW_HIT,
-	BLOCK_SNOW_PLACE,
-	BLOCK_SNOW_STEP,
-	BLOCK_STONE_BREAK,
-	BLOCK_STONE_BUTTON_CLICK_OFF,
-	BLOCK_STONE_BUTTON_CLICK_ON,
-	BLOCK_STONE_FALL,
-	BLOCK_STONE_HIT,
-	BLOCK_STONE_PLACE,
-	BLOCK_STONE_PRESSUREPLATE_CLICK_OFF,
-	BLOCK_STONE_PRESSUREPLATE_CLICK_ON,
-	BLOCK_STONE_STEP,
-	BLOCK_TRIPWIRE_ATTACH,
-	BLOCK_TRIPWIRE_CLICK_OFF,
-	BLOCK_TRIPWIRE_CLICK_ON,
-	BLOCK_TRIPWIRE_DETACH,
-	BLOCK_WATER_AMBIENT,
-	BLOCK_WATERLILY_PLACE,
-	BLOCK_WOOD_BREAK,
-	BLOCK_WOOD_BUTTON_CLICK_OFF,
-	BLOCK_WOOD_BUTTON_CLICK_ON,
-	BLOCK_WOOD_FALL,
-	BLOCK_WOOD_HIT,
-	BLOCK_WOOD_PLACE,
-	BLOCK_WOOD_PRESSUREPLATE_CLICK_OFF,
-	BLOCK_WOOD_PRESSUREPLATE_CLICK_ON,
-	BLOCK_WOOD_STEP,
-	BLOCK_WOODEN_DOOR_CLOSE,
-	BLOCK_WOODEN_DOOR_OPEN,
-	BLOCK_WOODEN_TRAPDOOR_CLOSE,
-	BLOCK_WOODEN_TRAPDOOR_OPEN,
-	ENCHANT_THORNS_HIT,
-	ENTITY_ARMORSTAND_BREAK,
-	ENTITY_ARMORSTAND_FALL,
-	ENTITY_ARMORSTAND_HIT,
-	ENTITY_ARMORSTAND_PLACE,
-	ENTITY_ARROW_HIT,
-	ENTITY_ARROW_HIT_PLAYER,
-	ENTITY_ARROW_SHOOT,
-	ENTITY_BAT_AMBIENT,
-	ENTITY_BAT_DEATH,
-	ENTITY_BAT_HURT,
-	ENTITY_BAT_LOOP,
-	ENTITY_BAT_TAKEOFF,
-	ENTITY_BLAZE_AMBIENT,
-	ENTITY_BLAZE_BURN,
-	ENTITY_BLAZE_DEATH,
-	ENTITY_BLAZE_HURT,
-	ENTITY_BLAZE_SHOOT,
-	ENTITY_BOBBER_SPLASH,
-	ENTITY_BOBBER_THROW,
-	ENTITY_CAT_AMBIENT,
-	ENTITY_CAT_DEATH,
-	ENTITY_CAT_HISS,
-	ENTITY_CAT_HURT,
-	ENTITY_CAT_PURR,
-	ENTITY_CAT_PURREOW,
-	ENTITY_CHICKEN_AMBIENT,
-	ENTITY_CHICKEN_DEATH,
-	ENTITY_CHICKEN_EGG,
-	ENTITY_CHICKEN_HURT,
-	ENTITY_CHICKEN_STEP,
-	ENTITY_COW_AMBIENT,
-	ENTITY_COW_DEATH,
-	ENTITY_COW_HURT,
-	ENTITY_COW_MILK,
-	ENTITY_COW_STEP,
-	ENTITY_CREEPER_DEATH,
-	ENTITY_CREEPER_HURT,
-	ENTITY_CREEPER_PRIMED,
-	ENTITY_DONKEY_AMBIENT,
-	ENTITY_DONKEY_ANGRY,
-	ENTITY_DONKEY_CHEST,
-	ENTITY_DONKEY_DEATH,
-	ENTITY_DONKEY_HURT,
-	ENTITY_EGG_THROW,
-	ENTITY_ELDER_GUARDIAN_AMBIENT,
-	ENTITY_ELDER_GUARDIAN_AMBIENT_LAND,
-	ENTITY_ELDER_GUARDIAN_CURSE,
-	ENTITY_ELDER_GUARDIAN_DEATH,
-	ENTITY_ELDER_GUARDIAN_DEATH_LAND,
-	ENTITY_ELDER_GUARDIAN_HURT,
-	ENTITY_ELDER_GUARDIAN_HURT_LAND,
-	ENTITY_ENDERDRAGON_AMBIENT,
-	ENTITY_ENDERDRAGON_DEATH,
-	ENTITY_ENDERDRAGON_FIREBALL_EXPLODE,
-	ENTITY_ENDERDRAGON_FLAP,
-	ENTITY_ENDERDRAGON_GROWL,
-	ENTITY_ENDERDRAGON_HURT,
-	ENTITY_ENDERDRAGON_SHOOT,
-	ENTITY_ENDEREYE_LAUNCH,
-	ENTITY_ENDERMEN_AMBIENT,
-	ENTITY_ENDERMEN_DEATH,
-	ENTITY_ENDERMEN_HURT,
-	ENTITY_ENDERMEN_SCREAM,
-	ENTITY_ENDERMEN_STARE,
-	ENTITY_ENDERMEN_TELEPORT,
-	ENTITY_ENDERMITE_AMBIENT,
-	ENTITY_ENDERMITE_DEATH,
-	ENTITY_ENDERMITE_HURT,
-	ENTITY_ENDERMITE_STEP,
-	ENTITY_ENDERPEARL_THROW,
-	ENTITY_EXPERIENCE_BOTTLE_THROW,
-	ENTITY_EXPERIENCE_ORB_PICKUP,
-	ENTITY_EXPERIENCE_ORB_TOUCH,
-	ENTITY_FIREWORK_BLAST,
-	ENTITY_FIREWORK_BLAST_FAR,
-	ENTITY_FIREWORK_LARGE_BLAST,
-	ENTITY_FIREWORK_LARGE_BLAST_FAR,
-	ENTITY_FIREWORK_LAUNCH,
-	ENTITY_FIREWORK_SHOOT,
-	ENTITY_FIREWORK_TWINKLE,
-	ENTITY_FIREWORK_TWINKLE_FAR,
-	ENTITY_GENERIC_BIG_FALL,
-	ENTITY_GENERIC_BURN,
-	ENTITY_GENERIC_DEATH,
-	ENTITY_GENERIC_DRINK,
-	ENTITY_GENERIC_EAT,
-	ENTITY_GENERIC_EXPLODE,
-	ENTITY_GENERIC_EXTINGUISH_FIRE,
-	ENTITY_GENERIC_HURT,
-	ENTITY_GENERIC_SMALL_FALL,
-	ENTITY_GENERIC_SPLASH,
-	ENTITY_GENERIC_SWIM,
-	ENTITY_GHAST_AMBIENT,
-	ENTITY_GHAST_DEATH,
-	ENTITY_GHAST_HURT,
-	ENTITY_GHAST_SCREAM,
-	ENTITY_GHAST_SHOOT,
-	ENTITY_GHAST_WARN,
-	ENTITY_GUARDIAN_AMBIENT,
-	ENTITY_GUARDIAN_AMBIENT_LAND,
-	ENTITY_GUARDIAN_ATTACK,
-	ENTITY_GUARDIAN_DEATH,
-	ENTITY_GUARDIAN_DEATH_LAND,
-	ENTITY_GUARDIAN_FLOP,
-	ENTITY_GUARDIAN_HURT,
-	ENTITY_GUARDIAN_HURT_LAND,
-	ENTITY_HORSE_AMBIENT,
-	ENTITY_HORSE_ANGRY,
-	ENTITY_HORSE_ARMOR,
-	ENTITY_HORSE_BREATHE,
-	ENTITY_HORSE_DEATH,
-	ENTITY_HORSE_EAT,
-	ENTITY_HORSE_GALLOP,
-	ENTITY_HORSE_HURT,
-	ENTITY_HORSE_JUMP,
-	ENTITY_HORSE_LAND,
-	ENTITY_HORSE_SADDLE,
-	ENTITY_HORSE_STEP,
-	ENTITY_HORSE_STEP_WOOD,
-	ENTITY_HOSTILE_BIG_FALL,
-	ENTITY_HOSTILE_DEATH,
-	ENTITY_HOSTILE_HURT,
-	ENTITY_HOSTILE_SMALL_FALL,
-	ENTITY_HOSTILE_SPLASH,
-	ENTITY_HOSTILE_SWIM,
-	ENTITY_HUSK_AMBIENT,
-	ENTITY_HUSK_DEATH,
-	ENTITY_HUSK_HURT,
-	ENTITY_HUSK_STEP,
-	ENTITY_IRONGOLEM_ATTACK,
-	ENTITY_IRONGOLEM_DEATH,
-	ENTITY_IRONGOLEM_HURT,
-	ENTITY_IRONGOLEM_STEP,
-	ENTITY_ITEM_BREAK,
-	ENTITY_ITEM_PICKUP,
-	ENTITY_ITEMFRAME_ADD_ITEM,
-	ENTITY_ITEMFRAME_BREAK,
-	ENTITY_ITEMFRAME_PLACE,
-	ENTITY_ITEMFRAME_REMOVE_ITEM,
-	ENTITY_ITEMFRAME_ROTATE_ITEM,
-	ENTITY_LEASHKNOT_BREAK,
-	ENTITY_LEASHKNOT_PLACE,
-	ENTITY_LIGHTNING_IMPACT,
-	ENTITY_LIGHTNING_THUNDER,
-	ENTITY_LINGERINGPOTION_THROW,
-	ENTITY_MAGMACUBE_DEATH,
-	ENTITY_MAGMACUBE_HURT,
-	ENTITY_MAGMACUBE_JUMP,
-	ENTITY_MAGMACUBE_SQUISH,
-	ENTITY_MINECART_INSIDE,
-	ENTITY_MINECART_RIDING,
-	ENTITY_MOOSHROOM_SHEAR,
-	ENTITY_MULE_AMBIENT,
-	ENTITY_MULE_DEATH,
-	ENTITY_MULE_HURT,
-	ENTITY_PAINTING_BREAK,
-	ENTITY_PAINTING_PLACE,
-	ENTITY_PIG_AMBIENT,
-	ENTITY_PIG_DEATH,
-	ENTITY_PIG_HURT,
-	ENTITY_PIG_SADDLE,
-	ENTITY_PIG_STEP,
-	ENTITY_PLAYER_ATTACK_CRIT,
-	ENTITY_PLAYER_ATTACK_KNOCKBACK,
-	ENTITY_PLAYER_ATTACK_NODAMAGE,
-	ENTITY_PLAYER_ATTACK_STRONG,
-	ENTITY_PLAYER_ATTACK_SWEEP,
-	ENTITY_PLAYER_ATTACK_WEAK,
-	ENTITY_PLAYER_BIG_FALL,
-	ENTITY_PLAYER_BREATH,
-	ENTITY_PLAYER_BURP,
-	ENTITY_PLAYER_DEATH,
-	ENTITY_PLAYER_HURT,
-	ENTITY_PLAYER_LEVELUP,
-	ENTITY_PLAYER_SMALL_FALL,
-	ENTITY_PLAYER_SPLASH,
-	ENTITY_PLAYER_SWIM,
-	ENTITY_POLAR_BEAR_AMBIENT,
-	ENTITY_POLAR_BEAR_BABY_AMBIENT,
-	ENTITY_POLAR_BEAR_DEATH,
-	ENTITY_POLAR_BEAR_HURT,
-	ENTITY_POLAR_BEAR_STEP,
-	ENTITY_POLAR_BEAR_WARNING,
-	ENTITY_RABBIT_AMBIENT,
-	ENTITY_RABBIT_ATTACK,
-	ENTITY_RABBIT_DEATH,
-	ENTITY_RABBIT_HURT,
-	ENTITY_RABBIT_JUMP,
-	ENTITY_SHEEP_AMBIENT,
-	ENTITY_SHEEP_DEATH,
-	ENTITY_SHEEP_HURT,
-	ENTITY_SHEEP_SHEAR,
-	ENTITY_SHEEP_STEP,
-	ENTITY_SHULKER_AMBIENT,
-	ENTITY_SHULKER_BULLET_HIT,
-	ENTITY_SHULKER_BULLET_HURT,
-	ENTITY_SHULKER_CLOSE,
-	ENTITY_SHULKER_DEATH,
-	ENTITY_SHULKER_HURT,
-	ENTITY_SHULKER_HURT_CLOSED,
-	ENTITY_SHULKER_OPEN,
-	ENTITY_SHULKER_SHOOT,
-	ENTITY_SHULKER_TELEPORT,
-	ENTITY_SILVERFISH_AMBIENT,
-	ENTITY_SILVERFISH_DEATH,
-	ENTITY_SILVERFISH_HURT,
-	ENTITY_SILVERFISH_STEP,
-	ENTITY_SKELETON_AMBIENT,
-	ENTITY_SKELETON_DEATH,
-	ENTITY_SKELETON_HORSE_AMBIENT,
-	ENTITY_SKELETON_HORSE_DEATH,
-	ENTITY_SKELETON_HORSE_HURT,
-	ENTITY_SKELETON_HURT,
-	ENTITY_SKELETON_SHOOT,
-	ENTITY_SKELETON_STEP,
-	ENTITY_SLIME_ATTACK,
-	ENTITY_SLIME_DEATH,
-	ENTITY_SLIME_HURT,
-	ENTITY_SLIME_JUMP,
-	ENTITY_SLIME_SQUISH,
-	ENTITY_SMALL_MAGMACUBE_DEATH,
-	ENTITY_SMALL_MAGMACUBE_HURT,
-	ENTITY_SMALL_MAGMACUBE_SQUISH,
-	ENTITY_SMALL_SLIME_DEATH,
-	ENTITY_SMALL_SLIME_HURT,
-	ENTITY_SMALL_SLIME_JUMP,
-	ENTITY_SMALL_SLIME_SQUISH,
-	ENTITY_SNOWBALL_THROW,
-	ENTITY_SNOWMAN_AMBIENT,
-	ENTITY_SNOWMAN_DEATH,
-	ENTITY_SNOWMAN_HURT,
-	ENTITY_SNOWMAN_SHOOT,
-	ENTITY_SPIDER_AMBIENT,
-	ENTITY_SPIDER_DEATH,
-	ENTITY_SPIDER_HURT,
-	ENTITY_SPIDER_STEP,
-	ENTITY_SPLASH_POTION_BREAK,
-	ENTITY_SPLASH_POTION_THROW,
-	ENTITY_SQUID_AMBIENT,
-	ENTITY_SQUID_DEATH,
-	ENTITY_SQUID_HURT,
-	ENTITY_STRAY_AMBIENT,
-	ENTITY_STRAY_DEATH,
-	ENTITY_STRAY_HURT,
-	ENTITY_STRAY_STEP,
-	ENTITY_TNT_PRIMED,
-	ENTITY_VILLAGER_AMBIENT,
-	ENTITY_VILLAGER_DEATH,
-	ENTITY_VILLAGER_HURT,
-	ENTITY_VILLAGER_NO,
-	ENTITY_VILLAGER_TRADING,
-	ENTITY_VILLAGER_YES,
-	ENTITY_WITCH_AMBIENT,
-	ENTITY_WITCH_DEATH,
-	ENTITY_WITCH_DRINK,
-	ENTITY_WITCH_HURT,
-	ENTITY_WITCH_THROW,
-	ENTITY_WITHER_AMBIENT,
-	ENTITY_WITHER_BREAK_BLOCK,
-	ENTITY_WITHER_DEATH,
-	ENTITY_WITHER_HURT,
-	ENTITY_WITHER_SHOOT,
-	ENTITY_WITHER_SKELETON_AMBIENT,
-	ENTITY_WITHER_SKELETON_DEATH,
-	ENTITY_WITHER_SKELETON_HURT,
-	ENTITY_WITHER_SKELETON_STEP,
-	ENTITY_WITHER_SPAWN,
-	ENTITY_WOLF_AMBIENT,
-	ENTITY_WOLF_DEATH,
-	ENTITY_WOLF_GROWL,
-	ENTITY_WOLF_HOWL,
-	ENTITY_WOLF_HURT,
-	ENTITY_WOLF_PANT,
-	ENTITY_WOLF_SHAKE,
-	ENTITY_WOLF_STEP,
-	ENTITY_WOLF_WHINE,
-	ENTITY_ZOMBIE_AMBIENT,
-	ENTITY_ZOMBIE_ATTACK_DOOR_WOOD,
-	ENTITY_ZOMBIE_ATTACK_IRON_DOOR,
-	ENTITY_ZOMBIE_BREAK_DOOR_WOOD,
-	ENTITY_ZOMBIE_DEATH,
-	ENTITY_ZOMBIE_HORSE_AMBIENT,
-	ENTITY_ZOMBIE_HORSE_DEATH,
-	ENTITY_ZOMBIE_HORSE_HURT,
-	ENTITY_ZOMBIE_HURT,
-	ENTITY_ZOMBIE_INFECT,
-	ENTITY_ZOMBIE_PIG_AMBIENT,
-	ENTITY_ZOMBIE_PIG_ANGRY,
-	ENTITY_ZOMBIE_PIG_DEATH,
-	ENTITY_ZOMBIE_PIG_HURT,
-	ENTITY_ZOMBIE_STEP,
-	ENTITY_ZOMBIE_VILLAGER_AMBIENT,
-	ENTITY_ZOMBIE_VILLAGER_CONVERTED,
-	ENTITY_ZOMBIE_VILLAGER_CURE,
-	ENTITY_ZOMBIE_VILLAGER_DEATH,
-	ENTITY_ZOMBIE_VILLAGER_HURT,
-	ENTITY_ZOMBIE_VILLAGER_STEP,
-	ITEM_ARMOR_EQUIP_CHAIN,
-	ITEM_ARMOR_EQUIP_DIAMOND,
-	ITEM_ARMOR_EQUIP_GENERIC,
-	ITEM_ARMOR_EQUIP_GOLD,
-	ITEM_ARMOR_EQUIP_IRON,
-	ITEM_ARMOR_EQUIP_LEATHER,
-	ITEM_BOTTLE_FILL,
-	ITEM_BOTTLE_FILL_DRAGONBREATH,
-	ITEM_BUCKET_EMPTY,
-	ITEM_BUCKET_EMPTY_LAVA,
-	ITEM_BUCKET_FILL,
-	ITEM_BUCKET_FILL_LAVA,
-	ITEM_CHORUS_FRUIT_TELEPORT,
-	ITEM_ELYTRA_FLYING,
-	ITEM_FIRECHARGE_USE,
-	ITEM_FLINTANDSTEEL_USE,
-	ITEM_HOE_TILL,
-	ITEM_SHIELD_BLOCK,
-	ITEM_SHIELD_BREAK,
-	ITEM_SHOVEL_FLATTEN,
-	MUSIC_CREATIVE,
-	MUSIC_CREDITS,
-	MUSIC_DRAGON,
-	MUSIC_END,
-	MUSIC_GAME,
-	MUSIC_MENU,
-	MUSIC_NETHER,
-	RECORD_11,
-	RECORD_13,
-	RECORD_BLOCKS,
-	RECORD_CAT,
-	RECORD_CHIRP,
-	RECORD_FAR,
-	RECORD_MALL,
-	RECORD_MELLOHI,
-	RECORD_STAL,
-	RECORD_STRAD,
-	RECORD_WAIT,
-	RECORD_WARD,
-	UI_BUTTON_CLICK,
-	WEATHER_RAIN,
-	WEATHER_RAIN_ABOVE;
-	//...
-	
-	static {
-		//1.10
-		addSound(AMBIENT_CAVE, BigClientVersion.v1_10, "ambient.cave");
-		addSound(BLOCK_ANVIL_BREAK, BigClientVersion.v1_10, "block.anvil.break");
-		addSound(BLOCK_ANVIL_DESTROY, BigClientVersion.v1_10, "block.anvil.destroy");
-		addSound(BLOCK_ANVIL_FALL, BigClientVersion.v1_10, "block.anvil.fall");
-		addSound(BLOCK_ANVIL_HIT, BigClientVersion.v1_10, "block.anvil.hit");
-		addSound(BLOCK_ANVIL_LAND, BigClientVersion.v1_10, "block.anvil.land");
-		addSound(BLOCK_ANVIL_PLACE, BigClientVersion.v1_10, "block.anvil.place");
-		addSound(BLOCK_ANVIL_STEP, BigClientVersion.v1_10, "block.anvil.step");
-		addSound(BLOCK_ANVIL_USE, BigClientVersion.v1_10, "block.anvil.use");
-		addSound(BLOCK_BREWING_STAND_BREW, BigClientVersion.v1_10, "block.brewing_stand.brew");
-		addSound(BLOCK_CHEST_CLOSE, BigClientVersion.v1_10, "block.chest.close");
-		addSound(BLOCK_CHEST_LOCKED, BigClientVersion.v1_10, "block.chest.locked");
-		addSound(BLOCK_CHEST_OPEN, BigClientVersion.v1_10, "block.chest.open");
-		addSound(BLOCK_CHORUS_FLOWER_DEATH, BigClientVersion.v1_10, "block.chorus_flower.death");
-		addSound(BLOCK_CHORUS_FLOWER_GROW, BigClientVersion.v1_10, "block.chorus_flower.grow");
-		addSound(BLOCK_CLOTH_BREAK, BigClientVersion.v1_10, "block.cloth.break");
-		addSound(BLOCK_CLOTH_FALL, BigClientVersion.v1_10, "block.cloth.fall");
-		addSound(BLOCK_CLOTH_HIT, BigClientVersion.v1_10, "block.cloth.hit");
-		addSound(BLOCK_CLOTH_PLACE, BigClientVersion.v1_10, "block.cloth.place");
-		addSound(BLOCK_CLOTH_STEP, BigClientVersion.v1_10, "block.cloth.step");
-		addSound(BLOCK_COMPARATOR_CLICK, BigClientVersion.v1_10, "block.comparator.click");
-		addSound(BLOCK_DISPENSER_DISPENSE, BigClientVersion.v1_10, "block.dispenser.dispense");
-		addSound(BLOCK_DISPENSER_FAIL, BigClientVersion.v1_10, "block.dispenser.fail");
-		addSound(BLOCK_DISPENSER_LAUNCH, BigClientVersion.v1_10, "block.dispenser.launch");
-		addSound(BLOCK_ENCHANTMENT_TABLE_USE, BigClientVersion.v1_10, "block.enchantment_table.use");
-		addSound(BLOCK_END_GATEWAY_SPAWN, BigClientVersion.v1_10, "block.end_gateway.spawn");
-		addSound(BLOCK_ENDERCHEST_CLOSE, BigClientVersion.v1_10, "block.enderchest.close");
-		addSound(BLOCK_ENDERCHEST_OPEN, BigClientVersion.v1_10, "block.enderchest.open");
-		addSound(BLOCK_FENCE_GATE_CLOSE, BigClientVersion.v1_10, "block.fence_gate.close");
-		addSound(BLOCK_FENCE_GATE_OPEN, BigClientVersion.v1_10, "block.fence_gate.open");
-		addSound(BLOCK_FIRE_AMBIENT, BigClientVersion.v1_10, "block.fire.ambient");
-		addSound(BLOCK_FIRE_EXTINGUISH, BigClientVersion.v1_10, "block.fire.extinguish");
-		addSound(BLOCK_FURNACE_FIRE_CRACKLE, BigClientVersion.v1_10, "block.furnace.fire_crackle");
-		addSound(BLOCK_GLASS_BREAK, BigClientVersion.v1_10, "block.glass.break");
-		addSound(BLOCK_GLASS_FALL, BigClientVersion.v1_10, "block.glass.fall");
-		addSound(BLOCK_GLASS_HIT, BigClientVersion.v1_10, "block.glass.hit");
-		addSound(BLOCK_GLASS_PLACE, BigClientVersion.v1_10, "block.glass.place");
-		addSound(BLOCK_GLASS_STEP, BigClientVersion.v1_10, "block.glass.step");
-		addSound(BLOCK_GRASS_BREAK, BigClientVersion.v1_10, "block.grass.break");
-		addSound(BLOCK_GRASS_FALL, BigClientVersion.v1_10, "block.grass.fall");
-		addSound(BLOCK_GRASS_HIT, BigClientVersion.v1_10, "block.grass.hit");
-		addSound(BLOCK_GRASS_PLACE, BigClientVersion.v1_10, "block.grass.place");
-		addSound(BLOCK_GRASS_STEP, BigClientVersion.v1_10, "block.grass.step");
-		addSound(BLOCK_GRAVEL_BREAK, BigClientVersion.v1_10, "block.gravel.break");
-		addSound(BLOCK_GRAVEL_FALL, BigClientVersion.v1_10, "block.gravel.fall");
-		addSound(BLOCK_GRAVEL_HIT, BigClientVersion.v1_10, "block.gravel.hit");
-		addSound(BLOCK_GRAVEL_PLACE, BigClientVersion.v1_10, "block.gravel.place");
-		addSound(BLOCK_GRAVEL_STEP, BigClientVersion.v1_10, "block.gravel.step");
-		addSound(BLOCK_IRON_DOOR_CLOSE, BigClientVersion.v1_10, "block.iron_door.close");
-		addSound(BLOCK_IRON_DOOR_OPEN, BigClientVersion.v1_10, "block.iron_door.open");
-		addSound(BLOCK_IRON_TRAPDOOR_CLOSE, BigClientVersion.v1_10, "block.iron_trapdoor.close");
-		addSound(BLOCK_IRON_TRAPDOOR_OPEN, BigClientVersion.v1_10, "block.iron_trapdoor.open");
-		addSound(BLOCK_LADDER_BREAK, BigClientVersion.v1_10, "block.ladder.break");
-		addSound(BLOCK_LADDER_FALL, BigClientVersion.v1_10, "block.ladder.fall");
-		addSound(BLOCK_LADDER_HIT, BigClientVersion.v1_10, "block.ladder.hit");
-		addSound(BLOCK_LADDER_PLACE, BigClientVersion.v1_10, "block.ladder.place");
-		addSound(BLOCK_LADDER_STEP, BigClientVersion.v1_10, "block.ladder.step");
-		addSound(BLOCK_LAVA_AMBIENT, BigClientVersion.v1_10, "block.lava.ambient");
-		addSound(BLOCK_LAVA_EXTINGUISH, BigClientVersion.v1_10, "block.lava.extinguish");
-		addSound(BLOCK_LAVA_POP, BigClientVersion.v1_10, "block.lava.pop");
-		addSound(BLOCK_LEVER_CLICK, BigClientVersion.v1_10, "block.lever.click");
-		addSound(BLOCK_METAL_BREAK, BigClientVersion.v1_10, "block.metal.break");
-		addSound(BLOCK_METAL_FALL, BigClientVersion.v1_10, "block.metal.fall");
-		addSound(BLOCK_METAL_HIT, BigClientVersion.v1_10, "block.metal.hit");
-		addSound(BLOCK_METAL_PLACE, BigClientVersion.v1_10, "block.metal.place");
-		addSound(BLOCK_METAL_STEP, BigClientVersion.v1_10, "block.metal.step");
-		addSound(BLOCK_METAL_PRESSUREPLATE_CLICK_OFF, BigClientVersion.v1_10, "block.metal_pressureplate.click_off");
-		addSound(BLOCK_METAL_PRESSUREPLATE_CLICK_ON, BigClientVersion.v1_10, "block.metal_pressureplate.click_on");
-		addSound(BLOCK_NOTE_BASEDRUM, BigClientVersion.v1_10, "block.note.basedrum");
-		addSound(BLOCK_NOTE_BASS, BigClientVersion.v1_10, "block.note.bass");
-		addSound(BLOCK_NOTE_HARP, BigClientVersion.v1_10, "block.note.harp");
-		addSound(BLOCK_NOTE_HAT, BigClientVersion.v1_10, "block.note.hat");
-		addSound(BLOCK_NOTE_PLING, BigClientVersion.v1_10, "block.note.pling");
-		addSound(BLOCK_NOTE_SNARE, BigClientVersion.v1_10, "block.note.snare");
-		addSound(BLOCK_PISTON_CONTRACT, BigClientVersion.v1_10, "block.piston.contract");
-		addSound(BLOCK_PISTON_EXTEND, BigClientVersion.v1_10, "block.piston.extend");
-		addSound(BLOCK_PORTAL_AMBIENT, BigClientVersion.v1_10, "block.portal.ambient");
-		addSound(BLOCK_PORTAL_TRAVEL, BigClientVersion.v1_10, "block.portal.travel");
-		addSound(BLOCK_PORTAL_TRIGGER, BigClientVersion.v1_10, "block.portal.trigger");
-		addSound(BLOCK_REDSTONE_TORCH_BURNOUT, BigClientVersion.v1_10, "block.redstone_torch.burnout");
-		addSound(BLOCK_SAND_BREAK, BigClientVersion.v1_10, "block.sand.break");
-		addSound(BLOCK_SAND_FALL, BigClientVersion.v1_10, "block.sand.fall");
-		addSound(BLOCK_SAND_HIT, BigClientVersion.v1_10, "block.sand.hit");
-		addSound(BLOCK_SAND_PLACE, BigClientVersion.v1_10, "block.sand.place");
-		addSound(BLOCK_SAND_STEP, BigClientVersion.v1_10, "block.sand.step");
-		addSound(BLOCK_SLIME_BREAK, BigClientVersion.v1_10, "block.slime.break");
-		addSound(BLOCK_SLIME_FALL, BigClientVersion.v1_10, "block.slime.fall");
-		addSound(BLOCK_SLIME_HIT, BigClientVersion.v1_10, "block.slime.hit");
-		addSound(BLOCK_SLIME_PLACE, BigClientVersion.v1_10, "block.slime.place");
-		addSound(BLOCK_SLIME_STEP, BigClientVersion.v1_10, "block.slime.step");
-		addSound(BLOCK_SNOW_BREAK, BigClientVersion.v1_10, "block.snow.break");
-		addSound(BLOCK_SNOW_FALL, BigClientVersion.v1_10, "block.snow.fall");
-		addSound(BLOCK_SNOW_HIT, BigClientVersion.v1_10, "block.snow.hit");
-		addSound(BLOCK_SNOW_PLACE, BigClientVersion.v1_10, "block.snow.place");
-		addSound(BLOCK_SNOW_STEP, BigClientVersion.v1_10, "block.snow.step");
-		addSound(BLOCK_STONE_BREAK, BigClientVersion.v1_10, "block.stone.break");
-		addSound(BLOCK_STONE_FALL, BigClientVersion.v1_10, "block.stone.fall");
-		addSound(BLOCK_STONE_HIT, BigClientVersion.v1_10, "block.stone.hit");
-		addSound(BLOCK_STONE_PLACE, BigClientVersion.v1_10, "block.stone.place");
-		addSound(BLOCK_STONE_STEP, BigClientVersion.v1_10, "block.stone.step");
-		addSound(BLOCK_STONE_BUTTON_CLICK_OFF, BigClientVersion.v1_10, "block.stone_button.click_off");
-		addSound(BLOCK_STONE_BUTTON_CLICK_ON, BigClientVersion.v1_10, "block.stone_button.click_on");
-		addSound(BLOCK_STONE_PRESSUREPLATE_CLICK_OFF, BigClientVersion.v1_10, "block.stone_pressureplate.click_off");
-		addSound(BLOCK_STONE_PRESSUREPLATE_CLICK_ON, BigClientVersion.v1_10, "block.stone_pressureplate.click_on");
-		addSound(BLOCK_TRIPWIRE_ATTACH, BigClientVersion.v1_10, "block.tripwire.attach");
-		addSound(BLOCK_TRIPWIRE_CLICK_OFF, BigClientVersion.v1_10, "block.tripwire.click_off");
-		addSound(BLOCK_TRIPWIRE_CLICK_ON, BigClientVersion.v1_10, "block.tripwire.click_on");
-		addSound(BLOCK_TRIPWIRE_DETACH, BigClientVersion.v1_10, "block.tripwire.detach");
-		addSound(BLOCK_WATER_AMBIENT, BigClientVersion.v1_10, "block.water.ambient");
-		addSound(BLOCK_WATERLILY_PLACE, BigClientVersion.v1_10, "block.waterlily.place");
-		addSound(BLOCK_WOOD_BREAK, BigClientVersion.v1_10, "block.wood.break");
-		addSound(BLOCK_WOOD_FALL, BigClientVersion.v1_10, "block.wood.fall");
-		addSound(BLOCK_WOOD_HIT, BigClientVersion.v1_10, "block.wood.hit");
-		addSound(BLOCK_WOOD_PLACE, BigClientVersion.v1_10, "block.wood.place");
-		addSound(BLOCK_WOOD_STEP, BigClientVersion.v1_10, "block.wood.step");
-		addSound(BLOCK_WOOD_BUTTON_CLICK_OFF, BigClientVersion.v1_10, "block.wood_button.click_off");
-		addSound(BLOCK_WOOD_BUTTON_CLICK_ON, BigClientVersion.v1_10, "block.wood_button.click_on");
-		addSound(BLOCK_WOOD_PRESSUREPLATE_CLICK_OFF, BigClientVersion.v1_10, "block.wood_pressureplate.click_off");
-		addSound(BLOCK_WOOD_PRESSUREPLATE_CLICK_ON, BigClientVersion.v1_10, "block.wood_pressureplate.click_on");
-		addSound(BLOCK_WOODEN_DOOR_CLOSE, BigClientVersion.v1_10, "block.wooden_door.close");
-		addSound(BLOCK_WOODEN_DOOR_OPEN, BigClientVersion.v1_10, "block.wooden_door.open");
-		addSound(BLOCK_WOODEN_TRAPDOOR_CLOSE, BigClientVersion.v1_10, "block.wooden_trapdoor.close");
-		addSound(BLOCK_WOODEN_TRAPDOOR_OPEN, BigClientVersion.v1_10, "block.wooden_trapdoor.open");
-		addSound(ENCHANT_THORNS_HIT, BigClientVersion.v1_10, "enchant.thorns.hit");
-		addSound(ENTITY_ARMORSTAND_BREAK, BigClientVersion.v1_10, "entity.armorstand.break");
-		addSound(ENTITY_ARMORSTAND_FALL, BigClientVersion.v1_10, "entity.armorstand.fall");
-		addSound(ENTITY_ARMORSTAND_HIT, BigClientVersion.v1_10, "entity.armorstand.hit");
-		addSound(ENTITY_ARMORSTAND_PLACE, BigClientVersion.v1_10, "entity.armorstand.place");
-		addSound(ENTITY_ARROW_HIT, BigClientVersion.v1_10, "entity.arrow.hit");
-		addSound(ENTITY_ARROW_HIT_PLAYER, BigClientVersion.v1_10, "entity.arrow.hit_player");
-		addSound(ENTITY_ARROW_SHOOT, BigClientVersion.v1_10, "entity.arrow.shoot");
-		addSound(ENTITY_BAT_AMBIENT, BigClientVersion.v1_10, "entity.bat.ambient");
-		addSound(ENTITY_BAT_DEATH, BigClientVersion.v1_10, "entity.bat.death");
-		addSound(ENTITY_BAT_HURT, BigClientVersion.v1_10, "entity.bat.hurt");
-		addSound(ENTITY_BAT_LOOP, BigClientVersion.v1_10, "entity.bat.loop");
-		addSound(ENTITY_BAT_TAKEOFF, BigClientVersion.v1_10, "entity.bat.takeoff");
-		addSound(ENTITY_BLAZE_AMBIENT, BigClientVersion.v1_10, "entity.blaze.ambient");
-		addSound(ENTITY_BLAZE_BURN, BigClientVersion.v1_10, "entity.blaze.burn");
-		addSound(ENTITY_BLAZE_DEATH, BigClientVersion.v1_10, "entity.blaze.death");
-		addSound(ENTITY_BLAZE_HURT, BigClientVersion.v1_10, "entity.blaze.hurt");
-		addSound(ENTITY_BLAZE_SHOOT, BigClientVersion.v1_10, "entity.blaze.shoot");
-		addSound(ENTITY_BOBBER_SPLASH, BigClientVersion.v1_10, "entity.bobber.splash");
-		addSound(ENTITY_BOBBER_THROW, BigClientVersion.v1_10, "entity.bobber.throw");
-		addSound(ENTITY_CAT_AMBIENT, BigClientVersion.v1_10, "entity.cat.ambient");
-		addSound(ENTITY_CAT_DEATH, BigClientVersion.v1_10, "entity.cat.death");
-		addSound(ENTITY_CAT_HISS, BigClientVersion.v1_10, "entity.cat.hiss");
-		addSound(ENTITY_CAT_HURT, BigClientVersion.v1_10, "entity.cat.hurt");
-		addSound(ENTITY_CAT_PURR, BigClientVersion.v1_10, "entity.cat.purr");
-		addSound(ENTITY_CAT_PURREOW, BigClientVersion.v1_10, "entity.cat.purreow");
-		addSound(ENTITY_CHICKEN_AMBIENT, BigClientVersion.v1_10, "entity.chicken.ambient");
-		addSound(ENTITY_CHICKEN_DEATH, BigClientVersion.v1_10, "entity.chicken.death");
-		addSound(ENTITY_CHICKEN_EGG, BigClientVersion.v1_10, "entity.chicken.egg");
-		addSound(ENTITY_CHICKEN_HURT, BigClientVersion.v1_10, "entity.chicken.hurt");
-		addSound(ENTITY_CHICKEN_STEP, BigClientVersion.v1_10, "entity.chicken.step");
-		addSound(ENTITY_COW_AMBIENT, BigClientVersion.v1_10, "entity.cow.ambient");
-		addSound(ENTITY_COW_DEATH, BigClientVersion.v1_10, "entity.cow.death");
-		addSound(ENTITY_COW_HURT, BigClientVersion.v1_10, "entity.cow.hurt");
-		addSound(ENTITY_COW_MILK, BigClientVersion.v1_10, "entity.cow.milk");
-		addSound(ENTITY_COW_STEP, BigClientVersion.v1_10, "entity.cow.step");
-		addSound(ENTITY_CREEPER_DEATH, BigClientVersion.v1_10, "entity.creeper.death");
-		addSound(ENTITY_CREEPER_HURT, BigClientVersion.v1_10, "entity.creeper.hurt");
-		addSound(ENTITY_CREEPER_PRIMED, BigClientVersion.v1_10, "entity.creeper.primed");
-		addSound(ENTITY_DONKEY_AMBIENT, BigClientVersion.v1_10, "entity.donkey.ambient");
-		addSound(ENTITY_DONKEY_ANGRY, BigClientVersion.v1_10, "entity.donkey.angry");
-		addSound(ENTITY_DONKEY_CHEST, BigClientVersion.v1_10, "entity.donkey.chest");
-		addSound(ENTITY_DONKEY_DEATH, BigClientVersion.v1_10, "entity.donkey.death");
-		addSound(ENTITY_DONKEY_HURT, BigClientVersion.v1_10, "entity.donkey.hurt");
-		addSound(ENTITY_EGG_THROW, BigClientVersion.v1_10, "entity.egg.throw");
-		addSound(ENTITY_ELDER_GUARDIAN_AMBIENT, BigClientVersion.v1_10, "entity.elder_guardian.ambient");
-		addSound(ENTITY_ELDER_GUARDIAN_AMBIENT_LAND, BigClientVersion.v1_10, "entity.elder_guardian.ambient_land");
-		addSound(ENTITY_ELDER_GUARDIAN_CURSE, BigClientVersion.v1_10, "entity.elder_guardian.curse");
-		addSound(ENTITY_ELDER_GUARDIAN_DEATH, BigClientVersion.v1_10, "entity.elder_guardian.death");
-		addSound(ENTITY_ELDER_GUARDIAN_DEATH_LAND, BigClientVersion.v1_10, "entity.elder_guardian.death_land");
-		addSound(ENTITY_ELDER_GUARDIAN_HURT, BigClientVersion.v1_10, "entity.elder_guardian.hurt");
-		addSound(ENTITY_ELDER_GUARDIAN_HURT_LAND, BigClientVersion.v1_10, "entity.elder_guardian.hurt_land");
-		addSound(ENTITY_ENDERDRAGON_AMBIENT, BigClientVersion.v1_10, "entity.enderdragon.ambient");
-		addSound(ENTITY_ENDERDRAGON_DEATH, BigClientVersion.v1_10, "entity.enderdragon.death");
-		addSound(ENTITY_ENDERDRAGON_FLAP, BigClientVersion.v1_10, "entity.enderdragon.flap");
-		addSound(ENTITY_ENDERDRAGON_GROWL, BigClientVersion.v1_10, "entity.enderdragon.growl");
-		addSound(ENTITY_ENDERDRAGON_HURT, BigClientVersion.v1_10, "entity.enderdragon.hurt");
-		addSound(ENTITY_ENDERDRAGON_SHOOT, BigClientVersion.v1_10, "entity.enderdragon.shoot");
-		addSound(ENTITY_ENDERDRAGON_FIREBALL_EXPLODE, BigClientVersion.v1_10, "entity.enderdragon_fireball.explode");
-		addSound(ENTITY_ENDEREYE_LAUNCH, BigClientVersion.v1_10, "entity.endereye.launch");
-		addSound(ENTITY_ENDERMEN_AMBIENT, BigClientVersion.v1_10, "entity.endermen.ambient");
-		addSound(ENTITY_ENDERMEN_DEATH, BigClientVersion.v1_10, "entity.endermen.death");
-		addSound(ENTITY_ENDERMEN_HURT, BigClientVersion.v1_10, "entity.endermen.hurt");
-		addSound(ENTITY_ENDERMEN_SCREAM, BigClientVersion.v1_10, "entity.endermen.scream");
-		addSound(ENTITY_ENDERMEN_STARE, BigClientVersion.v1_10, "entity.endermen.stare");
-		addSound(ENTITY_ENDERMEN_TELEPORT, BigClientVersion.v1_10, "entity.endermen.teleport");
-		addSound(ENTITY_ENDERMITE_AMBIENT, BigClientVersion.v1_10, "entity.endermite.ambient");
-		addSound(ENTITY_ENDERMITE_DEATH, BigClientVersion.v1_10, "entity.endermite.death");
-		addSound(ENTITY_ENDERMITE_HURT, BigClientVersion.v1_10, "entity.endermite.hurt");
-		addSound(ENTITY_ENDERMITE_STEP, BigClientVersion.v1_10, "entity.endermite.step");
-		addSound(ENTITY_ENDERPEARL_THROW, BigClientVersion.v1_10, "entity.enderpearl.throw");
-		addSound(ENTITY_EXPERIENCE_BOTTLE_THROW, BigClientVersion.v1_10, "entity.experience_bottle.throw");
-		addSound(ENTITY_EXPERIENCE_ORB_PICKUP, BigClientVersion.v1_10, "entity.experience_orb.pickup");
-		addSound(ENTITY_EXPERIENCE_ORB_TOUCH, BigClientVersion.v1_10, "entity.experience_orb.touch");
-		addSound(ENTITY_FIREWORK_BLAST, BigClientVersion.v1_10, "entity.firework.blast");
-		addSound(ENTITY_FIREWORK_BLAST_FAR, BigClientVersion.v1_10, "entity.firework.blast_far");
-		addSound(ENTITY_FIREWORK_LARGE_BLAST, BigClientVersion.v1_10, "entity.firework.large_blast");
-		addSound(ENTITY_FIREWORK_LARGE_BLAST_FAR, BigClientVersion.v1_10, "entity.firework.large_blast_far");
-		addSound(ENTITY_FIREWORK_LAUNCH, BigClientVersion.v1_10, "entity.firework.launch");
-		addSound(ENTITY_FIREWORK_SHOOT, BigClientVersion.v1_10, "entity.firework.shoot");
-		addSound(ENTITY_FIREWORK_TWINKLE, BigClientVersion.v1_10, "entity.firework.twinkle");
-		addSound(ENTITY_FIREWORK_TWINKLE_FAR, BigClientVersion.v1_10, "entity.firework.twinkle_far");
-		addSound(ENTITY_GENERIC_BIG_FALL, BigClientVersion.v1_10, "entity.generic.big_fall");
-		addSound(ENTITY_GENERIC_BURN, BigClientVersion.v1_10, "entity.generic.burn");
-		addSound(ENTITY_GENERIC_DEATH, BigClientVersion.v1_10, "entity.generic.death");
-		addSound(ENTITY_GENERIC_DRINK, BigClientVersion.v1_10, "entity.generic.drink");
-		addSound(ENTITY_GENERIC_EAT, BigClientVersion.v1_10, "entity.generic.eat");
-		addSound(ENTITY_GENERIC_EXPLODE, BigClientVersion.v1_10, "entity.generic.explode");
-		addSound(ENTITY_GENERIC_EXTINGUISH_FIRE, BigClientVersion.v1_10, "entity.generic.extinguish_fire");
-		addSound(ENTITY_GENERIC_HURT, BigClientVersion.v1_10, "entity.generic.hurt");
-		addSound(ENTITY_GENERIC_SMALL_FALL, BigClientVersion.v1_10, "entity.generic.small_fall");
-		addSound(ENTITY_GENERIC_SPLASH, BigClientVersion.v1_10, "entity.generic.splash");
-		addSound(ENTITY_GENERIC_SWIM, BigClientVersion.v1_10, "entity.generic.swim");
-		addSound(ENTITY_GHAST_AMBIENT, BigClientVersion.v1_10, "entity.ghast.ambient");
-		addSound(ENTITY_GHAST_DEATH, BigClientVersion.v1_10, "entity.ghast.death");
-		addSound(ENTITY_GHAST_HURT, BigClientVersion.v1_10, "entity.ghast.hurt");
-		addSound(ENTITY_GHAST_SCREAM, BigClientVersion.v1_10, "entity.ghast.scream");
-		addSound(ENTITY_GHAST_SHOOT, BigClientVersion.v1_10, "entity.ghast.shoot");
-		addSound(ENTITY_GHAST_WARN, BigClientVersion.v1_10, "entity.ghast.warn");
-		addSound(ENTITY_GUARDIAN_AMBIENT, BigClientVersion.v1_10, "entity.guardian.ambient");
-		addSound(ENTITY_GUARDIAN_AMBIENT_LAND, BigClientVersion.v1_10, "entity.guardian.ambient_land");
-		addSound(ENTITY_GUARDIAN_ATTACK, BigClientVersion.v1_10, "entity.guardian.attack");
-		addSound(ENTITY_GUARDIAN_DEATH, BigClientVersion.v1_10, "entity.guardian.death");
-		addSound(ENTITY_GUARDIAN_DEATH_LAND, BigClientVersion.v1_10, "entity.guardian.death_land");
-		addSound(ENTITY_GUARDIAN_FLOP, BigClientVersion.v1_10, "entity.guardian.flop");
-		addSound(ENTITY_GUARDIAN_HURT, BigClientVersion.v1_10, "entity.guardian.hurt");
-		addSound(ENTITY_GUARDIAN_HURT_LAND, BigClientVersion.v1_10, "entity.guardian.hurt_land");
-		addSound(ENTITY_HORSE_AMBIENT, BigClientVersion.v1_10, "entity.horse.ambient");
-		addSound(ENTITY_HORSE_ANGRY, BigClientVersion.v1_10, "entity.horse.angry");
-		addSound(ENTITY_HORSE_ARMOR, BigClientVersion.v1_10, "entity.horse.armor");
-		addSound(ENTITY_HORSE_BREATHE, BigClientVersion.v1_10, "entity.horse.breathe");
-		addSound(ENTITY_HORSE_DEATH, BigClientVersion.v1_10, "entity.horse.death");
-		addSound(ENTITY_HORSE_EAT, BigClientVersion.v1_10, "entity.horse.eat");
-		addSound(ENTITY_HORSE_GALLOP, BigClientVersion.v1_10, "entity.horse.gallop");
-		addSound(ENTITY_HORSE_HURT, BigClientVersion.v1_10, "entity.horse.hurt");
-		addSound(ENTITY_HORSE_JUMP, BigClientVersion.v1_10, "entity.horse.jump");
-		addSound(ENTITY_HORSE_LAND, BigClientVersion.v1_10, "entity.horse.land");
-		addSound(ENTITY_HORSE_SADDLE, BigClientVersion.v1_10, "entity.horse.saddle");
-		addSound(ENTITY_HORSE_STEP, BigClientVersion.v1_10, "entity.horse.step");
-		addSound(ENTITY_HORSE_STEP_WOOD, BigClientVersion.v1_10, "entity.horse.step_wood");
-		addSound(ENTITY_HOSTILE_BIG_FALL, BigClientVersion.v1_10, "entity.hostile.big_fall");
-		addSound(ENTITY_HOSTILE_DEATH, BigClientVersion.v1_10, "entity.hostile.death");
-		addSound(ENTITY_HOSTILE_HURT, BigClientVersion.v1_10, "entity.hostile.hurt");
-		addSound(ENTITY_HOSTILE_SMALL_FALL, BigClientVersion.v1_10, "entity.hostile.small_fall");
-		addSound(ENTITY_HOSTILE_SPLASH, BigClientVersion.v1_10, "entity.hostile.splash");
-		addSound(ENTITY_HOSTILE_SWIM, BigClientVersion.v1_10, "entity.hostile.swim");
-		addSound(ENTITY_HUSK_AMBIENT, BigClientVersion.v1_10, "entity.husk.ambient");
-		addSound(ENTITY_HUSK_DEATH, BigClientVersion.v1_10, "entity.husk.death");
-		addSound(ENTITY_HUSK_HURT, BigClientVersion.v1_10, "entity.husk.hurt");
-		addSound(ENTITY_HUSK_STEP, BigClientVersion.v1_10, "entity.husk.step");
-		addSound(ENTITY_IRONGOLEM_ATTACK, BigClientVersion.v1_10, "entity.irongolem.attack");
-		addSound(ENTITY_IRONGOLEM_DEATH, BigClientVersion.v1_10, "entity.irongolem.death");
-		addSound(ENTITY_IRONGOLEM_HURT, BigClientVersion.v1_10, "entity.irongolem.hurt");
-		addSound(ENTITY_IRONGOLEM_STEP, BigClientVersion.v1_10, "entity.irongolem.step");
-		addSound(ENTITY_ITEM_BREAK, BigClientVersion.v1_10, "entity.item.break");
-		addSound(ENTITY_ITEM_PICKUP, BigClientVersion.v1_10, "entity.item.pickup");
-		addSound(ENTITY_ITEMFRAME_ADD_ITEM, BigClientVersion.v1_10, "entity.itemframe.add_item");
-		addSound(ENTITY_ITEMFRAME_BREAK, BigClientVersion.v1_10, "entity.itemframe.break");
-		addSound(ENTITY_ITEMFRAME_PLACE, BigClientVersion.v1_10, "entity.itemframe.place");
-		addSound(ENTITY_ITEMFRAME_REMOVE_ITEM, BigClientVersion.v1_10, "entity.itemframe.remove_item");
-		addSound(ENTITY_ITEMFRAME_ROTATE_ITEM, BigClientVersion.v1_10, "entity.itemframe.rotate_item");
-		addSound(ENTITY_LEASHKNOT_BREAK, BigClientVersion.v1_10, "entity.leashknot.break");
-		addSound(ENTITY_LEASHKNOT_PLACE, BigClientVersion.v1_10, "entity.leashknot.place");
-		addSound(ENTITY_LIGHTNING_IMPACT, BigClientVersion.v1_10, "entity.lightning.impact");
-		addSound(ENTITY_LIGHTNING_THUNDER, BigClientVersion.v1_10, "entity.lightning.thunder");
-		addSound(ENTITY_LINGERINGPOTION_THROW, BigClientVersion.v1_10, "entity.lingeringpotion.throw");
-		addSound(ENTITY_MAGMACUBE_DEATH, BigClientVersion.v1_10, "entity.magmacube.death");
-		addSound(ENTITY_MAGMACUBE_HURT, BigClientVersion.v1_10, "entity.magmacube.hurt");
-		addSound(ENTITY_MAGMACUBE_JUMP, BigClientVersion.v1_10, "entity.magmacube.jump");
-		addSound(ENTITY_MAGMACUBE_SQUISH, BigClientVersion.v1_10, "entity.magmacube.squish");
-		addSound(ENTITY_MINECART_INSIDE, BigClientVersion.v1_10, "entity.minecart.inside");
-		addSound(ENTITY_MINECART_RIDING, BigClientVersion.v1_10, "entity.minecart.riding");
-		addSound(ENTITY_MOOSHROOM_SHEAR, BigClientVersion.v1_10, "entity.mooshroom.shear");
-		addSound(ENTITY_MULE_AMBIENT, BigClientVersion.v1_10, "entity.mule.ambient");
-		addSound(ENTITY_MULE_DEATH, BigClientVersion.v1_10, "entity.mule.death");
-		addSound(ENTITY_MULE_HURT, BigClientVersion.v1_10, "entity.mule.hurt");
-		addSound(ENTITY_PAINTING_BREAK, BigClientVersion.v1_10, "entity.painting.break");
-		addSound(ENTITY_PAINTING_PLACE, BigClientVersion.v1_10, "entity.painting.place");
-		addSound(ENTITY_PIG_AMBIENT, BigClientVersion.v1_10, "entity.pig.ambient");
-		addSound(ENTITY_PIG_DEATH, BigClientVersion.v1_10, "entity.pig.death");
-		addSound(ENTITY_PIG_HURT, BigClientVersion.v1_10, "entity.pig.hurt");
-		addSound(ENTITY_PIG_SADDLE, BigClientVersion.v1_10, "entity.pig.saddle");
-		addSound(ENTITY_PIG_STEP, BigClientVersion.v1_10, "entity.pig.step");
-		addSound(ENTITY_PLAYER_ATTACK_CRIT, BigClientVersion.v1_10, "entity.player.attack.crit");
-		addSound(ENTITY_PLAYER_ATTACK_KNOCKBACK, BigClientVersion.v1_10, "entity.player.attack.knockback");
-		addSound(ENTITY_PLAYER_ATTACK_NODAMAGE, BigClientVersion.v1_10, "entity.player.attack.nodamage");
-		addSound(ENTITY_PLAYER_ATTACK_STRONG, BigClientVersion.v1_10, "entity.player.attack.strong");
-		addSound(ENTITY_PLAYER_ATTACK_SWEEP, BigClientVersion.v1_10, "entity.player.attack.sweep");
-		addSound(ENTITY_PLAYER_ATTACK_WEAK, BigClientVersion.v1_10, "entity.player.attack.weak");
-		addSound(ENTITY_PLAYER_BIG_FALL, BigClientVersion.v1_10, "entity.player.big_fall");
-		addSound(ENTITY_PLAYER_BREATH, BigClientVersion.v1_10, "entity.player.breath");
-		addSound(ENTITY_PLAYER_BURP, BigClientVersion.v1_10, "entity.player.burp");
-		addSound(ENTITY_PLAYER_DEATH, BigClientVersion.v1_10, "entity.player.death");
-		addSound(ENTITY_PLAYER_HURT, BigClientVersion.v1_10, "entity.player.hurt");
-		addSound(ENTITY_PLAYER_LEVELUP, BigClientVersion.v1_10, "entity.player.levelup");
-		addSound(ENTITY_PLAYER_SMALL_FALL, BigClientVersion.v1_10, "entity.player.small_fall");
-		addSound(ENTITY_PLAYER_SPLASH, BigClientVersion.v1_10, "entity.player.splash");
-		addSound(ENTITY_PLAYER_SWIM, BigClientVersion.v1_10, "entity.player.swim");
-		addSound(ENTITY_POLAR_BEAR_AMBIENT, BigClientVersion.v1_10, "entity.polar_bear.ambient");
-		addSound(ENTITY_POLAR_BEAR_BABY_AMBIENT, BigClientVersion.v1_10, "entity.polar_bear.baby_ambient");
-		addSound(ENTITY_POLAR_BEAR_DEATH, BigClientVersion.v1_10, "entity.polar_bear.death");
-		addSound(ENTITY_POLAR_BEAR_HURT, BigClientVersion.v1_10, "entity.polar_bear.hurt");
-		addSound(ENTITY_POLAR_BEAR_STEP, BigClientVersion.v1_10, "entity.polar_bear.step");
-		addSound(ENTITY_POLAR_BEAR_WARNING, BigClientVersion.v1_10, "entity.polar_bear.warning");
-		addSound(ENTITY_RABBIT_AMBIENT, BigClientVersion.v1_10, "entity.rabbit.ambient");
-		addSound(ENTITY_RABBIT_ATTACK, BigClientVersion.v1_10, "entity.rabbit.attack");
-		addSound(ENTITY_RABBIT_DEATH, BigClientVersion.v1_10, "entity.rabbit.death");
-		addSound(ENTITY_RABBIT_HURT, BigClientVersion.v1_10, "entity.rabbit.hurt");
-		addSound(ENTITY_RABBIT_JUMP, BigClientVersion.v1_10, "entity.rabbit.jump");
-		addSound(ENTITY_SHEEP_AMBIENT, BigClientVersion.v1_10, "entity.sheep.ambient");
-		addSound(ENTITY_SHEEP_DEATH, BigClientVersion.v1_10, "entity.sheep.death");
-		addSound(ENTITY_SHEEP_HURT, BigClientVersion.v1_10, "entity.sheep.hurt");
-		addSound(ENTITY_SHEEP_SHEAR, BigClientVersion.v1_10, "entity.sheep.shear");
-		addSound(ENTITY_SHEEP_STEP, BigClientVersion.v1_10, "entity.sheep.step");
-		addSound(ENTITY_SHULKER_AMBIENT, BigClientVersion.v1_10, "entity.shulker.ambient");
-		addSound(ENTITY_SHULKER_CLOSE, BigClientVersion.v1_10, "entity.shulker.close");
-		addSound(ENTITY_SHULKER_DEATH, BigClientVersion.v1_10, "entity.shulker.death");
-		addSound(ENTITY_SHULKER_HURT, BigClientVersion.v1_10, "entity.shulker.hurt");
-		addSound(ENTITY_SHULKER_HURT_CLOSED, BigClientVersion.v1_10, "entity.shulker.hurt_closed");
-		addSound(ENTITY_SHULKER_OPEN, BigClientVersion.v1_10, "entity.shulker.open");
-		addSound(ENTITY_SHULKER_SHOOT, BigClientVersion.v1_10, "entity.shulker.shoot");
-		addSound(ENTITY_SHULKER_TELEPORT, BigClientVersion.v1_10, "entity.shulker.teleport");
-		addSound(ENTITY_SHULKER_BULLET_HIT, BigClientVersion.v1_10, "entity.shulker_bullet.hit");
-		addSound(ENTITY_SHULKER_BULLET_HURT, BigClientVersion.v1_10, "entity.shulker_bullet.hurt");
-		addSound(ENTITY_SILVERFISH_AMBIENT, BigClientVersion.v1_10, "entity.silverfish.ambient");
-		addSound(ENTITY_SILVERFISH_DEATH, BigClientVersion.v1_10, "entity.silverfish.death");
-		addSound(ENTITY_SILVERFISH_HURT, BigClientVersion.v1_10, "entity.silverfish.hurt");
-		addSound(ENTITY_SILVERFISH_STEP, BigClientVersion.v1_10, "entity.silverfish.step");
-		addSound(ENTITY_SKELETON_AMBIENT, BigClientVersion.v1_10, "entity.skeleton.ambient");
-		addSound(ENTITY_SKELETON_DEATH, BigClientVersion.v1_10, "entity.skeleton.death");
-		addSound(ENTITY_SKELETON_HURT, BigClientVersion.v1_10, "entity.skeleton.hurt");
-		addSound(ENTITY_SKELETON_SHOOT, BigClientVersion.v1_10, "entity.skeleton.shoot");
-		addSound(ENTITY_SKELETON_STEP, BigClientVersion.v1_10, "entity.skeleton.step");
-		addSound(ENTITY_SKELETON_HORSE_AMBIENT, BigClientVersion.v1_10, "entity.skeleton_horse.ambient");
-		addSound(ENTITY_SKELETON_HORSE_DEATH, BigClientVersion.v1_10, "entity.skeleton_horse.death");
-		addSound(ENTITY_SKELETON_HORSE_HURT, BigClientVersion.v1_10, "entity.skeleton_horse.hurt");
-		addSound(ENTITY_SLIME_ATTACK, BigClientVersion.v1_10, "entity.slime.attack");
-		addSound(ENTITY_SLIME_DEATH, BigClientVersion.v1_10, "entity.slime.death");
-		addSound(ENTITY_SLIME_HURT, BigClientVersion.v1_10, "entity.slime.hurt");
-		addSound(ENTITY_SLIME_JUMP, BigClientVersion.v1_10, "entity.slime.jump");
-		addSound(ENTITY_SLIME_SQUISH, BigClientVersion.v1_10, "entity.slime.squish");
-		addSound(ENTITY_SMALL_MAGMACUBE_DEATH, BigClientVersion.v1_10, "entity.small_magmacube.death");
-		addSound(ENTITY_SMALL_MAGMACUBE_HURT, BigClientVersion.v1_10, "entity.small_magmacube.hurt");
-		addSound(ENTITY_SMALL_MAGMACUBE_SQUISH, BigClientVersion.v1_10, "entity.small_magmacube.squish");
-		addSound(ENTITY_SMALL_SLIME_DEATH, BigClientVersion.v1_10, "entity.small_slime.death");
-		addSound(ENTITY_SMALL_SLIME_HURT, BigClientVersion.v1_10, "entity.small_slime.hurt");
-		addSound(ENTITY_SMALL_SLIME_JUMP, BigClientVersion.v1_10, "entity.small_slime.jump");
-		addSound(ENTITY_SMALL_SLIME_SQUISH, BigClientVersion.v1_10, "entity.small_slime.squish");
-		addSound(ENTITY_SNOWBALL_THROW, BigClientVersion.v1_10, "entity.snowball.throw");
-		addSound(ENTITY_SNOWMAN_AMBIENT, BigClientVersion.v1_10, "entity.snowman.ambient");
-		addSound(ENTITY_SNOWMAN_DEATH, BigClientVersion.v1_10, "entity.snowman.death");
-		addSound(ENTITY_SNOWMAN_HURT, BigClientVersion.v1_10, "entity.snowman.hurt");
-		addSound(ENTITY_SNOWMAN_SHOOT, BigClientVersion.v1_10, "entity.snowman.shoot");
-		addSound(ENTITY_SPIDER_AMBIENT, BigClientVersion.v1_10, "entity.spider.ambient");
-		addSound(ENTITY_SPIDER_DEATH, BigClientVersion.v1_10, "entity.spider.death");
-		addSound(ENTITY_SPIDER_HURT, BigClientVersion.v1_10, "entity.spider.hurt");
-		addSound(ENTITY_SPIDER_STEP, BigClientVersion.v1_10, "entity.spider.step");
-		addSound(ENTITY_SPLASH_POTION_BREAK, BigClientVersion.v1_10, "entity.splash_potion.break");
-		addSound(ENTITY_SPLASH_POTION_THROW, BigClientVersion.v1_10, "entity.splash_potion.throw");
-		addSound(ENTITY_SQUID_AMBIENT, BigClientVersion.v1_10, "entity.squid.ambient");
-		addSound(ENTITY_SQUID_DEATH, BigClientVersion.v1_10, "entity.squid.death");
-		addSound(ENTITY_SQUID_HURT, BigClientVersion.v1_10, "entity.squid.hurt");
-		addSound(ENTITY_STRAY_AMBIENT, BigClientVersion.v1_10, "entity.stray.ambient");
-		addSound(ENTITY_STRAY_DEATH, BigClientVersion.v1_10, "entity.stray.death");
-		addSound(ENTITY_STRAY_HURT, BigClientVersion.v1_10, "entity.stray.hurt");
-		addSound(ENTITY_STRAY_STEP, BigClientVersion.v1_10, "entity.stray.step");
-		addSound(ENTITY_TNT_PRIMED, BigClientVersion.v1_10, "entity.tnt.primed");
-		addSound(ENTITY_VILLAGER_AMBIENT, BigClientVersion.v1_10, "entity.villager.ambient");
-		addSound(ENTITY_VILLAGER_DEATH, BigClientVersion.v1_10, "entity.villager.death");
-		addSound(ENTITY_VILLAGER_HURT, BigClientVersion.v1_10, "entity.villager.hurt");
-		addSound(ENTITY_VILLAGER_NO, BigClientVersion.v1_10, "entity.villager.no");
-		addSound(ENTITY_VILLAGER_TRADING, BigClientVersion.v1_10, "entity.villager.trading");
-		addSound(ENTITY_VILLAGER_YES, BigClientVersion.v1_10, "entity.villager.yes");
-		addSound(ENTITY_WITCH_AMBIENT, BigClientVersion.v1_10, "entity.witch.ambient");
-		addSound(ENTITY_WITCH_DEATH, BigClientVersion.v1_10, "entity.witch.death");
-		addSound(ENTITY_WITCH_DRINK, BigClientVersion.v1_10, "entity.witch.drink");
-		addSound(ENTITY_WITCH_HURT, BigClientVersion.v1_10, "entity.witch.hurt");
-		addSound(ENTITY_WITCH_THROW, BigClientVersion.v1_10, "entity.witch.throw");
-		addSound(ENTITY_WITHER_AMBIENT, BigClientVersion.v1_10, "entity.wither.ambient");
-		addSound(ENTITY_WITHER_BREAK_BLOCK, BigClientVersion.v1_10, "entity.wither.break_block");
-		addSound(ENTITY_WITHER_DEATH, BigClientVersion.v1_10, "entity.wither.death");
-		addSound(ENTITY_WITHER_HURT, BigClientVersion.v1_10, "entity.wither.hurt");
-		addSound(ENTITY_WITHER_SHOOT, BigClientVersion.v1_10, "entity.wither.shoot");
-		addSound(ENTITY_WITHER_SPAWN, BigClientVersion.v1_10, "entity.wither.spawn");
-		addSound(ENTITY_WITHER_SKELETON_AMBIENT, BigClientVersion.v1_10, "entity.wither_skeleton.ambient");
-		addSound(ENTITY_WITHER_SKELETON_DEATH, BigClientVersion.v1_10, "entity.wither_skeleton.death");
-		addSound(ENTITY_WITHER_SKELETON_HURT, BigClientVersion.v1_10, "entity.wither_skeleton.hurt");
-		addSound(ENTITY_WITHER_SKELETON_STEP, BigClientVersion.v1_10, "entity.wither_skeleton.step");
-		addSound(ENTITY_WOLF_AMBIENT, BigClientVersion.v1_10, "entity.wolf.ambient");
-		addSound(ENTITY_WOLF_DEATH, BigClientVersion.v1_10, "entity.wolf.death");
-		addSound(ENTITY_WOLF_GROWL, BigClientVersion.v1_10, "entity.wolf.growl");
-		addSound(ENTITY_WOLF_HOWL, BigClientVersion.v1_10, "entity.wolf.howl");
-		addSound(ENTITY_WOLF_HURT, BigClientVersion.v1_10, "entity.wolf.hurt");
-		addSound(ENTITY_WOLF_PANT, BigClientVersion.v1_10, "entity.wolf.pant");
-		addSound(ENTITY_WOLF_SHAKE, BigClientVersion.v1_10, "entity.wolf.shake");
-		addSound(ENTITY_WOLF_STEP, BigClientVersion.v1_10, "entity.wolf.step");
-		addSound(ENTITY_WOLF_WHINE, BigClientVersion.v1_10, "entity.wolf.whine");
-		addSound(ENTITY_ZOMBIE_AMBIENT, BigClientVersion.v1_10, "entity.zombie.ambient");
-		addSound(ENTITY_ZOMBIE_ATTACK_DOOR_WOOD, BigClientVersion.v1_10, "entity.zombie.attack_door_wood");
-		addSound(ENTITY_ZOMBIE_ATTACK_IRON_DOOR, BigClientVersion.v1_10, "entity.zombie.attack_iron_door");
-		addSound(ENTITY_ZOMBIE_BREAK_DOOR_WOOD, BigClientVersion.v1_10, "entity.zombie.break_door_wood");
-		addSound(ENTITY_ZOMBIE_DEATH, BigClientVersion.v1_10, "entity.zombie.death");
-		addSound(ENTITY_ZOMBIE_HURT, BigClientVersion.v1_10, "entity.zombie.hurt");
-		addSound(ENTITY_ZOMBIE_INFECT, BigClientVersion.v1_10, "entity.zombie.infect");
-		addSound(ENTITY_ZOMBIE_STEP, BigClientVersion.v1_10, "entity.zombie.step");
-		addSound(ENTITY_ZOMBIE_HORSE_AMBIENT, BigClientVersion.v1_10, "entity.zombie_horse.ambient");
-		addSound(ENTITY_ZOMBIE_HORSE_DEATH, BigClientVersion.v1_10, "entity.zombie_horse.death");
-		addSound(ENTITY_ZOMBIE_HORSE_HURT, BigClientVersion.v1_10, "entity.zombie_horse.hurt");
-		addSound(ENTITY_ZOMBIE_PIG_AMBIENT, BigClientVersion.v1_10, "entity.zombie_pig.ambient");
-		addSound(ENTITY_ZOMBIE_PIG_ANGRY, BigClientVersion.v1_10, "entity.zombie_pig.angry");
-		addSound(ENTITY_ZOMBIE_PIG_DEATH, BigClientVersion.v1_10, "entity.zombie_pig.death");
-		addSound(ENTITY_ZOMBIE_PIG_HURT, BigClientVersion.v1_10, "entity.zombie_pig.hurt");
-		addSound(ENTITY_ZOMBIE_VILLAGER_AMBIENT, BigClientVersion.v1_10, "entity.zombie_villager.ambient");
-		addSound(ENTITY_ZOMBIE_VILLAGER_CONVERTED, BigClientVersion.v1_10, "entity.zombie_villager.converted");
-		addSound(ENTITY_ZOMBIE_VILLAGER_CURE, BigClientVersion.v1_10, "entity.zombie_villager.cure");
-		addSound(ENTITY_ZOMBIE_VILLAGER_DEATH, BigClientVersion.v1_10, "entity.zombie_villager.death");
-		addSound(ENTITY_ZOMBIE_VILLAGER_HURT, BigClientVersion.v1_10, "entity.zombie_villager.hurt");
-		addSound(ENTITY_ZOMBIE_VILLAGER_STEP, BigClientVersion.v1_10, "entity.zombie_villager.step");
-		addSound(ITEM_ARMOR_EQUIP_CHAIN, BigClientVersion.v1_10, "item.armor.equip_chain");
-		addSound(ITEM_ARMOR_EQUIP_DIAMOND, BigClientVersion.v1_10, "item.armor.equip_diamond");
-		addSound(ITEM_ARMOR_EQUIP_GENERIC, BigClientVersion.v1_10, "item.armor.equip_generic");
-		addSound(ITEM_ARMOR_EQUIP_GOLD, BigClientVersion.v1_10, "item.armor.equip_gold");
-		addSound(ITEM_ARMOR_EQUIP_IRON, BigClientVersion.v1_10, "item.armor.equip_iron");
-		addSound(ITEM_ARMOR_EQUIP_LEATHER, BigClientVersion.v1_10, "item.armor.equip_leather");
-		addSound(ITEM_BOTTLE_FILL, BigClientVersion.v1_10, "item.bottle.fill");
-		addSound(ITEM_BOTTLE_FILL_DRAGONBREATH, BigClientVersion.v1_10, "item.bottle.fill_dragonbreath");
-		addSound(ITEM_BUCKET_EMPTY, BigClientVersion.v1_10, "item.bucket.empty");
-		addSound(ITEM_BUCKET_EMPTY_LAVA, BigClientVersion.v1_10, "item.bucket.empty_lava");
-		addSound(ITEM_BUCKET_FILL, BigClientVersion.v1_10, "item.bucket.fill");
-		addSound(ITEM_BUCKET_FILL_LAVA, BigClientVersion.v1_10, "item.bucket.fill_lava");
-		addSound(ITEM_CHORUS_FRUIT_TELEPORT, BigClientVersion.v1_10, "item.chorus_fruit.teleport");
-		addSound(ITEM_ELYTRA_FLYING, BigClientVersion.v1_10, "item.elytra.flying");
-		addSound(ITEM_FIRECHARGE_USE, BigClientVersion.v1_10, "item.firecharge.use");
-		addSound(ITEM_FLINTANDSTEEL_USE, BigClientVersion.v1_10, "item.flintandsteel.use");
-		addSound(ITEM_HOE_TILL, BigClientVersion.v1_10, "item.hoe.till");
-		addSound(ITEM_SHIELD_BLOCK, BigClientVersion.v1_10, "item.shield.block");
-		addSound(ITEM_SHIELD_BREAK, BigClientVersion.v1_10, "item.shield.break");
-		addSound(ITEM_SHOVEL_FLATTEN, BigClientVersion.v1_10, "item.shovel.flatten");
-		addSound(MUSIC_CREATIVE, BigClientVersion.v1_10, "music.creative");
-		addSound(MUSIC_CREDITS, BigClientVersion.v1_10, "music.credits");
-		addSound(MUSIC_DRAGON, BigClientVersion.v1_10, "music.dragon");
-		addSound(MUSIC_END, BigClientVersion.v1_10, "music.end");
-		addSound(MUSIC_GAME, BigClientVersion.v1_10, "music.game");
-		addSound(MUSIC_MENU, BigClientVersion.v1_10, "music.menu");
-		addSound(MUSIC_NETHER, BigClientVersion.v1_10, "music.nether");
-		addSound(RECORD_11, BigClientVersion.v1_10, "record.11");
-		addSound(RECORD_13, BigClientVersion.v1_10, "record.13");
-		addSound(RECORD_BLOCKS, BigClientVersion.v1_10, "record.blocks");
-		addSound(RECORD_CAT, BigClientVersion.v1_10, "record.cat");
-		addSound(RECORD_CHIRP, BigClientVersion.v1_10, "record.chirp");
-		addSound(RECORD_FAR, BigClientVersion.v1_10, "record.far");
-		addSound(RECORD_MALL, BigClientVersion.v1_10, "record.mall");
-		addSound(RECORD_MELLOHI, BigClientVersion.v1_10, "record.mellohi");
-		addSound(RECORD_STAL, BigClientVersion.v1_10, "record.stal");
-		addSound(RECORD_STRAD, BigClientVersion.v1_10, "record.strad");
-		addSound(RECORD_WAIT, BigClientVersion.v1_10, "record.wait");
-		addSound(RECORD_WARD, BigClientVersion.v1_10, "record.ward");
-		addSound(UI_BUTTON_CLICK, BigClientVersion.v1_10, "ui.button.click");
-		addSound(WEATHER_RAIN, BigClientVersion.v1_10, "weather.rain");
-		addSound(WEATHER_RAIN_ABOVE, BigClientVersion.v1_10, "weather.rain.above");
-		
-		//1.9
-		addSound(AMBIENT_CAVE, BigClientVersion.v1_9, "ambient.cave");
-		addSound(BLOCK_ANVIL_BREAK, BigClientVersion.v1_9, "block.anvil.break");
-		addSound(BLOCK_ANVIL_DESTROY, BigClientVersion.v1_9, "block.anvil.destroy");
-		addSound(BLOCK_ANVIL_FALL, BigClientVersion.v1_9, "block.anvil.fall");
-		addSound(BLOCK_ANVIL_HIT, BigClientVersion.v1_9, "block.anvil.hit");
-		addSound(BLOCK_ANVIL_LAND, BigClientVersion.v1_9, "block.anvil.land");
-		addSound(BLOCK_ANVIL_PLACE, BigClientVersion.v1_9, "block.anvil.place");
-		addSound(BLOCK_ANVIL_STEP, BigClientVersion.v1_9, "block.anvil.step");
-		addSound(BLOCK_ANVIL_USE, BigClientVersion.v1_9, "block.anvil.use");
-		addSound(BLOCK_BREWING_STAND_BREW, BigClientVersion.v1_9, "block.brewing_stand.brew");
-		addSound(BLOCK_CHEST_CLOSE, BigClientVersion.v1_9, "block.chest.close");
-		addSound(BLOCK_CHEST_LOCKED, BigClientVersion.v1_9, "block.chest.locked");
-		addSound(BLOCK_CHEST_OPEN, BigClientVersion.v1_9, "block.chest.open");
-		addSound(BLOCK_CHORUS_FLOWER_DEATH, BigClientVersion.v1_9, "block.chorus_flower.death");
-		addSound(BLOCK_CHORUS_FLOWER_GROW, BigClientVersion.v1_9, "block.chorus_flower.grow");
-		addSound(BLOCK_CLOTH_BREAK, BigClientVersion.v1_9, "block.cloth.break");
-		addSound(BLOCK_CLOTH_FALL, BigClientVersion.v1_9, "block.cloth.fall");
-		addSound(BLOCK_CLOTH_HIT, BigClientVersion.v1_9, "block.cloth.hit");
-		addSound(BLOCK_CLOTH_PLACE, BigClientVersion.v1_9, "block.cloth.place");
-		addSound(BLOCK_CLOTH_STEP, BigClientVersion.v1_9, "block.cloth.step");
-		addSound(BLOCK_COMPARATOR_CLICK, BigClientVersion.v1_9, "block.comparator.click");
-		addSound(BLOCK_DISPENSER_DISPENSE, BigClientVersion.v1_9, "block.dispenser.dispense");
-		addSound(BLOCK_DISPENSER_FAIL, BigClientVersion.v1_9, "block.dispenser.fail");
-		addSound(BLOCK_DISPENSER_LAUNCH, BigClientVersion.v1_9, "block.dispenser.launch");
-		addSound(BLOCK_END_GATEWAY_SPAWN, BigClientVersion.v1_9, "block.end_gateway.spawn");
-		addSound(BLOCK_ENDERCHEST_CLOSE, BigClientVersion.v1_9, "block.enderchest.close");
-		addSound(BLOCK_ENDERCHEST_OPEN, BigClientVersion.v1_9, "block.enderchest.open");
-		addSound(BLOCK_FENCE_GATE_CLOSE, BigClientVersion.v1_9, "block.fence_gate.close");
-		addSound(BLOCK_FENCE_GATE_OPEN, BigClientVersion.v1_9, "block.fence_gate.open");
-		addSound(BLOCK_FIRE_AMBIENT, BigClientVersion.v1_9, "block.fire.ambient");
-		addSound(BLOCK_FIRE_EXTINGUISH, BigClientVersion.v1_9, "block.fire.extinguish");
-		addSound(BLOCK_FURNACE_FIRE_CRACKLE, BigClientVersion.v1_9, "block.furnace.fire_crackle");
-		addSound(BLOCK_GLASS_BREAK, BigClientVersion.v1_9, "block.glass.break");
-		addSound(BLOCK_GLASS_FALL, BigClientVersion.v1_9, "block.glass.fall");
-		addSound(BLOCK_GLASS_HIT, BigClientVersion.v1_9, "block.glass.hit");
-		addSound(BLOCK_GLASS_PLACE, BigClientVersion.v1_9, "block.glass.place");
-		addSound(BLOCK_GLASS_STEP, BigClientVersion.v1_9, "block.glass.step");
-		addSound(BLOCK_GRASS_BREAK, BigClientVersion.v1_9, "block.grass.break");
-		addSound(BLOCK_GRASS_FALL, BigClientVersion.v1_9, "block.grass.fall");
-		addSound(BLOCK_GRASS_HIT, BigClientVersion.v1_9, "block.grass.hit");
-		addSound(BLOCK_GRASS_PLACE, BigClientVersion.v1_9, "block.grass.place");
-		addSound(BLOCK_GRASS_STEP, BigClientVersion.v1_9, "block.grass.step");
-		addSound(BLOCK_GRAVEL_BREAK, BigClientVersion.v1_9, "block.gravel.break");
-		addSound(BLOCK_GRAVEL_FALL, BigClientVersion.v1_9, "block.gravel.fall");
-		addSound(BLOCK_GRAVEL_HIT, BigClientVersion.v1_9, "block.gravel.hit");
-		addSound(BLOCK_GRAVEL_PLACE, BigClientVersion.v1_9, "block.gravel.place");
-		addSound(BLOCK_GRAVEL_STEP, BigClientVersion.v1_9, "block.gravel.step");
-		addSound(BLOCK_IRON_DOOR_CLOSE, BigClientVersion.v1_9, "block.iron_door.close");
-		addSound(BLOCK_IRON_DOOR_OPEN, BigClientVersion.v1_9, "block.iron_door.open");
-		addSound(BLOCK_IRON_TRAPDOOR_CLOSE, BigClientVersion.v1_9, "block.iron_trapdoor.close");
-		addSound(BLOCK_IRON_TRAPDOOR_OPEN, BigClientVersion.v1_9, "block.iron_trapdoor.open");
-		addSound(BLOCK_LADDER_BREAK, BigClientVersion.v1_9, "block.ladder.break");
-		addSound(BLOCK_LADDER_FALL, BigClientVersion.v1_9, "block.ladder.fall");
-		addSound(BLOCK_LADDER_HIT, BigClientVersion.v1_9, "block.ladder.hit");
-		addSound(BLOCK_LADDER_PLACE, BigClientVersion.v1_9, "block.ladder.place");
-		addSound(BLOCK_LADDER_STEP, BigClientVersion.v1_9, "block.ladder.step");
-		addSound(BLOCK_LAVA_AMBIENT, BigClientVersion.v1_9, "block.lava.ambient");
-		addSound(BLOCK_LAVA_EXTINGUISH, BigClientVersion.v1_9, "block.lava.extinguish");
-		addSound(BLOCK_LAVA_POP, BigClientVersion.v1_9, "block.lava.pop");
-		addSound(BLOCK_LEVER_CLICK, BigClientVersion.v1_9, "block.lever.click");
-		addSound(BLOCK_METAL_BREAK, BigClientVersion.v1_9, "block.metal.break");
-		addSound(BLOCK_METAL_FALL, BigClientVersion.v1_9, "block.metal.fall");
-		addSound(BLOCK_METAL_HIT, BigClientVersion.v1_9, "block.metal.hit");
-		addSound(BLOCK_METAL_PLACE, BigClientVersion.v1_9, "block.metal.place");
-		addSound(BLOCK_METAL_STEP, BigClientVersion.v1_9, "block.metal.step");
-		addSound(BLOCK_METAL_PRESSUREPLATE_CLICK_OFF, BigClientVersion.v1_9, "block.metal_pressureplate.click_off");
-		addSound(BLOCK_METAL_PRESSUREPLATE_CLICK_ON, BigClientVersion.v1_9, "block.metal_pressureplate.click_on");
-		addSound(BLOCK_NOTE_BASEDRUM, BigClientVersion.v1_9, "block.note.basedrum");
-		addSound(BLOCK_NOTE_BASS, BigClientVersion.v1_9, "block.note.bass");
-		addSound(BLOCK_NOTE_HARP, BigClientVersion.v1_9, "block.note.harp");
-		addSound(BLOCK_NOTE_HAT, BigClientVersion.v1_9, "block.note.hat");
-		addSound(BLOCK_NOTE_PLING, BigClientVersion.v1_9, "block.note.pling");
-		addSound(BLOCK_NOTE_SNARE, BigClientVersion.v1_9, "block.note.snare");
-		addSound(BLOCK_PISTON_CONTRACT, BigClientVersion.v1_9, "block.piston.contract");
-		addSound(BLOCK_PISTON_EXTEND, BigClientVersion.v1_9, "block.piston.extend");
-		addSound(BLOCK_PORTAL_AMBIENT, BigClientVersion.v1_9, "block.portal.ambient");
-		addSound(BLOCK_PORTAL_TRAVEL, BigClientVersion.v1_9, "block.portal.travel");
-		addSound(BLOCK_PORTAL_TRIGGER, BigClientVersion.v1_9, "block.portal.trigger");
-		addSound(BLOCK_REDSTONE_TORCH_BURNOUT, BigClientVersion.v1_9, "block.redstone_torch.burnout");
-		addSound(BLOCK_SAND_BREAK, BigClientVersion.v1_9, "block.sand.break");
-		addSound(BLOCK_SAND_FALL, BigClientVersion.v1_9, "block.sand.fall");
-		addSound(BLOCK_SAND_HIT, BigClientVersion.v1_9, "block.sand.hit");
-		addSound(BLOCK_SAND_PLACE, BigClientVersion.v1_9, "block.sand.place");
-		addSound(BLOCK_SAND_STEP, BigClientVersion.v1_9, "block.sand.step");
-		addSound(BLOCK_SLIME_BREAK, BigClientVersion.v1_9, "block.slime.break");
-		addSound(BLOCK_SLIME_FALL, BigClientVersion.v1_9, "block.slime.fall");
-		addSound(BLOCK_SLIME_HIT, BigClientVersion.v1_9, "block.slime.hit");
-		addSound(BLOCK_SLIME_PLACE, BigClientVersion.v1_9, "block.slime.place");
-		addSound(BLOCK_SLIME_STEP, BigClientVersion.v1_9, "block.slime.step");
-		addSound(BLOCK_SNOW_BREAK, BigClientVersion.v1_9, "block.snow.break");
-		addSound(BLOCK_SNOW_FALL, BigClientVersion.v1_9, "block.snow.fall");
-		addSound(BLOCK_SNOW_HIT, BigClientVersion.v1_9, "block.snow.hit");
-		addSound(BLOCK_SNOW_PLACE, BigClientVersion.v1_9, "block.snow.place");
-		addSound(BLOCK_SNOW_STEP, BigClientVersion.v1_9, "block.snow.step");
-		addSound(BLOCK_STONE_BREAK, BigClientVersion.v1_9, "block.stone.break");
-		addSound(BLOCK_STONE_FALL, BigClientVersion.v1_9, "block.stone.fall");
-		addSound(BLOCK_STONE_HIT, BigClientVersion.v1_9, "block.stone.hit");
-		addSound(BLOCK_STONE_PLACE, BigClientVersion.v1_9, "block.stone.place");
-		addSound(BLOCK_STONE_STEP, BigClientVersion.v1_9, "block.stone.step");
-		addSound(BLOCK_STONE_BUTTON_CLICK_OFF, BigClientVersion.v1_9, "block.stone_button.click_off");
-		addSound(BLOCK_STONE_BUTTON_CLICK_ON, BigClientVersion.v1_9, "block.stone_button.click_on");
-		addSound(BLOCK_STONE_PRESSUREPLATE_CLICK_OFF, BigClientVersion.v1_9, "block.stone_pressureplate.click_off");
-		addSound(BLOCK_STONE_PRESSUREPLATE_CLICK_ON, BigClientVersion.v1_9, "block.stone_pressureplate.click_on");
-		addSound(BLOCK_TRIPWIRE_ATTACH, BigClientVersion.v1_9, "block.tripwire.attach");
-		addSound(BLOCK_TRIPWIRE_CLICK_OFF, BigClientVersion.v1_9, "block.tripwire.click_off");
-		addSound(BLOCK_TRIPWIRE_CLICK_ON, BigClientVersion.v1_9, "block.tripwire.click_on");
-		addSound(BLOCK_TRIPWIRE_DETACH, BigClientVersion.v1_9, "block.tripwire.detach");
-		addSound(BLOCK_WATER_AMBIENT, BigClientVersion.v1_9, "block.water.ambient");
-		addSound(BLOCK_WATERLILY_PLACE, BigClientVersion.v1_9, "block.waterlily.place");
-		addSound(BLOCK_WOOD_BREAK, BigClientVersion.v1_9, "block.wood.break");
-		addSound(BLOCK_WOOD_FALL, BigClientVersion.v1_9, "block.wood.fall");
-		addSound(BLOCK_WOOD_HIT, BigClientVersion.v1_9, "block.wood.hit");
-		addSound(BLOCK_WOOD_PLACE, BigClientVersion.v1_9, "block.wood.place");
-		addSound(BLOCK_WOOD_STEP, BigClientVersion.v1_9, "block.wood.step");
-		addSound(BLOCK_WOOD_BUTTON_CLICK_OFF, BigClientVersion.v1_9, "block.wood_button.click_off");
-		addSound(BLOCK_WOOD_BUTTON_CLICK_ON, BigClientVersion.v1_9, "block.wood_button.click_on");
-		addSound(BLOCK_WOOD_PRESSUREPLATE_CLICK_OFF, BigClientVersion.v1_9, "block.wood_pressureplate.click_off");
-		addSound(BLOCK_WOOD_PRESSUREPLATE_CLICK_ON, BigClientVersion.v1_9, "block.wood_pressureplate.click_on");
-		addSound(BLOCK_WOODEN_DOOR_CLOSE, BigClientVersion.v1_9, "block.wooden_door.close");
-		addSound(BLOCK_WOODEN_DOOR_OPEN, BigClientVersion.v1_9, "block.wooden_door.open");
-		addSound(BLOCK_WOODEN_TRAPDOOR_CLOSE, BigClientVersion.v1_9, "block.wooden_trapdoor.close");
-		addSound(BLOCK_WOODEN_TRAPDOOR_OPEN, BigClientVersion.v1_9, "block.wooden_trapdoor.open");
-		addSound(ENCHANT_THORNS_HIT, BigClientVersion.v1_9, "enchant.thorns.hit");
-		addSound(ENTITY_ARMORSTAND_BREAK, BigClientVersion.v1_9, "entity.armorstand.break");
-		addSound(ENTITY_ARMORSTAND_FALL, BigClientVersion.v1_9, "entity.armorstand.fall");
-		addSound(ENTITY_ARMORSTAND_HIT, BigClientVersion.v1_9, "entity.armorstand.hit");
-		addSound(ENTITY_ARMORSTAND_PLACE, BigClientVersion.v1_9, "entity.armorstand.place");
-		addSound(ENTITY_ARROW_HIT, BigClientVersion.v1_9, "entity.arrow.hit");
-		addSound(ENTITY_ARROW_HIT_PLAYER, BigClientVersion.v1_9, "entity.arrow.hit_player");
-		addSound(ENTITY_ARROW_SHOOT, BigClientVersion.v1_9, "entity.arrow.shoot");
-		addSound(ENTITY_BAT_AMBIENT, BigClientVersion.v1_9, "entity.bat.ambient");
-		addSound(ENTITY_BAT_DEATH, BigClientVersion.v1_9, "entity.bat.death");
-		addSound(ENTITY_BAT_HURT, BigClientVersion.v1_9, "entity.bat.hurt");
-		addSound(ENTITY_BAT_LOOP, BigClientVersion.v1_9, "entity.bat.loop");
-		addSound(ENTITY_BAT_TAKEOFF, BigClientVersion.v1_9, "entity.bat.takeoff");
-		addSound(ENTITY_BLAZE_AMBIENT, BigClientVersion.v1_9, "entity.blaze.ambient");
-		addSound(ENTITY_BLAZE_BURN, BigClientVersion.v1_9, "entity.blaze.burn");
-		addSound(ENTITY_BLAZE_DEATH, BigClientVersion.v1_9, "entity.blaze.death");
-		addSound(ENTITY_BLAZE_HURT, BigClientVersion.v1_9, "entity.blaze.hurt");
-		addSound(ENTITY_BLAZE_SHOOT, BigClientVersion.v1_9, "entity.blaze.shoot");
-		addSound(ENTITY_BOBBER_SPLASH, BigClientVersion.v1_9, "entity.bobber.splash");
-		addSound(ENTITY_BOBBER_THROW, BigClientVersion.v1_9, "entity.bobber.throw");
-		addSound(ENTITY_CAT_AMBIENT, BigClientVersion.v1_9, "entity.cat.ambient");
-		addSound(ENTITY_CAT_DEATH, BigClientVersion.v1_9, "entity.cat.death");
-		addSound(ENTITY_CAT_HISS, BigClientVersion.v1_9, "entity.cat.hiss");
-		addSound(ENTITY_CAT_HURT, BigClientVersion.v1_9, "entity.cat.hurt");
-		addSound(ENTITY_CAT_PURR, BigClientVersion.v1_9, "entity.cat.purr");
-		addSound(ENTITY_CAT_PURREOW, BigClientVersion.v1_9, "entity.cat.purreow");
-		addSound(ENTITY_CHICKEN_AMBIENT, BigClientVersion.v1_9, "entity.chicken.ambient");
-		addSound(ENTITY_CHICKEN_DEATH, BigClientVersion.v1_9, "entity.chicken.death");
-		addSound(ENTITY_CHICKEN_EGG, BigClientVersion.v1_9, "entity.chicken.egg");
-		addSound(ENTITY_CHICKEN_HURT, BigClientVersion.v1_9, "entity.chicken.hurt");
-		addSound(ENTITY_CHICKEN_STEP, BigClientVersion.v1_9, "entity.chicken.step");
-		addSound(ENTITY_COW_AMBIENT, BigClientVersion.v1_9, "entity.cow.ambient");
-		addSound(ENTITY_COW_DEATH, BigClientVersion.v1_9, "entity.cow.death");
-		addSound(ENTITY_COW_HURT, BigClientVersion.v1_9, "entity.cow.hurt");
-		addSound(ENTITY_COW_MILK, BigClientVersion.v1_9, "entity.cow.milk");
-		addSound(ENTITY_COW_STEP, BigClientVersion.v1_9, "entity.cow.step");
-		addSound(ENTITY_CREEPER_DEATH, BigClientVersion.v1_9, "entity.creeper.death");
-		addSound(ENTITY_CREEPER_HURT, BigClientVersion.v1_9, "entity.creeper.hurt");
-		addSound(ENTITY_CREEPER_PRIMED, BigClientVersion.v1_9, "entity.creeper.primed");
-		addSound(ENTITY_DONKEY_AMBIENT, BigClientVersion.v1_9, "entity.donkey.ambient");
-		addSound(ENTITY_DONKEY_ANGRY, BigClientVersion.v1_9, "entity.donkey.angry");
-		addSound(ENTITY_DONKEY_CHEST, BigClientVersion.v1_9, "entity.donkey.chest");
-		addSound(ENTITY_DONKEY_DEATH, BigClientVersion.v1_9, "entity.donkey.death");
-		addSound(ENTITY_DONKEY_HURT, BigClientVersion.v1_9, "entity.donkey.hurt");
-		addSound(ENTITY_EGG_THROW, BigClientVersion.v1_9, "entity.egg.throw");
-		addSound(ENTITY_ELDER_GUARDIAN_AMBIENT, BigClientVersion.v1_9, "entity.elder_guardian.ambient");
-		addSound(ENTITY_ELDER_GUARDIAN_AMBIENT_LAND, BigClientVersion.v1_9, "entity.elder_guardian.ambient_land");
-		addSound(ENTITY_ELDER_GUARDIAN_CURSE, BigClientVersion.v1_9, "entity.elder_guardian.curse");
-		addSound(ENTITY_ELDER_GUARDIAN_DEATH, BigClientVersion.v1_9, "entity.elder_guardian.death");
-		addSound(ENTITY_ELDER_GUARDIAN_DEATH_LAND, BigClientVersion.v1_9, "entity.elder_guardian.death_land");
-		addSound(ENTITY_ELDER_GUARDIAN_HURT, BigClientVersion.v1_9, "entity.elder_guardian.hurt");
-		addSound(ENTITY_ELDER_GUARDIAN_HURT_LAND, BigClientVersion.v1_9, "entity.elder_guardian.hurt_land");
-		addSound(ENTITY_ENDERDRAGON_AMBIENT, BigClientVersion.v1_9, "entity.enderdragon.ambient");
-		addSound(ENTITY_ENDERDRAGON_DEATH, BigClientVersion.v1_9, "entity.enderdragon.death");
-		addSound(ENTITY_ENDERDRAGON_FLAP, BigClientVersion.v1_9, "entity.enderdragon.flap");
-		addSound(ENTITY_ENDERDRAGON_GROWL, BigClientVersion.v1_9, "entity.enderdragon.growl");
-		addSound(ENTITY_ENDERDRAGON_HURT, BigClientVersion.v1_9, "entity.enderdragon.hurt");
-		addSound(ENTITY_ENDERDRAGON_SHOOT, BigClientVersion.v1_9, "entity.enderdragon.shoot");
-		addSound(ENTITY_ENDERDRAGON_FIREBALL_EXPLODE, BigClientVersion.v1_9, "entity.enderdragon_fireball.explode");
-		addSound(ENTITY_ENDEREYE_LAUNCH, BigClientVersion.v1_9, "entity.endereye.launch");
-		addSound(ENTITY_ENDERMEN_AMBIENT, BigClientVersion.v1_9, "entity.endermen.ambient");
-		addSound(ENTITY_ENDERMEN_DEATH, BigClientVersion.v1_9, "entity.endermen.death");
-		addSound(ENTITY_ENDERMEN_HURT, BigClientVersion.v1_9, "entity.endermen.hurt");
-		addSound(ENTITY_ENDERMEN_SCREAM, BigClientVersion.v1_9, "entity.endermen.scream");
-		addSound(ENTITY_ENDERMEN_STARE, BigClientVersion.v1_9, "entity.endermen.stare");
-		addSound(ENTITY_ENDERMEN_TELEPORT, BigClientVersion.v1_9, "entity.endermen.teleport");
-		addSound(ENTITY_ENDERMITE_AMBIENT, BigClientVersion.v1_9, "entity.endermite.ambient");
-		addSound(ENTITY_ENDERMITE_DEATH, BigClientVersion.v1_9, "entity.endermite.death");
-		addSound(ENTITY_ENDERMITE_HURT, BigClientVersion.v1_9, "entity.endermite.hurt");
-		addSound(ENTITY_ENDERMITE_STEP, BigClientVersion.v1_9, "entity.endermite.step");
-		addSound(ENTITY_ENDERPEARL_THROW, BigClientVersion.v1_9, "entity.enderpearl.throw");
-		addSound(ENTITY_EXPERIENCE_BOTTLE_THROW, BigClientVersion.v1_9, "entity.experience_bottle.throw");
-		addSound(ENTITY_EXPERIENCE_ORB_PICKUP, BigClientVersion.v1_9, "entity.experience_orb.pickup");
-		addSound(ENTITY_EXPERIENCE_ORB_TOUCH, BigClientVersion.v1_9, "entity.experience_orb.touch");
-		addSound(ENTITY_FIREWORK_BLAST, BigClientVersion.v1_9, "entity.firework.blast");
-		addSound(ENTITY_FIREWORK_BLAST_FAR, BigClientVersion.v1_9, "entity.firework.blast_far");
-		addSound(ENTITY_FIREWORK_LARGE_BLAST, BigClientVersion.v1_9, "entity.firework.large_blast");
-		addSound(ENTITY_FIREWORK_LARGE_BLAST_FAR, BigClientVersion.v1_9, "entity.firework.large_blast_far");
-		addSound(ENTITY_FIREWORK_LAUNCH, BigClientVersion.v1_9, "entity.firework.launch");
-		addSound(ENTITY_FIREWORK_SHOOT, BigClientVersion.v1_9, "entity.firework.shoot");
-		addSound(ENTITY_FIREWORK_TWINKLE, BigClientVersion.v1_9, "entity.firework.twinkle");
-		addSound(ENTITY_FIREWORK_TWINKLE_FAR, BigClientVersion.v1_9, "entity.firework.twinkle_far");
-		addSound(ENTITY_GENERIC_BIG_FALL, BigClientVersion.v1_9, "entity.generic.big_fall");
-		addSound(ENTITY_GENERIC_BURN, BigClientVersion.v1_9, "entity.generic.burn");
-		addSound(ENTITY_GENERIC_DEATH, BigClientVersion.v1_9, "entity.generic.death");
-		addSound(ENTITY_GENERIC_DRINK, BigClientVersion.v1_9, "entity.generic.drink");
-		addSound(ENTITY_GENERIC_EAT, BigClientVersion.v1_9, "entity.generic.eat");
-		addSound(ENTITY_GENERIC_EXPLODE, BigClientVersion.v1_9, "entity.generic.explode");
-		addSound(ENTITY_GENERIC_EXTINGUISH_FIRE, BigClientVersion.v1_9, "entity.generic.extinguish_fire");
-		addSound(ENTITY_GENERIC_HURT, BigClientVersion.v1_9, "entity.generic.hurt");
-		addSound(ENTITY_GENERIC_SMALL_FALL, BigClientVersion.v1_9, "entity.generic.small_fall");
-		addSound(ENTITY_GENERIC_SPLASH, BigClientVersion.v1_9, "entity.generic.splash");
-		addSound(ENTITY_GENERIC_SWIM, BigClientVersion.v1_9, "entity.generic.swim");
-		addSound(ENTITY_GHAST_AMBIENT, BigClientVersion.v1_9, "entity.ghast.ambient");
-		addSound(ENTITY_GHAST_DEATH, BigClientVersion.v1_9, "entity.ghast.death");
-		addSound(ENTITY_GHAST_HURT, BigClientVersion.v1_9, "entity.ghast.hurt");
-		addSound(ENTITY_GHAST_SCREAM, BigClientVersion.v1_9, "entity.ghast.scream");
-		addSound(ENTITY_GHAST_SHOOT, BigClientVersion.v1_9, "entity.ghast.shoot");
-		addSound(ENTITY_GHAST_WARN, BigClientVersion.v1_9, "entity.ghast.warn");
-		addSound(ENTITY_GUARDIAN_AMBIENT, BigClientVersion.v1_9, "entity.guardian.ambient");
-		addSound(ENTITY_GUARDIAN_AMBIENT_LAND, BigClientVersion.v1_9, "entity.guardian.ambient_land");
-		addSound(ENTITY_GUARDIAN_ATTACK, BigClientVersion.v1_9, "entity.guardian.attack");
-		addSound(ENTITY_GUARDIAN_DEATH, BigClientVersion.v1_9, "entity.guardian.death");
-		addSound(ENTITY_GUARDIAN_DEATH_LAND, BigClientVersion.v1_9, "entity.guardian.death_land");
-		addSound(ENTITY_GUARDIAN_FLOP, BigClientVersion.v1_9, "entity.guardian.flop");
-		addSound(ENTITY_GUARDIAN_HURT, BigClientVersion.v1_9, "entity.guardian.hurt");
-		addSound(ENTITY_GUARDIAN_HURT_LAND, BigClientVersion.v1_9, "entity.guardian.hurt_land");
-		addSound(ENTITY_HORSE_AMBIENT, BigClientVersion.v1_9, "entity.horse.ambient");
-		addSound(ENTITY_HORSE_ANGRY, BigClientVersion.v1_9, "entity.horse.angry");
-		addSound(ENTITY_HORSE_ARMOR, BigClientVersion.v1_9, "entity.horse.armor");
-		addSound(ENTITY_HORSE_BREATHE, BigClientVersion.v1_9, "entity.horse.breathe");
-		addSound(ENTITY_HORSE_DEATH, BigClientVersion.v1_9, "entity.horse.death");
-		addSound(ENTITY_HORSE_EAT, BigClientVersion.v1_9, "entity.horse.eat");
-		addSound(ENTITY_HORSE_GALLOP, BigClientVersion.v1_9, "entity.horse.gallop");
-		addSound(ENTITY_HORSE_HURT, BigClientVersion.v1_9, "entity.horse.hurt");
-		addSound(ENTITY_HORSE_JUMP, BigClientVersion.v1_9, "entity.horse.jump");
-		addSound(ENTITY_HORSE_LAND, BigClientVersion.v1_9, "entity.horse.land");
-		addSound(ENTITY_HORSE_SADDLE, BigClientVersion.v1_9, "entity.horse.saddle");
-		addSound(ENTITY_HORSE_STEP, BigClientVersion.v1_9, "entity.horse.step");
-		addSound(ENTITY_HORSE_STEP_WOOD, BigClientVersion.v1_9, "entity.horse.step_wood");
-		addSound(ENTITY_HOSTILE_BIG_FALL, BigClientVersion.v1_9, "entity.hostile.big_fall");
-		addSound(ENTITY_HOSTILE_DEATH, BigClientVersion.v1_9, "entity.hostile.death");
-		addSound(ENTITY_HOSTILE_HURT, BigClientVersion.v1_9, "entity.hostile.hurt");
-		addSound(ENTITY_HOSTILE_SMALL_FALL, BigClientVersion.v1_9, "entity.hostile.small_fall");
-		addSound(ENTITY_HOSTILE_SPLASH, BigClientVersion.v1_9, "entity.hostile.splash");
-		addSound(ENTITY_HOSTILE_SWIM, BigClientVersion.v1_9, "entity.hostile.swim");
-		addSound(ENTITY_IRONGOLEM_ATTACK, BigClientVersion.v1_9, "entity.irongolem.attack");
-		addSound(ENTITY_IRONGOLEM_DEATH, BigClientVersion.v1_9, "entity.irongolem.death");
-		addSound(ENTITY_IRONGOLEM_HURT, BigClientVersion.v1_9, "entity.irongolem.hurt");
-		addSound(ENTITY_IRONGOLEM_STEP, BigClientVersion.v1_9, "entity.irongolem.step");
-		addSound(ENTITY_ITEM_BREAK, BigClientVersion.v1_9, "entity.item.break");
-		addSound(ENTITY_ITEM_PICKUP, BigClientVersion.v1_9, "entity.item.pickup");
-		addSound(ENTITY_ITEMFRAME_ADD_ITEM, BigClientVersion.v1_9, "entity.itemframe.add_item");
-		addSound(ENTITY_ITEMFRAME_BREAK, BigClientVersion.v1_9, "entity.itemframe.break");
-		addSound(ENTITY_ITEMFRAME_PLACE, BigClientVersion.v1_9, "entity.itemframe.place");
-		addSound(ENTITY_ITEMFRAME_REMOVE_ITEM, BigClientVersion.v1_9, "entity.itemframe.remove_item");
-		addSound(ENTITY_ITEMFRAME_ROTATE_ITEM, BigClientVersion.v1_9, "entity.itemframe.rotate_item");
-		addSound(ENTITY_LEASHKNOT_BREAK, BigClientVersion.v1_9, "entity.leashknot.break");
-		addSound(ENTITY_LEASHKNOT_PLACE, BigClientVersion.v1_9, "entity.leashknot.place");
-		addSound(ENTITY_LIGHTNING_IMPACT, BigClientVersion.v1_9, "entity.lightning.impact");
-		addSound(ENTITY_LIGHTNING_THUNDER, BigClientVersion.v1_9, "entity.lightning.thunder");
-		addSound(ENTITY_LINGERINGPOTION_THROW, BigClientVersion.v1_9, "entity.lingeringpotion.throw");
-		addSound(ENTITY_MAGMACUBE_DEATH, BigClientVersion.v1_9, "entity.magmacube.death");
-		addSound(ENTITY_MAGMACUBE_HURT, BigClientVersion.v1_9, "entity.magmacube.hurt");
-		addSound(ENTITY_MAGMACUBE_JUMP, BigClientVersion.v1_9, "entity.magmacube.jump");
-		addSound(ENTITY_MAGMACUBE_SQUISH, BigClientVersion.v1_9, "entity.magmacube.squish");
-		addSound(ENTITY_MINECART_INSIDE, BigClientVersion.v1_9, "entity.minecart.inside");
-		addSound(ENTITY_MINECART_RIDING, BigClientVersion.v1_9, "entity.minecart.riding");
-		addSound(ENTITY_MOOSHROOM_SHEAR, BigClientVersion.v1_9, "entity.mooshroom.shear");
-		addSound(ENTITY_MULE_AMBIENT, BigClientVersion.v1_9, "entity.mule.ambient");
-		addSound(ENTITY_MULE_DEATH, BigClientVersion.v1_9, "entity.mule.death");
-		addSound(ENTITY_MULE_HURT, BigClientVersion.v1_9, "entity.mule.hurt");
-		addSound(ENTITY_PAINTING_BREAK, BigClientVersion.v1_9, "entity.painting.break");
-		addSound(ENTITY_PAINTING_PLACE, BigClientVersion.v1_9, "entity.painting.place");
-		addSound(ENTITY_PIG_AMBIENT, BigClientVersion.v1_9, "entity.pig.ambient");
-		addSound(ENTITY_PIG_DEATH, BigClientVersion.v1_9, "entity.pig.death");
-		addSound(ENTITY_PIG_HURT, BigClientVersion.v1_9, "entity.pig.hurt");
-		addSound(ENTITY_PIG_SADDLE, BigClientVersion.v1_9, "entity.pig.saddle");
-		addSound(ENTITY_PIG_STEP, BigClientVersion.v1_9, "entity.pig.step");
-		addSound(ENTITY_PLAYER_ATTACK_CRIT, BigClientVersion.v1_9, "entity.player.attack.crit");
-		addSound(ENTITY_PLAYER_ATTACK_KNOCKBACK, BigClientVersion.v1_9, "entity.player.attack.knockback");
-		addSound(ENTITY_PLAYER_ATTACK_NODAMAGE, BigClientVersion.v1_9, "entity.player.attack.nodamage");
-		addSound(ENTITY_PLAYER_ATTACK_STRONG, BigClientVersion.v1_9, "entity.player.attack.strong");
-		addSound(ENTITY_PLAYER_ATTACK_SWEEP, BigClientVersion.v1_9, "entity.player.attack.sweep");
-		addSound(ENTITY_PLAYER_ATTACK_WEAK, BigClientVersion.v1_9, "entity.player.attack.weak");
-		addSound(ENTITY_PLAYER_BIG_FALL, BigClientVersion.v1_9, "entity.player.big_fall");
-		addSound(ENTITY_PLAYER_BREATH, BigClientVersion.v1_9, "entity.player.breath");
-		addSound(ENTITY_PLAYER_BURP, BigClientVersion.v1_9, "entity.player.burp");
-		addSound(ENTITY_PLAYER_DEATH, BigClientVersion.v1_9, "entity.player.death");
-		addSound(ENTITY_PLAYER_HURT, BigClientVersion.v1_9, "entity.player.hurt");
-		addSound(ENTITY_PLAYER_LEVELUP, BigClientVersion.v1_9, "entity.player.levelup");
-		addSound(ENTITY_PLAYER_SMALL_FALL, BigClientVersion.v1_9, "entity.player.small_fall");
-		addSound(ENTITY_PLAYER_SPLASH, BigClientVersion.v1_9, "entity.player.splash");
-		addSound(ENTITY_PLAYER_SWIM, BigClientVersion.v1_9, "entity.player.swim");
-		addSound(ENTITY_RABBIT_AMBIENT, BigClientVersion.v1_9, "entity.rabbit.ambient");
-		addSound(ENTITY_RABBIT_ATTACK, BigClientVersion.v1_9, "entity.rabbit.attack");
-		addSound(ENTITY_RABBIT_DEATH, BigClientVersion.v1_9, "entity.rabbit.death");
-		addSound(ENTITY_RABBIT_HURT, BigClientVersion.v1_9, "entity.rabbit.hurt");
-		addSound(ENTITY_RABBIT_JUMP, BigClientVersion.v1_9, "entity.rabbit.jump");
-		addSound(ENTITY_SHEEP_AMBIENT, BigClientVersion.v1_9, "entity.sheep.ambient");
-		addSound(ENTITY_SHEEP_DEATH, BigClientVersion.v1_9, "entity.sheep.death");
-		addSound(ENTITY_SHEEP_HURT, BigClientVersion.v1_9, "entity.sheep.hurt");
-		addSound(ENTITY_SHEEP_SHEAR, BigClientVersion.v1_9, "entity.sheep.shear");
-		addSound(ENTITY_SHEEP_STEP, BigClientVersion.v1_9, "entity.sheep.step");
-		addSound(ENTITY_SHULKER_AMBIENT, BigClientVersion.v1_9, "entity.shulker.ambient");
-		addSound(ENTITY_SHULKER_CLOSE, BigClientVersion.v1_9, "entity.shulker.close");
-		addSound(ENTITY_SHULKER_DEATH, BigClientVersion.v1_9, "entity.shulker.death");
-		addSound(ENTITY_SHULKER_HURT, BigClientVersion.v1_9, "entity.shulker.hurt");
-		addSound(ENTITY_SHULKER_HURT_CLOSED, BigClientVersion.v1_9, "entity.shulker.hurt_closed");
-		addSound(ENTITY_SHULKER_OPEN, BigClientVersion.v1_9, "entity.shulker.open");
-		addSound(ENTITY_SHULKER_SHOOT, BigClientVersion.v1_9, "entity.shulker.shoot");
-		addSound(ENTITY_SHULKER_TELEPORT, BigClientVersion.v1_9, "entity.shulker.teleport");
-		addSound(ENTITY_SHULKER_BULLET_HIT, BigClientVersion.v1_9, "entity.shulker_bullet.hit");
-		addSound(ENTITY_SHULKER_BULLET_HURT, BigClientVersion.v1_9, "entity.shulker_bullet.hurt");
-		addSound(ENTITY_SILVERFISH_AMBIENT, BigClientVersion.v1_9, "entity.silverfish.ambient");
-		addSound(ENTITY_SILVERFISH_DEATH, BigClientVersion.v1_9, "entity.silverfish.death");
-		addSound(ENTITY_SILVERFISH_HURT, BigClientVersion.v1_9, "entity.silverfish.hurt");
-		addSound(ENTITY_SILVERFISH_STEP, BigClientVersion.v1_9, "entity.silverfish.step");
-		addSound(ENTITY_SKELETON_AMBIENT, BigClientVersion.v1_9, "entity.skeleton.ambient");
-		addSound(ENTITY_SKELETON_DEATH, BigClientVersion.v1_9, "entity.skeleton.death");
-		addSound(ENTITY_SKELETON_HURT, BigClientVersion.v1_9, "entity.skeleton.hurt");
-		addSound(ENTITY_SKELETON_SHOOT, BigClientVersion.v1_9, "entity.skeleton.shoot");
-		addSound(ENTITY_SKELETON_STEP, BigClientVersion.v1_9, "entity.skeleton.step");
-		addSound(ENTITY_SKELETON_HORSE_AMBIENT, BigClientVersion.v1_9, "entity.skeleton_horse.ambient");
-		addSound(ENTITY_SKELETON_HORSE_DEATH, BigClientVersion.v1_9, "entity.skeleton_horse.death");
-		addSound(ENTITY_SKELETON_HORSE_HURT, BigClientVersion.v1_9, "entity.skeleton_horse.hurt");
-		addSound(ENTITY_SLIME_ATTACK, BigClientVersion.v1_9, "entity.slime.attack");
-		addSound(ENTITY_SLIME_DEATH, BigClientVersion.v1_9, "entity.slime.death");
-		addSound(ENTITY_SLIME_HURT, BigClientVersion.v1_9, "entity.slime.hurt");
-		addSound(ENTITY_SLIME_JUMP, BigClientVersion.v1_9, "entity.slime.jump");
-		addSound(ENTITY_SLIME_SQUISH, BigClientVersion.v1_9, "entity.slime.squish");
-		addSound(ENTITY_SMALL_MAGMACUBE_DEATH, BigClientVersion.v1_9, "entity.small_magmacube.death");
-		addSound(ENTITY_SMALL_MAGMACUBE_HURT, BigClientVersion.v1_9, "entity.small_magmacube.hurt");
-		addSound(ENTITY_SMALL_MAGMACUBE_SQUISH, BigClientVersion.v1_9, "entity.small_magmacube.squish");
-		addSound(ENTITY_SMALL_SLIME_DEATH, BigClientVersion.v1_9, "entity.small_slime.death");
-		addSound(ENTITY_SMALL_SLIME_HURT, BigClientVersion.v1_9, "entity.small_slime.hurt");
-		addSound(ENTITY_SMALL_SLIME_JUMP, BigClientVersion.v1_9, "entity.small_slime.jump");
-		addSound(ENTITY_SMALL_SLIME_SQUISH, BigClientVersion.v1_9, "entity.small_slime.squish");
-		addSound(ENTITY_SNOWBALL_THROW, BigClientVersion.v1_9, "entity.snowball.throw");
-		addSound(ENTITY_SNOWMAN_AMBIENT, BigClientVersion.v1_9, "entity.snowman.ambient");
-		addSound(ENTITY_SNOWMAN_DEATH, BigClientVersion.v1_9, "entity.snowman.death");
-		addSound(ENTITY_SNOWMAN_HURT, BigClientVersion.v1_9, "entity.snowman.hurt");
-		addSound(ENTITY_SNOWMAN_SHOOT, BigClientVersion.v1_9, "entity.snowman.shoot");
-		addSound(ENTITY_SPIDER_AMBIENT, BigClientVersion.v1_9, "entity.spider.ambient");
-		addSound(ENTITY_SPIDER_DEATH, BigClientVersion.v1_9, "entity.spider.death");
-		addSound(ENTITY_SPIDER_HURT, BigClientVersion.v1_9, "entity.spider.hurt");
-		addSound(ENTITY_SPIDER_STEP, BigClientVersion.v1_9, "entity.spider.step");
-		addSound(ENTITY_SPLASH_POTION_BREAK, BigClientVersion.v1_9, "entity.splash_potion.break");
-		addSound(ENTITY_SPLASH_POTION_THROW, BigClientVersion.v1_9, "entity.splash_potion.throw");
-		addSound(ENTITY_SQUID_AMBIENT, BigClientVersion.v1_9, "entity.squid.ambient");
-		addSound(ENTITY_SQUID_DEATH, BigClientVersion.v1_9, "entity.squid.death");
-		addSound(ENTITY_SQUID_HURT, BigClientVersion.v1_9, "entity.squid.hurt");
-		addSound(ENTITY_TNT_PRIMED, BigClientVersion.v1_9, "entity.tnt.primed");
-		addSound(ENTITY_VILLAGER_AMBIENT, BigClientVersion.v1_9, "entity.villager.ambient");
-		addSound(ENTITY_VILLAGER_DEATH, BigClientVersion.v1_9, "entity.villager.death");
-		addSound(ENTITY_VILLAGER_HURT, BigClientVersion.v1_9, "entity.villager.hurt");
-		addSound(ENTITY_VILLAGER_NO, BigClientVersion.v1_9, "entity.villager.no");
-		addSound(ENTITY_VILLAGER_TRADING, BigClientVersion.v1_9, "entity.villager.trading");
-		addSound(ENTITY_VILLAGER_YES, BigClientVersion.v1_9, "entity.villager.yes");
-		addSound(ENTITY_WITCH_AMBIENT, BigClientVersion.v1_9, "entity.witch.ambient");
-		addSound(ENTITY_WITCH_DEATH, BigClientVersion.v1_9, "entity.witch.death");
-		addSound(ENTITY_WITCH_DRINK, BigClientVersion.v1_9, "entity.witch.drink");
-		addSound(ENTITY_WITCH_HURT, BigClientVersion.v1_9, "entity.witch.hurt");
-		addSound(ENTITY_WITCH_THROW, BigClientVersion.v1_9, "entity.witch.throw");
-		addSound(ENTITY_WITHER_AMBIENT, BigClientVersion.v1_9, "entity.wither.ambient");
-		addSound(ENTITY_WITHER_BREAK_BLOCK, BigClientVersion.v1_9, "entity.wither.break_block");
-		addSound(ENTITY_WITHER_DEATH, BigClientVersion.v1_9, "entity.wither.death");
-		addSound(ENTITY_WITHER_HURT, BigClientVersion.v1_9, "entity.wither.hurt");
-		addSound(ENTITY_WITHER_SHOOT, BigClientVersion.v1_9, "entity.wither.shoot");
-		addSound(ENTITY_WITHER_SPAWN, BigClientVersion.v1_9, "entity.wither.spawn");
-		addSound(ENTITY_WOLF_AMBIENT, BigClientVersion.v1_9, "entity.wolf.ambient");
-		addSound(ENTITY_WOLF_DEATH, BigClientVersion.v1_9, "entity.wolf.death");
-		addSound(ENTITY_WOLF_GROWL, BigClientVersion.v1_9, "entity.wolf.growl");
-		addSound(ENTITY_WOLF_HOWL, BigClientVersion.v1_9, "entity.wolf.howl");
-		addSound(ENTITY_WOLF_HURT, BigClientVersion.v1_9, "entity.wolf.hurt");
-		addSound(ENTITY_WOLF_PANT, BigClientVersion.v1_9, "entity.wolf.pant");
-		addSound(ENTITY_WOLF_SHAKE, BigClientVersion.v1_9, "entity.wolf.shake");
-		addSound(ENTITY_WOLF_STEP, BigClientVersion.v1_9, "entity.wolf.step");
-		addSound(ENTITY_WOLF_WHINE, BigClientVersion.v1_9, "entity.wolf.whine");
-		addSound(ENTITY_ZOMBIE_AMBIENT, BigClientVersion.v1_9, "entity.zombie.ambient");
-		addSound(ENTITY_ZOMBIE_ATTACK_DOOR_WOOD, BigClientVersion.v1_9, "entity.zombie.attack_door_wood");
-		addSound(ENTITY_ZOMBIE_ATTACK_IRON_DOOR, BigClientVersion.v1_9, "entity.zombie.attack_iron_door");
-		addSound(ENTITY_ZOMBIE_BREAK_DOOR_WOOD, BigClientVersion.v1_9, "entity.zombie.break_door_wood");
-		addSound(ENTITY_ZOMBIE_DEATH, BigClientVersion.v1_9, "entity.zombie.death");
-		addSound(ENTITY_ZOMBIE_HURT, BigClientVersion.v1_9, "entity.zombie.hurt");
-		addSound(ENTITY_ZOMBIE_INFECT, BigClientVersion.v1_9, "entity.zombie.infect");
-		addSound(ENTITY_ZOMBIE_STEP, BigClientVersion.v1_9, "entity.zombie.step");
-		addSound(ENTITY_ZOMBIE_HORSE_AMBIENT, BigClientVersion.v1_9, "entity.zombie_horse.ambient");
-		addSound(ENTITY_ZOMBIE_HORSE_DEATH, BigClientVersion.v1_9, "entity.zombie_horse.death");
-		addSound(ENTITY_ZOMBIE_HORSE_HURT, BigClientVersion.v1_9, "entity.zombie_horse.hurt");
-		addSound(ENTITY_ZOMBIE_PIG_AMBIENT, BigClientVersion.v1_9, "entity.zombie_pig.ambient");
-		addSound(ENTITY_ZOMBIE_PIG_ANGRY, BigClientVersion.v1_9, "entity.zombie_pig.angry");
-		addSound(ENTITY_ZOMBIE_PIG_DEATH, BigClientVersion.v1_9, "entity.zombie_pig.death");
-		addSound(ENTITY_ZOMBIE_PIG_HURT, BigClientVersion.v1_9, "entity.zombie_pig.hurt");
-		addSound(ENTITY_ZOMBIE_VILLAGER_AMBIENT, BigClientVersion.v1_9, "entity.zombie_villager.ambient");
-		addSound(ENTITY_ZOMBIE_VILLAGER_CONVERTED, BigClientVersion.v1_9, "entity.zombie_villager.converted");
-		addSound(ENTITY_ZOMBIE_VILLAGER_CURE, BigClientVersion.v1_9, "entity.zombie_villager.cure");
-		addSound(ENTITY_ZOMBIE_VILLAGER_DEATH, BigClientVersion.v1_9, "entity.zombie_villager.death");
-		addSound(ENTITY_ZOMBIE_VILLAGER_HURT, BigClientVersion.v1_9, "entity.zombie_villager.hurt");
-		addSound(ENTITY_ZOMBIE_VILLAGER_STEP, BigClientVersion.v1_9, "entity.zombie_villager.step");
-		addSound(ITEM_ARMOR_EQUIP_CHAIN, BigClientVersion.v1_9, "item.armor.equip_chain");
-		addSound(ITEM_ARMOR_EQUIP_DIAMOND, BigClientVersion.v1_9, "item.armor.equip_diamond");
-		addSound(ITEM_ARMOR_EQUIP_GENERIC, BigClientVersion.v1_9, "item.armor.equip_generic");
-		addSound(ITEM_ARMOR_EQUIP_GOLD, BigClientVersion.v1_9, "item.armor.equip_gold");
-		addSound(ITEM_ARMOR_EQUIP_IRON, BigClientVersion.v1_9, "item.armor.equip_iron");
-		addSound(ITEM_ARMOR_EQUIP_LEATHER, BigClientVersion.v1_9, "item.armor.equip_leather");
-		addSound(ITEM_BOTTLE_FILL, BigClientVersion.v1_9, "item.bottle.fill");
-		addSound(ITEM_BOTTLE_FILL_DRAGONBREATH, BigClientVersion.v1_9, "item.bottle.fill_dragonbreath");
-		addSound(ITEM_BUCKET_EMPTY, BigClientVersion.v1_9, "item.bucket.empty");
-		addSound(ITEM_BUCKET_EMPTY_LAVA, BigClientVersion.v1_9, "item.bucket.empty_lava");
-		addSound(ITEM_BUCKET_FILL, BigClientVersion.v1_9, "item.bucket.fill");
-		addSound(ITEM_BUCKET_FILL_LAVA, BigClientVersion.v1_9, "item.bucket.fill_lava");
-		addSound(ITEM_CHORUS_FRUIT_TELEPORT, BigClientVersion.v1_9, "item.chorus_fruit.teleport");
-		addSound(ITEM_ELYTRA_FLYING, BigClientVersion.v1_9, "item.elytra.flying");
-		addSound(ITEM_FIRECHARGE_USE, BigClientVersion.v1_9, "item.firecharge.use");
-		addSound(ITEM_FLINTANDSTEEL_USE, BigClientVersion.v1_9, "item.flintandsteel.use");
-		addSound(ITEM_HOE_TILL, BigClientVersion.v1_9, "item.hoe.till");
-		addSound(ITEM_SHIELD_BLOCK, BigClientVersion.v1_9, "item.shield.block");
-		addSound(ITEM_SHIELD_BREAK, BigClientVersion.v1_9, "item.shield.break");
-		addSound(ITEM_SHOVEL_FLATTEN, BigClientVersion.v1_9, "item.shovel.flatten");
-		addSound(MUSIC_CREATIVE, BigClientVersion.v1_9, "music.creative");
-		addSound(MUSIC_CREDITS, BigClientVersion.v1_9, "music.credits");
-		addSound(MUSIC_DRAGON, BigClientVersion.v1_9, "music.dragon");
-		addSound(MUSIC_END, BigClientVersion.v1_9, "music.end");
-		addSound(MUSIC_GAME, BigClientVersion.v1_9, "music.game");
-		addSound(MUSIC_MENU, BigClientVersion.v1_9, "music.menu");
-		addSound(MUSIC_NETHER, BigClientVersion.v1_9, "music.nether");
-		addSound(RECORD_11, BigClientVersion.v1_9, "record.11");
-		addSound(RECORD_13, BigClientVersion.v1_9, "record.13");
-		addSound(RECORD_BLOCKS, BigClientVersion.v1_9, "record.blocks");
-		addSound(RECORD_CAT, BigClientVersion.v1_9, "record.cat");
-		addSound(RECORD_CHIRP, BigClientVersion.v1_9, "record.chirp");
-		addSound(RECORD_FAR, BigClientVersion.v1_9, "record.far");
-		addSound(RECORD_MALL, BigClientVersion.v1_9, "record.mall");
-		addSound(RECORD_MELLOHI, BigClientVersion.v1_9, "record.mellohi");
-		addSound(RECORD_STAL, BigClientVersion.v1_9, "record.stal");
-		addSound(RECORD_STRAD, BigClientVersion.v1_9, "record.strad");
-		addSound(RECORD_WAIT, BigClientVersion.v1_9, "record.wait");
-		addSound(RECORD_WARD, BigClientVersion.v1_9, "record.ward");
-		addSound(UI_BUTTON_CLICK, BigClientVersion.v1_9, "ui.button.click");
-		addSound(WEATHER_RAIN, BigClientVersion.v1_9, "weather.rain");
-		addSound(WEATHER_RAIN_ABOVE, BigClientVersion.v1_9, "weather.rain.above");
 
-		//TODO implement sound for 1.8?
-	}
-	
-	private HashMap<BigClientVersion,String> versions = new HashMap<>();
-	
-	private SoundEffect() {}
-	
-	private static void addSound(SoundEffect effect, BigClientVersion version, String id) {
-		effect.versions.put(version, id);
-	}
-	
-	/**
-	 * Get the Sound-String for the BigClientVersion
-	 * @see BigClientVersion
-	 * 
-	 * @param BigClientVersion version
-	 * @return Sound-String
-	 * */
-	public String getId(BigClientVersion version) {
-		return versions.get(version);
-	}
-	
-	/**
-	 * checks if the Sound is Aviarible for the specified version
-	 * @see BigClientVersion
-	 * 
-	 * @param BigClientVersion version
-	 * @return true if its aviarible
-	 * */
-	public boolean isAvariable(BigClientVersion version) {
-		return versions.containsKey(version);
-	}
+    /**
+     * @author essem
+     */
+
+    AMBIENT_CAVE,
+    BLOCK_ANVIL_BREAK,
+    BLOCK_ANVIL_DESTROY,
+    BLOCK_ANVIL_FALL,
+    BLOCK_ANVIL_HIT,
+    BLOCK_ANVIL_LAND,
+    BLOCK_ANVIL_PLACE,
+    BLOCK_ANVIL_STEP,
+    BLOCK_ANVIL_USE,
+    BLOCK_BREWING_STAND_BREW,
+    BLOCK_CHEST_CLOSE,
+    BLOCK_CHEST_LOCKED,
+    BLOCK_CHEST_OPEN,
+    BLOCK_CHORUS_FLOWER_DEATH,
+    BLOCK_CHORUS_FLOWER_GROW,
+    BLOCK_CLOTH_BREAK,
+    BLOCK_CLOTH_FALL,
+    BLOCK_CLOTH_HIT,
+    BLOCK_CLOTH_PLACE,
+    BLOCK_CLOTH_STEP,
+    BLOCK_COMPARATOR_CLICK,
+    BLOCK_DISPENSER_DISPENSE,
+    BLOCK_DISPENSER_FAIL,
+    BLOCK_DISPENSER_LAUNCH,
+    BLOCK_ENCHANTMENT_TABLE_USE,
+    BLOCK_END_GATEWAY_SPAWN,
+    BLOCK_ENDERCHEST_CLOSE,
+    BLOCK_ENDERCHEST_OPEN,
+    BLOCK_FENCE_GATE_CLOSE,
+    BLOCK_FENCE_GATE_OPEN,
+    BLOCK_FIRE_AMBIENT,
+    BLOCK_FIRE_EXTINGUISH,
+    BLOCK_FURNACE_FIRE_CRACKLE,
+    BLOCK_GLASS_BREAK,
+    BLOCK_GLASS_FALL,
+    BLOCK_GLASS_HIT,
+    BLOCK_GLASS_PLACE,
+    BLOCK_GLASS_STEP,
+    BLOCK_GRASS_BREAK,
+    BLOCK_GRASS_FALL,
+    BLOCK_GRASS_HIT,
+    BLOCK_GRASS_PLACE,
+    BLOCK_GRASS_STEP,
+    BLOCK_GRAVEL_BREAK,
+    BLOCK_GRAVEL_FALL,
+    BLOCK_GRAVEL_HIT,
+    BLOCK_GRAVEL_PLACE,
+    BLOCK_GRAVEL_STEP,
+    BLOCK_IRON_DOOR_CLOSE,
+    BLOCK_IRON_DOOR_OPEN,
+    BLOCK_IRON_TRAPDOOR_CLOSE,
+    BLOCK_IRON_TRAPDOOR_OPEN,
+    BLOCK_LADDER_BREAK,
+    BLOCK_LADDER_FALL,
+    BLOCK_LADDER_HIT,
+    BLOCK_LADDER_PLACE,
+    BLOCK_LADDER_STEP,
+    BLOCK_LAVA_AMBIENT,
+    BLOCK_LAVA_EXTINGUISH,
+    BLOCK_LAVA_POP,
+    BLOCK_LEVER_CLICK,
+    BLOCK_METAL_BREAK,
+    BLOCK_METAL_FALL,
+    BLOCK_METAL_HIT,
+    BLOCK_METAL_PLACE,
+    BLOCK_METAL_PRESSUREPLATE_CLICK_OFF,
+    BLOCK_METAL_PRESSUREPLATE_CLICK_ON,
+    BLOCK_METAL_STEP,
+    BLOCK_NOTE_BASEDRUM,
+    BLOCK_NOTE_BASS,
+    BLOCK_NOTE_HARP,
+    BLOCK_NOTE_HAT,
+    BLOCK_NOTE_PLING,
+    BLOCK_NOTE_SNARE,
+    BLOCK_PISTON_CONTRACT,
+    BLOCK_PISTON_EXTEND,
+    BLOCK_PORTAL_AMBIENT,
+    BLOCK_PORTAL_TRAVEL,
+    BLOCK_PORTAL_TRIGGER,
+    BLOCK_REDSTONE_TORCH_BURNOUT,
+    BLOCK_SAND_BREAK,
+    BLOCK_SAND_FALL,
+    BLOCK_SAND_HIT,
+    BLOCK_SAND_PLACE,
+    BLOCK_SAND_STEP,
+    BLOCK_SLIME_BREAK,
+    BLOCK_SLIME_FALL,
+    BLOCK_SLIME_HIT,
+    BLOCK_SLIME_PLACE,
+    BLOCK_SLIME_STEP,
+    BLOCK_SNOW_BREAK,
+    BLOCK_SNOW_FALL,
+    BLOCK_SNOW_HIT,
+    BLOCK_SNOW_PLACE,
+    BLOCK_SNOW_STEP,
+    BLOCK_STONE_BREAK,
+    BLOCK_STONE_BUTTON_CLICK_OFF,
+    BLOCK_STONE_BUTTON_CLICK_ON,
+    BLOCK_STONE_FALL,
+    BLOCK_STONE_HIT,
+    BLOCK_STONE_PLACE,
+    BLOCK_STONE_PRESSUREPLATE_CLICK_OFF,
+    BLOCK_STONE_PRESSUREPLATE_CLICK_ON,
+    BLOCK_STONE_STEP,
+    BLOCK_TRIPWIRE_ATTACH,
+    BLOCK_TRIPWIRE_CLICK_OFF,
+    BLOCK_TRIPWIRE_CLICK_ON,
+    BLOCK_TRIPWIRE_DETACH,
+    BLOCK_WATER_AMBIENT,
+    BLOCK_WATERLILY_PLACE,
+    BLOCK_WOOD_BREAK,
+    BLOCK_WOOD_BUTTON_CLICK_OFF,
+    BLOCK_WOOD_BUTTON_CLICK_ON,
+    BLOCK_WOOD_FALL,
+    BLOCK_WOOD_HIT,
+    BLOCK_WOOD_PLACE,
+    BLOCK_WOOD_PRESSUREPLATE_CLICK_OFF,
+    BLOCK_WOOD_PRESSUREPLATE_CLICK_ON,
+    BLOCK_WOOD_STEP,
+    BLOCK_WOODEN_DOOR_CLOSE,
+    BLOCK_WOODEN_DOOR_OPEN,
+    BLOCK_WOODEN_TRAPDOOR_CLOSE,
+    BLOCK_WOODEN_TRAPDOOR_OPEN,
+    ENCHANT_THORNS_HIT,
+    ENTITY_ARMORSTAND_BREAK,
+    ENTITY_ARMORSTAND_FALL,
+    ENTITY_ARMORSTAND_HIT,
+    ENTITY_ARMORSTAND_PLACE,
+    ENTITY_ARROW_HIT,
+    ENTITY_ARROW_HIT_PLAYER,
+    ENTITY_ARROW_SHOOT,
+    ENTITY_BAT_AMBIENT,
+    ENTITY_BAT_DEATH,
+    ENTITY_BAT_HURT,
+    ENTITY_BAT_LOOP,
+    ENTITY_BAT_TAKEOFF,
+    ENTITY_BLAZE_AMBIENT,
+    ENTITY_BLAZE_BURN,
+    ENTITY_BLAZE_DEATH,
+    ENTITY_BLAZE_HURT,
+    ENTITY_BLAZE_SHOOT,
+    ENTITY_BOBBER_SPLASH,
+    ENTITY_BOBBER_THROW,
+    ENTITY_CAT_AMBIENT,
+    ENTITY_CAT_DEATH,
+    ENTITY_CAT_HISS,
+    ENTITY_CAT_HURT,
+    ENTITY_CAT_PURR,
+    ENTITY_CAT_PURREOW,
+    ENTITY_CHICKEN_AMBIENT,
+    ENTITY_CHICKEN_DEATH,
+    ENTITY_CHICKEN_EGG,
+    ENTITY_CHICKEN_HURT,
+    ENTITY_CHICKEN_STEP,
+    ENTITY_COW_AMBIENT,
+    ENTITY_COW_DEATH,
+    ENTITY_COW_HURT,
+    ENTITY_COW_MILK,
+    ENTITY_COW_STEP,
+    ENTITY_CREEPER_DEATH,
+    ENTITY_CREEPER_HURT,
+    ENTITY_CREEPER_PRIMED,
+    ENTITY_DONKEY_AMBIENT,
+    ENTITY_DONKEY_ANGRY,
+    ENTITY_DONKEY_CHEST,
+    ENTITY_DONKEY_DEATH,
+    ENTITY_DONKEY_HURT,
+    ENTITY_EGG_THROW,
+    ENTITY_ELDER_GUARDIAN_AMBIENT,
+    ENTITY_ELDER_GUARDIAN_AMBIENT_LAND,
+    ENTITY_ELDER_GUARDIAN_CURSE,
+    ENTITY_ELDER_GUARDIAN_DEATH,
+    ENTITY_ELDER_GUARDIAN_DEATH_LAND,
+    ENTITY_ELDER_GUARDIAN_HURT,
+    ENTITY_ELDER_GUARDIAN_HURT_LAND,
+    ENTITY_ENDERDRAGON_AMBIENT,
+    ENTITY_ENDERDRAGON_DEATH,
+    ENTITY_ENDERDRAGON_FIREBALL_EXPLODE,
+    ENTITY_ENDERDRAGON_FLAP,
+    ENTITY_ENDERDRAGON_GROWL,
+    ENTITY_ENDERDRAGON_HURT,
+    ENTITY_ENDERDRAGON_SHOOT,
+    ENTITY_ENDEREYE_LAUNCH,
+    ENTITY_ENDERMEN_AMBIENT,
+    ENTITY_ENDERMEN_DEATH,
+    ENTITY_ENDERMEN_HURT,
+    ENTITY_ENDERMEN_SCREAM,
+    ENTITY_ENDERMEN_STARE,
+    ENTITY_ENDERMEN_TELEPORT,
+    ENTITY_ENDERMITE_AMBIENT,
+    ENTITY_ENDERMITE_DEATH,
+    ENTITY_ENDERMITE_HURT,
+    ENTITY_ENDERMITE_STEP,
+    ENTITY_ENDERPEARL_THROW,
+    ENTITY_EXPERIENCE_BOTTLE_THROW,
+    ENTITY_EXPERIENCE_ORB_PICKUP,
+    ENTITY_EXPERIENCE_ORB_TOUCH,
+    ENTITY_FIREWORK_BLAST,
+    ENTITY_FIREWORK_BLAST_FAR,
+    ENTITY_FIREWORK_LARGE_BLAST,
+    ENTITY_FIREWORK_LARGE_BLAST_FAR,
+    ENTITY_FIREWORK_LAUNCH,
+    ENTITY_FIREWORK_SHOOT,
+    ENTITY_FIREWORK_TWINKLE,
+    ENTITY_FIREWORK_TWINKLE_FAR,
+    ENTITY_GENERIC_BIG_FALL,
+    ENTITY_GENERIC_BURN,
+    ENTITY_GENERIC_DEATH,
+    ENTITY_GENERIC_DRINK,
+    ENTITY_GENERIC_EAT,
+    ENTITY_GENERIC_EXPLODE,
+    ENTITY_GENERIC_EXTINGUISH_FIRE,
+    ENTITY_GENERIC_HURT,
+    ENTITY_GENERIC_SMALL_FALL,
+    ENTITY_GENERIC_SPLASH,
+    ENTITY_GENERIC_SWIM,
+    ENTITY_GHAST_AMBIENT,
+    ENTITY_GHAST_DEATH,
+    ENTITY_GHAST_HURT,
+    ENTITY_GHAST_SCREAM,
+    ENTITY_GHAST_SHOOT,
+    ENTITY_GHAST_WARN,
+    ENTITY_GUARDIAN_AMBIENT,
+    ENTITY_GUARDIAN_AMBIENT_LAND,
+    ENTITY_GUARDIAN_ATTACK,
+    ENTITY_GUARDIAN_DEATH,
+    ENTITY_GUARDIAN_DEATH_LAND,
+    ENTITY_GUARDIAN_FLOP,
+    ENTITY_GUARDIAN_HURT,
+    ENTITY_GUARDIAN_HURT_LAND,
+    ENTITY_HORSE_AMBIENT,
+    ENTITY_HORSE_ANGRY,
+    ENTITY_HORSE_ARMOR,
+    ENTITY_HORSE_BREATHE,
+    ENTITY_HORSE_DEATH,
+    ENTITY_HORSE_EAT,
+    ENTITY_HORSE_GALLOP,
+    ENTITY_HORSE_HURT,
+    ENTITY_HORSE_JUMP,
+    ENTITY_HORSE_LAND,
+    ENTITY_HORSE_SADDLE,
+    ENTITY_HORSE_STEP,
+    ENTITY_HORSE_STEP_WOOD,
+    ENTITY_HOSTILE_BIG_FALL,
+    ENTITY_HOSTILE_DEATH,
+    ENTITY_HOSTILE_HURT,
+    ENTITY_HOSTILE_SMALL_FALL,
+    ENTITY_HOSTILE_SPLASH,
+    ENTITY_HOSTILE_SWIM,
+    ENTITY_HUSK_AMBIENT,
+    ENTITY_HUSK_DEATH,
+    ENTITY_HUSK_HURT,
+    ENTITY_HUSK_STEP,
+    ENTITY_IRONGOLEM_ATTACK,
+    ENTITY_IRONGOLEM_DEATH,
+    ENTITY_IRONGOLEM_HURT,
+    ENTITY_IRONGOLEM_STEP,
+    ENTITY_ITEM_BREAK,
+    ENTITY_ITEM_PICKUP,
+    ENTITY_ITEMFRAME_ADD_ITEM,
+    ENTITY_ITEMFRAME_BREAK,
+    ENTITY_ITEMFRAME_PLACE,
+    ENTITY_ITEMFRAME_REMOVE_ITEM,
+    ENTITY_ITEMFRAME_ROTATE_ITEM,
+    ENTITY_LEASHKNOT_BREAK,
+    ENTITY_LEASHKNOT_PLACE,
+    ENTITY_LIGHTNING_IMPACT,
+    ENTITY_LIGHTNING_THUNDER,
+    ENTITY_LINGERINGPOTION_THROW,
+    ENTITY_MAGMACUBE_DEATH,
+    ENTITY_MAGMACUBE_HURT,
+    ENTITY_MAGMACUBE_JUMP,
+    ENTITY_MAGMACUBE_SQUISH,
+    ENTITY_MINECART_INSIDE,
+    ENTITY_MINECART_RIDING,
+    ENTITY_MOOSHROOM_SHEAR,
+    ENTITY_MULE_AMBIENT,
+    ENTITY_MULE_DEATH,
+    ENTITY_MULE_HURT,
+    ENTITY_PAINTING_BREAK,
+    ENTITY_PAINTING_PLACE,
+    ENTITY_PIG_AMBIENT,
+    ENTITY_PIG_DEATH,
+    ENTITY_PIG_HURT,
+    ENTITY_PIG_SADDLE,
+    ENTITY_PIG_STEP,
+    ENTITY_PLAYER_ATTACK_CRIT,
+    ENTITY_PLAYER_ATTACK_KNOCKBACK,
+    ENTITY_PLAYER_ATTACK_NODAMAGE,
+    ENTITY_PLAYER_ATTACK_STRONG,
+    ENTITY_PLAYER_ATTACK_SWEEP,
+    ENTITY_PLAYER_ATTACK_WEAK,
+    ENTITY_PLAYER_BIG_FALL,
+    ENTITY_PLAYER_BREATH,
+    ENTITY_PLAYER_BURP,
+    ENTITY_PLAYER_DEATH,
+    ENTITY_PLAYER_HURT,
+    ENTITY_PLAYER_LEVELUP,
+    ENTITY_PLAYER_SMALL_FALL,
+    ENTITY_PLAYER_SPLASH,
+    ENTITY_PLAYER_SWIM,
+    ENTITY_POLAR_BEAR_AMBIENT,
+    ENTITY_POLAR_BEAR_BABY_AMBIENT,
+    ENTITY_POLAR_BEAR_DEATH,
+    ENTITY_POLAR_BEAR_HURT,
+    ENTITY_POLAR_BEAR_STEP,
+    ENTITY_POLAR_BEAR_WARNING,
+    ENTITY_RABBIT_AMBIENT,
+    ENTITY_RABBIT_ATTACK,
+    ENTITY_RABBIT_DEATH,
+    ENTITY_RABBIT_HURT,
+    ENTITY_RABBIT_JUMP,
+    ENTITY_SHEEP_AMBIENT,
+    ENTITY_SHEEP_DEATH,
+    ENTITY_SHEEP_HURT,
+    ENTITY_SHEEP_SHEAR,
+    ENTITY_SHEEP_STEP,
+    ENTITY_SHULKER_AMBIENT,
+    ENTITY_SHULKER_BULLET_HIT,
+    ENTITY_SHULKER_BULLET_HURT,
+    ENTITY_SHULKER_CLOSE,
+    ENTITY_SHULKER_DEATH,
+    ENTITY_SHULKER_HURT,
+    ENTITY_SHULKER_HURT_CLOSED,
+    ENTITY_SHULKER_OPEN,
+    ENTITY_SHULKER_SHOOT,
+    ENTITY_SHULKER_TELEPORT,
+    ENTITY_SILVERFISH_AMBIENT,
+    ENTITY_SILVERFISH_DEATH,
+    ENTITY_SILVERFISH_HURT,
+    ENTITY_SILVERFISH_STEP,
+    ENTITY_SKELETON_AMBIENT,
+    ENTITY_SKELETON_DEATH,
+    ENTITY_SKELETON_HORSE_AMBIENT,
+    ENTITY_SKELETON_HORSE_DEATH,
+    ENTITY_SKELETON_HORSE_HURT,
+    ENTITY_SKELETON_HURT,
+    ENTITY_SKELETON_SHOOT,
+    ENTITY_SKELETON_STEP,
+    ENTITY_SLIME_ATTACK,
+    ENTITY_SLIME_DEATH,
+    ENTITY_SLIME_HURT,
+    ENTITY_SLIME_JUMP,
+    ENTITY_SLIME_SQUISH,
+    ENTITY_SMALL_MAGMACUBE_DEATH,
+    ENTITY_SMALL_MAGMACUBE_HURT,
+    ENTITY_SMALL_MAGMACUBE_SQUISH,
+    ENTITY_SMALL_SLIME_DEATH,
+    ENTITY_SMALL_SLIME_HURT,
+    ENTITY_SMALL_SLIME_JUMP,
+    ENTITY_SMALL_SLIME_SQUISH,
+    ENTITY_SNOWBALL_THROW,
+    ENTITY_SNOWMAN_AMBIENT,
+    ENTITY_SNOWMAN_DEATH,
+    ENTITY_SNOWMAN_HURT,
+    ENTITY_SNOWMAN_SHOOT,
+    ENTITY_SPIDER_AMBIENT,
+    ENTITY_SPIDER_DEATH,
+    ENTITY_SPIDER_HURT,
+    ENTITY_SPIDER_STEP,
+    ENTITY_SPLASH_POTION_BREAK,
+    ENTITY_SPLASH_POTION_THROW,
+    ENTITY_SQUID_AMBIENT,
+    ENTITY_SQUID_DEATH,
+    ENTITY_SQUID_HURT,
+    ENTITY_STRAY_AMBIENT,
+    ENTITY_STRAY_DEATH,
+    ENTITY_STRAY_HURT,
+    ENTITY_STRAY_STEP,
+    ENTITY_TNT_PRIMED,
+    ENTITY_VILLAGER_AMBIENT,
+    ENTITY_VILLAGER_DEATH,
+    ENTITY_VILLAGER_HURT,
+    ENTITY_VILLAGER_NO,
+    ENTITY_VILLAGER_TRADING,
+    ENTITY_VILLAGER_YES,
+    ENTITY_WITCH_AMBIENT,
+    ENTITY_WITCH_DEATH,
+    ENTITY_WITCH_DRINK,
+    ENTITY_WITCH_HURT,
+    ENTITY_WITCH_THROW,
+    ENTITY_WITHER_AMBIENT,
+    ENTITY_WITHER_BREAK_BLOCK,
+    ENTITY_WITHER_DEATH,
+    ENTITY_WITHER_HURT,
+    ENTITY_WITHER_SHOOT,
+    ENTITY_WITHER_SKELETON_AMBIENT,
+    ENTITY_WITHER_SKELETON_DEATH,
+    ENTITY_WITHER_SKELETON_HURT,
+    ENTITY_WITHER_SKELETON_STEP,
+    ENTITY_WITHER_SPAWN,
+    ENTITY_WOLF_AMBIENT,
+    ENTITY_WOLF_DEATH,
+    ENTITY_WOLF_GROWL,
+    ENTITY_WOLF_HOWL,
+    ENTITY_WOLF_HURT,
+    ENTITY_WOLF_PANT,
+    ENTITY_WOLF_SHAKE,
+    ENTITY_WOLF_STEP,
+    ENTITY_WOLF_WHINE,
+    ENTITY_ZOMBIE_AMBIENT,
+    ENTITY_ZOMBIE_ATTACK_DOOR_WOOD,
+    ENTITY_ZOMBIE_ATTACK_IRON_DOOR,
+    ENTITY_ZOMBIE_BREAK_DOOR_WOOD,
+    ENTITY_ZOMBIE_DEATH,
+    ENTITY_ZOMBIE_HORSE_AMBIENT,
+    ENTITY_ZOMBIE_HORSE_DEATH,
+    ENTITY_ZOMBIE_HORSE_HURT,
+    ENTITY_ZOMBIE_HURT,
+    ENTITY_ZOMBIE_INFECT,
+    ENTITY_ZOMBIE_PIG_AMBIENT,
+    ENTITY_ZOMBIE_PIG_ANGRY,
+    ENTITY_ZOMBIE_PIG_DEATH,
+    ENTITY_ZOMBIE_PIG_HURT,
+    ENTITY_ZOMBIE_STEP,
+    ENTITY_ZOMBIE_VILLAGER_AMBIENT,
+    ENTITY_ZOMBIE_VILLAGER_CONVERTED,
+    ENTITY_ZOMBIE_VILLAGER_CURE,
+    ENTITY_ZOMBIE_VILLAGER_DEATH,
+    ENTITY_ZOMBIE_VILLAGER_HURT,
+    ENTITY_ZOMBIE_VILLAGER_STEP,
+    ITEM_ARMOR_EQUIP_CHAIN,
+    ITEM_ARMOR_EQUIP_DIAMOND,
+    ITEM_ARMOR_EQUIP_GENERIC,
+    ITEM_ARMOR_EQUIP_GOLD,
+    ITEM_ARMOR_EQUIP_IRON,
+    ITEM_ARMOR_EQUIP_LEATHER,
+    ITEM_BOTTLE_FILL,
+    ITEM_BOTTLE_FILL_DRAGONBREATH,
+    ITEM_BUCKET_EMPTY,
+    ITEM_BUCKET_EMPTY_LAVA,
+    ITEM_BUCKET_FILL,
+    ITEM_BUCKET_FILL_LAVA,
+    ITEM_CHORUS_FRUIT_TELEPORT,
+    ITEM_ELYTRA_FLYING,
+    ITEM_FIRECHARGE_USE,
+    ITEM_FLINTANDSTEEL_USE,
+    ITEM_HOE_TILL,
+    ITEM_SHIELD_BLOCK,
+    ITEM_SHIELD_BREAK,
+    ITEM_SHOVEL_FLATTEN,
+    MUSIC_CREATIVE,
+    MUSIC_CREDITS,
+    MUSIC_DRAGON,
+    MUSIC_END,
+    MUSIC_GAME,
+    MUSIC_MENU,
+    MUSIC_NETHER,
+    RECORD_11,
+    RECORD_13,
+    RECORD_BLOCKS,
+    RECORD_CAT,
+    RECORD_CHIRP,
+    RECORD_FAR,
+    RECORD_MALL,
+    RECORD_MELLOHI,
+    RECORD_STAL,
+    RECORD_STRAD,
+    RECORD_WAIT,
+    RECORD_WARD,
+    UI_BUTTON_CLICK,
+    WEATHER_RAIN,
+    WEATHER_RAIN_ABOVE;
+    //...
+
+    static {
+        //1.10
+        addSound(AMBIENT_CAVE, BigClientVersion.v1_10, "ambient.cave");
+        addSound(BLOCK_ANVIL_BREAK, BigClientVersion.v1_10, "block.anvil.break");
+        addSound(BLOCK_ANVIL_DESTROY, BigClientVersion.v1_10, "block.anvil.destroy");
+        addSound(BLOCK_ANVIL_FALL, BigClientVersion.v1_10, "block.anvil.fall");
+        addSound(BLOCK_ANVIL_HIT, BigClientVersion.v1_10, "block.anvil.hit");
+        addSound(BLOCK_ANVIL_LAND, BigClientVersion.v1_10, "block.anvil.land");
+        addSound(BLOCK_ANVIL_PLACE, BigClientVersion.v1_10, "block.anvil.place");
+        addSound(BLOCK_ANVIL_STEP, BigClientVersion.v1_10, "block.anvil.step");
+        addSound(BLOCK_ANVIL_USE, BigClientVersion.v1_10, "block.anvil.use");
+        addSound(BLOCK_BREWING_STAND_BREW, BigClientVersion.v1_10, "block.brewing_stand.brew");
+        addSound(BLOCK_CHEST_CLOSE, BigClientVersion.v1_10, "block.chest.close");
+        addSound(BLOCK_CHEST_LOCKED, BigClientVersion.v1_10, "block.chest.locked");
+        addSound(BLOCK_CHEST_OPEN, BigClientVersion.v1_10, "block.chest.open");
+        addSound(BLOCK_CHORUS_FLOWER_DEATH, BigClientVersion.v1_10, "block.chorus_flower.death");
+        addSound(BLOCK_CHORUS_FLOWER_GROW, BigClientVersion.v1_10, "block.chorus_flower.grow");
+        addSound(BLOCK_CLOTH_BREAK, BigClientVersion.v1_10, "block.cloth.break");
+        addSound(BLOCK_CLOTH_FALL, BigClientVersion.v1_10, "block.cloth.fall");
+        addSound(BLOCK_CLOTH_HIT, BigClientVersion.v1_10, "block.cloth.hit");
+        addSound(BLOCK_CLOTH_PLACE, BigClientVersion.v1_10, "block.cloth.place");
+        addSound(BLOCK_CLOTH_STEP, BigClientVersion.v1_10, "block.cloth.step");
+        addSound(BLOCK_COMPARATOR_CLICK, BigClientVersion.v1_10, "block.comparator.click");
+        addSound(BLOCK_DISPENSER_DISPENSE, BigClientVersion.v1_10, "block.dispenser.dispense");
+        addSound(BLOCK_DISPENSER_FAIL, BigClientVersion.v1_10, "block.dispenser.fail");
+        addSound(BLOCK_DISPENSER_LAUNCH, BigClientVersion.v1_10, "block.dispenser.launch");
+        addSound(BLOCK_ENCHANTMENT_TABLE_USE, BigClientVersion.v1_10, "block.enchantment_table.use");
+        addSound(BLOCK_END_GATEWAY_SPAWN, BigClientVersion.v1_10, "block.end_gateway.spawn");
+        addSound(BLOCK_ENDERCHEST_CLOSE, BigClientVersion.v1_10, "block.enderchest.close");
+        addSound(BLOCK_ENDERCHEST_OPEN, BigClientVersion.v1_10, "block.enderchest.open");
+        addSound(BLOCK_FENCE_GATE_CLOSE, BigClientVersion.v1_10, "block.fence_gate.close");
+        addSound(BLOCK_FENCE_GATE_OPEN, BigClientVersion.v1_10, "block.fence_gate.open");
+        addSound(BLOCK_FIRE_AMBIENT, BigClientVersion.v1_10, "block.fire.ambient");
+        addSound(BLOCK_FIRE_EXTINGUISH, BigClientVersion.v1_10, "block.fire.extinguish");
+        addSound(BLOCK_FURNACE_FIRE_CRACKLE, BigClientVersion.v1_10, "block.furnace.fire_crackle");
+        addSound(BLOCK_GLASS_BREAK, BigClientVersion.v1_10, "block.glass.break");
+        addSound(BLOCK_GLASS_FALL, BigClientVersion.v1_10, "block.glass.fall");
+        addSound(BLOCK_GLASS_HIT, BigClientVersion.v1_10, "block.glass.hit");
+        addSound(BLOCK_GLASS_PLACE, BigClientVersion.v1_10, "block.glass.place");
+        addSound(BLOCK_GLASS_STEP, BigClientVersion.v1_10, "block.glass.step");
+        addSound(BLOCK_GRASS_BREAK, BigClientVersion.v1_10, "block.grass.break");
+        addSound(BLOCK_GRASS_FALL, BigClientVersion.v1_10, "block.grass.fall");
+        addSound(BLOCK_GRASS_HIT, BigClientVersion.v1_10, "block.grass.hit");
+        addSound(BLOCK_GRASS_PLACE, BigClientVersion.v1_10, "block.grass.place");
+        addSound(BLOCK_GRASS_STEP, BigClientVersion.v1_10, "block.grass.step");
+        addSound(BLOCK_GRAVEL_BREAK, BigClientVersion.v1_10, "block.gravel.break");
+        addSound(BLOCK_GRAVEL_FALL, BigClientVersion.v1_10, "block.gravel.fall");
+        addSound(BLOCK_GRAVEL_HIT, BigClientVersion.v1_10, "block.gravel.hit");
+        addSound(BLOCK_GRAVEL_PLACE, BigClientVersion.v1_10, "block.gravel.place");
+        addSound(BLOCK_GRAVEL_STEP, BigClientVersion.v1_10, "block.gravel.step");
+        addSound(BLOCK_IRON_DOOR_CLOSE, BigClientVersion.v1_10, "block.iron_door.close");
+        addSound(BLOCK_IRON_DOOR_OPEN, BigClientVersion.v1_10, "block.iron_door.open");
+        addSound(BLOCK_IRON_TRAPDOOR_CLOSE, BigClientVersion.v1_10, "block.iron_trapdoor.close");
+        addSound(BLOCK_IRON_TRAPDOOR_OPEN, BigClientVersion.v1_10, "block.iron_trapdoor.open");
+        addSound(BLOCK_LADDER_BREAK, BigClientVersion.v1_10, "block.ladder.break");
+        addSound(BLOCK_LADDER_FALL, BigClientVersion.v1_10, "block.ladder.fall");
+        addSound(BLOCK_LADDER_HIT, BigClientVersion.v1_10, "block.ladder.hit");
+        addSound(BLOCK_LADDER_PLACE, BigClientVersion.v1_10, "block.ladder.place");
+        addSound(BLOCK_LADDER_STEP, BigClientVersion.v1_10, "block.ladder.step");
+        addSound(BLOCK_LAVA_AMBIENT, BigClientVersion.v1_10, "block.lava.ambient");
+        addSound(BLOCK_LAVA_EXTINGUISH, BigClientVersion.v1_10, "block.lava.extinguish");
+        addSound(BLOCK_LAVA_POP, BigClientVersion.v1_10, "block.lava.pop");
+        addSound(BLOCK_LEVER_CLICK, BigClientVersion.v1_10, "block.lever.click");
+        addSound(BLOCK_METAL_BREAK, BigClientVersion.v1_10, "block.metal.break");
+        addSound(BLOCK_METAL_FALL, BigClientVersion.v1_10, "block.metal.fall");
+        addSound(BLOCK_METAL_HIT, BigClientVersion.v1_10, "block.metal.hit");
+        addSound(BLOCK_METAL_PLACE, BigClientVersion.v1_10, "block.metal.place");
+        addSound(BLOCK_METAL_STEP, BigClientVersion.v1_10, "block.metal.step");
+        addSound(BLOCK_METAL_PRESSUREPLATE_CLICK_OFF, BigClientVersion.v1_10, "block.metal_pressureplate.click_off");
+        addSound(BLOCK_METAL_PRESSUREPLATE_CLICK_ON, BigClientVersion.v1_10, "block.metal_pressureplate.click_on");
+        addSound(BLOCK_NOTE_BASEDRUM, BigClientVersion.v1_10, "block.note.basedrum");
+        addSound(BLOCK_NOTE_BASS, BigClientVersion.v1_10, "block.note.bass");
+        addSound(BLOCK_NOTE_HARP, BigClientVersion.v1_10, "block.note.harp");
+        addSound(BLOCK_NOTE_HAT, BigClientVersion.v1_10, "block.note.hat");
+        addSound(BLOCK_NOTE_PLING, BigClientVersion.v1_10, "block.note.pling");
+        addSound(BLOCK_NOTE_SNARE, BigClientVersion.v1_10, "block.note.snare");
+        addSound(BLOCK_PISTON_CONTRACT, BigClientVersion.v1_10, "block.piston.contract");
+        addSound(BLOCK_PISTON_EXTEND, BigClientVersion.v1_10, "block.piston.extend");
+        addSound(BLOCK_PORTAL_AMBIENT, BigClientVersion.v1_10, "block.portal.ambient");
+        addSound(BLOCK_PORTAL_TRAVEL, BigClientVersion.v1_10, "block.portal.travel");
+        addSound(BLOCK_PORTAL_TRIGGER, BigClientVersion.v1_10, "block.portal.trigger");
+        addSound(BLOCK_REDSTONE_TORCH_BURNOUT, BigClientVersion.v1_10, "block.redstone_torch.burnout");
+        addSound(BLOCK_SAND_BREAK, BigClientVersion.v1_10, "block.sand.break");
+        addSound(BLOCK_SAND_FALL, BigClientVersion.v1_10, "block.sand.fall");
+        addSound(BLOCK_SAND_HIT, BigClientVersion.v1_10, "block.sand.hit");
+        addSound(BLOCK_SAND_PLACE, BigClientVersion.v1_10, "block.sand.place");
+        addSound(BLOCK_SAND_STEP, BigClientVersion.v1_10, "block.sand.step");
+        addSound(BLOCK_SLIME_BREAK, BigClientVersion.v1_10, "block.slime.break");
+        addSound(BLOCK_SLIME_FALL, BigClientVersion.v1_10, "block.slime.fall");
+        addSound(BLOCK_SLIME_HIT, BigClientVersion.v1_10, "block.slime.hit");
+        addSound(BLOCK_SLIME_PLACE, BigClientVersion.v1_10, "block.slime.place");
+        addSound(BLOCK_SLIME_STEP, BigClientVersion.v1_10, "block.slime.step");
+        addSound(BLOCK_SNOW_BREAK, BigClientVersion.v1_10, "block.snow.break");
+        addSound(BLOCK_SNOW_FALL, BigClientVersion.v1_10, "block.snow.fall");
+        addSound(BLOCK_SNOW_HIT, BigClientVersion.v1_10, "block.snow.hit");
+        addSound(BLOCK_SNOW_PLACE, BigClientVersion.v1_10, "block.snow.place");
+        addSound(BLOCK_SNOW_STEP, BigClientVersion.v1_10, "block.snow.step");
+        addSound(BLOCK_STONE_BREAK, BigClientVersion.v1_10, "block.stone.break");
+        addSound(BLOCK_STONE_FALL, BigClientVersion.v1_10, "block.stone.fall");
+        addSound(BLOCK_STONE_HIT, BigClientVersion.v1_10, "block.stone.hit");
+        addSound(BLOCK_STONE_PLACE, BigClientVersion.v1_10, "block.stone.place");
+        addSound(BLOCK_STONE_STEP, BigClientVersion.v1_10, "block.stone.step");
+        addSound(BLOCK_STONE_BUTTON_CLICK_OFF, BigClientVersion.v1_10, "block.stone_button.click_off");
+        addSound(BLOCK_STONE_BUTTON_CLICK_ON, BigClientVersion.v1_10, "block.stone_button.click_on");
+        addSound(BLOCK_STONE_PRESSUREPLATE_CLICK_OFF, BigClientVersion.v1_10, "block.stone_pressureplate.click_off");
+        addSound(BLOCK_STONE_PRESSUREPLATE_CLICK_ON, BigClientVersion.v1_10, "block.stone_pressureplate.click_on");
+        addSound(BLOCK_TRIPWIRE_ATTACH, BigClientVersion.v1_10, "block.tripwire.attach");
+        addSound(BLOCK_TRIPWIRE_CLICK_OFF, BigClientVersion.v1_10, "block.tripwire.click_off");
+        addSound(BLOCK_TRIPWIRE_CLICK_ON, BigClientVersion.v1_10, "block.tripwire.click_on");
+        addSound(BLOCK_TRIPWIRE_DETACH, BigClientVersion.v1_10, "block.tripwire.detach");
+        addSound(BLOCK_WATER_AMBIENT, BigClientVersion.v1_10, "block.water.ambient");
+        addSound(BLOCK_WATERLILY_PLACE, BigClientVersion.v1_10, "block.waterlily.place");
+        addSound(BLOCK_WOOD_BREAK, BigClientVersion.v1_10, "block.wood.break");
+        addSound(BLOCK_WOOD_FALL, BigClientVersion.v1_10, "block.wood.fall");
+        addSound(BLOCK_WOOD_HIT, BigClientVersion.v1_10, "block.wood.hit");
+        addSound(BLOCK_WOOD_PLACE, BigClientVersion.v1_10, "block.wood.place");
+        addSound(BLOCK_WOOD_STEP, BigClientVersion.v1_10, "block.wood.step");
+        addSound(BLOCK_WOOD_BUTTON_CLICK_OFF, BigClientVersion.v1_10, "block.wood_button.click_off");
+        addSound(BLOCK_WOOD_BUTTON_CLICK_ON, BigClientVersion.v1_10, "block.wood_button.click_on");
+        addSound(BLOCK_WOOD_PRESSUREPLATE_CLICK_OFF, BigClientVersion.v1_10, "block.wood_pressureplate.click_off");
+        addSound(BLOCK_WOOD_PRESSUREPLATE_CLICK_ON, BigClientVersion.v1_10, "block.wood_pressureplate.click_on");
+        addSound(BLOCK_WOODEN_DOOR_CLOSE, BigClientVersion.v1_10, "block.wooden_door.close");
+        addSound(BLOCK_WOODEN_DOOR_OPEN, BigClientVersion.v1_10, "block.wooden_door.open");
+        addSound(BLOCK_WOODEN_TRAPDOOR_CLOSE, BigClientVersion.v1_10, "block.wooden_trapdoor.close");
+        addSound(BLOCK_WOODEN_TRAPDOOR_OPEN, BigClientVersion.v1_10, "block.wooden_trapdoor.open");
+        addSound(ENCHANT_THORNS_HIT, BigClientVersion.v1_10, "enchant.thorns.hit");
+        addSound(ENTITY_ARMORSTAND_BREAK, BigClientVersion.v1_10, "entity.armorstand.break");
+        addSound(ENTITY_ARMORSTAND_FALL, BigClientVersion.v1_10, "entity.armorstand.fall");
+        addSound(ENTITY_ARMORSTAND_HIT, BigClientVersion.v1_10, "entity.armorstand.hit");
+        addSound(ENTITY_ARMORSTAND_PLACE, BigClientVersion.v1_10, "entity.armorstand.place");
+        addSound(ENTITY_ARROW_HIT, BigClientVersion.v1_10, "entity.arrow.hit");
+        addSound(ENTITY_ARROW_HIT_PLAYER, BigClientVersion.v1_10, "entity.arrow.hit_player");
+        addSound(ENTITY_ARROW_SHOOT, BigClientVersion.v1_10, "entity.arrow.shoot");
+        addSound(ENTITY_BAT_AMBIENT, BigClientVersion.v1_10, "entity.bat.ambient");
+        addSound(ENTITY_BAT_DEATH, BigClientVersion.v1_10, "entity.bat.death");
+        addSound(ENTITY_BAT_HURT, BigClientVersion.v1_10, "entity.bat.hurt");
+        addSound(ENTITY_BAT_LOOP, BigClientVersion.v1_10, "entity.bat.loop");
+        addSound(ENTITY_BAT_TAKEOFF, BigClientVersion.v1_10, "entity.bat.takeoff");
+        addSound(ENTITY_BLAZE_AMBIENT, BigClientVersion.v1_10, "entity.blaze.ambient");
+        addSound(ENTITY_BLAZE_BURN, BigClientVersion.v1_10, "entity.blaze.burn");
+        addSound(ENTITY_BLAZE_DEATH, BigClientVersion.v1_10, "entity.blaze.death");
+        addSound(ENTITY_BLAZE_HURT, BigClientVersion.v1_10, "entity.blaze.hurt");
+        addSound(ENTITY_BLAZE_SHOOT, BigClientVersion.v1_10, "entity.blaze.shoot");
+        addSound(ENTITY_BOBBER_SPLASH, BigClientVersion.v1_10, "entity.bobber.splash");
+        addSound(ENTITY_BOBBER_THROW, BigClientVersion.v1_10, "entity.bobber.throw");
+        addSound(ENTITY_CAT_AMBIENT, BigClientVersion.v1_10, "entity.cat.ambient");
+        addSound(ENTITY_CAT_DEATH, BigClientVersion.v1_10, "entity.cat.death");
+        addSound(ENTITY_CAT_HISS, BigClientVersion.v1_10, "entity.cat.hiss");
+        addSound(ENTITY_CAT_HURT, BigClientVersion.v1_10, "entity.cat.hurt");
+        addSound(ENTITY_CAT_PURR, BigClientVersion.v1_10, "entity.cat.purr");
+        addSound(ENTITY_CAT_PURREOW, BigClientVersion.v1_10, "entity.cat.purreow");
+        addSound(ENTITY_CHICKEN_AMBIENT, BigClientVersion.v1_10, "entity.chicken.ambient");
+        addSound(ENTITY_CHICKEN_DEATH, BigClientVersion.v1_10, "entity.chicken.death");
+        addSound(ENTITY_CHICKEN_EGG, BigClientVersion.v1_10, "entity.chicken.egg");
+        addSound(ENTITY_CHICKEN_HURT, BigClientVersion.v1_10, "entity.chicken.hurt");
+        addSound(ENTITY_CHICKEN_STEP, BigClientVersion.v1_10, "entity.chicken.step");
+        addSound(ENTITY_COW_AMBIENT, BigClientVersion.v1_10, "entity.cow.ambient");
+        addSound(ENTITY_COW_DEATH, BigClientVersion.v1_10, "entity.cow.death");
+        addSound(ENTITY_COW_HURT, BigClientVersion.v1_10, "entity.cow.hurt");
+        addSound(ENTITY_COW_MILK, BigClientVersion.v1_10, "entity.cow.milk");
+        addSound(ENTITY_COW_STEP, BigClientVersion.v1_10, "entity.cow.step");
+        addSound(ENTITY_CREEPER_DEATH, BigClientVersion.v1_10, "entity.creeper.death");
+        addSound(ENTITY_CREEPER_HURT, BigClientVersion.v1_10, "entity.creeper.hurt");
+        addSound(ENTITY_CREEPER_PRIMED, BigClientVersion.v1_10, "entity.creeper.primed");
+        addSound(ENTITY_DONKEY_AMBIENT, BigClientVersion.v1_10, "entity.donkey.ambient");
+        addSound(ENTITY_DONKEY_ANGRY, BigClientVersion.v1_10, "entity.donkey.angry");
+        addSound(ENTITY_DONKEY_CHEST, BigClientVersion.v1_10, "entity.donkey.chest");
+        addSound(ENTITY_DONKEY_DEATH, BigClientVersion.v1_10, "entity.donkey.death");
+        addSound(ENTITY_DONKEY_HURT, BigClientVersion.v1_10, "entity.donkey.hurt");
+        addSound(ENTITY_EGG_THROW, BigClientVersion.v1_10, "entity.egg.throw");
+        addSound(ENTITY_ELDER_GUARDIAN_AMBIENT, BigClientVersion.v1_10, "entity.elder_guardian.ambient");
+        addSound(ENTITY_ELDER_GUARDIAN_AMBIENT_LAND, BigClientVersion.v1_10, "entity.elder_guardian.ambient_land");
+        addSound(ENTITY_ELDER_GUARDIAN_CURSE, BigClientVersion.v1_10, "entity.elder_guardian.curse");
+        addSound(ENTITY_ELDER_GUARDIAN_DEATH, BigClientVersion.v1_10, "entity.elder_guardian.death");
+        addSound(ENTITY_ELDER_GUARDIAN_DEATH_LAND, BigClientVersion.v1_10, "entity.elder_guardian.death_land");
+        addSound(ENTITY_ELDER_GUARDIAN_HURT, BigClientVersion.v1_10, "entity.elder_guardian.hurt");
+        addSound(ENTITY_ELDER_GUARDIAN_HURT_LAND, BigClientVersion.v1_10, "entity.elder_guardian.hurt_land");
+        addSound(ENTITY_ENDERDRAGON_AMBIENT, BigClientVersion.v1_10, "entity.enderdragon.ambient");
+        addSound(ENTITY_ENDERDRAGON_DEATH, BigClientVersion.v1_10, "entity.enderdragon.death");
+        addSound(ENTITY_ENDERDRAGON_FLAP, BigClientVersion.v1_10, "entity.enderdragon.flap");
+        addSound(ENTITY_ENDERDRAGON_GROWL, BigClientVersion.v1_10, "entity.enderdragon.growl");
+        addSound(ENTITY_ENDERDRAGON_HURT, BigClientVersion.v1_10, "entity.enderdragon.hurt");
+        addSound(ENTITY_ENDERDRAGON_SHOOT, BigClientVersion.v1_10, "entity.enderdragon.shoot");
+        addSound(ENTITY_ENDERDRAGON_FIREBALL_EXPLODE, BigClientVersion.v1_10, "entity.enderdragon_fireball.explode");
+        addSound(ENTITY_ENDEREYE_LAUNCH, BigClientVersion.v1_10, "entity.endereye.launch");
+        addSound(ENTITY_ENDERMEN_AMBIENT, BigClientVersion.v1_10, "entity.endermen.ambient");
+        addSound(ENTITY_ENDERMEN_DEATH, BigClientVersion.v1_10, "entity.endermen.death");
+        addSound(ENTITY_ENDERMEN_HURT, BigClientVersion.v1_10, "entity.endermen.hurt");
+        addSound(ENTITY_ENDERMEN_SCREAM, BigClientVersion.v1_10, "entity.endermen.scream");
+        addSound(ENTITY_ENDERMEN_STARE, BigClientVersion.v1_10, "entity.endermen.stare");
+        addSound(ENTITY_ENDERMEN_TELEPORT, BigClientVersion.v1_10, "entity.endermen.teleport");
+        addSound(ENTITY_ENDERMITE_AMBIENT, BigClientVersion.v1_10, "entity.endermite.ambient");
+        addSound(ENTITY_ENDERMITE_DEATH, BigClientVersion.v1_10, "entity.endermite.death");
+        addSound(ENTITY_ENDERMITE_HURT, BigClientVersion.v1_10, "entity.endermite.hurt");
+        addSound(ENTITY_ENDERMITE_STEP, BigClientVersion.v1_10, "entity.endermite.step");
+        addSound(ENTITY_ENDERPEARL_THROW, BigClientVersion.v1_10, "entity.enderpearl.throw");
+        addSound(ENTITY_EXPERIENCE_BOTTLE_THROW, BigClientVersion.v1_10, "entity.experience_bottle.throw");
+        addSound(ENTITY_EXPERIENCE_ORB_PICKUP, BigClientVersion.v1_10, "entity.experience_orb.pickup");
+        addSound(ENTITY_EXPERIENCE_ORB_TOUCH, BigClientVersion.v1_10, "entity.experience_orb.touch");
+        addSound(ENTITY_FIREWORK_BLAST, BigClientVersion.v1_10, "entity.firework.blast");
+        addSound(ENTITY_FIREWORK_BLAST_FAR, BigClientVersion.v1_10, "entity.firework.blast_far");
+        addSound(ENTITY_FIREWORK_LARGE_BLAST, BigClientVersion.v1_10, "entity.firework.large_blast");
+        addSound(ENTITY_FIREWORK_LARGE_BLAST_FAR, BigClientVersion.v1_10, "entity.firework.large_blast_far");
+        addSound(ENTITY_FIREWORK_LAUNCH, BigClientVersion.v1_10, "entity.firework.launch");
+        addSound(ENTITY_FIREWORK_SHOOT, BigClientVersion.v1_10, "entity.firework.shoot");
+        addSound(ENTITY_FIREWORK_TWINKLE, BigClientVersion.v1_10, "entity.firework.twinkle");
+        addSound(ENTITY_FIREWORK_TWINKLE_FAR, BigClientVersion.v1_10, "entity.firework.twinkle_far");
+        addSound(ENTITY_GENERIC_BIG_FALL, BigClientVersion.v1_10, "entity.generic.big_fall");
+        addSound(ENTITY_GENERIC_BURN, BigClientVersion.v1_10, "entity.generic.burn");
+        addSound(ENTITY_GENERIC_DEATH, BigClientVersion.v1_10, "entity.generic.death");
+        addSound(ENTITY_GENERIC_DRINK, BigClientVersion.v1_10, "entity.generic.drink");
+        addSound(ENTITY_GENERIC_EAT, BigClientVersion.v1_10, "entity.generic.eat");
+        addSound(ENTITY_GENERIC_EXPLODE, BigClientVersion.v1_10, "entity.generic.explode");
+        addSound(ENTITY_GENERIC_EXTINGUISH_FIRE, BigClientVersion.v1_10, "entity.generic.extinguish_fire");
+        addSound(ENTITY_GENERIC_HURT, BigClientVersion.v1_10, "entity.generic.hurt");
+        addSound(ENTITY_GENERIC_SMALL_FALL, BigClientVersion.v1_10, "entity.generic.small_fall");
+        addSound(ENTITY_GENERIC_SPLASH, BigClientVersion.v1_10, "entity.generic.splash");
+        addSound(ENTITY_GENERIC_SWIM, BigClientVersion.v1_10, "entity.generic.swim");
+        addSound(ENTITY_GHAST_AMBIENT, BigClientVersion.v1_10, "entity.ghast.ambient");
+        addSound(ENTITY_GHAST_DEATH, BigClientVersion.v1_10, "entity.ghast.death");
+        addSound(ENTITY_GHAST_HURT, BigClientVersion.v1_10, "entity.ghast.hurt");
+        addSound(ENTITY_GHAST_SCREAM, BigClientVersion.v1_10, "entity.ghast.scream");
+        addSound(ENTITY_GHAST_SHOOT, BigClientVersion.v1_10, "entity.ghast.shoot");
+        addSound(ENTITY_GHAST_WARN, BigClientVersion.v1_10, "entity.ghast.warn");
+        addSound(ENTITY_GUARDIAN_AMBIENT, BigClientVersion.v1_10, "entity.guardian.ambient");
+        addSound(ENTITY_GUARDIAN_AMBIENT_LAND, BigClientVersion.v1_10, "entity.guardian.ambient_land");
+        addSound(ENTITY_GUARDIAN_ATTACK, BigClientVersion.v1_10, "entity.guardian.attack");
+        addSound(ENTITY_GUARDIAN_DEATH, BigClientVersion.v1_10, "entity.guardian.death");
+        addSound(ENTITY_GUARDIAN_DEATH_LAND, BigClientVersion.v1_10, "entity.guardian.death_land");
+        addSound(ENTITY_GUARDIAN_FLOP, BigClientVersion.v1_10, "entity.guardian.flop");
+        addSound(ENTITY_GUARDIAN_HURT, BigClientVersion.v1_10, "entity.guardian.hurt");
+        addSound(ENTITY_GUARDIAN_HURT_LAND, BigClientVersion.v1_10, "entity.guardian.hurt_land");
+        addSound(ENTITY_HORSE_AMBIENT, BigClientVersion.v1_10, "entity.horse.ambient");
+        addSound(ENTITY_HORSE_ANGRY, BigClientVersion.v1_10, "entity.horse.angry");
+        addSound(ENTITY_HORSE_ARMOR, BigClientVersion.v1_10, "entity.horse.armor");
+        addSound(ENTITY_HORSE_BREATHE, BigClientVersion.v1_10, "entity.horse.breathe");
+        addSound(ENTITY_HORSE_DEATH, BigClientVersion.v1_10, "entity.horse.death");
+        addSound(ENTITY_HORSE_EAT, BigClientVersion.v1_10, "entity.horse.eat");
+        addSound(ENTITY_HORSE_GALLOP, BigClientVersion.v1_10, "entity.horse.gallop");
+        addSound(ENTITY_HORSE_HURT, BigClientVersion.v1_10, "entity.horse.hurt");
+        addSound(ENTITY_HORSE_JUMP, BigClientVersion.v1_10, "entity.horse.jump");
+        addSound(ENTITY_HORSE_LAND, BigClientVersion.v1_10, "entity.horse.land");
+        addSound(ENTITY_HORSE_SADDLE, BigClientVersion.v1_10, "entity.horse.saddle");
+        addSound(ENTITY_HORSE_STEP, BigClientVersion.v1_10, "entity.horse.step");
+        addSound(ENTITY_HORSE_STEP_WOOD, BigClientVersion.v1_10, "entity.horse.step_wood");
+        addSound(ENTITY_HOSTILE_BIG_FALL, BigClientVersion.v1_10, "entity.hostile.big_fall");
+        addSound(ENTITY_HOSTILE_DEATH, BigClientVersion.v1_10, "entity.hostile.death");
+        addSound(ENTITY_HOSTILE_HURT, BigClientVersion.v1_10, "entity.hostile.hurt");
+        addSound(ENTITY_HOSTILE_SMALL_FALL, BigClientVersion.v1_10, "entity.hostile.small_fall");
+        addSound(ENTITY_HOSTILE_SPLASH, BigClientVersion.v1_10, "entity.hostile.splash");
+        addSound(ENTITY_HOSTILE_SWIM, BigClientVersion.v1_10, "entity.hostile.swim");
+        addSound(ENTITY_HUSK_AMBIENT, BigClientVersion.v1_10, "entity.husk.ambient");
+        addSound(ENTITY_HUSK_DEATH, BigClientVersion.v1_10, "entity.husk.death");
+        addSound(ENTITY_HUSK_HURT, BigClientVersion.v1_10, "entity.husk.hurt");
+        addSound(ENTITY_HUSK_STEP, BigClientVersion.v1_10, "entity.husk.step");
+        addSound(ENTITY_IRONGOLEM_ATTACK, BigClientVersion.v1_10, "entity.irongolem.attack");
+        addSound(ENTITY_IRONGOLEM_DEATH, BigClientVersion.v1_10, "entity.irongolem.death");
+        addSound(ENTITY_IRONGOLEM_HURT, BigClientVersion.v1_10, "entity.irongolem.hurt");
+        addSound(ENTITY_IRONGOLEM_STEP, BigClientVersion.v1_10, "entity.irongolem.step");
+        addSound(ENTITY_ITEM_BREAK, BigClientVersion.v1_10, "entity.item.break");
+        addSound(ENTITY_ITEM_PICKUP, BigClientVersion.v1_10, "entity.item.pickup");
+        addSound(ENTITY_ITEMFRAME_ADD_ITEM, BigClientVersion.v1_10, "entity.itemframe.add_item");
+        addSound(ENTITY_ITEMFRAME_BREAK, BigClientVersion.v1_10, "entity.itemframe.break");
+        addSound(ENTITY_ITEMFRAME_PLACE, BigClientVersion.v1_10, "entity.itemframe.place");
+        addSound(ENTITY_ITEMFRAME_REMOVE_ITEM, BigClientVersion.v1_10, "entity.itemframe.remove_item");
+        addSound(ENTITY_ITEMFRAME_ROTATE_ITEM, BigClientVersion.v1_10, "entity.itemframe.rotate_item");
+        addSound(ENTITY_LEASHKNOT_BREAK, BigClientVersion.v1_10, "entity.leashknot.break");
+        addSound(ENTITY_LEASHKNOT_PLACE, BigClientVersion.v1_10, "entity.leashknot.place");
+        addSound(ENTITY_LIGHTNING_IMPACT, BigClientVersion.v1_10, "entity.lightning.impact");
+        addSound(ENTITY_LIGHTNING_THUNDER, BigClientVersion.v1_10, "entity.lightning.thunder");
+        addSound(ENTITY_LINGERINGPOTION_THROW, BigClientVersion.v1_10, "entity.lingeringpotion.throw");
+        addSound(ENTITY_MAGMACUBE_DEATH, BigClientVersion.v1_10, "entity.magmacube.death");
+        addSound(ENTITY_MAGMACUBE_HURT, BigClientVersion.v1_10, "entity.magmacube.hurt");
+        addSound(ENTITY_MAGMACUBE_JUMP, BigClientVersion.v1_10, "entity.magmacube.jump");
+        addSound(ENTITY_MAGMACUBE_SQUISH, BigClientVersion.v1_10, "entity.magmacube.squish");
+        addSound(ENTITY_MINECART_INSIDE, BigClientVersion.v1_10, "entity.minecart.inside");
+        addSound(ENTITY_MINECART_RIDING, BigClientVersion.v1_10, "entity.minecart.riding");
+        addSound(ENTITY_MOOSHROOM_SHEAR, BigClientVersion.v1_10, "entity.mooshroom.shear");
+        addSound(ENTITY_MULE_AMBIENT, BigClientVersion.v1_10, "entity.mule.ambient");
+        addSound(ENTITY_MULE_DEATH, BigClientVersion.v1_10, "entity.mule.death");
+        addSound(ENTITY_MULE_HURT, BigClientVersion.v1_10, "entity.mule.hurt");
+        addSound(ENTITY_PAINTING_BREAK, BigClientVersion.v1_10, "entity.painting.break");
+        addSound(ENTITY_PAINTING_PLACE, BigClientVersion.v1_10, "entity.painting.place");
+        addSound(ENTITY_PIG_AMBIENT, BigClientVersion.v1_10, "entity.pig.ambient");
+        addSound(ENTITY_PIG_DEATH, BigClientVersion.v1_10, "entity.pig.death");
+        addSound(ENTITY_PIG_HURT, BigClientVersion.v1_10, "entity.pig.hurt");
+        addSound(ENTITY_PIG_SADDLE, BigClientVersion.v1_10, "entity.pig.saddle");
+        addSound(ENTITY_PIG_STEP, BigClientVersion.v1_10, "entity.pig.step");
+        addSound(ENTITY_PLAYER_ATTACK_CRIT, BigClientVersion.v1_10, "entity.player.attack.crit");
+        addSound(ENTITY_PLAYER_ATTACK_KNOCKBACK, BigClientVersion.v1_10, "entity.player.attack.knockback");
+        addSound(ENTITY_PLAYER_ATTACK_NODAMAGE, BigClientVersion.v1_10, "entity.player.attack.nodamage");
+        addSound(ENTITY_PLAYER_ATTACK_STRONG, BigClientVersion.v1_10, "entity.player.attack.strong");
+        addSound(ENTITY_PLAYER_ATTACK_SWEEP, BigClientVersion.v1_10, "entity.player.attack.sweep");
+        addSound(ENTITY_PLAYER_ATTACK_WEAK, BigClientVersion.v1_10, "entity.player.attack.weak");
+        addSound(ENTITY_PLAYER_BIG_FALL, BigClientVersion.v1_10, "entity.player.big_fall");
+        addSound(ENTITY_PLAYER_BREATH, BigClientVersion.v1_10, "entity.player.breath");
+        addSound(ENTITY_PLAYER_BURP, BigClientVersion.v1_10, "entity.player.burp");
+        addSound(ENTITY_PLAYER_DEATH, BigClientVersion.v1_10, "entity.player.death");
+        addSound(ENTITY_PLAYER_HURT, BigClientVersion.v1_10, "entity.player.hurt");
+        addSound(ENTITY_PLAYER_LEVELUP, BigClientVersion.v1_10, "entity.player.levelup");
+        addSound(ENTITY_PLAYER_SMALL_FALL, BigClientVersion.v1_10, "entity.player.small_fall");
+        addSound(ENTITY_PLAYER_SPLASH, BigClientVersion.v1_10, "entity.player.splash");
+        addSound(ENTITY_PLAYER_SWIM, BigClientVersion.v1_10, "entity.player.swim");
+        addSound(ENTITY_POLAR_BEAR_AMBIENT, BigClientVersion.v1_10, "entity.polar_bear.ambient");
+        addSound(ENTITY_POLAR_BEAR_BABY_AMBIENT, BigClientVersion.v1_10, "entity.polar_bear.baby_ambient");
+        addSound(ENTITY_POLAR_BEAR_DEATH, BigClientVersion.v1_10, "entity.polar_bear.death");
+        addSound(ENTITY_POLAR_BEAR_HURT, BigClientVersion.v1_10, "entity.polar_bear.hurt");
+        addSound(ENTITY_POLAR_BEAR_STEP, BigClientVersion.v1_10, "entity.polar_bear.step");
+        addSound(ENTITY_POLAR_BEAR_WARNING, BigClientVersion.v1_10, "entity.polar_bear.warning");
+        addSound(ENTITY_RABBIT_AMBIENT, BigClientVersion.v1_10, "entity.rabbit.ambient");
+        addSound(ENTITY_RABBIT_ATTACK, BigClientVersion.v1_10, "entity.rabbit.attack");
+        addSound(ENTITY_RABBIT_DEATH, BigClientVersion.v1_10, "entity.rabbit.death");
+        addSound(ENTITY_RABBIT_HURT, BigClientVersion.v1_10, "entity.rabbit.hurt");
+        addSound(ENTITY_RABBIT_JUMP, BigClientVersion.v1_10, "entity.rabbit.jump");
+        addSound(ENTITY_SHEEP_AMBIENT, BigClientVersion.v1_10, "entity.sheep.ambient");
+        addSound(ENTITY_SHEEP_DEATH, BigClientVersion.v1_10, "entity.sheep.death");
+        addSound(ENTITY_SHEEP_HURT, BigClientVersion.v1_10, "entity.sheep.hurt");
+        addSound(ENTITY_SHEEP_SHEAR, BigClientVersion.v1_10, "entity.sheep.shear");
+        addSound(ENTITY_SHEEP_STEP, BigClientVersion.v1_10, "entity.sheep.step");
+        addSound(ENTITY_SHULKER_AMBIENT, BigClientVersion.v1_10, "entity.shulker.ambient");
+        addSound(ENTITY_SHULKER_CLOSE, BigClientVersion.v1_10, "entity.shulker.close");
+        addSound(ENTITY_SHULKER_DEATH, BigClientVersion.v1_10, "entity.shulker.death");
+        addSound(ENTITY_SHULKER_HURT, BigClientVersion.v1_10, "entity.shulker.hurt");
+        addSound(ENTITY_SHULKER_HURT_CLOSED, BigClientVersion.v1_10, "entity.shulker.hurt_closed");
+        addSound(ENTITY_SHULKER_OPEN, BigClientVersion.v1_10, "entity.shulker.open");
+        addSound(ENTITY_SHULKER_SHOOT, BigClientVersion.v1_10, "entity.shulker.shoot");
+        addSound(ENTITY_SHULKER_TELEPORT, BigClientVersion.v1_10, "entity.shulker.teleport");
+        addSound(ENTITY_SHULKER_BULLET_HIT, BigClientVersion.v1_10, "entity.shulker_bullet.hit");
+        addSound(ENTITY_SHULKER_BULLET_HURT, BigClientVersion.v1_10, "entity.shulker_bullet.hurt");
+        addSound(ENTITY_SILVERFISH_AMBIENT, BigClientVersion.v1_10, "entity.silverfish.ambient");
+        addSound(ENTITY_SILVERFISH_DEATH, BigClientVersion.v1_10, "entity.silverfish.death");
+        addSound(ENTITY_SILVERFISH_HURT, BigClientVersion.v1_10, "entity.silverfish.hurt");
+        addSound(ENTITY_SILVERFISH_STEP, BigClientVersion.v1_10, "entity.silverfish.step");
+        addSound(ENTITY_SKELETON_AMBIENT, BigClientVersion.v1_10, "entity.skeleton.ambient");
+        addSound(ENTITY_SKELETON_DEATH, BigClientVersion.v1_10, "entity.skeleton.death");
+        addSound(ENTITY_SKELETON_HURT, BigClientVersion.v1_10, "entity.skeleton.hurt");
+        addSound(ENTITY_SKELETON_SHOOT, BigClientVersion.v1_10, "entity.skeleton.shoot");
+        addSound(ENTITY_SKELETON_STEP, BigClientVersion.v1_10, "entity.skeleton.step");
+        addSound(ENTITY_SKELETON_HORSE_AMBIENT, BigClientVersion.v1_10, "entity.skeleton_horse.ambient");
+        addSound(ENTITY_SKELETON_HORSE_DEATH, BigClientVersion.v1_10, "entity.skeleton_horse.death");
+        addSound(ENTITY_SKELETON_HORSE_HURT, BigClientVersion.v1_10, "entity.skeleton_horse.hurt");
+        addSound(ENTITY_SLIME_ATTACK, BigClientVersion.v1_10, "entity.slime.attack");
+        addSound(ENTITY_SLIME_DEATH, BigClientVersion.v1_10, "entity.slime.death");
+        addSound(ENTITY_SLIME_HURT, BigClientVersion.v1_10, "entity.slime.hurt");
+        addSound(ENTITY_SLIME_JUMP, BigClientVersion.v1_10, "entity.slime.jump");
+        addSound(ENTITY_SLIME_SQUISH, BigClientVersion.v1_10, "entity.slime.squish");
+        addSound(ENTITY_SMALL_MAGMACUBE_DEATH, BigClientVersion.v1_10, "entity.small_magmacube.death");
+        addSound(ENTITY_SMALL_MAGMACUBE_HURT, BigClientVersion.v1_10, "entity.small_magmacube.hurt");
+        addSound(ENTITY_SMALL_MAGMACUBE_SQUISH, BigClientVersion.v1_10, "entity.small_magmacube.squish");
+        addSound(ENTITY_SMALL_SLIME_DEATH, BigClientVersion.v1_10, "entity.small_slime.death");
+        addSound(ENTITY_SMALL_SLIME_HURT, BigClientVersion.v1_10, "entity.small_slime.hurt");
+        addSound(ENTITY_SMALL_SLIME_JUMP, BigClientVersion.v1_10, "entity.small_slime.jump");
+        addSound(ENTITY_SMALL_SLIME_SQUISH, BigClientVersion.v1_10, "entity.small_slime.squish");
+        addSound(ENTITY_SNOWBALL_THROW, BigClientVersion.v1_10, "entity.snowball.throw");
+        addSound(ENTITY_SNOWMAN_AMBIENT, BigClientVersion.v1_10, "entity.snowman.ambient");
+        addSound(ENTITY_SNOWMAN_DEATH, BigClientVersion.v1_10, "entity.snowman.death");
+        addSound(ENTITY_SNOWMAN_HURT, BigClientVersion.v1_10, "entity.snowman.hurt");
+        addSound(ENTITY_SNOWMAN_SHOOT, BigClientVersion.v1_10, "entity.snowman.shoot");
+        addSound(ENTITY_SPIDER_AMBIENT, BigClientVersion.v1_10, "entity.spider.ambient");
+        addSound(ENTITY_SPIDER_DEATH, BigClientVersion.v1_10, "entity.spider.death");
+        addSound(ENTITY_SPIDER_HURT, BigClientVersion.v1_10, "entity.spider.hurt");
+        addSound(ENTITY_SPIDER_STEP, BigClientVersion.v1_10, "entity.spider.step");
+        addSound(ENTITY_SPLASH_POTION_BREAK, BigClientVersion.v1_10, "entity.splash_potion.break");
+        addSound(ENTITY_SPLASH_POTION_THROW, BigClientVersion.v1_10, "entity.splash_potion.throw");
+        addSound(ENTITY_SQUID_AMBIENT, BigClientVersion.v1_10, "entity.squid.ambient");
+        addSound(ENTITY_SQUID_DEATH, BigClientVersion.v1_10, "entity.squid.death");
+        addSound(ENTITY_SQUID_HURT, BigClientVersion.v1_10, "entity.squid.hurt");
+        addSound(ENTITY_STRAY_AMBIENT, BigClientVersion.v1_10, "entity.stray.ambient");
+        addSound(ENTITY_STRAY_DEATH, BigClientVersion.v1_10, "entity.stray.death");
+        addSound(ENTITY_STRAY_HURT, BigClientVersion.v1_10, "entity.stray.hurt");
+        addSound(ENTITY_STRAY_STEP, BigClientVersion.v1_10, "entity.stray.step");
+        addSound(ENTITY_TNT_PRIMED, BigClientVersion.v1_10, "entity.tnt.primed");
+        addSound(ENTITY_VILLAGER_AMBIENT, BigClientVersion.v1_10, "entity.villager.ambient");
+        addSound(ENTITY_VILLAGER_DEATH, BigClientVersion.v1_10, "entity.villager.death");
+        addSound(ENTITY_VILLAGER_HURT, BigClientVersion.v1_10, "entity.villager.hurt");
+        addSound(ENTITY_VILLAGER_NO, BigClientVersion.v1_10, "entity.villager.no");
+        addSound(ENTITY_VILLAGER_TRADING, BigClientVersion.v1_10, "entity.villager.trading");
+        addSound(ENTITY_VILLAGER_YES, BigClientVersion.v1_10, "entity.villager.yes");
+        addSound(ENTITY_WITCH_AMBIENT, BigClientVersion.v1_10, "entity.witch.ambient");
+        addSound(ENTITY_WITCH_DEATH, BigClientVersion.v1_10, "entity.witch.death");
+        addSound(ENTITY_WITCH_DRINK, BigClientVersion.v1_10, "entity.witch.drink");
+        addSound(ENTITY_WITCH_HURT, BigClientVersion.v1_10, "entity.witch.hurt");
+        addSound(ENTITY_WITCH_THROW, BigClientVersion.v1_10, "entity.witch.throw");
+        addSound(ENTITY_WITHER_AMBIENT, BigClientVersion.v1_10, "entity.wither.ambient");
+        addSound(ENTITY_WITHER_BREAK_BLOCK, BigClientVersion.v1_10, "entity.wither.break_block");
+        addSound(ENTITY_WITHER_DEATH, BigClientVersion.v1_10, "entity.wither.death");
+        addSound(ENTITY_WITHER_HURT, BigClientVersion.v1_10, "entity.wither.hurt");
+        addSound(ENTITY_WITHER_SHOOT, BigClientVersion.v1_10, "entity.wither.shoot");
+        addSound(ENTITY_WITHER_SPAWN, BigClientVersion.v1_10, "entity.wither.spawn");
+        addSound(ENTITY_WITHER_SKELETON_AMBIENT, BigClientVersion.v1_10, "entity.wither_skeleton.ambient");
+        addSound(ENTITY_WITHER_SKELETON_DEATH, BigClientVersion.v1_10, "entity.wither_skeleton.death");
+        addSound(ENTITY_WITHER_SKELETON_HURT, BigClientVersion.v1_10, "entity.wither_skeleton.hurt");
+        addSound(ENTITY_WITHER_SKELETON_STEP, BigClientVersion.v1_10, "entity.wither_skeleton.step");
+        addSound(ENTITY_WOLF_AMBIENT, BigClientVersion.v1_10, "entity.wolf.ambient");
+        addSound(ENTITY_WOLF_DEATH, BigClientVersion.v1_10, "entity.wolf.death");
+        addSound(ENTITY_WOLF_GROWL, BigClientVersion.v1_10, "entity.wolf.growl");
+        addSound(ENTITY_WOLF_HOWL, BigClientVersion.v1_10, "entity.wolf.howl");
+        addSound(ENTITY_WOLF_HURT, BigClientVersion.v1_10, "entity.wolf.hurt");
+        addSound(ENTITY_WOLF_PANT, BigClientVersion.v1_10, "entity.wolf.pant");
+        addSound(ENTITY_WOLF_SHAKE, BigClientVersion.v1_10, "entity.wolf.shake");
+        addSound(ENTITY_WOLF_STEP, BigClientVersion.v1_10, "entity.wolf.step");
+        addSound(ENTITY_WOLF_WHINE, BigClientVersion.v1_10, "entity.wolf.whine");
+        addSound(ENTITY_ZOMBIE_AMBIENT, BigClientVersion.v1_10, "entity.zombie.ambient");
+        addSound(ENTITY_ZOMBIE_ATTACK_DOOR_WOOD, BigClientVersion.v1_10, "entity.zombie.attack_door_wood");
+        addSound(ENTITY_ZOMBIE_ATTACK_IRON_DOOR, BigClientVersion.v1_10, "entity.zombie.attack_iron_door");
+        addSound(ENTITY_ZOMBIE_BREAK_DOOR_WOOD, BigClientVersion.v1_10, "entity.zombie.break_door_wood");
+        addSound(ENTITY_ZOMBIE_DEATH, BigClientVersion.v1_10, "entity.zombie.death");
+        addSound(ENTITY_ZOMBIE_HURT, BigClientVersion.v1_10, "entity.zombie.hurt");
+        addSound(ENTITY_ZOMBIE_INFECT, BigClientVersion.v1_10, "entity.zombie.infect");
+        addSound(ENTITY_ZOMBIE_STEP, BigClientVersion.v1_10, "entity.zombie.step");
+        addSound(ENTITY_ZOMBIE_HORSE_AMBIENT, BigClientVersion.v1_10, "entity.zombie_horse.ambient");
+        addSound(ENTITY_ZOMBIE_HORSE_DEATH, BigClientVersion.v1_10, "entity.zombie_horse.death");
+        addSound(ENTITY_ZOMBIE_HORSE_HURT, BigClientVersion.v1_10, "entity.zombie_horse.hurt");
+        addSound(ENTITY_ZOMBIE_PIG_AMBIENT, BigClientVersion.v1_10, "entity.zombie_pig.ambient");
+        addSound(ENTITY_ZOMBIE_PIG_ANGRY, BigClientVersion.v1_10, "entity.zombie_pig.angry");
+        addSound(ENTITY_ZOMBIE_PIG_DEATH, BigClientVersion.v1_10, "entity.zombie_pig.death");
+        addSound(ENTITY_ZOMBIE_PIG_HURT, BigClientVersion.v1_10, "entity.zombie_pig.hurt");
+        addSound(ENTITY_ZOMBIE_VILLAGER_AMBIENT, BigClientVersion.v1_10, "entity.zombie_villager.ambient");
+        addSound(ENTITY_ZOMBIE_VILLAGER_CONVERTED, BigClientVersion.v1_10, "entity.zombie_villager.converted");
+        addSound(ENTITY_ZOMBIE_VILLAGER_CURE, BigClientVersion.v1_10, "entity.zombie_villager.cure");
+        addSound(ENTITY_ZOMBIE_VILLAGER_DEATH, BigClientVersion.v1_10, "entity.zombie_villager.death");
+        addSound(ENTITY_ZOMBIE_VILLAGER_HURT, BigClientVersion.v1_10, "entity.zombie_villager.hurt");
+        addSound(ENTITY_ZOMBIE_VILLAGER_STEP, BigClientVersion.v1_10, "entity.zombie_villager.step");
+        addSound(ITEM_ARMOR_EQUIP_CHAIN, BigClientVersion.v1_10, "item.armor.equip_chain");
+        addSound(ITEM_ARMOR_EQUIP_DIAMOND, BigClientVersion.v1_10, "item.armor.equip_diamond");
+        addSound(ITEM_ARMOR_EQUIP_GENERIC, BigClientVersion.v1_10, "item.armor.equip_generic");
+        addSound(ITEM_ARMOR_EQUIP_GOLD, BigClientVersion.v1_10, "item.armor.equip_gold");
+        addSound(ITEM_ARMOR_EQUIP_IRON, BigClientVersion.v1_10, "item.armor.equip_iron");
+        addSound(ITEM_ARMOR_EQUIP_LEATHER, BigClientVersion.v1_10, "item.armor.equip_leather");
+        addSound(ITEM_BOTTLE_FILL, BigClientVersion.v1_10, "item.bottle.fill");
+        addSound(ITEM_BOTTLE_FILL_DRAGONBREATH, BigClientVersion.v1_10, "item.bottle.fill_dragonbreath");
+        addSound(ITEM_BUCKET_EMPTY, BigClientVersion.v1_10, "item.bucket.empty");
+        addSound(ITEM_BUCKET_EMPTY_LAVA, BigClientVersion.v1_10, "item.bucket.empty_lava");
+        addSound(ITEM_BUCKET_FILL, BigClientVersion.v1_10, "item.bucket.fill");
+        addSound(ITEM_BUCKET_FILL_LAVA, BigClientVersion.v1_10, "item.bucket.fill_lava");
+        addSound(ITEM_CHORUS_FRUIT_TELEPORT, BigClientVersion.v1_10, "item.chorus_fruit.teleport");
+        addSound(ITEM_ELYTRA_FLYING, BigClientVersion.v1_10, "item.elytra.flying");
+        addSound(ITEM_FIRECHARGE_USE, BigClientVersion.v1_10, "item.firecharge.use");
+        addSound(ITEM_FLINTANDSTEEL_USE, BigClientVersion.v1_10, "item.flintandsteel.use");
+        addSound(ITEM_HOE_TILL, BigClientVersion.v1_10, "item.hoe.till");
+        addSound(ITEM_SHIELD_BLOCK, BigClientVersion.v1_10, "item.shield.block");
+        addSound(ITEM_SHIELD_BREAK, BigClientVersion.v1_10, "item.shield.break");
+        addSound(ITEM_SHOVEL_FLATTEN, BigClientVersion.v1_10, "item.shovel.flatten");
+        addSound(MUSIC_CREATIVE, BigClientVersion.v1_10, "music.creative");
+        addSound(MUSIC_CREDITS, BigClientVersion.v1_10, "music.credits");
+        addSound(MUSIC_DRAGON, BigClientVersion.v1_10, "music.dragon");
+        addSound(MUSIC_END, BigClientVersion.v1_10, "music.end");
+        addSound(MUSIC_GAME, BigClientVersion.v1_10, "music.game");
+        addSound(MUSIC_MENU, BigClientVersion.v1_10, "music.menu");
+        addSound(MUSIC_NETHER, BigClientVersion.v1_10, "music.nether");
+        addSound(RECORD_11, BigClientVersion.v1_10, "record.11");
+        addSound(RECORD_13, BigClientVersion.v1_10, "record.13");
+        addSound(RECORD_BLOCKS, BigClientVersion.v1_10, "record.blocks");
+        addSound(RECORD_CAT, BigClientVersion.v1_10, "record.cat");
+        addSound(RECORD_CHIRP, BigClientVersion.v1_10, "record.chirp");
+        addSound(RECORD_FAR, BigClientVersion.v1_10, "record.far");
+        addSound(RECORD_MALL, BigClientVersion.v1_10, "record.mall");
+        addSound(RECORD_MELLOHI, BigClientVersion.v1_10, "record.mellohi");
+        addSound(RECORD_STAL, BigClientVersion.v1_10, "record.stal");
+        addSound(RECORD_STRAD, BigClientVersion.v1_10, "record.strad");
+        addSound(RECORD_WAIT, BigClientVersion.v1_10, "record.wait");
+        addSound(RECORD_WARD, BigClientVersion.v1_10, "record.ward");
+        addSound(UI_BUTTON_CLICK, BigClientVersion.v1_10, "ui.button.click");
+        addSound(WEATHER_RAIN, BigClientVersion.v1_10, "weather.rain");
+        addSound(WEATHER_RAIN_ABOVE, BigClientVersion.v1_10, "weather.rain.above");
+
+        //1.9
+        addSound(AMBIENT_CAVE, BigClientVersion.v1_9, "ambient.cave");
+        addSound(BLOCK_ANVIL_BREAK, BigClientVersion.v1_9, "block.anvil.break");
+        addSound(BLOCK_ANVIL_DESTROY, BigClientVersion.v1_9, "block.anvil.destroy");
+        addSound(BLOCK_ANVIL_FALL, BigClientVersion.v1_9, "block.anvil.fall");
+        addSound(BLOCK_ANVIL_HIT, BigClientVersion.v1_9, "block.anvil.hit");
+        addSound(BLOCK_ANVIL_LAND, BigClientVersion.v1_9, "block.anvil.land");
+        addSound(BLOCK_ANVIL_PLACE, BigClientVersion.v1_9, "block.anvil.place");
+        addSound(BLOCK_ANVIL_STEP, BigClientVersion.v1_9, "block.anvil.step");
+        addSound(BLOCK_ANVIL_USE, BigClientVersion.v1_9, "block.anvil.use");
+        addSound(BLOCK_BREWING_STAND_BREW, BigClientVersion.v1_9, "block.brewing_stand.brew");
+        addSound(BLOCK_CHEST_CLOSE, BigClientVersion.v1_9, "block.chest.close");
+        addSound(BLOCK_CHEST_LOCKED, BigClientVersion.v1_9, "block.chest.locked");
+        addSound(BLOCK_CHEST_OPEN, BigClientVersion.v1_9, "block.chest.open");
+        addSound(BLOCK_CHORUS_FLOWER_DEATH, BigClientVersion.v1_9, "block.chorus_flower.death");
+        addSound(BLOCK_CHORUS_FLOWER_GROW, BigClientVersion.v1_9, "block.chorus_flower.grow");
+        addSound(BLOCK_CLOTH_BREAK, BigClientVersion.v1_9, "block.cloth.break");
+        addSound(BLOCK_CLOTH_FALL, BigClientVersion.v1_9, "block.cloth.fall");
+        addSound(BLOCK_CLOTH_HIT, BigClientVersion.v1_9, "block.cloth.hit");
+        addSound(BLOCK_CLOTH_PLACE, BigClientVersion.v1_9, "block.cloth.place");
+        addSound(BLOCK_CLOTH_STEP, BigClientVersion.v1_9, "block.cloth.step");
+        addSound(BLOCK_COMPARATOR_CLICK, BigClientVersion.v1_9, "block.comparator.click");
+        addSound(BLOCK_DISPENSER_DISPENSE, BigClientVersion.v1_9, "block.dispenser.dispense");
+        addSound(BLOCK_DISPENSER_FAIL, BigClientVersion.v1_9, "block.dispenser.fail");
+        addSound(BLOCK_DISPENSER_LAUNCH, BigClientVersion.v1_9, "block.dispenser.launch");
+        addSound(BLOCK_END_GATEWAY_SPAWN, BigClientVersion.v1_9, "block.end_gateway.spawn");
+        addSound(BLOCK_ENDERCHEST_CLOSE, BigClientVersion.v1_9, "block.enderchest.close");
+        addSound(BLOCK_ENDERCHEST_OPEN, BigClientVersion.v1_9, "block.enderchest.open");
+        addSound(BLOCK_FENCE_GATE_CLOSE, BigClientVersion.v1_9, "block.fence_gate.close");
+        addSound(BLOCK_FENCE_GATE_OPEN, BigClientVersion.v1_9, "block.fence_gate.open");
+        addSound(BLOCK_FIRE_AMBIENT, BigClientVersion.v1_9, "block.fire.ambient");
+        addSound(BLOCK_FIRE_EXTINGUISH, BigClientVersion.v1_9, "block.fire.extinguish");
+        addSound(BLOCK_FURNACE_FIRE_CRACKLE, BigClientVersion.v1_9, "block.furnace.fire_crackle");
+        addSound(BLOCK_GLASS_BREAK, BigClientVersion.v1_9, "block.glass.break");
+        addSound(BLOCK_GLASS_FALL, BigClientVersion.v1_9, "block.glass.fall");
+        addSound(BLOCK_GLASS_HIT, BigClientVersion.v1_9, "block.glass.hit");
+        addSound(BLOCK_GLASS_PLACE, BigClientVersion.v1_9, "block.glass.place");
+        addSound(BLOCK_GLASS_STEP, BigClientVersion.v1_9, "block.glass.step");
+        addSound(BLOCK_GRASS_BREAK, BigClientVersion.v1_9, "block.grass.break");
+        addSound(BLOCK_GRASS_FALL, BigClientVersion.v1_9, "block.grass.fall");
+        addSound(BLOCK_GRASS_HIT, BigClientVersion.v1_9, "block.grass.hit");
+        addSound(BLOCK_GRASS_PLACE, BigClientVersion.v1_9, "block.grass.place");
+        addSound(BLOCK_GRASS_STEP, BigClientVersion.v1_9, "block.grass.step");
+        addSound(BLOCK_GRAVEL_BREAK, BigClientVersion.v1_9, "block.gravel.break");
+        addSound(BLOCK_GRAVEL_FALL, BigClientVersion.v1_9, "block.gravel.fall");
+        addSound(BLOCK_GRAVEL_HIT, BigClientVersion.v1_9, "block.gravel.hit");
+        addSound(BLOCK_GRAVEL_PLACE, BigClientVersion.v1_9, "block.gravel.place");
+        addSound(BLOCK_GRAVEL_STEP, BigClientVersion.v1_9, "block.gravel.step");
+        addSound(BLOCK_IRON_DOOR_CLOSE, BigClientVersion.v1_9, "block.iron_door.close");
+        addSound(BLOCK_IRON_DOOR_OPEN, BigClientVersion.v1_9, "block.iron_door.open");
+        addSound(BLOCK_IRON_TRAPDOOR_CLOSE, BigClientVersion.v1_9, "block.iron_trapdoor.close");
+        addSound(BLOCK_IRON_TRAPDOOR_OPEN, BigClientVersion.v1_9, "block.iron_trapdoor.open");
+        addSound(BLOCK_LADDER_BREAK, BigClientVersion.v1_9, "block.ladder.break");
+        addSound(BLOCK_LADDER_FALL, BigClientVersion.v1_9, "block.ladder.fall");
+        addSound(BLOCK_LADDER_HIT, BigClientVersion.v1_9, "block.ladder.hit");
+        addSound(BLOCK_LADDER_PLACE, BigClientVersion.v1_9, "block.ladder.place");
+        addSound(BLOCK_LADDER_STEP, BigClientVersion.v1_9, "block.ladder.step");
+        addSound(BLOCK_LAVA_AMBIENT, BigClientVersion.v1_9, "block.lava.ambient");
+        addSound(BLOCK_LAVA_EXTINGUISH, BigClientVersion.v1_9, "block.lava.extinguish");
+        addSound(BLOCK_LAVA_POP, BigClientVersion.v1_9, "block.lava.pop");
+        addSound(BLOCK_LEVER_CLICK, BigClientVersion.v1_9, "block.lever.click");
+        addSound(BLOCK_METAL_BREAK, BigClientVersion.v1_9, "block.metal.break");
+        addSound(BLOCK_METAL_FALL, BigClientVersion.v1_9, "block.metal.fall");
+        addSound(BLOCK_METAL_HIT, BigClientVersion.v1_9, "block.metal.hit");
+        addSound(BLOCK_METAL_PLACE, BigClientVersion.v1_9, "block.metal.place");
+        addSound(BLOCK_METAL_STEP, BigClientVersion.v1_9, "block.metal.step");
+        addSound(BLOCK_METAL_PRESSUREPLATE_CLICK_OFF, BigClientVersion.v1_9, "block.metal_pressureplate.click_off");
+        addSound(BLOCK_METAL_PRESSUREPLATE_CLICK_ON, BigClientVersion.v1_9, "block.metal_pressureplate.click_on");
+        addSound(BLOCK_NOTE_BASEDRUM, BigClientVersion.v1_9, "block.note.basedrum");
+        addSound(BLOCK_NOTE_BASS, BigClientVersion.v1_9, "block.note.bass");
+        addSound(BLOCK_NOTE_HARP, BigClientVersion.v1_9, "block.note.harp");
+        addSound(BLOCK_NOTE_HAT, BigClientVersion.v1_9, "block.note.hat");
+        addSound(BLOCK_NOTE_PLING, BigClientVersion.v1_9, "block.note.pling");
+        addSound(BLOCK_NOTE_SNARE, BigClientVersion.v1_9, "block.note.snare");
+        addSound(BLOCK_PISTON_CONTRACT, BigClientVersion.v1_9, "block.piston.contract");
+        addSound(BLOCK_PISTON_EXTEND, BigClientVersion.v1_9, "block.piston.extend");
+        addSound(BLOCK_PORTAL_AMBIENT, BigClientVersion.v1_9, "block.portal.ambient");
+        addSound(BLOCK_PORTAL_TRAVEL, BigClientVersion.v1_9, "block.portal.travel");
+        addSound(BLOCK_PORTAL_TRIGGER, BigClientVersion.v1_9, "block.portal.trigger");
+        addSound(BLOCK_REDSTONE_TORCH_BURNOUT, BigClientVersion.v1_9, "block.redstone_torch.burnout");
+        addSound(BLOCK_SAND_BREAK, BigClientVersion.v1_9, "block.sand.break");
+        addSound(BLOCK_SAND_FALL, BigClientVersion.v1_9, "block.sand.fall");
+        addSound(BLOCK_SAND_HIT, BigClientVersion.v1_9, "block.sand.hit");
+        addSound(BLOCK_SAND_PLACE, BigClientVersion.v1_9, "block.sand.place");
+        addSound(BLOCK_SAND_STEP, BigClientVersion.v1_9, "block.sand.step");
+        addSound(BLOCK_SLIME_BREAK, BigClientVersion.v1_9, "block.slime.break");
+        addSound(BLOCK_SLIME_FALL, BigClientVersion.v1_9, "block.slime.fall");
+        addSound(BLOCK_SLIME_HIT, BigClientVersion.v1_9, "block.slime.hit");
+        addSound(BLOCK_SLIME_PLACE, BigClientVersion.v1_9, "block.slime.place");
+        addSound(BLOCK_SLIME_STEP, BigClientVersion.v1_9, "block.slime.step");
+        addSound(BLOCK_SNOW_BREAK, BigClientVersion.v1_9, "block.snow.break");
+        addSound(BLOCK_SNOW_FALL, BigClientVersion.v1_9, "block.snow.fall");
+        addSound(BLOCK_SNOW_HIT, BigClientVersion.v1_9, "block.snow.hit");
+        addSound(BLOCK_SNOW_PLACE, BigClientVersion.v1_9, "block.snow.place");
+        addSound(BLOCK_SNOW_STEP, BigClientVersion.v1_9, "block.snow.step");
+        addSound(BLOCK_STONE_BREAK, BigClientVersion.v1_9, "block.stone.break");
+        addSound(BLOCK_STONE_FALL, BigClientVersion.v1_9, "block.stone.fall");
+        addSound(BLOCK_STONE_HIT, BigClientVersion.v1_9, "block.stone.hit");
+        addSound(BLOCK_STONE_PLACE, BigClientVersion.v1_9, "block.stone.place");
+        addSound(BLOCK_STONE_STEP, BigClientVersion.v1_9, "block.stone.step");
+        addSound(BLOCK_STONE_BUTTON_CLICK_OFF, BigClientVersion.v1_9, "block.stone_button.click_off");
+        addSound(BLOCK_STONE_BUTTON_CLICK_ON, BigClientVersion.v1_9, "block.stone_button.click_on");
+        addSound(BLOCK_STONE_PRESSUREPLATE_CLICK_OFF, BigClientVersion.v1_9, "block.stone_pressureplate.click_off");
+        addSound(BLOCK_STONE_PRESSUREPLATE_CLICK_ON, BigClientVersion.v1_9, "block.stone_pressureplate.click_on");
+        addSound(BLOCK_TRIPWIRE_ATTACH, BigClientVersion.v1_9, "block.tripwire.attach");
+        addSound(BLOCK_TRIPWIRE_CLICK_OFF, BigClientVersion.v1_9, "block.tripwire.click_off");
+        addSound(BLOCK_TRIPWIRE_CLICK_ON, BigClientVersion.v1_9, "block.tripwire.click_on");
+        addSound(BLOCK_TRIPWIRE_DETACH, BigClientVersion.v1_9, "block.tripwire.detach");
+        addSound(BLOCK_WATER_AMBIENT, BigClientVersion.v1_9, "block.water.ambient");
+        addSound(BLOCK_WATERLILY_PLACE, BigClientVersion.v1_9, "block.waterlily.place");
+        addSound(BLOCK_WOOD_BREAK, BigClientVersion.v1_9, "block.wood.break");
+        addSound(BLOCK_WOOD_FALL, BigClientVersion.v1_9, "block.wood.fall");
+        addSound(BLOCK_WOOD_HIT, BigClientVersion.v1_9, "block.wood.hit");
+        addSound(BLOCK_WOOD_PLACE, BigClientVersion.v1_9, "block.wood.place");
+        addSound(BLOCK_WOOD_STEP, BigClientVersion.v1_9, "block.wood.step");
+        addSound(BLOCK_WOOD_BUTTON_CLICK_OFF, BigClientVersion.v1_9, "block.wood_button.click_off");
+        addSound(BLOCK_WOOD_BUTTON_CLICK_ON, BigClientVersion.v1_9, "block.wood_button.click_on");
+        addSound(BLOCK_WOOD_PRESSUREPLATE_CLICK_OFF, BigClientVersion.v1_9, "block.wood_pressureplate.click_off");
+        addSound(BLOCK_WOOD_PRESSUREPLATE_CLICK_ON, BigClientVersion.v1_9, "block.wood_pressureplate.click_on");
+        addSound(BLOCK_WOODEN_DOOR_CLOSE, BigClientVersion.v1_9, "block.wooden_door.close");
+        addSound(BLOCK_WOODEN_DOOR_OPEN, BigClientVersion.v1_9, "block.wooden_door.open");
+        addSound(BLOCK_WOODEN_TRAPDOOR_CLOSE, BigClientVersion.v1_9, "block.wooden_trapdoor.close");
+        addSound(BLOCK_WOODEN_TRAPDOOR_OPEN, BigClientVersion.v1_9, "block.wooden_trapdoor.open");
+        addSound(ENCHANT_THORNS_HIT, BigClientVersion.v1_9, "enchant.thorns.hit");
+        addSound(ENTITY_ARMORSTAND_BREAK, BigClientVersion.v1_9, "entity.armorstand.break");
+        addSound(ENTITY_ARMORSTAND_FALL, BigClientVersion.v1_9, "entity.armorstand.fall");
+        addSound(ENTITY_ARMORSTAND_HIT, BigClientVersion.v1_9, "entity.armorstand.hit");
+        addSound(ENTITY_ARMORSTAND_PLACE, BigClientVersion.v1_9, "entity.armorstand.place");
+        addSound(ENTITY_ARROW_HIT, BigClientVersion.v1_9, "entity.arrow.hit");
+        addSound(ENTITY_ARROW_HIT_PLAYER, BigClientVersion.v1_9, "entity.arrow.hit_player");
+        addSound(ENTITY_ARROW_SHOOT, BigClientVersion.v1_9, "entity.arrow.shoot");
+        addSound(ENTITY_BAT_AMBIENT, BigClientVersion.v1_9, "entity.bat.ambient");
+        addSound(ENTITY_BAT_DEATH, BigClientVersion.v1_9, "entity.bat.death");
+        addSound(ENTITY_BAT_HURT, BigClientVersion.v1_9, "entity.bat.hurt");
+        addSound(ENTITY_BAT_LOOP, BigClientVersion.v1_9, "entity.bat.loop");
+        addSound(ENTITY_BAT_TAKEOFF, BigClientVersion.v1_9, "entity.bat.takeoff");
+        addSound(ENTITY_BLAZE_AMBIENT, BigClientVersion.v1_9, "entity.blaze.ambient");
+        addSound(ENTITY_BLAZE_BURN, BigClientVersion.v1_9, "entity.blaze.burn");
+        addSound(ENTITY_BLAZE_DEATH, BigClientVersion.v1_9, "entity.blaze.death");
+        addSound(ENTITY_BLAZE_HURT, BigClientVersion.v1_9, "entity.blaze.hurt");
+        addSound(ENTITY_BLAZE_SHOOT, BigClientVersion.v1_9, "entity.blaze.shoot");
+        addSound(ENTITY_BOBBER_SPLASH, BigClientVersion.v1_9, "entity.bobber.splash");
+        addSound(ENTITY_BOBBER_THROW, BigClientVersion.v1_9, "entity.bobber.throw");
+        addSound(ENTITY_CAT_AMBIENT, BigClientVersion.v1_9, "entity.cat.ambient");
+        addSound(ENTITY_CAT_DEATH, BigClientVersion.v1_9, "entity.cat.death");
+        addSound(ENTITY_CAT_HISS, BigClientVersion.v1_9, "entity.cat.hiss");
+        addSound(ENTITY_CAT_HURT, BigClientVersion.v1_9, "entity.cat.hurt");
+        addSound(ENTITY_CAT_PURR, BigClientVersion.v1_9, "entity.cat.purr");
+        addSound(ENTITY_CAT_PURREOW, BigClientVersion.v1_9, "entity.cat.purreow");
+        addSound(ENTITY_CHICKEN_AMBIENT, BigClientVersion.v1_9, "entity.chicken.ambient");
+        addSound(ENTITY_CHICKEN_DEATH, BigClientVersion.v1_9, "entity.chicken.death");
+        addSound(ENTITY_CHICKEN_EGG, BigClientVersion.v1_9, "entity.chicken.egg");
+        addSound(ENTITY_CHICKEN_HURT, BigClientVersion.v1_9, "entity.chicken.hurt");
+        addSound(ENTITY_CHICKEN_STEP, BigClientVersion.v1_9, "entity.chicken.step");
+        addSound(ENTITY_COW_AMBIENT, BigClientVersion.v1_9, "entity.cow.ambient");
+        addSound(ENTITY_COW_DEATH, BigClientVersion.v1_9, "entity.cow.death");
+        addSound(ENTITY_COW_HURT, BigClientVersion.v1_9, "entity.cow.hurt");
+        addSound(ENTITY_COW_MILK, BigClientVersion.v1_9, "entity.cow.milk");
+        addSound(ENTITY_COW_STEP, BigClientVersion.v1_9, "entity.cow.step");
+        addSound(ENTITY_CREEPER_DEATH, BigClientVersion.v1_9, "entity.creeper.death");
+        addSound(ENTITY_CREEPER_HURT, BigClientVersion.v1_9, "entity.creeper.hurt");
+        addSound(ENTITY_CREEPER_PRIMED, BigClientVersion.v1_9, "entity.creeper.primed");
+        addSound(ENTITY_DONKEY_AMBIENT, BigClientVersion.v1_9, "entity.donkey.ambient");
+        addSound(ENTITY_DONKEY_ANGRY, BigClientVersion.v1_9, "entity.donkey.angry");
+        addSound(ENTITY_DONKEY_CHEST, BigClientVersion.v1_9, "entity.donkey.chest");
+        addSound(ENTITY_DONKEY_DEATH, BigClientVersion.v1_9, "entity.donkey.death");
+        addSound(ENTITY_DONKEY_HURT, BigClientVersion.v1_9, "entity.donkey.hurt");
+        addSound(ENTITY_EGG_THROW, BigClientVersion.v1_9, "entity.egg.throw");
+        addSound(ENTITY_ELDER_GUARDIAN_AMBIENT, BigClientVersion.v1_9, "entity.elder_guardian.ambient");
+        addSound(ENTITY_ELDER_GUARDIAN_AMBIENT_LAND, BigClientVersion.v1_9, "entity.elder_guardian.ambient_land");
+        addSound(ENTITY_ELDER_GUARDIAN_CURSE, BigClientVersion.v1_9, "entity.elder_guardian.curse");
+        addSound(ENTITY_ELDER_GUARDIAN_DEATH, BigClientVersion.v1_9, "entity.elder_guardian.death");
+        addSound(ENTITY_ELDER_GUARDIAN_DEATH_LAND, BigClientVersion.v1_9, "entity.elder_guardian.death_land");
+        addSound(ENTITY_ELDER_GUARDIAN_HURT, BigClientVersion.v1_9, "entity.elder_guardian.hurt");
+        addSound(ENTITY_ELDER_GUARDIAN_HURT_LAND, BigClientVersion.v1_9, "entity.elder_guardian.hurt_land");
+        addSound(ENTITY_ENDERDRAGON_AMBIENT, BigClientVersion.v1_9, "entity.enderdragon.ambient");
+        addSound(ENTITY_ENDERDRAGON_DEATH, BigClientVersion.v1_9, "entity.enderdragon.death");
+        addSound(ENTITY_ENDERDRAGON_FLAP, BigClientVersion.v1_9, "entity.enderdragon.flap");
+        addSound(ENTITY_ENDERDRAGON_GROWL, BigClientVersion.v1_9, "entity.enderdragon.growl");
+        addSound(ENTITY_ENDERDRAGON_HURT, BigClientVersion.v1_9, "entity.enderdragon.hurt");
+        addSound(ENTITY_ENDERDRAGON_SHOOT, BigClientVersion.v1_9, "entity.enderdragon.shoot");
+        addSound(ENTITY_ENDERDRAGON_FIREBALL_EXPLODE, BigClientVersion.v1_9, "entity.enderdragon_fireball.explode");
+        addSound(ENTITY_ENDEREYE_LAUNCH, BigClientVersion.v1_9, "entity.endereye.launch");
+        addSound(ENTITY_ENDERMEN_AMBIENT, BigClientVersion.v1_9, "entity.endermen.ambient");
+        addSound(ENTITY_ENDERMEN_DEATH, BigClientVersion.v1_9, "entity.endermen.death");
+        addSound(ENTITY_ENDERMEN_HURT, BigClientVersion.v1_9, "entity.endermen.hurt");
+        addSound(ENTITY_ENDERMEN_SCREAM, BigClientVersion.v1_9, "entity.endermen.scream");
+        addSound(ENTITY_ENDERMEN_STARE, BigClientVersion.v1_9, "entity.endermen.stare");
+        addSound(ENTITY_ENDERMEN_TELEPORT, BigClientVersion.v1_9, "entity.endermen.teleport");
+        addSound(ENTITY_ENDERMITE_AMBIENT, BigClientVersion.v1_9, "entity.endermite.ambient");
+        addSound(ENTITY_ENDERMITE_DEATH, BigClientVersion.v1_9, "entity.endermite.death");
+        addSound(ENTITY_ENDERMITE_HURT, BigClientVersion.v1_9, "entity.endermite.hurt");
+        addSound(ENTITY_ENDERMITE_STEP, BigClientVersion.v1_9, "entity.endermite.step");
+        addSound(ENTITY_ENDERPEARL_THROW, BigClientVersion.v1_9, "entity.enderpearl.throw");
+        addSound(ENTITY_EXPERIENCE_BOTTLE_THROW, BigClientVersion.v1_9, "entity.experience_bottle.throw");
+        addSound(ENTITY_EXPERIENCE_ORB_PICKUP, BigClientVersion.v1_9, "entity.experience_orb.pickup");
+        addSound(ENTITY_EXPERIENCE_ORB_TOUCH, BigClientVersion.v1_9, "entity.experience_orb.touch");
+        addSound(ENTITY_FIREWORK_BLAST, BigClientVersion.v1_9, "entity.firework.blast");
+        addSound(ENTITY_FIREWORK_BLAST_FAR, BigClientVersion.v1_9, "entity.firework.blast_far");
+        addSound(ENTITY_FIREWORK_LARGE_BLAST, BigClientVersion.v1_9, "entity.firework.large_blast");
+        addSound(ENTITY_FIREWORK_LARGE_BLAST_FAR, BigClientVersion.v1_9, "entity.firework.large_blast_far");
+        addSound(ENTITY_FIREWORK_LAUNCH, BigClientVersion.v1_9, "entity.firework.launch");
+        addSound(ENTITY_FIREWORK_SHOOT, BigClientVersion.v1_9, "entity.firework.shoot");
+        addSound(ENTITY_FIREWORK_TWINKLE, BigClientVersion.v1_9, "entity.firework.twinkle");
+        addSound(ENTITY_FIREWORK_TWINKLE_FAR, BigClientVersion.v1_9, "entity.firework.twinkle_far");
+        addSound(ENTITY_GENERIC_BIG_FALL, BigClientVersion.v1_9, "entity.generic.big_fall");
+        addSound(ENTITY_GENERIC_BURN, BigClientVersion.v1_9, "entity.generic.burn");
+        addSound(ENTITY_GENERIC_DEATH, BigClientVersion.v1_9, "entity.generic.death");
+        addSound(ENTITY_GENERIC_DRINK, BigClientVersion.v1_9, "entity.generic.drink");
+        addSound(ENTITY_GENERIC_EAT, BigClientVersion.v1_9, "entity.generic.eat");
+        addSound(ENTITY_GENERIC_EXPLODE, BigClientVersion.v1_9, "entity.generic.explode");
+        addSound(ENTITY_GENERIC_EXTINGUISH_FIRE, BigClientVersion.v1_9, "entity.generic.extinguish_fire");
+        addSound(ENTITY_GENERIC_HURT, BigClientVersion.v1_9, "entity.generic.hurt");
+        addSound(ENTITY_GENERIC_SMALL_FALL, BigClientVersion.v1_9, "entity.generic.small_fall");
+        addSound(ENTITY_GENERIC_SPLASH, BigClientVersion.v1_9, "entity.generic.splash");
+        addSound(ENTITY_GENERIC_SWIM, BigClientVersion.v1_9, "entity.generic.swim");
+        addSound(ENTITY_GHAST_AMBIENT, BigClientVersion.v1_9, "entity.ghast.ambient");
+        addSound(ENTITY_GHAST_DEATH, BigClientVersion.v1_9, "entity.ghast.death");
+        addSound(ENTITY_GHAST_HURT, BigClientVersion.v1_9, "entity.ghast.hurt");
+        addSound(ENTITY_GHAST_SCREAM, BigClientVersion.v1_9, "entity.ghast.scream");
+        addSound(ENTITY_GHAST_SHOOT, BigClientVersion.v1_9, "entity.ghast.shoot");
+        addSound(ENTITY_GHAST_WARN, BigClientVersion.v1_9, "entity.ghast.warn");
+        addSound(ENTITY_GUARDIAN_AMBIENT, BigClientVersion.v1_9, "entity.guardian.ambient");
+        addSound(ENTITY_GUARDIAN_AMBIENT_LAND, BigClientVersion.v1_9, "entity.guardian.ambient_land");
+        addSound(ENTITY_GUARDIAN_ATTACK, BigClientVersion.v1_9, "entity.guardian.attack");
+        addSound(ENTITY_GUARDIAN_DEATH, BigClientVersion.v1_9, "entity.guardian.death");
+        addSound(ENTITY_GUARDIAN_DEATH_LAND, BigClientVersion.v1_9, "entity.guardian.death_land");
+        addSound(ENTITY_GUARDIAN_FLOP, BigClientVersion.v1_9, "entity.guardian.flop");
+        addSound(ENTITY_GUARDIAN_HURT, BigClientVersion.v1_9, "entity.guardian.hurt");
+        addSound(ENTITY_GUARDIAN_HURT_LAND, BigClientVersion.v1_9, "entity.guardian.hurt_land");
+        addSound(ENTITY_HORSE_AMBIENT, BigClientVersion.v1_9, "entity.horse.ambient");
+        addSound(ENTITY_HORSE_ANGRY, BigClientVersion.v1_9, "entity.horse.angry");
+        addSound(ENTITY_HORSE_ARMOR, BigClientVersion.v1_9, "entity.horse.armor");
+        addSound(ENTITY_HORSE_BREATHE, BigClientVersion.v1_9, "entity.horse.breathe");
+        addSound(ENTITY_HORSE_DEATH, BigClientVersion.v1_9, "entity.horse.death");
+        addSound(ENTITY_HORSE_EAT, BigClientVersion.v1_9, "entity.horse.eat");
+        addSound(ENTITY_HORSE_GALLOP, BigClientVersion.v1_9, "entity.horse.gallop");
+        addSound(ENTITY_HORSE_HURT, BigClientVersion.v1_9, "entity.horse.hurt");
+        addSound(ENTITY_HORSE_JUMP, BigClientVersion.v1_9, "entity.horse.jump");
+        addSound(ENTITY_HORSE_LAND, BigClientVersion.v1_9, "entity.horse.land");
+        addSound(ENTITY_HORSE_SADDLE, BigClientVersion.v1_9, "entity.horse.saddle");
+        addSound(ENTITY_HORSE_STEP, BigClientVersion.v1_9, "entity.horse.step");
+        addSound(ENTITY_HORSE_STEP_WOOD, BigClientVersion.v1_9, "entity.horse.step_wood");
+        addSound(ENTITY_HOSTILE_BIG_FALL, BigClientVersion.v1_9, "entity.hostile.big_fall");
+        addSound(ENTITY_HOSTILE_DEATH, BigClientVersion.v1_9, "entity.hostile.death");
+        addSound(ENTITY_HOSTILE_HURT, BigClientVersion.v1_9, "entity.hostile.hurt");
+        addSound(ENTITY_HOSTILE_SMALL_FALL, BigClientVersion.v1_9, "entity.hostile.small_fall");
+        addSound(ENTITY_HOSTILE_SPLASH, BigClientVersion.v1_9, "entity.hostile.splash");
+        addSound(ENTITY_HOSTILE_SWIM, BigClientVersion.v1_9, "entity.hostile.swim");
+        addSound(ENTITY_IRONGOLEM_ATTACK, BigClientVersion.v1_9, "entity.irongolem.attack");
+        addSound(ENTITY_IRONGOLEM_DEATH, BigClientVersion.v1_9, "entity.irongolem.death");
+        addSound(ENTITY_IRONGOLEM_HURT, BigClientVersion.v1_9, "entity.irongolem.hurt");
+        addSound(ENTITY_IRONGOLEM_STEP, BigClientVersion.v1_9, "entity.irongolem.step");
+        addSound(ENTITY_ITEM_BREAK, BigClientVersion.v1_9, "entity.item.break");
+        addSound(ENTITY_ITEM_PICKUP, BigClientVersion.v1_9, "entity.item.pickup");
+        addSound(ENTITY_ITEMFRAME_ADD_ITEM, BigClientVersion.v1_9, "entity.itemframe.add_item");
+        addSound(ENTITY_ITEMFRAME_BREAK, BigClientVersion.v1_9, "entity.itemframe.break");
+        addSound(ENTITY_ITEMFRAME_PLACE, BigClientVersion.v1_9, "entity.itemframe.place");
+        addSound(ENTITY_ITEMFRAME_REMOVE_ITEM, BigClientVersion.v1_9, "entity.itemframe.remove_item");
+        addSound(ENTITY_ITEMFRAME_ROTATE_ITEM, BigClientVersion.v1_9, "entity.itemframe.rotate_item");
+        addSound(ENTITY_LEASHKNOT_BREAK, BigClientVersion.v1_9, "entity.leashknot.break");
+        addSound(ENTITY_LEASHKNOT_PLACE, BigClientVersion.v1_9, "entity.leashknot.place");
+        addSound(ENTITY_LIGHTNING_IMPACT, BigClientVersion.v1_9, "entity.lightning.impact");
+        addSound(ENTITY_LIGHTNING_THUNDER, BigClientVersion.v1_9, "entity.lightning.thunder");
+        addSound(ENTITY_LINGERINGPOTION_THROW, BigClientVersion.v1_9, "entity.lingeringpotion.throw");
+        addSound(ENTITY_MAGMACUBE_DEATH, BigClientVersion.v1_9, "entity.magmacube.death");
+        addSound(ENTITY_MAGMACUBE_HURT, BigClientVersion.v1_9, "entity.magmacube.hurt");
+        addSound(ENTITY_MAGMACUBE_JUMP, BigClientVersion.v1_9, "entity.magmacube.jump");
+        addSound(ENTITY_MAGMACUBE_SQUISH, BigClientVersion.v1_9, "entity.magmacube.squish");
+        addSound(ENTITY_MINECART_INSIDE, BigClientVersion.v1_9, "entity.minecart.inside");
+        addSound(ENTITY_MINECART_RIDING, BigClientVersion.v1_9, "entity.minecart.riding");
+        addSound(ENTITY_MOOSHROOM_SHEAR, BigClientVersion.v1_9, "entity.mooshroom.shear");
+        addSound(ENTITY_MULE_AMBIENT, BigClientVersion.v1_9, "entity.mule.ambient");
+        addSound(ENTITY_MULE_DEATH, BigClientVersion.v1_9, "entity.mule.death");
+        addSound(ENTITY_MULE_HURT, BigClientVersion.v1_9, "entity.mule.hurt");
+        addSound(ENTITY_PAINTING_BREAK, BigClientVersion.v1_9, "entity.painting.break");
+        addSound(ENTITY_PAINTING_PLACE, BigClientVersion.v1_9, "entity.painting.place");
+        addSound(ENTITY_PIG_AMBIENT, BigClientVersion.v1_9, "entity.pig.ambient");
+        addSound(ENTITY_PIG_DEATH, BigClientVersion.v1_9, "entity.pig.death");
+        addSound(ENTITY_PIG_HURT, BigClientVersion.v1_9, "entity.pig.hurt");
+        addSound(ENTITY_PIG_SADDLE, BigClientVersion.v1_9, "entity.pig.saddle");
+        addSound(ENTITY_PIG_STEP, BigClientVersion.v1_9, "entity.pig.step");
+        addSound(ENTITY_PLAYER_ATTACK_CRIT, BigClientVersion.v1_9, "entity.player.attack.crit");
+        addSound(ENTITY_PLAYER_ATTACK_KNOCKBACK, BigClientVersion.v1_9, "entity.player.attack.knockback");
+        addSound(ENTITY_PLAYER_ATTACK_NODAMAGE, BigClientVersion.v1_9, "entity.player.attack.nodamage");
+        addSound(ENTITY_PLAYER_ATTACK_STRONG, BigClientVersion.v1_9, "entity.player.attack.strong");
+        addSound(ENTITY_PLAYER_ATTACK_SWEEP, BigClientVersion.v1_9, "entity.player.attack.sweep");
+        addSound(ENTITY_PLAYER_ATTACK_WEAK, BigClientVersion.v1_9, "entity.player.attack.weak");
+        addSound(ENTITY_PLAYER_BIG_FALL, BigClientVersion.v1_9, "entity.player.big_fall");
+        addSound(ENTITY_PLAYER_BREATH, BigClientVersion.v1_9, "entity.player.breath");
+        addSound(ENTITY_PLAYER_BURP, BigClientVersion.v1_9, "entity.player.burp");
+        addSound(ENTITY_PLAYER_DEATH, BigClientVersion.v1_9, "entity.player.death");
+        addSound(ENTITY_PLAYER_HURT, BigClientVersion.v1_9, "entity.player.hurt");
+        addSound(ENTITY_PLAYER_LEVELUP, BigClientVersion.v1_9, "entity.player.levelup");
+        addSound(ENTITY_PLAYER_SMALL_FALL, BigClientVersion.v1_9, "entity.player.small_fall");
+        addSound(ENTITY_PLAYER_SPLASH, BigClientVersion.v1_9, "entity.player.splash");
+        addSound(ENTITY_PLAYER_SWIM, BigClientVersion.v1_9, "entity.player.swim");
+        addSound(ENTITY_RABBIT_AMBIENT, BigClientVersion.v1_9, "entity.rabbit.ambient");
+        addSound(ENTITY_RABBIT_ATTACK, BigClientVersion.v1_9, "entity.rabbit.attack");
+        addSound(ENTITY_RABBIT_DEATH, BigClientVersion.v1_9, "entity.rabbit.death");
+        addSound(ENTITY_RABBIT_HURT, BigClientVersion.v1_9, "entity.rabbit.hurt");
+        addSound(ENTITY_RABBIT_JUMP, BigClientVersion.v1_9, "entity.rabbit.jump");
+        addSound(ENTITY_SHEEP_AMBIENT, BigClientVersion.v1_9, "entity.sheep.ambient");
+        addSound(ENTITY_SHEEP_DEATH, BigClientVersion.v1_9, "entity.sheep.death");
+        addSound(ENTITY_SHEEP_HURT, BigClientVersion.v1_9, "entity.sheep.hurt");
+        addSound(ENTITY_SHEEP_SHEAR, BigClientVersion.v1_9, "entity.sheep.shear");
+        addSound(ENTITY_SHEEP_STEP, BigClientVersion.v1_9, "entity.sheep.step");
+        addSound(ENTITY_SHULKER_AMBIENT, BigClientVersion.v1_9, "entity.shulker.ambient");
+        addSound(ENTITY_SHULKER_CLOSE, BigClientVersion.v1_9, "entity.shulker.close");
+        addSound(ENTITY_SHULKER_DEATH, BigClientVersion.v1_9, "entity.shulker.death");
+        addSound(ENTITY_SHULKER_HURT, BigClientVersion.v1_9, "entity.shulker.hurt");
+        addSound(ENTITY_SHULKER_HURT_CLOSED, BigClientVersion.v1_9, "entity.shulker.hurt_closed");
+        addSound(ENTITY_SHULKER_OPEN, BigClientVersion.v1_9, "entity.shulker.open");
+        addSound(ENTITY_SHULKER_SHOOT, BigClientVersion.v1_9, "entity.shulker.shoot");
+        addSound(ENTITY_SHULKER_TELEPORT, BigClientVersion.v1_9, "entity.shulker.teleport");
+        addSound(ENTITY_SHULKER_BULLET_HIT, BigClientVersion.v1_9, "entity.shulker_bullet.hit");
+        addSound(ENTITY_SHULKER_BULLET_HURT, BigClientVersion.v1_9, "entity.shulker_bullet.hurt");
+        addSound(ENTITY_SILVERFISH_AMBIENT, BigClientVersion.v1_9, "entity.silverfish.ambient");
+        addSound(ENTITY_SILVERFISH_DEATH, BigClientVersion.v1_9, "entity.silverfish.death");
+        addSound(ENTITY_SILVERFISH_HURT, BigClientVersion.v1_9, "entity.silverfish.hurt");
+        addSound(ENTITY_SILVERFISH_STEP, BigClientVersion.v1_9, "entity.silverfish.step");
+        addSound(ENTITY_SKELETON_AMBIENT, BigClientVersion.v1_9, "entity.skeleton.ambient");
+        addSound(ENTITY_SKELETON_DEATH, BigClientVersion.v1_9, "entity.skeleton.death");
+        addSound(ENTITY_SKELETON_HURT, BigClientVersion.v1_9, "entity.skeleton.hurt");
+        addSound(ENTITY_SKELETON_SHOOT, BigClientVersion.v1_9, "entity.skeleton.shoot");
+        addSound(ENTITY_SKELETON_STEP, BigClientVersion.v1_9, "entity.skeleton.step");
+        addSound(ENTITY_SKELETON_HORSE_AMBIENT, BigClientVersion.v1_9, "entity.skeleton_horse.ambient");
+        addSound(ENTITY_SKELETON_HORSE_DEATH, BigClientVersion.v1_9, "entity.skeleton_horse.death");
+        addSound(ENTITY_SKELETON_HORSE_HURT, BigClientVersion.v1_9, "entity.skeleton_horse.hurt");
+        addSound(ENTITY_SLIME_ATTACK, BigClientVersion.v1_9, "entity.slime.attack");
+        addSound(ENTITY_SLIME_DEATH, BigClientVersion.v1_9, "entity.slime.death");
+        addSound(ENTITY_SLIME_HURT, BigClientVersion.v1_9, "entity.slime.hurt");
+        addSound(ENTITY_SLIME_JUMP, BigClientVersion.v1_9, "entity.slime.jump");
+        addSound(ENTITY_SLIME_SQUISH, BigClientVersion.v1_9, "entity.slime.squish");
+        addSound(ENTITY_SMALL_MAGMACUBE_DEATH, BigClientVersion.v1_9, "entity.small_magmacube.death");
+        addSound(ENTITY_SMALL_MAGMACUBE_HURT, BigClientVersion.v1_9, "entity.small_magmacube.hurt");
+        addSound(ENTITY_SMALL_MAGMACUBE_SQUISH, BigClientVersion.v1_9, "entity.small_magmacube.squish");
+        addSound(ENTITY_SMALL_SLIME_DEATH, BigClientVersion.v1_9, "entity.small_slime.death");
+        addSound(ENTITY_SMALL_SLIME_HURT, BigClientVersion.v1_9, "entity.small_slime.hurt");
+        addSound(ENTITY_SMALL_SLIME_JUMP, BigClientVersion.v1_9, "entity.small_slime.jump");
+        addSound(ENTITY_SMALL_SLIME_SQUISH, BigClientVersion.v1_9, "entity.small_slime.squish");
+        addSound(ENTITY_SNOWBALL_THROW, BigClientVersion.v1_9, "entity.snowball.throw");
+        addSound(ENTITY_SNOWMAN_AMBIENT, BigClientVersion.v1_9, "entity.snowman.ambient");
+        addSound(ENTITY_SNOWMAN_DEATH, BigClientVersion.v1_9, "entity.snowman.death");
+        addSound(ENTITY_SNOWMAN_HURT, BigClientVersion.v1_9, "entity.snowman.hurt");
+        addSound(ENTITY_SNOWMAN_SHOOT, BigClientVersion.v1_9, "entity.snowman.shoot");
+        addSound(ENTITY_SPIDER_AMBIENT, BigClientVersion.v1_9, "entity.spider.ambient");
+        addSound(ENTITY_SPIDER_DEATH, BigClientVersion.v1_9, "entity.spider.death");
+        addSound(ENTITY_SPIDER_HURT, BigClientVersion.v1_9, "entity.spider.hurt");
+        addSound(ENTITY_SPIDER_STEP, BigClientVersion.v1_9, "entity.spider.step");
+        addSound(ENTITY_SPLASH_POTION_BREAK, BigClientVersion.v1_9, "entity.splash_potion.break");
+        addSound(ENTITY_SPLASH_POTION_THROW, BigClientVersion.v1_9, "entity.splash_potion.throw");
+        addSound(ENTITY_SQUID_AMBIENT, BigClientVersion.v1_9, "entity.squid.ambient");
+        addSound(ENTITY_SQUID_DEATH, BigClientVersion.v1_9, "entity.squid.death");
+        addSound(ENTITY_SQUID_HURT, BigClientVersion.v1_9, "entity.squid.hurt");
+        addSound(ENTITY_TNT_PRIMED, BigClientVersion.v1_9, "entity.tnt.primed");
+        addSound(ENTITY_VILLAGER_AMBIENT, BigClientVersion.v1_9, "entity.villager.ambient");
+        addSound(ENTITY_VILLAGER_DEATH, BigClientVersion.v1_9, "entity.villager.death");
+        addSound(ENTITY_VILLAGER_HURT, BigClientVersion.v1_9, "entity.villager.hurt");
+        addSound(ENTITY_VILLAGER_NO, BigClientVersion.v1_9, "entity.villager.no");
+        addSound(ENTITY_VILLAGER_TRADING, BigClientVersion.v1_9, "entity.villager.trading");
+        addSound(ENTITY_VILLAGER_YES, BigClientVersion.v1_9, "entity.villager.yes");
+        addSound(ENTITY_WITCH_AMBIENT, BigClientVersion.v1_9, "entity.witch.ambient");
+        addSound(ENTITY_WITCH_DEATH, BigClientVersion.v1_9, "entity.witch.death");
+        addSound(ENTITY_WITCH_DRINK, BigClientVersion.v1_9, "entity.witch.drink");
+        addSound(ENTITY_WITCH_HURT, BigClientVersion.v1_9, "entity.witch.hurt");
+        addSound(ENTITY_WITCH_THROW, BigClientVersion.v1_9, "entity.witch.throw");
+        addSound(ENTITY_WITHER_AMBIENT, BigClientVersion.v1_9, "entity.wither.ambient");
+        addSound(ENTITY_WITHER_BREAK_BLOCK, BigClientVersion.v1_9, "entity.wither.break_block");
+        addSound(ENTITY_WITHER_DEATH, BigClientVersion.v1_9, "entity.wither.death");
+        addSound(ENTITY_WITHER_HURT, BigClientVersion.v1_9, "entity.wither.hurt");
+        addSound(ENTITY_WITHER_SHOOT, BigClientVersion.v1_9, "entity.wither.shoot");
+        addSound(ENTITY_WITHER_SPAWN, BigClientVersion.v1_9, "entity.wither.spawn");
+        addSound(ENTITY_WOLF_AMBIENT, BigClientVersion.v1_9, "entity.wolf.ambient");
+        addSound(ENTITY_WOLF_DEATH, BigClientVersion.v1_9, "entity.wolf.death");
+        addSound(ENTITY_WOLF_GROWL, BigClientVersion.v1_9, "entity.wolf.growl");
+        addSound(ENTITY_WOLF_HOWL, BigClientVersion.v1_9, "entity.wolf.howl");
+        addSound(ENTITY_WOLF_HURT, BigClientVersion.v1_9, "entity.wolf.hurt");
+        addSound(ENTITY_WOLF_PANT, BigClientVersion.v1_9, "entity.wolf.pant");
+        addSound(ENTITY_WOLF_SHAKE, BigClientVersion.v1_9, "entity.wolf.shake");
+        addSound(ENTITY_WOLF_STEP, BigClientVersion.v1_9, "entity.wolf.step");
+        addSound(ENTITY_WOLF_WHINE, BigClientVersion.v1_9, "entity.wolf.whine");
+        addSound(ENTITY_ZOMBIE_AMBIENT, BigClientVersion.v1_9, "entity.zombie.ambient");
+        addSound(ENTITY_ZOMBIE_ATTACK_DOOR_WOOD, BigClientVersion.v1_9, "entity.zombie.attack_door_wood");
+        addSound(ENTITY_ZOMBIE_ATTACK_IRON_DOOR, BigClientVersion.v1_9, "entity.zombie.attack_iron_door");
+        addSound(ENTITY_ZOMBIE_BREAK_DOOR_WOOD, BigClientVersion.v1_9, "entity.zombie.break_door_wood");
+        addSound(ENTITY_ZOMBIE_DEATH, BigClientVersion.v1_9, "entity.zombie.death");
+        addSound(ENTITY_ZOMBIE_HURT, BigClientVersion.v1_9, "entity.zombie.hurt");
+        addSound(ENTITY_ZOMBIE_INFECT, BigClientVersion.v1_9, "entity.zombie.infect");
+        addSound(ENTITY_ZOMBIE_STEP, BigClientVersion.v1_9, "entity.zombie.step");
+        addSound(ENTITY_ZOMBIE_HORSE_AMBIENT, BigClientVersion.v1_9, "entity.zombie_horse.ambient");
+        addSound(ENTITY_ZOMBIE_HORSE_DEATH, BigClientVersion.v1_9, "entity.zombie_horse.death");
+        addSound(ENTITY_ZOMBIE_HORSE_HURT, BigClientVersion.v1_9, "entity.zombie_horse.hurt");
+        addSound(ENTITY_ZOMBIE_PIG_AMBIENT, BigClientVersion.v1_9, "entity.zombie_pig.ambient");
+        addSound(ENTITY_ZOMBIE_PIG_ANGRY, BigClientVersion.v1_9, "entity.zombie_pig.angry");
+        addSound(ENTITY_ZOMBIE_PIG_DEATH, BigClientVersion.v1_9, "entity.zombie_pig.death");
+        addSound(ENTITY_ZOMBIE_PIG_HURT, BigClientVersion.v1_9, "entity.zombie_pig.hurt");
+        addSound(ENTITY_ZOMBIE_VILLAGER_AMBIENT, BigClientVersion.v1_9, "entity.zombie_villager.ambient");
+        addSound(ENTITY_ZOMBIE_VILLAGER_CONVERTED, BigClientVersion.v1_9, "entity.zombie_villager.converted");
+        addSound(ENTITY_ZOMBIE_VILLAGER_CURE, BigClientVersion.v1_9, "entity.zombie_villager.cure");
+        addSound(ENTITY_ZOMBIE_VILLAGER_DEATH, BigClientVersion.v1_9, "entity.zombie_villager.death");
+        addSound(ENTITY_ZOMBIE_VILLAGER_HURT, BigClientVersion.v1_9, "entity.zombie_villager.hurt");
+        addSound(ENTITY_ZOMBIE_VILLAGER_STEP, BigClientVersion.v1_9, "entity.zombie_villager.step");
+        addSound(ITEM_ARMOR_EQUIP_CHAIN, BigClientVersion.v1_9, "item.armor.equip_chain");
+        addSound(ITEM_ARMOR_EQUIP_DIAMOND, BigClientVersion.v1_9, "item.armor.equip_diamond");
+        addSound(ITEM_ARMOR_EQUIP_GENERIC, BigClientVersion.v1_9, "item.armor.equip_generic");
+        addSound(ITEM_ARMOR_EQUIP_GOLD, BigClientVersion.v1_9, "item.armor.equip_gold");
+        addSound(ITEM_ARMOR_EQUIP_IRON, BigClientVersion.v1_9, "item.armor.equip_iron");
+        addSound(ITEM_ARMOR_EQUIP_LEATHER, BigClientVersion.v1_9, "item.armor.equip_leather");
+        addSound(ITEM_BOTTLE_FILL, BigClientVersion.v1_9, "item.bottle.fill");
+        addSound(ITEM_BOTTLE_FILL_DRAGONBREATH, BigClientVersion.v1_9, "item.bottle.fill_dragonbreath");
+        addSound(ITEM_BUCKET_EMPTY, BigClientVersion.v1_9, "item.bucket.empty");
+        addSound(ITEM_BUCKET_EMPTY_LAVA, BigClientVersion.v1_9, "item.bucket.empty_lava");
+        addSound(ITEM_BUCKET_FILL, BigClientVersion.v1_9, "item.bucket.fill");
+        addSound(ITEM_BUCKET_FILL_LAVA, BigClientVersion.v1_9, "item.bucket.fill_lava");
+        addSound(ITEM_CHORUS_FRUIT_TELEPORT, BigClientVersion.v1_9, "item.chorus_fruit.teleport");
+        addSound(ITEM_ELYTRA_FLYING, BigClientVersion.v1_9, "item.elytra.flying");
+        addSound(ITEM_FIRECHARGE_USE, BigClientVersion.v1_9, "item.firecharge.use");
+        addSound(ITEM_FLINTANDSTEEL_USE, BigClientVersion.v1_9, "item.flintandsteel.use");
+        addSound(ITEM_HOE_TILL, BigClientVersion.v1_9, "item.hoe.till");
+        addSound(ITEM_SHIELD_BLOCK, BigClientVersion.v1_9, "item.shield.block");
+        addSound(ITEM_SHIELD_BREAK, BigClientVersion.v1_9, "item.shield.break");
+        addSound(ITEM_SHOVEL_FLATTEN, BigClientVersion.v1_9, "item.shovel.flatten");
+        addSound(MUSIC_CREATIVE, BigClientVersion.v1_9, "music.creative");
+        addSound(MUSIC_CREDITS, BigClientVersion.v1_9, "music.credits");
+        addSound(MUSIC_DRAGON, BigClientVersion.v1_9, "music.dragon");
+        addSound(MUSIC_END, BigClientVersion.v1_9, "music.end");
+        addSound(MUSIC_GAME, BigClientVersion.v1_9, "music.game");
+        addSound(MUSIC_MENU, BigClientVersion.v1_9, "music.menu");
+        addSound(MUSIC_NETHER, BigClientVersion.v1_9, "music.nether");
+        addSound(RECORD_11, BigClientVersion.v1_9, "record.11");
+        addSound(RECORD_13, BigClientVersion.v1_9, "record.13");
+        addSound(RECORD_BLOCKS, BigClientVersion.v1_9, "record.blocks");
+        addSound(RECORD_CAT, BigClientVersion.v1_9, "record.cat");
+        addSound(RECORD_CHIRP, BigClientVersion.v1_9, "record.chirp");
+        addSound(RECORD_FAR, BigClientVersion.v1_9, "record.far");
+        addSound(RECORD_MALL, BigClientVersion.v1_9, "record.mall");
+        addSound(RECORD_MELLOHI, BigClientVersion.v1_9, "record.mellohi");
+        addSound(RECORD_STAL, BigClientVersion.v1_9, "record.stal");
+        addSound(RECORD_STRAD, BigClientVersion.v1_9, "record.strad");
+        addSound(RECORD_WAIT, BigClientVersion.v1_9, "record.wait");
+        addSound(RECORD_WARD, BigClientVersion.v1_9, "record.ward");
+        addSound(UI_BUTTON_CLICK, BigClientVersion.v1_9, "ui.button.click");
+        addSound(WEATHER_RAIN, BigClientVersion.v1_9, "weather.rain");
+        addSound(WEATHER_RAIN_ABOVE, BigClientVersion.v1_9, "weather.rain.above");
+
+        //TODO implement sound for 1.8?
+    }
+
+    private HashMap<BigClientVersion, String> versions = new HashMap<>();
+
+    private SoundEffect() {
+    }
+
+    private static void addSound(SoundEffect effect, BigClientVersion version, String id) {
+        effect.versions.put(version, id);
+    }
+
+    /**
+     * Get the Sound-String for the BigClientVersion
+     *
+     * @param BigClientVersion version
+     * @return Sound-String
+     * @see BigClientVersion
+     */
+    public String getId(BigClientVersion version) {
+        return versions.get(version);
+    }
+
+    /**
+     * checks if the Sound is Aviarible for the specified version
+     *
+     * @param BigClientVersion version
+     * @return true if its aviarible
+     * @see BigClientVersion
+     */
+    public boolean isAvariable(BigClientVersion version) {
+        return versions.containsKey(version);
+    }
 }
diff --git a/src/main/java/dev/wolveringer/chat/ChatBaseComponent.java b/src/main/java/dev/wolveringer/chat/ChatBaseComponent.java
index a265157..d752b58 100644
--- a/src/main/java/dev/wolveringer/chat/ChatBaseComponent.java
+++ b/src/main/java/dev/wolveringer/chat/ChatBaseComponent.java
@@ -1,131 +1,131 @@
 package dev.wolveringer.chat;
 
+import com.google.common.collect.Iterators;
+import com.google.common.collect.Lists;
+
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
 
-import com.google.common.collect.Iterators;
-import com.google.common.collect.Lists;
-
-@SuppressWarnings({ "rawtypes" })
+@SuppressWarnings({"rawtypes"})
 public abstract class ChatBaseComponent implements IChatBaseComponent {
 
-	protected List<IChatBaseComponent> texte = Lists.newArrayList();
-
-	protected ChatModifier modifier;
-
-	public ChatBaseComponent() {
-	}
-
-	@Override
-	public List getSiblings() {
-		return this.texte;
-	}
-
-	public IChatBaseComponent addSibling(String text) {
-		return this.addSibling(new ChatComponentText(text));
-	}
-
-	@Override
-	public IChatBaseComponent addSibling(IChatBaseComponent ichatbasecomponent) {
-		ichatbasecomponent.getChatModifier().setChatModifier(this.getChatModifier());
-		this.texte.add(ichatbasecomponent);
-		return this;
-	}
-
-	@Override
-	public String getRawText() {
-		StringBuilder stringbuilder = new StringBuilder();
-		Iterator iterator = this.iterator();
-
-		while (iterator.hasNext()){
-			IChatBaseComponent ichatbasecomponent = (IChatBaseComponent) iterator.next();
-
-			stringbuilder.append(ichatbasecomponent.getText());
-		}
-		return stringbuilder.toString();
-	}
-
-	@Override
-	public boolean equals(Object object) {
-		if(this == object){
-			return true;
-		}else if(!(object instanceof ChatBaseComponent)){
-			return false;
-		}else{
-			ChatBaseComponent chatbasecomponent = (ChatBaseComponent) object;
-			return this.texte.equals(chatbasecomponent.texte) && this.getChatModifier().equals(chatbasecomponent.getChatModifier());
-		}
-	}
-
-	@Override
-	public ChatModifier getChatModifier() {
-		if(this.modifier == null){
-			this.modifier = new ChatModifier();
-			Iterator iterator = this.texte.iterator();
-
-			while (iterator.hasNext()){
-				IChatBaseComponent ichatbasecomponent = (IChatBaseComponent) iterator.next();
-
-				ichatbasecomponent.getChatModifier().setChatModifier(this.modifier);
-			}
-		}
-
-		return this.modifier;
-	}
-
-	@Override
-	public int hashCode() {
-		return 31 * this.modifier.hashCode() + this.texte.hashCode();
-	}
-
-	@Override
-	public Iterator<IChatBaseComponent> iterator() {
-		return Iterators.concat(Iterators.forArray(new ChatBaseComponent[] { this }), Iterators.forArray(this.texte.toArray(new IChatBaseComponent[this.texte.size()])));
-	}
-
-	@Override
-	public IChatBaseComponent setChatModifier(ChatModifier chatmodifier) {
-		this.modifier = chatmodifier;
-		Iterator<IChatBaseComponent> iterator = this.texte.iterator();
-		while (iterator.hasNext()){
-			iterator.next().getChatModifier().setChatModifier(this.getChatModifier());
-		}
-
-		return this;
-	}
-
-	@Override
-	public boolean hasClickListener() {
-		Iterator<IChatBaseComponent> copms = iterator();
-		for(IChatBaseComponent comp = copms.next();copms.hasNext();comp = copms.next()){
-			if(comp.hasClickListener())
-				return true;
-		}
-		return false;
-	}
-
-	@Override
-	public ArrayList<String> getClickSignature() {
-		ArrayList<String> strings = new ArrayList<String>();
-		Iterator<IChatBaseComponent> copms = iterator();
-		for(IChatBaseComponent comp = copms.next();copms.hasNext();comp = copms.next())
-			if(comp.hasClickListener())
-				strings.addAll(comp.getClickSignature());
-		return strings;
-	}
-
-	@Override
-	public ChatClickListener run(String s) {
-		Iterator<IChatBaseComponent> copms = iterator();
-		for(IChatBaseComponent comp = copms.next();copms.hasNext();comp = copms.next()){
-			if(comp.hasClickListener()){
-				ChatClickListener click = comp.run(s);
-				if(click != null)
-					return click;
-			}
-		}
-		return null;
-	}
+    protected List<IChatBaseComponent> texte = Lists.newArrayList();
+
+    protected ChatModifier modifier;
+
+    public ChatBaseComponent() {
+    }
+
+    @Override
+    public List getSiblings() {
+        return this.texte;
+    }
+
+    public IChatBaseComponent addSibling(String text) {
+        return this.addSibling(new ChatComponentText(text));
+    }
+
+    @Override
+    public IChatBaseComponent addSibling(IChatBaseComponent ichatbasecomponent) {
+        ichatbasecomponent.getChatModifier().setChatModifier(this.getChatModifier());
+        this.texte.add(ichatbasecomponent);
+        return this;
+    }
+
+    @Override
+    public String getRawText() {
+        StringBuilder stringbuilder = new StringBuilder();
+        Iterator iterator = this.iterator();
+
+        while (iterator.hasNext()) {
+            IChatBaseComponent ichatbasecomponent = (IChatBaseComponent) iterator.next();
+
+            stringbuilder.append(ichatbasecomponent.getText());
+        }
+        return stringbuilder.toString();
+    }
+
+    @Override
+    public boolean equals(Object object) {
+        if (this == object) {
+            return true;
+        } else if (!(object instanceof ChatBaseComponent)) {
+            return false;
+        } else {
+            ChatBaseComponent chatbasecomponent = (ChatBaseComponent) object;
+            return this.texte.equals(chatbasecomponent.texte) && this.getChatModifier().equals(chatbasecomponent.getChatModifier());
+        }
+    }
+
+    @Override
+    public ChatModifier getChatModifier() {
+        if (this.modifier == null) {
+            this.modifier = new ChatModifier();
+            Iterator iterator = this.texte.iterator();
+
+            while (iterator.hasNext()) {
+                IChatBaseComponent ichatbasecomponent = (IChatBaseComponent) iterator.next();
+
+                ichatbasecomponent.getChatModifier().setChatModifier(this.modifier);
+            }
+        }
+
+        return this.modifier;
+    }
+
+    @Override
+    public int hashCode() {
+        return 31 * this.modifier.hashCode() + this.texte.hashCode();
+    }
+
+    @Override
+    public Iterator<IChatBaseComponent> iterator() {
+        return Iterators.concat(Iterators.forArray(new ChatBaseComponent[]{this}), Iterators.forArray(this.texte.toArray(new IChatBaseComponent[this.texte.size()])));
+    }
+
+    @Override
+    public IChatBaseComponent setChatModifier(ChatModifier chatmodifier) {
+        this.modifier = chatmodifier;
+        Iterator<IChatBaseComponent> iterator = this.texte.iterator();
+        while (iterator.hasNext()) {
+            iterator.next().getChatModifier().setChatModifier(this.getChatModifier());
+        }
+
+        return this;
+    }
+
+    @Override
+    public boolean hasClickListener() {
+        Iterator<IChatBaseComponent> copms = iterator();
+        for (IChatBaseComponent comp = copms.next(); copms.hasNext(); comp = copms.next()) {
+            if (comp.hasClickListener())
+                return true;
+        }
+        return false;
+    }
+
+    @Override
+    public ArrayList<String> getClickSignature() {
+        ArrayList<String> strings = new ArrayList<String>();
+        Iterator<IChatBaseComponent> copms = iterator();
+        for (IChatBaseComponent comp = copms.next(); copms.hasNext(); comp = copms.next())
+            if (comp.hasClickListener())
+                strings.addAll(comp.getClickSignature());
+        return strings;
+    }
+
+    @Override
+    public ChatClickListener run(String s) {
+        Iterator<IChatBaseComponent> copms = iterator();
+        for (IChatBaseComponent comp = copms.next(); copms.hasNext(); comp = copms.next()) {
+            if (comp.hasClickListener()) {
+                ChatClickListener click = comp.run(s);
+                if (click != null)
+                    return click;
+            }
+        }
+        return null;
+    }
 
 }
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/chat/ChatClickListener.java b/src/main/java/dev/wolveringer/chat/ChatClickListener.java
index 583b9fb..fba8132 100644
--- a/src/main/java/dev/wolveringer/chat/ChatClickListener.java
+++ b/src/main/java/dev/wolveringer/chat/ChatClickListener.java
@@ -3,5 +3,5 @@ package dev.wolveringer.chat;
 import dev.wolveringer.BungeeUtil.Player;
 
 public interface ChatClickListener {
-	public void click(Player p);
+    public void click(Player p);
 }
diff --git a/src/main/java/dev/wolveringer/chat/ChatClickable.java b/src/main/java/dev/wolveringer/chat/ChatClickable.java
index 0bbdbfb..16d94c7 100644
--- a/src/main/java/dev/wolveringer/chat/ChatClickable.java
+++ b/src/main/java/dev/wolveringer/chat/ChatClickable.java
@@ -4,56 +4,58 @@ import java.util.UUID;
 
 public class ChatClickable {
 
-	private EnumClickAction action;
-	private String value;
-	private transient String command_signature;
-	private transient ChatClickListener listener = null;
-
-	public ChatClickable(EnumClickAction action) {
-		this.action = action;
-	}
-	public ChatClickable(EnumClickAction action, String data) {
-		this(action);
-		this.value = data;
-	}
-	public ChatClickable(EnumClickAction enumclickaction, String s,ChatClickListener listener) {
-		this(enumclickaction,s);
-		this.command_signature = UUID.randomUUID().toString() + System.currentTimeMillis();
-	}
-
-	public EnumClickAction getAction() {
-		return this.action;
-	}
-
-	public String getValue() {
-		return this.value;
-	}
-	
-	@Override
-	public int hashCode() {
-		int i = this.action.hashCode();
-
-		i = 31 * i + (this.value != null ? this.value.hashCode() : 0);
-		return i;
-	}
-
-	@Override
-	public String toString() {
-		if(!hasListener())
-			return "ClickEvent{action=" + this.action + ", value=\'" + this.value + '\'' + '}';
-		else
-			return "ClickEvent{action=" + this.action + ", value=\'" + this.value + '\'' +", CommandSignature=\'"+ command_signature +"\'"+'}';
-	}
-
-	public String getCommandSignature() {
-		return command_signature;
-	}
-
-	public boolean hasListener() {
-		return listener != null && command_signature != null && !"".equalsIgnoreCase(command_signature);
-	}
-
-	public ChatClickListener getListener() {
-		return listener;
-	}
+    private EnumClickAction action;
+    private String value;
+    private transient String command_signature;
+    private transient ChatClickListener listener = null;
+
+    public ChatClickable(EnumClickAction action) {
+        this.action = action;
+    }
+
+    public ChatClickable(EnumClickAction action, String data) {
+        this(action);
+        this.value = data;
+    }
+
+    public ChatClickable(EnumClickAction enumclickaction, String s, ChatClickListener listener) {
+        this(enumclickaction, s);
+        this.command_signature = UUID.randomUUID().toString() + System.currentTimeMillis();
+    }
+
+    public EnumClickAction getAction() {
+        return this.action;
+    }
+
+    public String getValue() {
+        return this.value;
+    }
+
+    @Override
+    public int hashCode() {
+        int i = this.action.hashCode();
+
+        i = 31 * i + (this.value != null ? this.value.hashCode() : 0);
+        return i;
+    }
+
+    @Override
+    public String toString() {
+        if (!hasListener())
+            return "ClickEvent{action=" + this.action + ", value=\'" + this.value + '\'' + '}';
+        else
+            return "ClickEvent{action=" + this.action + ", value=\'" + this.value + '\'' + ", CommandSignature=\'" + command_signature + "\'" + '}';
+    }
+
+    public String getCommandSignature() {
+        return command_signature;
+    }
+
+    public boolean hasListener() {
+        return listener != null && command_signature != null && !"".equalsIgnoreCase(command_signature);
+    }
+
+    public ChatClickListener getListener() {
+        return listener;
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/chat/ChatColor/AnsiColorFormater.java b/src/main/java/dev/wolveringer/chat/ChatColor/AnsiColorFormater.java
index 11ec03b..4cc390d 100644
--- a/src/main/java/dev/wolveringer/chat/ChatColor/AnsiColorFormater.java
+++ b/src/main/java/dev/wolveringer/chat/ChatColor/AnsiColorFormater.java
@@ -1,67 +1,66 @@
 package dev.wolveringer.chat.ChatColor;
 
-import java.util.HashMap;
-import java.util.Map;
-
 import net.md_5.bungee.api.ChatColor;
 
 import org.fusesource.jansi.Ansi;
 
+import java.util.HashMap;
+import java.util.Map;
+
 public class AnsiColorFormater {
 
-	public static AnsiColorFormater formater = new AnsiColorFormater();
+    public static AnsiColorFormater formater = new AnsiColorFormater();
+    private final Map<String, String> replacements = new HashMap<String, String>();
 
-	public static AnsiColorFormater getFormater() {
-		if (formater == null)
-			formater = new AnsiColorFormater();
-		return formater;
-	}
+    public AnsiColorFormater() {
+        this.replacements.put(ChatColor.BLACK.toString(), Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.BLACK).boldOff().toString());
+        this.replacements.put(ChatColor.DARK_BLUE.toString(), Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.BLUE).boldOff().toString());
+        this.replacements.put(ChatColor.DARK_GREEN.toString(), Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.GREEN).boldOff().toString());
+        this.replacements.put(ChatColor.DARK_AQUA.toString(), Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.CYAN).boldOff().toString());
+        this.replacements.put(ChatColor.DARK_RED.toString(), Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.RED).boldOff().toString());
+        this.replacements.put(ChatColor.DARK_PURPLE.toString(), Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.MAGENTA).boldOff().toString());
+        this.replacements.put(ChatColor.GOLD.toString(), Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.YELLOW).boldOff().toString());
+        this.replacements.put(ChatColor.GRAY.toString(), Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.WHITE).boldOff().toString());
+        this.replacements.put(ChatColor.DARK_GRAY.toString(), Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.BLACK).bold().toString());
+        this.replacements.put(ChatColor.BLUE.toString(), Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.BLUE).bold().toString());
+        this.replacements.put(ChatColor.GREEN.toString(), Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.GREEN).bold().toString());
+        this.replacements.put(ChatColor.AQUA.toString(), Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.CYAN).bold().toString());
+        this.replacements.put(ChatColor.RED.toString(), Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.RED).bold().toString());
+        this.replacements.put(ChatColor.LIGHT_PURPLE.toString(), Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.MAGENTA).bold().toString());
+        this.replacements.put(ChatColor.YELLOW.toString(), Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.YELLOW).bold().toString());
+        this.replacements.put(ChatColor.WHITE.toString(), Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.WHITE).bold().toString());
+        this.replacements.put(ChatColor.MAGIC.toString(), Ansi.ansi().a(Ansi.Attribute.BLINK_SLOW).toString());
+        this.replacements.put(ChatColor.BOLD.toString(), Ansi.ansi().a(Ansi.Attribute.UNDERLINE_DOUBLE).toString());
+        this.replacements.put(ChatColor.STRIKETHROUGH.toString(), Ansi.ansi().a(Ansi.Attribute.STRIKETHROUGH_ON).toString());
+        this.replacements.put(ChatColor.UNDERLINE.toString(), Ansi.ansi().a(Ansi.Attribute.UNDERLINE).toString());
+        this.replacements.put(ChatColor.ITALIC.toString(), Ansi.ansi().a(Ansi.Attribute.ITALIC).toString());
+        this.replacements.put(ChatColor.COLOR_CHAR + "z", Ansi.ansi().newline().toString());
+        this.replacements.put(ChatColor.RESET.toString(), Ansi.ansi().a(Ansi.Attribute.RESET).toString());
+    }
 
-	public static void setFormater(AnsiColorFormater formater) {
-		AnsiColorFormater.formater = formater;
-	}
+    public static AnsiColorFormater getFormater() {
+        if (formater == null)
+            formater = new AnsiColorFormater();
+        return formater;
+    }
 
-	private final Map<String, String> replacements = new HashMap<String, String>();
+    public static void setFormater(AnsiColorFormater formater) {
+        AnsiColorFormater.formater = formater;
+    }
 
-	public AnsiColorFormater() {
-		this.replacements.put(ChatColor.BLACK.toString(), Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.BLACK).boldOff().toString());
-		this.replacements.put(ChatColor.DARK_BLUE.toString(), Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.BLUE).boldOff().toString());
-		this.replacements.put(ChatColor.DARK_GREEN.toString(), Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.GREEN).boldOff().toString());
-		this.replacements.put(ChatColor.DARK_AQUA.toString(), Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.CYAN).boldOff().toString());
-		this.replacements.put(ChatColor.DARK_RED.toString(), Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.RED).boldOff().toString());
-		this.replacements.put(ChatColor.DARK_PURPLE.toString(), Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.MAGENTA).boldOff().toString());
-		this.replacements.put(ChatColor.GOLD.toString(), Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.YELLOW).boldOff().toString());
-		this.replacements.put(ChatColor.GRAY.toString(), Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.WHITE).boldOff().toString());
-		this.replacements.put(ChatColor.DARK_GRAY.toString(), Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.BLACK).bold().toString());
-		this.replacements.put(ChatColor.BLUE.toString(), Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.BLUE).bold().toString());
-		this.replacements.put(ChatColor.GREEN.toString(), Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.GREEN).bold().toString());
-		this.replacements.put(ChatColor.AQUA.toString(), Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.CYAN).bold().toString());
-		this.replacements.put(ChatColor.RED.toString(), Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.RED).bold().toString());
-		this.replacements.put(ChatColor.LIGHT_PURPLE.toString(), Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.MAGENTA).bold().toString());
-		this.replacements.put(ChatColor.YELLOW.toString(), Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.YELLOW).bold().toString());
-		this.replacements.put(ChatColor.WHITE.toString(), Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.WHITE).bold().toString());
-		this.replacements.put(ChatColor.MAGIC.toString(), Ansi.ansi().a(Ansi.Attribute.BLINK_SLOW).toString());
-		this.replacements.put(ChatColor.BOLD.toString(), Ansi.ansi().a(Ansi.Attribute.UNDERLINE_DOUBLE).toString());
-		this.replacements.put(ChatColor.STRIKETHROUGH.toString(), Ansi.ansi().a(Ansi.Attribute.STRIKETHROUGH_ON).toString());
-		this.replacements.put(ChatColor.UNDERLINE.toString(), Ansi.ansi().a(Ansi.Attribute.UNDERLINE).toString());
-		this.replacements.put(ChatColor.ITALIC.toString(), Ansi.ansi().a(Ansi.Attribute.ITALIC).toString());
-		this.replacements.put(ChatColor.COLOR_CHAR + "z", Ansi.ansi().newline().toString());
-		this.replacements.put(ChatColor.RESET.toString(), Ansi.ansi().a(Ansi.Attribute.RESET).toString());
-	}
+    public static void main(String[] args) {
+        System.out.println(AnsiColorFormater.getFormater().stripAnsi(AnsiColorFormater.getFormater().format("\u00A7c\u00A7z\u00A7rHello world")));
+    }
 
-	public String format(String s) {
-		for (String color : replacements.keySet()) {
-			s = s.replaceAll("(?i)" + color, (String) this.replacements.get(color));
-		}
-		return s + Ansi.ansi().a(Ansi.Attribute.RESET).toString();
-	}
+    public String format(String s) {
+        for (String color : replacements.keySet()) {
+            s = s.replaceAll("(?i)" + color, (String) this.replacements.get(color));
+        }
+        return s + Ansi.ansi().a(Ansi.Attribute.RESET).toString();
+    }
 
-	public String stripAnsi(String message) {
-		message = message.replaceAll("\033\\[m", "");
-		return message;
-	}
-	
-	public static void main(String[] args) {
-		System.out.println(AnsiColorFormater.getFormater().stripAnsi(AnsiColorFormater.getFormater().format("\u00A7c\u00A7z\u00A7rHello world")));
-	}
+    public String stripAnsi(String message) {
+        message = message.replaceAll("\033\\[m", "");
+        return message;
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/chat/ChatColor/ChatColorUtils.java b/src/main/java/dev/wolveringer/chat/ChatColor/ChatColorUtils.java
index 38f6293..58a7129 100644
--- a/src/main/java/dev/wolveringer/chat/ChatColor/ChatColorUtils.java
+++ b/src/main/java/dev/wolveringer/chat/ChatColor/ChatColorUtils.java
@@ -1,162 +1,156 @@
 package dev.wolveringer.chat.ChatColor;
 
-import java.util.Map;
-import java.util.regex.Pattern;
+import com.google.common.collect.Maps;
 
 import net.md_5.bungee.api.ChatColor;
 
-import com.google.common.collect.Maps;
+import java.util.Map;
+import java.util.regex.Pattern;
 
 import dev.wolveringer.chat.ChatModifier;
 
 public class ChatColorUtils {
-	private final static Map<Character, ChatColor> BY_CHAR = Maps.newHashMap();
-	public static final char COLOR_CHAR = '\u00A7';// \u00A7
-	public static final String PREFIX = ChatColorUtils.COLOR_CHAR + "7[" + ChatColorUtils.COLOR_CHAR + "eBungeeUntil"
-			+ ChatColorUtils.COLOR_CHAR + "7]";
-	private static final Pattern STRIP_FORMAT_PATTERN = Pattern
-			.compile("(?i)" + String.valueOf(COLOR_CHAR) + "[A-FK-OR]");
-	private static final Pattern STRIP_COLOR_PATTERN = Pattern.compile("(?i)" + String.valueOf(COLOR_CHAR) + "[0-9]");
-	static {
-		for (ChatColor color : ChatColor.values()) {
-			BY_CHAR.put(color.toString().charAt(1), color);
-		}
-	}
+    public static final char COLOR_CHAR = '\u00A7';// \u00A7
+    public static final String PREFIX = ChatColorUtils.COLOR_CHAR + "7[" + ChatColorUtils.COLOR_CHAR + "eBungeeUntil"
+            + ChatColorUtils.COLOR_CHAR + "7]";
+    private final static Map<Character, ChatColor> BY_CHAR = Maps.newHashMap();
+    private static final Pattern STRIP_FORMAT_PATTERN = Pattern
+            .compile("(?i)" + String.valueOf(COLOR_CHAR) + "[A-FK-OR]");
+    private static final Pattern STRIP_COLOR_PATTERN = Pattern.compile("(?i)" + String.valueOf(COLOR_CHAR) + "[0-9]");
+
+    static {
+        for (ChatColor color : ChatColor.values()) {
+            BY_CHAR.put(color.toString().charAt(1), color);
+        }
+    }
 
-	/**
-	 * Gets the color represented by the specified color code
-	 *
-	 * @param code
-	 *            Code to check
-	 * @return Associative {@link org.bukkit.ChatColor} with the given code, or
-	 *         null if it doesn't exist
-	 */
-	public static ChatColor getByChar(char code) {
-		return BY_CHAR.get(code);
-	}
+    /**
+     * Gets the color represented by the specified color code
+     *
+     * @param code Code to check
+     * @return Associative {@link org.bukkit.ChatColor} with the given code, or null if it doesn't
+     * exist
+     */
+    public static ChatColor getByChar(char code) {
+        return BY_CHAR.get(code);
+    }
 
-	/**
-	 * Gets the color represented by the specified color code
-	 *
-	 * @param code
-	 *            Code to check
-	 * @return Associative {@link org.bukkit.ChatColor} with the given code, or
-	 *         null if it doesn't exist
-	 */
-	public static ChatColor getByChar(String code) {
-		return BY_CHAR.get(code.charAt(0));
-	}
+    /**
+     * Gets the color represented by the specified color code
+     *
+     * @param code Code to check
+     * @return Associative {@link org.bukkit.ChatColor} with the given code, or null if it doesn't
+     * exist
+     */
+    public static ChatColor getByChar(String code) {
+        return BY_CHAR.get(code.charAt(0));
+    }
 
-	/**
-	 * Gets the ChatColors used at the end of the given input string.
-	 *
-	 * @param input
-	 *            Input string to retrieve the colors from.
-	 * @return Any remaining ChatColors to pass onto the next line.
-	 */
-	public static String getLastColors(String input) {
-		String result = "";
-		int length = input.length();
-		for (int index = length - 1; index > -1; index--) {
-			char section = input.charAt(index);
-			if (section == COLOR_CHAR && index < length - 1) {
-				char c = input.charAt(index + 1);
-				ChatColor color = getByChar(c);
-				if (color != null) {
-					result = color.toString() + result;
-					if (isColor(color) || color.equals(ChatColor.RESET)) {
-						break;
-					}
-				}
-			}
-		}
-		return result;
-	}
+    /**
+     * Gets the ChatColors used at the end of the given input string.
+     *
+     * @param input Input string to retrieve the colors from.
+     * @return Any remaining ChatColors to pass onto the next line.
+     */
+    public static String getLastColors(String input) {
+        String result = "";
+        int length = input.length();
+        for (int index = length - 1; index > -1; index--) {
+            char section = input.charAt(index);
+            if (section == COLOR_CHAR && index < length - 1) {
+                char c = input.charAt(index + 1);
+                ChatColor color = getByChar(c);
+                if (color != null) {
+                    result = color.toString() + result;
+                    if (isColor(color) || color.equals(ChatColor.RESET)) {
+                        break;
+                    }
+                }
+            }
+        }
+        return result;
+    }
 
-	/**
-	 * Gets the ChatColors used at the end of the given input string.
-	 *
-	 * @param input
-	 *            Input string to retrieve the colors from.
-	 * @return Any remaining ChatColors to pass onto the next line.
-	 */
-	public static ChatModifier getLastModifierColors(String input) {
-		String in = getLastColors(input);
-		ChatModifier mod = new ChatModifier();
-		for (String s : in.split("(?<=\\G.{2})")) {
-			switch (getByChar(s.charAt(1))) {
-			case MAGIC:
-				mod.setRandom(true);
-				break;
-			case UNDERLINE:
-				mod.setUnderline(true);
-				break;
-			case STRIKETHROUGH:
-				mod.setStrikethrough(true);
-				break;
-			case BOLD:
-				mod.setBold(true);
-				break;
-			case ITALIC:
-				mod.setItalic(true);
-				break;
-			case RESET:
-				break;
-			default:
-				mod.setColor(getByChar(s.charAt(1)));
-				break;
-			}
-		}
-		return mod;
-	}
+    /**
+     * Gets the ChatColors used at the end of the given input string.
+     *
+     * @param input Input string to retrieve the colors from.
+     * @return Any remaining ChatColors to pass onto the next line.
+     */
+    public static ChatModifier getLastModifierColors(String input) {
+        String in = getLastColors(input);
+        ChatModifier mod = new ChatModifier();
+        for (String s : in.split("(?<=\\G.{2})")) {
+            switch (getByChar(s.charAt(1))) {
+                case MAGIC:
+                    mod.setRandom(true);
+                    break;
+                case UNDERLINE:
+                    mod.setUnderline(true);
+                    break;
+                case STRIKETHROUGH:
+                    mod.setStrikethrough(true);
+                    break;
+                case BOLD:
+                    mod.setBold(true);
+                    break;
+                case ITALIC:
+                    mod.setItalic(true);
+                    break;
+                case RESET:
+                    break;
+                default:
+                    mod.setColor(getByChar(s.charAt(1)));
+                    break;
+            }
+        }
+        return mod;
+    }
 
-	/**
-	 * Strips the given message of all color codes
-	 *
-	 * @param input
-	 *            String to strip of color
-	 * @return A copy of the input string, without any coloring
-	 */
-	public static String stripColor(final String input) {
-		if (input == null) {
-			return null;
-		}
-		return STRIP_COLOR_PATTERN.matcher(STRIP_FORMAT_PATTERN.matcher(input).replaceAll("")).replaceAll("");
-	}
+    /**
+     * Strips the given message of all color codes
+     *
+     * @param input String to strip of color
+     * @return A copy of the input string, without any coloring
+     */
+    public static String stripColor(final String input) {
+        if (input == null) {
+            return null;
+        }
+        return STRIP_COLOR_PATTERN.matcher(STRIP_FORMAT_PATTERN.matcher(input).replaceAll("")).replaceAll("");
+    }
 
-	public static String stripFormat(final String input) {
-		if (input == null) {
-			return null;
-		}
-		return STRIP_FORMAT_PATTERN.matcher(input).replaceAll("");
-	}
+    public static String stripFormat(final String input) {
+        if (input == null) {
+            return null;
+        }
+        return STRIP_FORMAT_PATTERN.matcher(input).replaceAll("");
+    }
 
-	/**
-	 * Translates a string using an alternate color code character into a string
-	 * that uses the internal ChatColor.COLOR_CODE color code character. The
-	 * alternate color code character will only be replaced if it is immediately
-	 * followed by 0-9, A-F, a-f, K-O, k-o, R or r.
-	 *
-	 * @param altColorChar
-	 *            The alternate color code character to replace. Ex: &
-	 * @param textToTranslate
-	 *            Text containing the alternate color code character.
-	 * @return Text containing the ChatColor.COLOR_CODE color code character.
-	 */
-	public static String translateAlternateColorCodes(char altColorChar, String textToTranslate) {
-		char[] b = textToTranslate.toCharArray();
-		for (int i = 0; i < b.length - 1; i++) {
-			if (b[i] == altColorChar && "0123456789AaBbCcDdEeFfKkLlMmNnOoRr".indexOf(b[i + 1]) > -1) {
-				b[i] = ChatColorUtils.COLOR_CHAR;
-				b[i + 1] = Character.toLowerCase(b[i + 1]);
-			}
-		}
-		return new String(b);
-	}
+    /**
+     * Translates a string using an alternate color code character into a string
+     * that uses the internal ChatColor.COLOR_CODE color code character. The
+     * alternate color code character will only be replaced if it is immediately
+     * followed by 0-9, A-F, a-f, K-O, k-o, R or r.
+     *
+     * @param altColorChar    The alternate color code character to replace. Ex: &
+     * @param textToTranslate Text containing the alternate color code character.
+     * @return Text containing the ChatColor.COLOR_CODE color code character.
+     */
+    public static String translateAlternateColorCodes(char altColorChar, String textToTranslate) {
+        char[] b = textToTranslate.toCharArray();
+        for (int i = 0; i < b.length - 1; i++) {
+            if (b[i] == altColorChar && "0123456789AaBbCcDdEeFfKkLlMmNnOoRr".indexOf(b[i + 1]) > -1) {
+                b[i] = ChatColorUtils.COLOR_CHAR;
+                b[i + 1] = Character.toLowerCase(b[i + 1]);
+            }
+        }
+        return new String(b);
+    }
 
-	public static boolean isColor(ChatColor color) {
-		if (color == null)
-			return false;
-		return !"".equalsIgnoreCase(stripFormat(color.toString()));
-	}
+    public static boolean isColor(ChatColor color) {
+        if (color == null)
+            return false;
+        return !"".equalsIgnoreCase(stripFormat(color.toString()));
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/chat/ChatComponentText.java b/src/main/java/dev/wolveringer/chat/ChatComponentText.java
index 4ce69f7..ae38e47 100644
--- a/src/main/java/dev/wolveringer/chat/ChatComponentText.java
+++ b/src/main/java/dev/wolveringer/chat/ChatComponentText.java
@@ -1,83 +1,84 @@
 package dev.wolveringer.chat;
 
+import net.md_5.bungee.api.ChatColor;
+
 import java.util.Iterator;
 
-import net.md_5.bungee.api.ChatColor;
+public class ChatComponentText extends ChatBaseComponent {
+
+    private final String message;
 
-public class ChatComponentText extends ChatBaseComponent{
+    public ChatComponentText(String s) {
+        this.message = s;
+    }
 
-	private final String message;
+    @Override
+    public String getText() {
+        return this.message;
+    }
 
-	public ChatComponentText(String s) {
-		this.message = s;
-	}
+    @Override
+    public boolean equals(Object object) {
+        if (this == object) {
+            return true;
+        } else if (!(object instanceof ChatComponentText)) {
+            return false;
+        } else {
+            ChatComponentText chatcomponenttext = (ChatComponentText) object;
+            return this.message.equals(chatcomponenttext.getText()) && super.equals(object);
+        }
+    }
 
-	@Override
-	public String getText() {
-		return this.message;
-	}
+    @SuppressWarnings("unchecked")
+    @Override
+    public IChatBaseComponent addSibling() {
+        ChatComponentText chatcomponenttext = new ChatComponentText(this.message);
 
-	@Override
-	public boolean equals(Object object) {
-		if(this == object){
-			return true;
-		}else if(!(object instanceof ChatComponentText)){
-			return false;
-		}else{
-			ChatComponentText chatcomponenttext = (ChatComponentText) object;
-			return this.message.equals(chatcomponenttext.getText()) && super.equals(object);
-		}
-	}
+        chatcomponenttext.setChatModifier(this.getChatModifier().clone());
+        Iterator<IChatBaseComponent> iterator = this.getSiblings().iterator();
 
-	@SuppressWarnings("unchecked")
-	@Override
-	public IChatBaseComponent addSibling() {
-		ChatComponentText chatcomponenttext = new ChatComponentText(this.message);
+        while (iterator.hasNext()) {
+            chatcomponenttext.addSibling(iterator.next().addSibling());
+        }
 
-		chatcomponenttext.setChatModifier(this.getChatModifier().clone());
-		Iterator<IChatBaseComponent> iterator = this.getSiblings().iterator();
+        return chatcomponenttext;
+    }
 
-		while (iterator.hasNext()){
-			chatcomponenttext.addSibling(iterator.next().addSibling());
-		}
+    @Override
+    public String toString() {
+        return toString(StringMethode.LIST_VAR);
+    }
 
-		return chatcomponenttext;
-	}
-	@Override
-	public String toString() {
-		return toString(StringMethode.LIST_VAR);
-	}
-	
-	public String toString(StringMethode m) {
-		if(m == StringMethode.LIST_VAR)
-			return "TextComponent{text=\'" + this.message + '\'' + ", siblings=" + this.texte + ", style=" + this.getChatModifier() + '}';
-		else if(m == StringMethode.LIST_NOT_NULL_VAR){
-			StringBuilder builder = new StringBuilder();
-			builder.append("TextComponent{");
-			if(this.message != null  && !"".equalsIgnoreCase(this.message)){
-				builder.append("text=");
-				builder.append(this.message);
-				builder.append(", ");
-			}
-			if(this.modifier != null){
-				builder.append("style=");
-				builder.append(this.modifier.toString(m));
-				builder.append(", ");
-			}
-			if(this.texte != null){
-				builder.append("siblings=[");
-				for(IChatBaseComponent c : texte)
-					builder.append(c.toString(m)+", ");
-				builder.append("]");
-			}
-			return builder.append("}").toString().replaceAll(", \\}", "").replaceAll(", \\]", "");
-		}else if(m == StringMethode.MESSAGE_COLORED){
-			return ChatSerializer.toMessage(this, ""+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"f");
-		}else if(m == StringMethode.MESSAGE_UNCOLORED){
-			return ChatColor.stripColor(ChatSerializer.toMessage(this, ""+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"f"));
-		}else if(m == StringMethode.JSON){
-			return ChatSerializer.toJSONString(this);
-		}
-		return "";
-	}
+    public String toString(StringMethode m) {
+        if (m == StringMethode.LIST_VAR)
+            return "TextComponent{text=\'" + this.message + '\'' + ", siblings=" + this.texte + ", style=" + this.getChatModifier() + '}';
+        else if (m == StringMethode.LIST_NOT_NULL_VAR) {
+            StringBuilder builder = new StringBuilder();
+            builder.append("TextComponent{");
+            if (this.message != null && !"".equalsIgnoreCase(this.message)) {
+                builder.append("text=");
+                builder.append(this.message);
+                builder.append(", ");
+            }
+            if (this.modifier != null) {
+                builder.append("style=");
+                builder.append(this.modifier.toString(m));
+                builder.append(", ");
+            }
+            if (this.texte != null) {
+                builder.append("siblings=[");
+                for (IChatBaseComponent c : texte)
+                    builder.append(c.toString(m) + ", ");
+                builder.append("]");
+            }
+            return builder.append("}").toString().replaceAll(", \\}", "").replaceAll(", \\]", "");
+        } else if (m == StringMethode.MESSAGE_COLORED) {
+            return ChatSerializer.toMessage(this, "" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "f");
+        } else if (m == StringMethode.MESSAGE_UNCOLORED) {
+            return ChatColor.stripColor(ChatSerializer.toMessage(this, "" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "f"));
+        } else if (m == StringMethode.JSON) {
+            return ChatSerializer.toJSONString(this);
+        }
+        return "";
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/chat/ChatFunction1.java b/src/main/java/dev/wolveringer/chat/ChatFunction1.java
index a9d1cde..4e1a0ad 100644
--- a/src/main/java/dev/wolveringer/chat/ChatFunction1.java
+++ b/src/main/java/dev/wolveringer/chat/ChatFunction1.java
@@ -2,13 +2,14 @@ package dev.wolveringer.chat;
 
 import com.google.common.base.Function;
 
-@SuppressWarnings({ "rawtypes" })
+@SuppressWarnings({"rawtypes"})
 final class ChatFunction1 implements Function {
 
-	ChatFunction1() {}
+    ChatFunction1() {
+    }
 
-	@Override
-	public Object apply(Object object) {
-		return ((IChatBaseComponent) object).iterator();
-	}
+    @Override
+    public Object apply(Object object) {
+        return ((IChatBaseComponent) object).iterator();
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/chat/ChatFunction2.java b/src/main/java/dev/wolveringer/chat/ChatFunction2.java
index f5443e7..996dfbb 100644
--- a/src/main/java/dev/wolveringer/chat/ChatFunction2.java
+++ b/src/main/java/dev/wolveringer/chat/ChatFunction2.java
@@ -4,13 +4,14 @@ import com.google.common.base.Function;
 
 @SuppressWarnings("rawtypes")
 final class ChatFunction2 implements Function {
-	ChatFunction2() {}
-	
-	@Override
-	public Object apply(Object object) {
-		IChatBaseComponent obj = (IChatBaseComponent) object;
-		IChatBaseComponent silber = obj.addSibling();
-		silber.setChatModifier(silber.getChatModifier().getChatModifier());
-		return silber;
-	}
+    ChatFunction2() {
+    }
+
+    @Override
+    public Object apply(Object object) {
+        IChatBaseComponent obj = (IChatBaseComponent) object;
+        IChatBaseComponent silber = obj.addSibling();
+        silber.setChatModifier(silber.getChatModifier().getChatModifier());
+        return silber;
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/chat/ChatHoverable.java b/src/main/java/dev/wolveringer/chat/ChatHoverable.java
index de069d2..64f0262 100644
--- a/src/main/java/dev/wolveringer/chat/ChatHoverable.java
+++ b/src/main/java/dev/wolveringer/chat/ChatHoverable.java
@@ -3,57 +3,57 @@ package dev.wolveringer.chat;
 
 public class ChatHoverable {
 
-	private final EnumHoverAction action;
-	private final IChatBaseComponent value;
-
-	public ChatHoverable(EnumHoverAction enumhoveraction, IChatBaseComponent ichatbasecomponent) {
-		this.action = enumhoveraction;
-		this.value = ichatbasecomponent;
-	}
-
-	public EnumHoverAction getAction() {
-		return this.action;
-	}
-
-	public IChatBaseComponent getValue() {
-		return this.value;
-	}
-
-	@Override
-	public boolean equals(Object object) {
-		if(this == object){
-			return true;
-		}else if(object != null && this.getClass() == object.getClass()){
-			ChatHoverable chathoverable = (ChatHoverable) object;
-
-			if(this.action != chathoverable.action){
-				return false;
-			}else{
-				if(this.value != null){
-					if(!this.value.equals(chathoverable.value)){
-						return false;
-					}
-				}else if(chathoverable.value != null){
-					return false;
-				}
-
-				return true;
-			}
-		}else{
-			return false;
-		}
-	}
-
-	@Override
-	public int hashCode() {
-		int i = this.action.hashCode();
-
-		i = 31 * i + (this.value != null ? this.value.hashCode() : 0);
-		return i;
-	}
-
-	@Override
-	public String toString() {
-		return "HoverEvent{action=" + this.action + ", value=\'" + this.value + '\'' + '}';
-	}
+    private final EnumHoverAction action;
+    private final IChatBaseComponent value;
+
+    public ChatHoverable(EnumHoverAction enumhoveraction, IChatBaseComponent ichatbasecomponent) {
+        this.action = enumhoveraction;
+        this.value = ichatbasecomponent;
+    }
+
+    public EnumHoverAction getAction() {
+        return this.action;
+    }
+
+    public IChatBaseComponent getValue() {
+        return this.value;
+    }
+
+    @Override
+    public boolean equals(Object object) {
+        if (this == object) {
+            return true;
+        } else if (object != null && this.getClass() == object.getClass()) {
+            ChatHoverable chathoverable = (ChatHoverable) object;
+
+            if (this.action != chathoverable.action) {
+                return false;
+            } else {
+                if (this.value != null) {
+                    if (!this.value.equals(chathoverable.value)) {
+                        return false;
+                    }
+                } else if (chathoverable.value != null) {
+                    return false;
+                }
+
+                return true;
+            }
+        } else {
+            return false;
+        }
+    }
+
+    @Override
+    public int hashCode() {
+        int i = this.action.hashCode();
+
+        i = 31 * i + (this.value != null ? this.value.hashCode() : 0);
+        return i;
+    }
+
+    @Override
+    public String toString() {
+        return "HoverEvent{action=" + this.action + ", value=\'" + this.value + '\'' + '}';
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/chat/ChatMessage.java b/src/main/java/dev/wolveringer/chat/ChatMessage.java
index 86da2af..b8d6434 100644
--- a/src/main/java/dev/wolveringer/chat/ChatMessage.java
+++ b/src/main/java/dev/wolveringer/chat/ChatMessage.java
@@ -1,148 +1,146 @@
 package dev.wolveringer.chat;
 
+import com.google.common.collect.Iterators;
+import com.google.common.collect.Lists;
+
 import java.util.Arrays;
-import java.util.IllegalFormatException;
 import java.util.Iterator;
 import java.util.List;
-import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
-import com.google.common.collect.Iterators;
-import com.google.common.collect.Lists;
-
-@SuppressWarnings({"unused","unchecked"})
+@SuppressWarnings({"unused", "unchecked"})
 public class ChatMessage extends ChatBaseComponent {
 
-	public static final Pattern pattern = Pattern.compile("%(?:(\\d+)\\$)?([A-Za-z%]|$)");
-	List<IChatBaseComponent> siblings = Lists.newArrayList();
-	private final String translationKey;
-	private final Object[] values;
-
-	public ChatMessage(String s, Object... aobject) {
-		this.translationKey = s;
-		this.values = aobject;
-		Object[] aobject1 = aobject;
-		int i = aobject.length;
-
-		for(int j = 0;j < i;++j){
-			Object object = aobject1[j];
-			if(object instanceof IChatBaseComponent){
-				((IChatBaseComponent) object).getChatModifier().setChatModifier(this.getChatModifier());
-			}
-		}
-	}
-
-	private IChatBaseComponent getText(int i){
-		if(i >= this.values.length){
-			throw new ChatMessageException(this, i);
-		}else{
-			Object object = this.values[i];
-			Object object1;
-
-			if(object instanceof IChatBaseComponent){
-				object1 = object;
-			}else{
-				object1 = new ChatComponentText(object == null ? "null" : object.toString());
-				((IChatBaseComponent) object1).getChatModifier().setChatModifier(this.getChatModifier());
-			}
-
-			return (IChatBaseComponent) object1;
-		}
-	}
-
-	@Override
-	public String getText() {
-		StringBuilder stringbuilder = new StringBuilder();
-		Iterator<IChatBaseComponent> iterator = this.siblings.iterator();
-
-		while (iterator.hasNext())
-			stringbuilder.append(iterator.next().getText());
-
-		return stringbuilder.toString();
-	}
-
-	@Override
-	public boolean equals(Object object) {
-		if(this == object){
-			return true;
-		}else if(!(object instanceof ChatMessage)){
-			return false;
-		}else{
-			ChatMessage chatmessage = (ChatMessage) object;
-
-			return Arrays.equals(this.values, chatmessage.values) && this.translationKey.equals(chatmessage.translationKey) && super.equals(object);
-		}
-	}
-
-	@Override
-	public ChatMessage addSibling() {
-		Object[] aobject = new Object[this.values.length];
-
-		for(int i = 0;i < this.values.length;++i){
-			if(this.values[i] instanceof IChatBaseComponent){
-				aobject[i] = ((IChatBaseComponent) this.values[i]).addSibling();
-			}else{
-				aobject[i] = this.values[i];
-			}
-		}
-
-		ChatMessage chatmessage = new ChatMessage(this.translationKey, aobject);
-
-		chatmessage.setChatModifier(this.getChatModifier().clone());
-		Iterator<IChatBaseComponent> iterator = this.getSiblings().iterator();
-
-		while (iterator.hasNext())
-			chatmessage.addSibling(iterator.next().addSibling());
-
-		return chatmessage;
-	}
-
-	@Override
-	public int hashCode() {
-		int i = super.hashCode();
-
-		i = 31 * i + this.translationKey.hashCode();
-		i = 31 * i + Arrays.hashCode(this.values);
-		return i;
-	}
-
-	public String getLanguage() {
-		return this.translationKey;
-	}
-
-	@Override
-	public Iterator<IChatBaseComponent> iterator() {
-		return Iterators.concat(this.siblings.iterator(), this.texte.iterator());
-	}
-
-	public Object[] getData() {
-		return this.values;
-	}
-
-	@Override
-	public IChatBaseComponent setChatModifier(ChatModifier chatmodifier) {
-		super.setChatModifier(chatmodifier);
-		for(int j = 0;j < this.values.length;++j){
-			if(this.values[j] instanceof IChatBaseComponent)
-				((IChatBaseComponent) this.values[j]).getChatModifier().setChatModifier(this.getChatModifier());
-		}
-		if(false){
-			Iterator<IChatBaseComponent> iterator = this.siblings.iterator();
-			while (iterator.hasNext()){
-				iterator.next().getChatModifier().setChatModifier(chatmodifier);
-			}
-		}
-
-		return this;
-	}
-
-	@Override
-	public String toString() {
-		return "TranslatableComponent{key=\'" + this.translationKey + '\'' + ", args=" + Arrays.toString(this.values) + ", siblings=" + this.texte + ", style=" + this.getChatModifier() + '}';
-	}
-
-	@Override
-	public String toString(StringMethode m) {
-		return null;
-	}
+    public static final Pattern pattern = Pattern.compile("%(?:(\\d+)\\$)?([A-Za-z%]|$)");
+    private final String translationKey;
+    private final Object[] values;
+    List<IChatBaseComponent> siblings = Lists.newArrayList();
+
+    public ChatMessage(String s, Object... aobject) {
+        this.translationKey = s;
+        this.values = aobject;
+        Object[] aobject1 = aobject;
+        int i = aobject.length;
+
+        for (int j = 0; j < i; ++j) {
+            Object object = aobject1[j];
+            if (object instanceof IChatBaseComponent) {
+                ((IChatBaseComponent) object).getChatModifier().setChatModifier(this.getChatModifier());
+            }
+        }
+    }
+
+    private IChatBaseComponent getText(int i) {
+        if (i >= this.values.length) {
+            throw new ChatMessageException(this, i);
+        } else {
+            Object object = this.values[i];
+            Object object1;
+
+            if (object instanceof IChatBaseComponent) {
+                object1 = object;
+            } else {
+                object1 = new ChatComponentText(object == null ? "null" : object.toString());
+                ((IChatBaseComponent) object1).getChatModifier().setChatModifier(this.getChatModifier());
+            }
+
+            return (IChatBaseComponent) object1;
+        }
+    }
+
+    @Override
+    public String getText() {
+        StringBuilder stringbuilder = new StringBuilder();
+        Iterator<IChatBaseComponent> iterator = this.siblings.iterator();
+
+        while (iterator.hasNext())
+            stringbuilder.append(iterator.next().getText());
+
+        return stringbuilder.toString();
+    }
+
+    @Override
+    public boolean equals(Object object) {
+        if (this == object) {
+            return true;
+        } else if (!(object instanceof ChatMessage)) {
+            return false;
+        } else {
+            ChatMessage chatmessage = (ChatMessage) object;
+
+            return Arrays.equals(this.values, chatmessage.values) && this.translationKey.equals(chatmessage.translationKey) && super.equals(object);
+        }
+    }
+
+    @Override
+    public ChatMessage addSibling() {
+        Object[] aobject = new Object[this.values.length];
+
+        for (int i = 0; i < this.values.length; ++i) {
+            if (this.values[i] instanceof IChatBaseComponent) {
+                aobject[i] = ((IChatBaseComponent) this.values[i]).addSibling();
+            } else {
+                aobject[i] = this.values[i];
+            }
+        }
+
+        ChatMessage chatmessage = new ChatMessage(this.translationKey, aobject);
+
+        chatmessage.setChatModifier(this.getChatModifier().clone());
+        Iterator<IChatBaseComponent> iterator = this.getSiblings().iterator();
+
+        while (iterator.hasNext())
+            chatmessage.addSibling(iterator.next().addSibling());
+
+        return chatmessage;
+    }
+
+    @Override
+    public int hashCode() {
+        int i = super.hashCode();
+
+        i = 31 * i + this.translationKey.hashCode();
+        i = 31 * i + Arrays.hashCode(this.values);
+        return i;
+    }
+
+    public String getLanguage() {
+        return this.translationKey;
+    }
+
+    @Override
+    public Iterator<IChatBaseComponent> iterator() {
+        return Iterators.concat(this.siblings.iterator(), this.texte.iterator());
+    }
+
+    public Object[] getData() {
+        return this.values;
+    }
+
+    @Override
+    public IChatBaseComponent setChatModifier(ChatModifier chatmodifier) {
+        super.setChatModifier(chatmodifier);
+        for (int j = 0; j < this.values.length; ++j) {
+            if (this.values[j] instanceof IChatBaseComponent)
+                ((IChatBaseComponent) this.values[j]).getChatModifier().setChatModifier(this.getChatModifier());
+        }
+        if (false) {
+            Iterator<IChatBaseComponent> iterator = this.siblings.iterator();
+            while (iterator.hasNext()) {
+                iterator.next().getChatModifier().setChatModifier(chatmodifier);
+            }
+        }
+
+        return this;
+    }
+
+    @Override
+    public String toString() {
+        return "TranslatableComponent{key=\'" + this.translationKey + '\'' + ", args=" + Arrays.toString(this.values) + ", siblings=" + this.texte + ", style=" + this.getChatModifier() + '}';
+    }
+
+    @Override
+    public String toString(StringMethode m) {
+        return null;
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/chat/ChatMessageException.java b/src/main/java/dev/wolveringer/chat/ChatMessageException.java
index e99463f..6c07c74 100644
--- a/src/main/java/dev/wolveringer/chat/ChatMessageException.java
+++ b/src/main/java/dev/wolveringer/chat/ChatMessageException.java
@@ -4,15 +4,15 @@ package dev.wolveringer.chat;
 @SuppressWarnings("serial")
 public class ChatMessageException extends IllegalArgumentException {
 
-	public ChatMessageException(ChatMessage chatmessage, int i) {
-		super(String.format("Invalid index %d requested for %s", new Object[] { Integer.valueOf(i), chatmessage }));
-	}
+    public ChatMessageException(ChatMessage chatmessage, int i) {
+        super(String.format("Invalid index %d requested for %s", new Object[]{Integer.valueOf(i), chatmessage}));
+    }
 
-	public ChatMessageException(ChatMessage chatmessage, String s) {
-		super(String.format("Error parsing: %s: %s", new Object[] { chatmessage, s }));
-	}
+    public ChatMessageException(ChatMessage chatmessage, String s) {
+        super(String.format("Error parsing: %s: %s", new Object[]{chatmessage, s}));
+    }
 
-	public ChatMessageException(ChatMessage chatmessage, Throwable throwable) {
-		super(String.format("Error while parsing: %s", new Object[] { chatmessage }), throwable);
-	}
+    public ChatMessageException(ChatMessage chatmessage, Throwable throwable) {
+        super(String.format("Error while parsing: %s", new Object[]{chatmessage}), throwable);
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/chat/ChatModifier.java b/src/main/java/dev/wolveringer/chat/ChatModifier.java
index d00c34a..37ae032 100644
--- a/src/main/java/dev/wolveringer/chat/ChatModifier.java
+++ b/src/main/java/dev/wolveringer/chat/ChatModifier.java
@@ -4,268 +4,269 @@ import net.md_5.bungee.api.ChatColor;
 
 public class ChatModifier {
 
-	private static final ChatModifier defaultModifier = new ChatStyleRoot();
-
-	private ChatModifier modifier;
-
-	private ChatColor color;
-	private Boolean bold = false;
-
-	private Boolean italic = false;
-
-	private Boolean underlined = false;
-
-	private Boolean strikethrough = false;
-
-	private Boolean obfuscated = false;
-
-	private ChatClickable click;
-
-	private ChatHoverable hover;
-
-	public ChatModifier() {
-	}
-
-	public ChatModifier(ChatColor color, Boolean bold, Boolean italic, Boolean underlined, Boolean strikethrough, Boolean obfuscated, ChatClickable click, ChatHoverable hover) {
-		this.color = color;
-		this.bold = bold;
-		this.italic = italic;
-		this.underlined = underlined;
-		this.strikethrough = strikethrough;
-		this.obfuscated = obfuscated;
-		this.click = click;
-		this.hover = hover;
-	}
-
-	public ChatColor getColor() {
-		return this.color == null ? this.getModifier().getColor() : this.color;
-	}
-
-	public ChatModifier setChatModifier(ChatModifier chatmodifier) {
-		this.modifier = chatmodifier;
-		return this;
-	}
-
-	public boolean isBold() {
-		return this.bold == null ? this.getModifier().isBold() : this.bold.booleanValue();
-	}
-
-	public boolean isItalic() {
-		return this.italic == null ? this.getModifier().isItalic() : this.italic.booleanValue();
-	}
-
-	@Override
-	public ChatModifier clone() {
-		ChatModifier chatmodifier = new ChatModifier();
-		chatmodifier.bold = this.bold;
-		chatmodifier.italic = this.italic;
-		chatmodifier.strikethrough = this.strikethrough;
-		chatmodifier.underlined = this.underlined;
-		chatmodifier.obfuscated = this.obfuscated;
-		chatmodifier.color = this.color;
-		chatmodifier.click = this.click;
-		chatmodifier.hover = this.hover;
-		chatmodifier.modifier = this.modifier;
-		return chatmodifier;
-	}
-
-	public boolean isStrikethrough() {
-		return this.strikethrough == null ? this.getModifier().isStrikethrough() : this.strikethrough.booleanValue();
-	}
-
-	public boolean isUnderlined() {
-		return this.underlined == null ? this.getModifier().isUnderlined() : this.underlined.booleanValue();
-	}
-
-	@Override
-	public boolean equals(Object object) {
-		if(this == object){
-			return true;
-		}else if(!(object instanceof ChatModifier)){
-			return false;
-		}else{
-			ChatModifier chatmodifier = (ChatModifier) object;
-			boolean flag;
-
-			if(this.isBold() == chatmodifier.isBold() && this.getColor() == chatmodifier.getColor() && this.isItalic() == chatmodifier.isItalic() && this.isObfuscated() == chatmodifier.isObfuscated() && this.isStrikethrough() == chatmodifier.isStrikethrough() && this.isUnderlined() == chatmodifier.isUnderlined()){
-				label56: {
-					if(this.getClick() != null){
-						if(!this.getClick().equals(chatmodifier.getClick())){
-							break label56;
-						}
-					}else if(chatmodifier.getClick() != null){
-						break label56;
-					}
-
-					if(this.getHover() != null){
-						if(!this.getHover().equals(chatmodifier.getHover())){
-							break label56;
-						}
-					}else if(chatmodifier.getHover() != null){
-						break label56;
-					}
-
-					flag = true;
-					return flag;
-				}
-			}
-
-			flag = false;
-			return flag;
-		}
-	}
-
-	public boolean isObfuscated() {
-		return this.obfuscated == null ? this.getModifier().isObfuscated() : this.obfuscated.booleanValue();
-	}
-
-	public boolean hasOwnStyle() {
-		return this.bold == null && this.italic == null && this.strikethrough == null && this.underlined == null && this.obfuscated == null && this.color == null && this.click == null && this.hover == null;
-	}
-
-	public ChatClickable getClick() {
-		return this.click == null ? this.getModifier().getClick() : this.click;
-	}
-
-	@Override
-	public int hashCode() {
-		int i = this.color.hashCode();
-
-		i = 31 * i + this.bold.hashCode();
-		i = 31 * i + this.italic.hashCode();
-		i = 31 * i + this.underlined.hashCode();
-		i = 31 * i + this.strikethrough.hashCode();
-		i = 31 * i + this.obfuscated.hashCode();
-		i = 31 * i + this.click.hashCode();
-		i = 31 * i + this.hover.hashCode();
-		return i;
-	}
-
-	public ChatHoverable getHover() {
-		return this.hover == null ? this.getModifier().getHover() : this.hover;
-	}
-
-	public ChatModifier getChatModifier() {
-		ChatModifier chatmodifier = new ChatModifier();
-		chatmodifier.setBold(Boolean.valueOf(this.isBold()));
-		chatmodifier.setItalic(Boolean.valueOf(this.isItalic()));
-		chatmodifier.setStrikethrough(Boolean.valueOf(this.isStrikethrough()));
-		chatmodifier.setUnderline(Boolean.valueOf(this.isUnderlined()));
-		chatmodifier.setRandom(Boolean.valueOf(this.isObfuscated()));
-		chatmodifier.setColor(this.getColor());
-		chatmodifier.setChatClickable(this.getClick());
-		chatmodifier.setHover(this.getHover());
-		return chatmodifier;
-	}
-
-	private ChatModifier getModifier() {
-		return this.modifier == null ? defaultModifier : this.modifier;
-	}
-
-	public ChatModifier setBold(Boolean obool) {
-		this.bold = obool;
-		return this;
-	}
-
-	public ChatModifier setChatClickable(ChatClickable chatclickable) {
-		this.click = chatclickable;
-		return this;
-	}
-
-	public ChatModifier setHover(ChatHoverable hover) {
-		this.hover = hover;
-		return this;
-	}
-
-	public ChatModifier setColor(ChatColor enumchatformat) {
-		this.color = enumchatformat;
-		return this;
-	}
-
-	public ChatModifier setItalic(Boolean obool) {
-		this.italic = obool;
-		return this;
-	}
-
-	public ChatModifier setRandom(Boolean obool) {
-		this.obfuscated = obool;
-		return this;
-	}
-
-	public ChatModifier setStrikethrough(Boolean obool) {
-		this.strikethrough = obool;
-		return this;
-	}
-
-	public ChatModifier setUnderline(Boolean obool) {
-		this.underlined = obool;
-		return this;
-	}
-
-	public void resetColors() {
-		bold = null;
-		color = null;
-		italic = null;
-		obfuscated = null;
-		strikethrough = null;
-		underlined = null;
-	}
-	
-	@Override
-	public String toString() {
-		return "Style{hasParent=" + (this.modifier != null) + ", color=" + this.color + ", bold=" + this.bold + ", italic=" + this.italic + ", underlined=" + this.underlined + ", strikethrough=" + this.strikethrough + ", obfuscated=" + this.obfuscated + ", clickEvent=" + this.getClick() + ", hoverEvent=" + this.getHover() + '}';
-	}
-
-	public String toString(StringMethode m) {
-		if(m == StringMethode.LIST_NOT_NULL_VAR){
-			StringBuilder builder = new StringBuilder();
-			builder.append("Style");
-			builder.append("{");
-			builder.append("hasParent=");
-			builder.append(this.modifier != null);
-			builder.append(", ");
-			if(this.color != null){
-				builder.append("color=");
-				builder.append(this.color);
-				builder.append(", ");
-			}
-			if(this.bold != null){
-				builder.append("bold=");
-				builder.append(this.bold);
-				builder.append(", ");
-			}
-			if(this.italic != null){
-				builder.append("italic=");
-				builder.append(this.italic);
-				builder.append(", ");
-			}
-			if(this.underlined != null){
-				builder.append("underlined=");
-				builder.append(this.underlined);
-				builder.append(", ");
-			}
-			if(this.strikethrough != null){
-				builder.append("strikethrough=");
-				builder.append(this.strikethrough);
-				builder.append(", ");
-			}
-			if(this.obfuscated != null){
-				builder.append("obfuscated=");
-				builder.append(this.obfuscated);
-				builder.append(", ");
-			}
-			if(this.click != null){
-				builder.append("clickEvent=");
-				builder.append(this.click);
-				builder.append(", ");
-			}
-			if(this.hover != null){
-				builder.append("hoverEvent=");
-				builder.append(this.hover);
-			}
-			builder.append("}");
-			return builder.toString();
-		}
-		return toString();
-	}
+    private static final ChatModifier defaultModifier = new ChatStyleRoot();
+
+    private ChatModifier modifier;
+
+    private ChatColor color;
+    private Boolean bold = false;
+
+    private Boolean italic = false;
+
+    private Boolean underlined = false;
+
+    private Boolean strikethrough = false;
+
+    private Boolean obfuscated = false;
+
+    private ChatClickable click;
+
+    private ChatHoverable hover;
+
+    public ChatModifier() {
+    }
+
+    public ChatModifier(ChatColor color, Boolean bold, Boolean italic, Boolean underlined, Boolean strikethrough, Boolean obfuscated, ChatClickable click, ChatHoverable hover) {
+        this.color = color;
+        this.bold = bold;
+        this.italic = italic;
+        this.underlined = underlined;
+        this.strikethrough = strikethrough;
+        this.obfuscated = obfuscated;
+        this.click = click;
+        this.hover = hover;
+    }
+
+    public ChatColor getColor() {
+        return this.color == null ? this.getModifier().getColor() : this.color;
+    }
+
+    public ChatModifier setColor(ChatColor enumchatformat) {
+        this.color = enumchatformat;
+        return this;
+    }
+
+    public boolean isBold() {
+        return this.bold == null ? this.getModifier().isBold() : this.bold.booleanValue();
+    }
+
+    public ChatModifier setBold(Boolean obool) {
+        this.bold = obool;
+        return this;
+    }
+
+    public boolean isItalic() {
+        return this.italic == null ? this.getModifier().isItalic() : this.italic.booleanValue();
+    }
+
+    public ChatModifier setItalic(Boolean obool) {
+        this.italic = obool;
+        return this;
+    }
+
+    @Override
+    public ChatModifier clone() {
+        ChatModifier chatmodifier = new ChatModifier();
+        chatmodifier.bold = this.bold;
+        chatmodifier.italic = this.italic;
+        chatmodifier.strikethrough = this.strikethrough;
+        chatmodifier.underlined = this.underlined;
+        chatmodifier.obfuscated = this.obfuscated;
+        chatmodifier.color = this.color;
+        chatmodifier.click = this.click;
+        chatmodifier.hover = this.hover;
+        chatmodifier.modifier = this.modifier;
+        return chatmodifier;
+    }
+
+    public boolean isStrikethrough() {
+        return this.strikethrough == null ? this.getModifier().isStrikethrough() : this.strikethrough.booleanValue();
+    }
+
+    public ChatModifier setStrikethrough(Boolean obool) {
+        this.strikethrough = obool;
+        return this;
+    }
+
+    public boolean isUnderlined() {
+        return this.underlined == null ? this.getModifier().isUnderlined() : this.underlined.booleanValue();
+    }
+
+    @Override
+    public boolean equals(Object object) {
+        if (this == object) {
+            return true;
+        } else if (!(object instanceof ChatModifier)) {
+            return false;
+        } else {
+            ChatModifier chatmodifier = (ChatModifier) object;
+            boolean flag;
+
+            if (this.isBold() == chatmodifier.isBold() && this.getColor() == chatmodifier.getColor() && this.isItalic() == chatmodifier.isItalic() && this.isObfuscated() == chatmodifier.isObfuscated() && this.isStrikethrough() == chatmodifier.isStrikethrough() && this.isUnderlined() == chatmodifier.isUnderlined()) {
+                label56:
+                {
+                    if (this.getClick() != null) {
+                        if (!this.getClick().equals(chatmodifier.getClick())) {
+                            break label56;
+                        }
+                    } else if (chatmodifier.getClick() != null) {
+                        break label56;
+                    }
+
+                    if (this.getHover() != null) {
+                        if (!this.getHover().equals(chatmodifier.getHover())) {
+                            break label56;
+                        }
+                    } else if (chatmodifier.getHover() != null) {
+                        break label56;
+                    }
+
+                    flag = true;
+                    return flag;
+                }
+            }
+
+            flag = false;
+            return flag;
+        }
+    }
+
+    public boolean isObfuscated() {
+        return this.obfuscated == null ? this.getModifier().isObfuscated() : this.obfuscated.booleanValue();
+    }
+
+    public boolean hasOwnStyle() {
+        return this.bold == null && this.italic == null && this.strikethrough == null && this.underlined == null && this.obfuscated == null && this.color == null && this.click == null && this.hover == null;
+    }
+
+    public ChatClickable getClick() {
+        return this.click == null ? this.getModifier().getClick() : this.click;
+    }
+
+    @Override
+    public int hashCode() {
+        int i = this.color.hashCode();
+
+        i = 31 * i + this.bold.hashCode();
+        i = 31 * i + this.italic.hashCode();
+        i = 31 * i + this.underlined.hashCode();
+        i = 31 * i + this.strikethrough.hashCode();
+        i = 31 * i + this.obfuscated.hashCode();
+        i = 31 * i + this.click.hashCode();
+        i = 31 * i + this.hover.hashCode();
+        return i;
+    }
+
+    public ChatHoverable getHover() {
+        return this.hover == null ? this.getModifier().getHover() : this.hover;
+    }
+
+    public ChatModifier setHover(ChatHoverable hover) {
+        this.hover = hover;
+        return this;
+    }
+
+    public ChatModifier getChatModifier() {
+        ChatModifier chatmodifier = new ChatModifier();
+        chatmodifier.setBold(Boolean.valueOf(this.isBold()));
+        chatmodifier.setItalic(Boolean.valueOf(this.isItalic()));
+        chatmodifier.setStrikethrough(Boolean.valueOf(this.isStrikethrough()));
+        chatmodifier.setUnderline(Boolean.valueOf(this.isUnderlined()));
+        chatmodifier.setRandom(Boolean.valueOf(this.isObfuscated()));
+        chatmodifier.setColor(this.getColor());
+        chatmodifier.setChatClickable(this.getClick());
+        chatmodifier.setHover(this.getHover());
+        return chatmodifier;
+    }
+
+    public ChatModifier setChatModifier(ChatModifier chatmodifier) {
+        this.modifier = chatmodifier;
+        return this;
+    }
+
+    private ChatModifier getModifier() {
+        return this.modifier == null ? defaultModifier : this.modifier;
+    }
+
+    public ChatModifier setChatClickable(ChatClickable chatclickable) {
+        this.click = chatclickable;
+        return this;
+    }
+
+    public ChatModifier setRandom(Boolean obool) {
+        this.obfuscated = obool;
+        return this;
+    }
+
+    public ChatModifier setUnderline(Boolean obool) {
+        this.underlined = obool;
+        return this;
+    }
+
+    public void resetColors() {
+        bold = null;
+        color = null;
+        italic = null;
+        obfuscated = null;
+        strikethrough = null;
+        underlined = null;
+    }
+
+    @Override
+    public String toString() {
+        return "Style{hasParent=" + (this.modifier != null) + ", color=" + this.color + ", bold=" + this.bold + ", italic=" + this.italic + ", underlined=" + this.underlined + ", strikethrough=" + this.strikethrough + ", obfuscated=" + this.obfuscated + ", clickEvent=" + this.getClick() + ", hoverEvent=" + this.getHover() + '}';
+    }
+
+    public String toString(StringMethode m) {
+        if (m == StringMethode.LIST_NOT_NULL_VAR) {
+            StringBuilder builder = new StringBuilder();
+            builder.append("Style");
+            builder.append("{");
+            builder.append("hasParent=");
+            builder.append(this.modifier != null);
+            builder.append(", ");
+            if (this.color != null) {
+                builder.append("color=");
+                builder.append(this.color);
+                builder.append(", ");
+            }
+            if (this.bold != null) {
+                builder.append("bold=");
+                builder.append(this.bold);
+                builder.append(", ");
+            }
+            if (this.italic != null) {
+                builder.append("italic=");
+                builder.append(this.italic);
+                builder.append(", ");
+            }
+            if (this.underlined != null) {
+                builder.append("underlined=");
+                builder.append(this.underlined);
+                builder.append(", ");
+            }
+            if (this.strikethrough != null) {
+                builder.append("strikethrough=");
+                builder.append(this.strikethrough);
+                builder.append(", ");
+            }
+            if (this.obfuscated != null) {
+                builder.append("obfuscated=");
+                builder.append(this.obfuscated);
+                builder.append(", ");
+            }
+            if (this.click != null) {
+                builder.append("clickEvent=");
+                builder.append(this.click);
+                builder.append(", ");
+            }
+            if (this.hover != null) {
+                builder.append("hoverEvent=");
+                builder.append(this.hover);
+            }
+            builder.append("}");
+            return builder.toString();
+        }
+        return toString();
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/chat/ChatModifierSerializer.java b/src/main/java/dev/wolveringer/chat/ChatModifierSerializer.java
index e92bb11..b8bca8e 100644
--- a/src/main/java/dev/wolveringer/chat/ChatModifierSerializer.java
+++ b/src/main/java/dev/wolveringer/chat/ChatModifierSerializer.java
@@ -1,9 +1,5 @@
 package dev.wolveringer.chat;
 
-import java.lang.reflect.Type;
-
-import net.md_5.bungee.api.ChatColor;
-
 import com.google.gson.JsonDeserializationContext;
 import com.google.gson.JsonDeserializer;
 import com.google.gson.JsonElement;
@@ -12,131 +8,135 @@ import com.google.gson.JsonPrimitive;
 import com.google.gson.JsonSerializationContext;
 import com.google.gson.JsonSerializer;
 
-@SuppressWarnings({ "rawtypes" })
+import net.md_5.bungee.api.ChatColor;
+
+import java.lang.reflect.Type;
+
+@SuppressWarnings({"rawtypes"})
 public class ChatModifierSerializer implements JsonDeserializer, JsonSerializer {
 
-	public ChatModifierSerializer() {
-	}
-
-	public JsonElement serialize(Object obj, Type type, JsonSerializationContext jsonserializationcontext) {
-		if(!(obj instanceof ChatModifier))
-			throw new IllegalStateException();
-		ChatModifier modifier = (ChatModifier) obj;
-		if(modifier.hasOwnStyle()){
-			return null;
-		}else{
-			JsonObject json = new JsonObject();
-
-			if(modifier.isBold() == true){
-				json.addProperty("bold", modifier.isBold());
-			}
-
-			if(modifier.isItalic() == true){
-				json.addProperty("italic", modifier.isItalic());
-			}
-
-			if(modifier.isUnderlined() == true){
-				json.addProperty("underlined", modifier.isUnderlined());
-			}
-
-			if(modifier.isStrikethrough() == true){
-				json.addProperty("strikethrough", modifier.isStrikethrough());
-			}
-
-			if(modifier.isObfuscated() == true){
-				json.addProperty("obfuscated", modifier.isObfuscated());
-			}
-
-			if(modifier.getColor() != null){
-				json.add("color", jsonserializationcontext.serialize(modifier.getColor()));
-			}
-
-			JsonObject actionJson;
-
-			if(modifier.getClick() != null){
-				actionJson = new JsonObject();
-				actionJson.addProperty("action", modifier.getClick().getAction().getActionName());
-				actionJson.addProperty("value", modifier.getClick().getValue());
-				json.add("clickEvent", actionJson);
-			}
-
-			if(modifier.getHover() != null){
-				actionJson = new JsonObject();
-				actionJson.addProperty("action", modifier.getHover().getAction().getActionName());
-				actionJson.add("value", jsonserializationcontext.serialize(modifier.getHover().getValue()));
-				json.add("hoverEvent", actionJson);
-			}
-
-			return json;
-		}
-	}
-
-	public ChatModifier deserialize(JsonElement jsonelement, Type type, JsonDeserializationContext jsondeserializationcontext) {
-		if(jsonelement.isJsonObject()){
-			ChatModifier chatmodifier = new ChatModifier();
-			JsonObject jsonobject = jsonelement.getAsJsonObject();
-
-			if(jsonobject == null){
-				return null;
-			}else{
-				if(jsonobject.has("bold")){
-					chatmodifier.setBold(jsonobject.get("bold").getAsBoolean());
-				}
-
-				if(jsonobject.has("italic")){
-					chatmodifier.setItalic(jsonobject.get("italic").getAsBoolean());
-				}
-
-				if(jsonobject.has("underlined")){
-					chatmodifier.setUnderline(jsonobject.get("underlined").getAsBoolean());
-				}
-
-				if(jsonobject.has("strikethrough")){
-					chatmodifier.setStrikethrough(jsonobject.get("strikethrough").getAsBoolean());
-				}
-
-				if(jsonobject.has("obfuscated")){
-					chatmodifier.setRandom(jsonobject.get("obfuscated").getAsBoolean());
-				}
-
-				if(jsonobject.has("color")){
-					chatmodifier.setColor((ChatColor) jsondeserializationcontext.deserialize(jsonobject.get("color"), ChatColor.class));
-				}
-
-				JsonObject jsonobject1;
-				JsonPrimitive jsonprimitive;
-
-				if(jsonobject.has("clickEvent")){
-					jsonobject1 = jsonobject.getAsJsonObject("clickEvent");
-					if(jsonobject1 != null){
-						jsonprimitive = jsonobject1.getAsJsonPrimitive("action");
-						EnumClickAction enumclickaction = jsonprimitive == null ? null : EnumClickAction.getActionFromName(jsonprimitive.getAsString());
-						JsonPrimitive jsonprimitive1 = jsonobject1.getAsJsonPrimitive("value");
-						String s = jsonprimitive1 == null ? null : jsonprimitive1.getAsString();
-
-						if(enumclickaction != null && s != null && enumclickaction.hasExtraData()){
-							chatmodifier.setChatClickable(new ChatClickable(enumclickaction, s));
-						}
-					}
-				}
-
-				if(jsonobject.has("hoverEvent")){
-					jsonobject1 = jsonobject.getAsJsonObject("hoverEvent");
-					if(jsonobject1 != null){
-						jsonprimitive = jsonobject1.getAsJsonPrimitive("action");
-						EnumHoverAction enumhoveraction = jsonprimitive == null ? null : EnumHoverAction.getActionFromName(jsonprimitive.getAsString());
-						IChatBaseComponent ichatbasecomponent = (IChatBaseComponent) jsondeserializationcontext.deserialize(jsonobject1.get("value"), IChatBaseComponent.class);
-
-						if(enumhoveraction != null && ichatbasecomponent != null && enumhoveraction.hasExtraData()){
-							chatmodifier.setHover(new ChatHoverable(enumhoveraction, ichatbasecomponent));
-						}
-					}
-				}
-
-				return chatmodifier;
-			}
-		}else{
-			return null;
-		}
-	}
+    public ChatModifierSerializer() {
+    }
+
+    public JsonElement serialize(Object obj, Type type, JsonSerializationContext jsonserializationcontext) {
+        if (!(obj instanceof ChatModifier))
+            throw new IllegalStateException();
+        ChatModifier modifier = (ChatModifier) obj;
+        if (modifier.hasOwnStyle()) {
+            return null;
+        } else {
+            JsonObject json = new JsonObject();
+
+            if (modifier.isBold() == true) {
+                json.addProperty("bold", modifier.isBold());
+            }
+
+            if (modifier.isItalic() == true) {
+                json.addProperty("italic", modifier.isItalic());
+            }
+
+            if (modifier.isUnderlined() == true) {
+                json.addProperty("underlined", modifier.isUnderlined());
+            }
+
+            if (modifier.isStrikethrough() == true) {
+                json.addProperty("strikethrough", modifier.isStrikethrough());
+            }
+
+            if (modifier.isObfuscated() == true) {
+                json.addProperty("obfuscated", modifier.isObfuscated());
+            }
+
+            if (modifier.getColor() != null) {
+                json.add("color", jsonserializationcontext.serialize(modifier.getColor()));
+            }
+
+            JsonObject actionJson;
+
+            if (modifier.getClick() != null) {
+                actionJson = new JsonObject();
+                actionJson.addProperty("action", modifier.getClick().getAction().getActionName());
+                actionJson.addProperty("value", modifier.getClick().getValue());
+                json.add("clickEvent", actionJson);
+            }
+
+            if (modifier.getHover() != null) {
+                actionJson = new JsonObject();
+                actionJson.addProperty("action", modifier.getHover().getAction().getActionName());
+                actionJson.add("value", jsonserializationcontext.serialize(modifier.getHover().getValue()));
+                json.add("hoverEvent", actionJson);
+            }
+
+            return json;
+        }
+    }
+
+    public ChatModifier deserialize(JsonElement jsonelement, Type type, JsonDeserializationContext jsondeserializationcontext) {
+        if (jsonelement.isJsonObject()) {
+            ChatModifier chatmodifier = new ChatModifier();
+            JsonObject jsonobject = jsonelement.getAsJsonObject();
+
+            if (jsonobject == null) {
+                return null;
+            } else {
+                if (jsonobject.has("bold")) {
+                    chatmodifier.setBold(jsonobject.get("bold").getAsBoolean());
+                }
+
+                if (jsonobject.has("italic")) {
+                    chatmodifier.setItalic(jsonobject.get("italic").getAsBoolean());
+                }
+
+                if (jsonobject.has("underlined")) {
+                    chatmodifier.setUnderline(jsonobject.get("underlined").getAsBoolean());
+                }
+
+                if (jsonobject.has("strikethrough")) {
+                    chatmodifier.setStrikethrough(jsonobject.get("strikethrough").getAsBoolean());
+                }
+
+                if (jsonobject.has("obfuscated")) {
+                    chatmodifier.setRandom(jsonobject.get("obfuscated").getAsBoolean());
+                }
+
+                if (jsonobject.has("color")) {
+                    chatmodifier.setColor((ChatColor) jsondeserializationcontext.deserialize(jsonobject.get("color"), ChatColor.class));
+                }
+
+                JsonObject jsonobject1;
+                JsonPrimitive jsonprimitive;
+
+                if (jsonobject.has("clickEvent")) {
+                    jsonobject1 = jsonobject.getAsJsonObject("clickEvent");
+                    if (jsonobject1 != null) {
+                        jsonprimitive = jsonobject1.getAsJsonPrimitive("action");
+                        EnumClickAction enumclickaction = jsonprimitive == null ? null : EnumClickAction.getActionFromName(jsonprimitive.getAsString());
+                        JsonPrimitive jsonprimitive1 = jsonobject1.getAsJsonPrimitive("value");
+                        String s = jsonprimitive1 == null ? null : jsonprimitive1.getAsString();
+
+                        if (enumclickaction != null && s != null && enumclickaction.hasExtraData()) {
+                            chatmodifier.setChatClickable(new ChatClickable(enumclickaction, s));
+                        }
+                    }
+                }
+
+                if (jsonobject.has("hoverEvent")) {
+                    jsonobject1 = jsonobject.getAsJsonObject("hoverEvent");
+                    if (jsonobject1 != null) {
+                        jsonprimitive = jsonobject1.getAsJsonPrimitive("action");
+                        EnumHoverAction enumhoveraction = jsonprimitive == null ? null : EnumHoverAction.getActionFromName(jsonprimitive.getAsString());
+                        IChatBaseComponent ichatbasecomponent = (IChatBaseComponent) jsondeserializationcontext.deserialize(jsonobject1.get("value"), IChatBaseComponent.class);
+
+                        if (enumhoveraction != null && ichatbasecomponent != null && enumhoveraction.hasExtraData()) {
+                            chatmodifier.setHover(new ChatHoverable(enumhoveraction, ichatbasecomponent));
+                        }
+                    }
+                }
+
+                return chatmodifier;
+            }
+        } else {
+            return null;
+        }
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/chat/ChatSerializer.java b/src/main/java/dev/wolveringer/chat/ChatSerializer.java
index 82a36cc..582da98 100644
--- a/src/main/java/dev/wolveringer/chat/ChatSerializer.java
+++ b/src/main/java/dev/wolveringer/chat/ChatSerializer.java
@@ -1,13 +1,5 @@
 package dev.wolveringer.chat;
 
-import java.lang.reflect.Type;
-import java.util.Iterator;
-import java.util.Map.Entry;
-
-import net.md_5.bungee.api.ChatColor;
-import net.md_5.bungee.api.chat.BaseComponent;
-import net.md_5.bungee.chat.ComponentSerializer;
-
 import com.google.gson.Gson;
 import com.google.gson.GsonBuilder;
 import com.google.gson.JsonArray;
@@ -20,290 +12,298 @@ import com.google.gson.JsonPrimitive;
 import com.google.gson.JsonSerializationContext;
 import com.google.gson.JsonSerializer;
 
+import net.md_5.bungee.api.ChatColor;
+import net.md_5.bungee.api.chat.BaseComponent;
+import net.md_5.bungee.chat.ComponentSerializer;
+
+import java.lang.reflect.Type;
+import java.util.Iterator;
+import java.util.Map.Entry;
+
 import dev.wolveringer.chat.ChatColor.ChatColorUtils;
 
 @SuppressWarnings("rawtypes")
 public class ChatSerializer implements JsonDeserializer, JsonSerializer {
 
-	private static final Gson deserelizer;
-
-	static{
-		GsonBuilder gsonbuilder = new GsonBuilder();
-		gsonbuilder.registerTypeHierarchyAdapter(IChatBaseComponent.class, new ChatSerializer());
-		gsonbuilder.registerTypeHierarchyAdapter(ChatModifier.class, new ChatModifierSerializer());
-		gsonbuilder.registerTypeAdapterFactory(new ChatTypeAdapterFactory());
-		deserelizer = gsonbuilder.create();
-	}
-
-	public static IChatBaseComponent toIChatBaseComponent(BaseComponent comp) {
-		return fromJSON(ComponentSerializer.toString(comp));
-	}
-
-	public static String toJSONString(IChatBaseComponent ichatbasecomponent) {
-		return deserelizer.toJson(ichatbasecomponent);
-	}
-
-	public static IChatBaseComponent fromJSON(String s) {
-		return deserelizer.fromJson(s, IChatBaseComponent.class);
-	}
-
-	ChatSerializer() {
-	}
-
-	public static String toMessage(IChatBaseComponent component) {
-		return toMessage(component, new ChatModifier());
-	}
-
-	public static String toMessage(IChatBaseComponent component, String last) {
-		return toMessage(component, ChatColorUtils.getLastModifierColors(last));
-	}
-
-	public static String toMessage(IChatBaseComponent component, ChatModifier defaultModifier) {
-		return toMessage(component, defaultModifier, 0);
-	}
-
-	@SuppressWarnings("unchecked")
-	public static String toMessage(IChatBaseComponent component, ChatModifier defaultModifier, int start) {
-		if(component == null)
-			return "";
-		StringBuilder out = new StringBuilder();
-		String first = null;
-		int count = 0;
-		for(IChatBaseComponent c : (Iterable<IChatBaseComponent>) component){
-			if(count < start){
-				count++;
-				continue;
-			}
-			if(first == null)
-				first = c.getText();
-			ChatModifier modi = c.getChatModifier();
-			if(modi == null)
-				modi = defaultModifier;
-			out.append(modi.getColor() == null ? defaultModifier.getColor() == null ? ChatColor.WHITE : defaultModifier.getColor() : modi.getColor());
-			if(modi.isBold())
-				out.append(ChatColor.BOLD);
-			if(modi.isItalic())
-				out.append(ChatColor.ITALIC);
-			if(modi.isUnderlined())
-				out.append(ChatColor.UNDERLINE);
-			if(modi.isBold())
-				out.append(ChatColor.STRIKETHROUGH);
-			if(modi.isObfuscated())
-				out.append(ChatColor.MAGIC);
-			out.append(c.getText());
-		}
-		String o = out.toString();
-		if(defaultModifier.getColor() != null)
-			o = o.replaceFirst("^(" + defaultModifier.getColor() + ")*", "");
-		return o;
-	}
-
-	public static IChatBaseComponent fromMessage(String s) {
-		ChatComponentText comp = new ChatComponentText("");
-		if(!s.startsWith(""+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+""))
-			s = ""+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"f" + s;
-		ChatColor color = ChatColor.WHITE;
-		boolean bold = false;
-		boolean italic = false;
-		boolean underlined = false;
-		boolean strikethrough = false;
-		boolean obfuscated = false;
-		String[] all = s.split(""+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"");
-		for(int i = 0;i < all.length;i++){
-			if(i + 1 < all.length){
-				ChatColor c = ChatColor.getByChar(all[i + 1].charAt(0));
-				if(c == ChatColor.BOLD)
-					bold = true;
-				else if(c == ChatColor.ITALIC)
-					italic = true;
-				else if(c == ChatColor.UNDERLINE)
-					underlined = true;
-				else if(c == ChatColor.STRIKETHROUGH)
-					strikethrough = true;
-				else if(c == ChatColor.MAGIC)
-					obfuscated = true;
-				else if(c == ChatColor.RESET){
-					bold = false;
-					italic = false;
-					underlined = false;
-					strikethrough = false;
-					obfuscated = false;
-					color = ChatColor.WHITE;
-				}else{
-					bold = false;
-					italic = false;
-					underlined = false;
-					strikethrough = false;
-					obfuscated = false;
-					color = c;
-				}
-				String msg = all[i + 1].substring(1);
-				if(msg.equalsIgnoreCase(""))
-					continue;
-				ChatComponentText sibling = new ChatComponentText(msg);
-				sibling.getChatModifier().setColor(color);
-				sibling.getChatModifier().setBold(bold);
-				sibling.getChatModifier().setItalic(italic);
-				sibling.getChatModifier().setRandom(obfuscated);
-				sibling.getChatModifier().setUnderline(underlined);
-				sibling.getChatModifier().setStrikethrough(strikethrough);
-				comp.addSibling(sibling);
-			}
-		}
-		return comp;
-	}
-
-	@Override
-	public JsonElement serialize(Object arg0, Type arg1, JsonSerializationContext arg2) {
-		return this.serialize((IChatBaseComponent) arg0, arg1, arg2);
-	}
-
-	@Override
-	public Object deserialize(JsonElement in_obj, Type type, JsonDeserializationContext context) throws JsonParseException {
-		if(in_obj.isJsonPrimitive()){
-			return new ChatComponentText(in_obj.getAsString());
-		}else if(!in_obj.isJsonObject()){
-			if(in_obj.isJsonArray()){
-				JsonArray in = in_obj.getAsJsonArray();
-				IChatBaseComponent ichatbasecomponent = null;
-				Iterator<JsonElement> iterator = in.iterator();
-				while (iterator.hasNext()){
-					JsonElement jsonelement1 = iterator.next();
-					IChatBaseComponent ichatbasecomponent1 = (IChatBaseComponent) this.deserialize(jsonelement1, jsonelement1.getClass(), context);
-
-					if(ichatbasecomponent == null){
-						ichatbasecomponent = ichatbasecomponent1;
-					}else{
-						ichatbasecomponent.addSibling(ichatbasecomponent1);
-					}
-				}
-
-				return ichatbasecomponent;
-			}else{
-				throw new JsonParseException("Don\'t know how to turn " + in_obj.toString() + " into a Component");
-			}
-		}else{
-			JsonObject jsonobject = in_obj.getAsJsonObject();
-			Object object;
-
-			if(jsonobject.has("text")){
-				object = new ChatComponentText(jsonobject.get("text").getAsString());
-			}else{
-				if(!jsonobject.has("translate")){
-					throw new JsonParseException("Don\'t know how to turn " + in_obj.toString() + " into a Component");
-				}
-
-				String s = jsonobject.get("translate").getAsString();
-
-				if(jsonobject.has("with")){
-					JsonArray jsonarray1 = jsonobject.getAsJsonArray("with");
-					Object[] aobject = new Object[jsonarray1.size()];
-
-					for(int i = 0;i < aobject.length;++i){
-						aobject[i] = this.deserialize(jsonarray1.get(i), type, context);
-						if(aobject[i] instanceof ChatComponentText){
-							ChatComponentText chatcomponenttext = (ChatComponentText) aobject[i];
-
-							if(chatcomponenttext.getChatModifier().hasOwnStyle() && chatcomponenttext.getSiblings().isEmpty()){
-								aobject[i] = chatcomponenttext.getRawText();
-							}
-						}
-					}
-
-					object = new ChatMessage(s, aobject);
-				}else{
-					object = new ChatMessage(s, new Object[0]);
-				}
-			}
-
-			if(jsonobject.has("extra")){
-				JsonArray jsonarray2 = jsonobject.getAsJsonArray("extra");
-
-				if(jsonarray2.size() <= 0){
-					throw new JsonParseException("Unexpected empty array of components");
-				}
-
-				for(int j = 0;j < jsonarray2.size();++j){
-					((IChatBaseComponent) object).addSibling((IChatBaseComponent) this.deserialize(jsonarray2.get(j), type, context));
-				}
-			}
-
-			((IChatBaseComponent) object).setChatModifier((ChatModifier) context.deserialize(in_obj, ChatModifier.class));
-			return (IChatBaseComponent) object;
-		}
-	}
-
-	@SuppressWarnings("unchecked")
-	public JsonElement serialize(IChatBaseComponent in, Type type, JsonSerializationContext context) {
-		if(in instanceof ChatComponentText && in.getChatModifier().hasOwnStyle() && in.getSiblings().isEmpty()){
-			return new JsonPrimitive(((ChatComponentText) in).getRawText());
-		}else{
-			JsonObject out = new JsonObject();
-
-			if(!in.getChatModifier().hasOwnStyle()){
-				this.a(in.getChatModifier(), out, context);
-			}
-
-			if(!in.getSiblings().isEmpty()){
-				JsonArray siblings = new JsonArray();
-				Iterator<IChatBaseComponent> iterator = in.getSiblings().iterator();
-
-				while (iterator.hasNext()){
-					IChatBaseComponent ichatbasecomponent1 = iterator.next();
-					siblings.add(this.serialize(ichatbasecomponent1, ichatbasecomponent1.getClass(), context));
-				}
-				out.add("extra", siblings);
-				if("".equalsIgnoreCase(in.getText()))
-					out.addProperty("text", "");
-				else
-					out.addProperty("text", in.getText());
-			}else if(in instanceof ChatComponentText){
-				out.addProperty("text", ((ChatComponentText) in).getRawText());
-			}else{
-				if(!(in instanceof ChatMessage))
-					throw new IllegalArgumentException("Don\'t know how to serialize " + in + " as a Component");
-
-				ChatMessage message = (ChatMessage) in;
-
-				out.addProperty("translate", message.getLanguage());
-				if(message.getData() != null && message.getData().length > 0){
-					JsonArray jsonarray1 = new JsonArray();
-					Object[] aobject = message.getData();
-					int i = aobject.length;
-
-					for(int j = 0;j < i;++j){
-						Object object = aobject[j];
-
-						if(object instanceof IChatBaseComponent){
-							jsonarray1.add(this.serialize((IChatBaseComponent) object, (Type) object.getClass(), context));
-						}else{
-							jsonarray1.add(new JsonPrimitive(String.valueOf(object)));
-						}
-					}
-
-					out.add("with", jsonarray1);
-				}
-			}
-
-			return out;
-		}
-	}
-
-	private void a(ChatModifier chatmodifier, JsonObject jsonobject, JsonSerializationContext jsonserializationcontext) {
-		JsonElement jsonelement = jsonserializationcontext.serialize(chatmodifier);
-		if(jsonelement.isJsonObject()){
-			JsonObject jsonobject1 = (JsonObject) jsonelement;
-			Iterator iterator = jsonobject1.entrySet().iterator();
-
-			while (iterator.hasNext()){
-				Entry entry = (Entry) iterator.next();
-
-				jsonobject.add((String) entry.getKey(), (JsonElement) entry.getValue());
-			}
-		}
-	}
-
-	public static String toString(IChatBaseComponent comp, StringMethode m) {
-		return ((ChatBaseComponent) comp).toString(m).replaceAll(", \\}", "").replaceAll(", \\]", "");
-	}
+    private static final Gson deserelizer;
+
+    static {
+        GsonBuilder gsonbuilder = new GsonBuilder();
+        gsonbuilder.registerTypeHierarchyAdapter(IChatBaseComponent.class, new ChatSerializer());
+        gsonbuilder.registerTypeHierarchyAdapter(ChatModifier.class, new ChatModifierSerializer());
+        gsonbuilder.registerTypeAdapterFactory(new ChatTypeAdapterFactory());
+        deserelizer = gsonbuilder.create();
+    }
+
+    ChatSerializer() {
+    }
+
+    public static IChatBaseComponent toIChatBaseComponent(BaseComponent comp) {
+        return fromJSON(ComponentSerializer.toString(comp));
+    }
+
+    public static String toJSONString(IChatBaseComponent ichatbasecomponent) {
+        return deserelizer.toJson(ichatbasecomponent);
+    }
+
+    public static IChatBaseComponent fromJSON(String s) {
+        return deserelizer.fromJson(s, IChatBaseComponent.class);
+    }
+
+    public static String toMessage(IChatBaseComponent component) {
+        return toMessage(component, new ChatModifier());
+    }
+
+    public static String toMessage(IChatBaseComponent component, String last) {
+        return toMessage(component, ChatColorUtils.getLastModifierColors(last));
+    }
+
+    public static String toMessage(IChatBaseComponent component, ChatModifier defaultModifier) {
+        return toMessage(component, defaultModifier, 0);
+    }
+
+    @SuppressWarnings("unchecked")
+    public static String toMessage(IChatBaseComponent component, ChatModifier defaultModifier, int start) {
+        if (component == null)
+            return "";
+        StringBuilder out = new StringBuilder();
+        String first = null;
+        int count = 0;
+        for (IChatBaseComponent c : (Iterable<IChatBaseComponent>) component) {
+            if (count < start) {
+                count++;
+                continue;
+            }
+            if (first == null)
+                first = c.getText();
+            ChatModifier modi = c.getChatModifier();
+            if (modi == null)
+                modi = defaultModifier;
+            out.append(modi.getColor() == null ? defaultModifier.getColor() == null ? ChatColor.WHITE : defaultModifier.getColor() : modi.getColor());
+            if (modi.isBold())
+                out.append(ChatColor.BOLD);
+            if (modi.isItalic())
+                out.append(ChatColor.ITALIC);
+            if (modi.isUnderlined())
+                out.append(ChatColor.UNDERLINE);
+            if (modi.isBold())
+                out.append(ChatColor.STRIKETHROUGH);
+            if (modi.isObfuscated())
+                out.append(ChatColor.MAGIC);
+            out.append(c.getText());
+        }
+        String o = out.toString();
+        if (defaultModifier.getColor() != null)
+            o = o.replaceFirst("^(" + defaultModifier.getColor() + ")*", "");
+        return o;
+    }
+
+    public static IChatBaseComponent fromMessage(String s) {
+        ChatComponentText comp = new ChatComponentText("");
+        if (!s.startsWith("" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + ""))
+            s = "" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "f" + s;
+        ChatColor color = ChatColor.WHITE;
+        boolean bold = false;
+        boolean italic = false;
+        boolean underlined = false;
+        boolean strikethrough = false;
+        boolean obfuscated = false;
+        String[] all = s.split("" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "");
+        for (int i = 0; i < all.length; i++) {
+            if (i + 1 < all.length) {
+                ChatColor c = ChatColor.getByChar(all[i + 1].charAt(0));
+                if (c == ChatColor.BOLD)
+                    bold = true;
+                else if (c == ChatColor.ITALIC)
+                    italic = true;
+                else if (c == ChatColor.UNDERLINE)
+                    underlined = true;
+                else if (c == ChatColor.STRIKETHROUGH)
+                    strikethrough = true;
+                else if (c == ChatColor.MAGIC)
+                    obfuscated = true;
+                else if (c == ChatColor.RESET) {
+                    bold = false;
+                    italic = false;
+                    underlined = false;
+                    strikethrough = false;
+                    obfuscated = false;
+                    color = ChatColor.WHITE;
+                } else {
+                    bold = false;
+                    italic = false;
+                    underlined = false;
+                    strikethrough = false;
+                    obfuscated = false;
+                    color = c;
+                }
+                String msg = all[i + 1].substring(1);
+                if (msg.equalsIgnoreCase(""))
+                    continue;
+                ChatComponentText sibling = new ChatComponentText(msg);
+                sibling.getChatModifier().setColor(color);
+                sibling.getChatModifier().setBold(bold);
+                sibling.getChatModifier().setItalic(italic);
+                sibling.getChatModifier().setRandom(obfuscated);
+                sibling.getChatModifier().setUnderline(underlined);
+                sibling.getChatModifier().setStrikethrough(strikethrough);
+                comp.addSibling(sibling);
+            }
+        }
+        return comp;
+    }
+
+    public static String toString(IChatBaseComponent comp, StringMethode m) {
+        return ((ChatBaseComponent) comp).toString(m).replaceAll(", \\}", "").replaceAll(", \\]", "");
+    }
+
+    @Override
+    public JsonElement serialize(Object arg0, Type arg1, JsonSerializationContext arg2) {
+        return this.serialize((IChatBaseComponent) arg0, arg1, arg2);
+    }
+
+    @Override
+    public Object deserialize(JsonElement in_obj, Type type, JsonDeserializationContext context) throws JsonParseException {
+        if (in_obj.isJsonPrimitive()) {
+            return new ChatComponentText(in_obj.getAsString());
+        } else if (!in_obj.isJsonObject()) {
+            if (in_obj.isJsonArray()) {
+                JsonArray in = in_obj.getAsJsonArray();
+                IChatBaseComponent ichatbasecomponent = null;
+                Iterator<JsonElement> iterator = in.iterator();
+                while (iterator.hasNext()) {
+                    JsonElement jsonelement1 = iterator.next();
+                    IChatBaseComponent ichatbasecomponent1 = (IChatBaseComponent) this.deserialize(jsonelement1, jsonelement1.getClass(), context);
+
+                    if (ichatbasecomponent == null) {
+                        ichatbasecomponent = ichatbasecomponent1;
+                    } else {
+                        ichatbasecomponent.addSibling(ichatbasecomponent1);
+                    }
+                }
+
+                return ichatbasecomponent;
+            } else {
+                throw new JsonParseException("Don\'t know how to turn " + in_obj.toString() + " into a Component");
+            }
+        } else {
+            JsonObject jsonobject = in_obj.getAsJsonObject();
+            Object object;
+
+            if (jsonobject.has("text")) {
+                object = new ChatComponentText(jsonobject.get("text").getAsString());
+            } else {
+                if (!jsonobject.has("translate")) {
+                    throw new JsonParseException("Don\'t know how to turn " + in_obj.toString() + " into a Component");
+                }
+
+                String s = jsonobject.get("translate").getAsString();
+
+                if (jsonobject.has("with")) {
+                    JsonArray jsonarray1 = jsonobject.getAsJsonArray("with");
+                    Object[] aobject = new Object[jsonarray1.size()];
+
+                    for (int i = 0; i < aobject.length; ++i) {
+                        aobject[i] = this.deserialize(jsonarray1.get(i), type, context);
+                        if (aobject[i] instanceof ChatComponentText) {
+                            ChatComponentText chatcomponenttext = (ChatComponentText) aobject[i];
+
+                            if (chatcomponenttext.getChatModifier().hasOwnStyle() && chatcomponenttext.getSiblings().isEmpty()) {
+                                aobject[i] = chatcomponenttext.getRawText();
+                            }
+                        }
+                    }
+
+                    object = new ChatMessage(s, aobject);
+                } else {
+                    object = new ChatMessage(s, new Object[0]);
+                }
+            }
+
+            if (jsonobject.has("extra")) {
+                JsonArray jsonarray2 = jsonobject.getAsJsonArray("extra");
+
+                if (jsonarray2.size() <= 0) {
+                    throw new JsonParseException("Unexpected empty array of components");
+                }
+
+                for (int j = 0; j < jsonarray2.size(); ++j) {
+                    ((IChatBaseComponent) object).addSibling((IChatBaseComponent) this.deserialize(jsonarray2.get(j), type, context));
+                }
+            }
+
+            ((IChatBaseComponent) object).setChatModifier((ChatModifier) context.deserialize(in_obj, ChatModifier.class));
+            return (IChatBaseComponent) object;
+        }
+    }
+
+    @SuppressWarnings("unchecked")
+    public JsonElement serialize(IChatBaseComponent in, Type type, JsonSerializationContext context) {
+        if (in instanceof ChatComponentText && in.getChatModifier().hasOwnStyle() && in.getSiblings().isEmpty()) {
+            return new JsonPrimitive(((ChatComponentText) in).getRawText());
+        } else {
+            JsonObject out = new JsonObject();
+
+            if (!in.getChatModifier().hasOwnStyle()) {
+                this.a(in.getChatModifier(), out, context);
+            }
+
+            if (!in.getSiblings().isEmpty()) {
+                JsonArray siblings = new JsonArray();
+                Iterator<IChatBaseComponent> iterator = in.getSiblings().iterator();
+
+                while (iterator.hasNext()) {
+                    IChatBaseComponent ichatbasecomponent1 = iterator.next();
+                    siblings.add(this.serialize(ichatbasecomponent1, ichatbasecomponent1.getClass(), context));
+                }
+                out.add("extra", siblings);
+                if ("".equalsIgnoreCase(in.getText()))
+                    out.addProperty("text", "");
+                else
+                    out.addProperty("text", in.getText());
+            } else if (in instanceof ChatComponentText) {
+                out.addProperty("text", ((ChatComponentText) in).getRawText());
+            } else {
+                if (!(in instanceof ChatMessage))
+                    throw new IllegalArgumentException("Don\'t know how to serialize " + in + " as a Component");
+
+                ChatMessage message = (ChatMessage) in;
+
+                out.addProperty("translate", message.getLanguage());
+                if (message.getData() != null && message.getData().length > 0) {
+                    JsonArray jsonarray1 = new JsonArray();
+                    Object[] aobject = message.getData();
+                    int i = aobject.length;
+
+                    for (int j = 0; j < i; ++j) {
+                        Object object = aobject[j];
+
+                        if (object instanceof IChatBaseComponent) {
+                            jsonarray1.add(this.serialize((IChatBaseComponent) object, (Type) object.getClass(), context));
+                        } else {
+                            jsonarray1.add(new JsonPrimitive(String.valueOf(object)));
+                        }
+                    }
+
+                    out.add("with", jsonarray1);
+                }
+            }
+
+            return out;
+        }
+    }
+
+    private void a(ChatModifier chatmodifier, JsonObject jsonobject, JsonSerializationContext jsonserializationcontext) {
+        JsonElement jsonelement = jsonserializationcontext.serialize(chatmodifier);
+        if (jsonelement.isJsonObject()) {
+            JsonObject jsonobject1 = (JsonObject) jsonelement;
+            Iterator iterator = jsonobject1.entrySet().iterator();
+
+            while (iterator.hasNext()) {
+                Entry entry = (Entry) iterator.next();
+
+                jsonobject.add((String) entry.getKey(), (JsonElement) entry.getValue());
+            }
+        }
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/chat/ChatStyleRoot.java b/src/main/java/dev/wolveringer/chat/ChatStyleRoot.java
index ea4b0a7..77ca2da 100644
--- a/src/main/java/dev/wolveringer/chat/ChatStyleRoot.java
+++ b/src/main/java/dev/wolveringer/chat/ChatStyleRoot.java
@@ -4,106 +4,106 @@ import net.md_5.bungee.api.ChatColor;
 
 final class ChatStyleRoot extends ChatModifier {
 
-	ChatStyleRoot() {
-	}
-
-	@Override
-	public ChatModifier setHover(ChatHoverable chathoverable) {
-		throw new UnsupportedOperationException();
-	}
-
-	@Override
-	public ChatModifier setChatModifier(ChatModifier chatmodifier) {
-		throw new UnsupportedOperationException();
-	}
-
-	@Override
-	public ChatModifier clone() {
-		return this;
-	}
-
-	@Override
-	public ChatModifier getChatModifier() {
-		return super.getChatModifier();
-	}
-
-	@Override
-	public ChatClickable getClick() {
-		return null;
-	}
-
-	@Override
-	public ChatColor getColor() {
-		return ChatColor.WHITE;
-	}
-
-	@Override
-	public ChatHoverable getHover() {
-		return null;
-	}
-
-	@Override
-	public ChatModifier setBold(Boolean obool) {
-		throw new UnsupportedOperationException();
-	}
-
-	@Override
-	public ChatModifier setChatClickable(ChatClickable chatclickable) {
-		throw new UnsupportedOperationException();
-	}
-
-	@Override
-	public ChatModifier setColor(ChatColor enumchatformat) {
-		throw new UnsupportedOperationException();
-	}
-
-	@Override
-	public ChatModifier setItalic(Boolean obool) {
-		throw new UnsupportedOperationException();
-	}
-
-	@Override
-	public ChatModifier setRandom(Boolean obool) {
-		throw new UnsupportedOperationException();
-	}
-
-	@Override
-	public ChatModifier setStrikethrough(Boolean obool) {
-		throw new UnsupportedOperationException();
-	}
-
-	@Override
-	public ChatModifier setUnderline(Boolean obool) {
-		throw new UnsupportedOperationException();
-	}
-
-	@Override
-	public boolean isBold() {
-		return false;
-	}
-
-	@Override
-	public boolean isItalic() {
-		return false;
-	}
-
-	@Override
-	public boolean isObfuscated() {
-		return false;
-	}
-
-	@Override
-	public boolean isStrikethrough() {
-		return false;
-	}
-
-	@Override
-	public boolean isUnderlined() {
-		return false;
-	}
-
-	@Override
-	public String toString() {
-		return "Style.ROOT";
-	}
+    ChatStyleRoot() {
+    }
+
+    @Override
+    public ChatModifier setHover(ChatHoverable chathoverable) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public ChatModifier setChatModifier(ChatModifier chatmodifier) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public ChatModifier clone() {
+        return this;
+    }
+
+    @Override
+    public ChatModifier getChatModifier() {
+        return super.getChatModifier();
+    }
+
+    @Override
+    public ChatClickable getClick() {
+        return null;
+    }
+
+    @Override
+    public ChatColor getColor() {
+        return ChatColor.WHITE;
+    }
+
+    @Override
+    public ChatHoverable getHover() {
+        return null;
+    }
+
+    @Override
+    public ChatModifier setBold(Boolean obool) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public ChatModifier setChatClickable(ChatClickable chatclickable) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public ChatModifier setColor(ChatColor enumchatformat) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public ChatModifier setItalic(Boolean obool) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public ChatModifier setRandom(Boolean obool) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public ChatModifier setStrikethrough(Boolean obool) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public ChatModifier setUnderline(Boolean obool) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean isBold() {
+        return false;
+    }
+
+    @Override
+    public boolean isItalic() {
+        return false;
+    }
+
+    @Override
+    public boolean isObfuscated() {
+        return false;
+    }
+
+    @Override
+    public boolean isStrikethrough() {
+        return false;
+    }
+
+    @Override
+    public boolean isUnderlined() {
+        return false;
+    }
+
+    @Override
+    public String toString() {
+        return "Style.ROOT";
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/chat/ChatTextBuilder.java b/src/main/java/dev/wolveringer/chat/ChatTextBuilder.java
index 20c3655..aad6881 100644
--- a/src/main/java/dev/wolveringer/chat/ChatTextBuilder.java
+++ b/src/main/java/dev/wolveringer/chat/ChatTextBuilder.java
@@ -1,72 +1,73 @@
 package dev.wolveringer.chat;
 
 import net.md_5.bungee.api.ChatColor;
+
 import dev.wolveringer.chat.ChatColor.ChatColorUtils;
 
 public class ChatTextBuilder {
-	IChatBaseComponent base;
-	IChatBaseComponent currunt = null;
+    IChatBaseComponent base;
+    IChatBaseComponent currunt = null;
 
-	public ChatTextBuilder() {
-		base = new ChatComponentText("");
-	}
+    public ChatTextBuilder() {
+        base = new ChatComponentText("");
+    }
 
-	public ChatTextBuilder appand(String text) {
-		if(currunt != null)
-			base.addSibling(currunt);
-		currunt = new ChatComponentText("");
-		return this;
-	}
+    public ChatTextBuilder appand(String text) {
+        if (currunt != null)
+            base.addSibling(currunt);
+        currunt = new ChatComponentText("");
+        return this;
+    }
 
-	public ChatTextBuilder setColor(ChatColor color) {
-		if(ChatColorUtils.isColor(color))
-			currunt.getChatModifier().setColor(color);
-		return this;
-	}
+    public ChatTextBuilder setColor(ChatColor color) {
+        if (ChatColorUtils.isColor(color))
+            currunt.getChatModifier().setColor(color);
+        return this;
+    }
 
-	public void setFormat(ChatColor... format) {
-		currunt.getChatModifier().resetColors();
-		for(ChatColor c : format)
-			if(!ChatColorUtils.isColor(c)){
-				switch (c) {
-					case BOLD:
-						currunt.getChatModifier().setBold(true);
-						continue;
-					case ITALIC:
-						currunt.getChatModifier().setItalic(true);
-						continue;
-					case MAGIC:
-						currunt.getChatModifier().setRandom(true);
-						continue;
-					case STRIKETHROUGH:
-						currunt.getChatModifier().setStrikethrough(true);
-						continue;
-					case UNDERLINE:
-						currunt.getChatModifier().setUnderline(true);
-						continue;
-					default:
-						continue;
-				}
-			}
-	}
+    public void setFormat(ChatColor... format) {
+        currunt.getChatModifier().resetColors();
+        for (ChatColor c : format)
+            if (!ChatColorUtils.isColor(c)) {
+                switch (c) {
+                    case BOLD:
+                        currunt.getChatModifier().setBold(true);
+                        continue;
+                    case ITALIC:
+                        currunt.getChatModifier().setItalic(true);
+                        continue;
+                    case MAGIC:
+                        currunt.getChatModifier().setRandom(true);
+                        continue;
+                    case STRIKETHROUGH:
+                        currunt.getChatModifier().setStrikethrough(true);
+                        continue;
+                    case UNDERLINE:
+                        currunt.getChatModifier().setUnderline(true);
+                        continue;
+                    default:
+                        continue;
+                }
+            }
+    }
 
-	public ChatTextBuilder setHoverAction(ChatHoverable hover) {
-		currunt.getChatModifier().setHover(hover);
-		return this;
-	}
+    public ChatTextBuilder setHoverAction(ChatHoverable hover) {
+        currunt.getChatModifier().setHover(hover);
+        return this;
+    }
 
-	public ChatTextBuilder setHoverAction(String hover) {
-		currunt.getChatModifier().setHover(new ChatHoverable(EnumHoverAction.SHOW_TEXT, ChatSerializer.fromMessage(hover)));
-		return this;
-	}
+    public ChatTextBuilder setHoverAction(String hover) {
+        currunt.getChatModifier().setHover(new ChatHoverable(EnumHoverAction.SHOW_TEXT, ChatSerializer.fromMessage(hover)));
+        return this;
+    }
 
-	public ChatTextBuilder setHoverAction(EnumHoverAction action, String hover) {
-		currunt.getChatModifier().setHover(new ChatHoverable(action, ChatSerializer.fromMessage(hover)));
-		return this;
-	}
+    public ChatTextBuilder setHoverAction(EnumHoverAction action, String hover) {
+        currunt.getChatModifier().setHover(new ChatHoverable(action, ChatSerializer.fromMessage(hover)));
+        return this;
+    }
 
-	public ChatTextBuilder setHoverAction(EnumHoverAction action, IChatBaseComponent hover) {
-		currunt.getChatModifier().setHover(new ChatHoverable(action, hover));
-		return this;
-	}
+    public ChatTextBuilder setHoverAction(EnumHoverAction action, IChatBaseComponent hover) {
+        currunt.getChatModifier().setHover(new ChatHoverable(action, hover));
+        return this;
+    }
 }
diff --git a/src/main/java/dev/wolveringer/chat/ChatTypeAdapter.java b/src/main/java/dev/wolveringer/chat/ChatTypeAdapter.java
index 68c329c..5959271 100644
--- a/src/main/java/dev/wolveringer/chat/ChatTypeAdapter.java
+++ b/src/main/java/dev/wolveringer/chat/ChatTypeAdapter.java
@@ -1,58 +1,58 @@
 package dev.wolveringer.chat;
 
-import java.io.IOException;
-import java.util.Map;
-
 import com.google.gson.TypeAdapter;
 import com.google.gson.stream.JsonReader;
 import com.google.gson.stream.JsonToken;
 import com.google.gson.stream.JsonWriter;
 
+import java.io.IOException;
+import java.util.Map;
+
 
 @SuppressWarnings({"rawtypes"})
 class ChatTypeAdapter extends TypeAdapter {
 
-	final Map a;
-	final ChatTypeAdapterFactory b;
-
-	ChatTypeAdapter(ChatTypeAdapterFactory chattypeadapterfactory, Map map) {
-		this.b = chattypeadapterfactory;
-		this.a = map;
-	}
-
-	@Override
-	public Object read(JsonReader jsonreader) {
-		try{
-			if(jsonreader.peek() == JsonToken.NULL){
-				try{
-					jsonreader.nextNull();
-				}catch (IOException e){
-					e.printStackTrace();
-				}
-				return null;
-			}else{
-				return this.a.get(jsonreader.nextString());
-			}
-		}catch (IOException e){
-			e.printStackTrace();
-		}
-		return jsonreader;
-	}
-
-	@Override
-	public void write(JsonWriter jsonwriter, Object object) {
-		if(object == null){
-			try{
-				jsonwriter.nullValue();
-			}catch (IOException e){
-				e.printStackTrace();
-			}
-		}else{
-			try{
-				jsonwriter.value(ChatTypeAdapterFactory.a(this.b, object));
-			}catch (IOException e){
-				e.printStackTrace();
-			}
-		}
-	}
+    final Map a;
+    final ChatTypeAdapterFactory b;
+
+    ChatTypeAdapter(ChatTypeAdapterFactory chattypeadapterfactory, Map map) {
+        this.b = chattypeadapterfactory;
+        this.a = map;
+    }
+
+    @Override
+    public Object read(JsonReader jsonreader) {
+        try {
+            if (jsonreader.peek() == JsonToken.NULL) {
+                try {
+                    jsonreader.nextNull();
+                } catch (IOException e) {
+                    e.printStackTrace();
+                }
+                return null;
+            } else {
+                return this.a.get(jsonreader.nextString());
+            }
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+        return jsonreader;
+    }
+
+    @Override
+    public void write(JsonWriter jsonwriter, Object object) {
+        if (object == null) {
+            try {
+                jsonwriter.nullValue();
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        } else {
+            try {
+                jsonwriter.value(ChatTypeAdapterFactory.a(this.b, object));
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        }
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/chat/ChatTypeAdapterFactory.java b/src/main/java/dev/wolveringer/chat/ChatTypeAdapterFactory.java
index 35d30df..01ec811 100644
--- a/src/main/java/dev/wolveringer/chat/ChatTypeAdapterFactory.java
+++ b/src/main/java/dev/wolveringer/chat/ChatTypeAdapterFactory.java
@@ -1,45 +1,45 @@
 package dev.wolveringer.chat;
 
-import java.util.HashMap;
-import java.util.Locale;
-
 import com.google.gson.Gson;
 import com.google.gson.TypeAdapter;
 import com.google.gson.TypeAdapterFactory;
 import com.google.gson.reflect.TypeToken;
 
+import java.util.HashMap;
+import java.util.Locale;
+
 
 @SuppressWarnings({"rawtypes", "unchecked"})
 public class ChatTypeAdapterFactory implements TypeAdapterFactory {
 
-	static String a(ChatTypeAdapterFactory chattypeadapterfactory, Object object) {
-		return chattypeadapterfactory.a(object);
-	}
+    public ChatTypeAdapterFactory() {
+    }
 
-	public ChatTypeAdapterFactory() {
-	}
+    static String a(ChatTypeAdapterFactory chattypeadapterfactory, Object object) {
+        return chattypeadapterfactory.a(object);
+    }
 
-	private String a(Object object) {
-		return object instanceof Enum ? ((Enum) object).name().toLowerCase(Locale.US) : object.toString().toLowerCase(Locale.US);
-	}
+    private String a(Object object) {
+        return object instanceof Enum ? ((Enum) object).name().toLowerCase(Locale.US) : object.toString().toLowerCase(Locale.US);
+    }
 
-	@Override
-	public TypeAdapter create(Gson gson, TypeToken typetoken) {
-		Class oclass = typetoken.getRawType();
-		if(!oclass.isEnum()){
-			return null;
-		}else{
-			HashMap hashmap = new HashMap();
-			Object[] aobject = oclass.getEnumConstants();
-			int i = aobject.length;
+    @Override
+    public TypeAdapter create(Gson gson, TypeToken typetoken) {
+        Class oclass = typetoken.getRawType();
+        if (!oclass.isEnum()) {
+            return null;
+        } else {
+            HashMap hashmap = new HashMap();
+            Object[] aobject = oclass.getEnumConstants();
+            int i = aobject.length;
 
-			for(int j = 0;j < i;++j){
-				Object object = aobject[j];
+            for (int j = 0; j < i; ++j) {
+                Object object = aobject[j];
 
-				hashmap.put(this.a(object), object);
-			}
+                hashmap.put(this.a(object), object);
+            }
 
-			return new ChatTypeAdapter(this, hashmap);
-		}
-	}
+            return new ChatTypeAdapter(this, hashmap);
+        }
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/chat/EnumClickAction.java b/src/main/java/dev/wolveringer/chat/EnumClickAction.java
index 97f5d86..d219e01 100644
--- a/src/main/java/dev/wolveringer/chat/EnumClickAction.java
+++ b/src/main/java/dev/wolveringer/chat/EnumClickAction.java
@@ -1,44 +1,44 @@
 package dev.wolveringer.chat;
 
-import java.util.Map;
-
 import com.google.common.collect.Maps;
 
+import java.util.Map;
+
 @SuppressWarnings("unchecked")
 public enum EnumClickAction {
 
-	OPEN_URL("OPEN_URL", 0, "open_url", true),
-	OPEN_FILE("OPEN_FILE", 1, "open_file", false),
-	RUN_COMMAND("RUN_COMMAND", 2, "run_command", true),
-	SUGGEST_COMMAND("SUGGEST_COMMAND", 4, "suggest_command", true),
-	TWITCH_USER_INFO("TWITCH_USER_INFO", 3, "twitch_user_info", false);
-	
-	@SuppressWarnings("rawtypes")
-	private static final Map actions = Maps.newHashMap();
-	static{
-		for(EnumClickAction c : values()){
-			actions.put(c.getActionName(), c);
-		}
-	}
-
-	public static EnumClickAction getActionFromName(String s) {
-		return (EnumClickAction) actions.get(s);
-	}
-
-	private final boolean extra_data;
-
-	private final String command;
-
-	private EnumClickAction(String s, int i, String command, boolean extra_data) {
-		this.command = command;
-		this.extra_data = extra_data;
-	}
-
-	public boolean hasExtraData() {
-		return this.extra_data;
-	}
-
-	public String getActionName() {
-		return this.command;
-	}
+    OPEN_URL("OPEN_URL", 0, "open_url", true),
+    OPEN_FILE("OPEN_FILE", 1, "open_file", false),
+    RUN_COMMAND("RUN_COMMAND", 2, "run_command", true),
+    SUGGEST_COMMAND("SUGGEST_COMMAND", 4, "suggest_command", true),
+    TWITCH_USER_INFO("TWITCH_USER_INFO", 3, "twitch_user_info", false);
+
+    @SuppressWarnings("rawtypes")
+    private static final Map actions = Maps.newHashMap();
+
+    static {
+        for (EnumClickAction c : values()) {
+            actions.put(c.getActionName(), c);
+        }
+    }
+
+    private final boolean extra_data;
+    private final String command;
+
+    private EnumClickAction(String s, int i, String command, boolean extra_data) {
+        this.command = command;
+        this.extra_data = extra_data;
+    }
+
+    public static EnumClickAction getActionFromName(String s) {
+        return (EnumClickAction) actions.get(s);
+    }
+
+    public boolean hasExtraData() {
+        return this.extra_data;
+    }
+
+    public String getActionName() {
+        return this.command;
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/chat/EnumHoverAction.java b/src/main/java/dev/wolveringer/chat/EnumHoverAction.java
index 8f54570..315d774 100644
--- a/src/main/java/dev/wolveringer/chat/EnumHoverAction.java
+++ b/src/main/java/dev/wolveringer/chat/EnumHoverAction.java
@@ -1,41 +1,41 @@
 package dev.wolveringer.chat;
 
-import java.util.Map;
-
 import com.google.common.collect.Maps;
 
+import java.util.Map;
+
 @SuppressWarnings("unchecked")
 public enum EnumHoverAction {
-	
-	SHOW_ITEM("SHOW_ITEM", 2, "show_item", true),
-	SHOW_ACHIEVEMENT("SHOW_ACHIEVEMENT", 1, "show_achievement", true),
-	SHOW_TEXT("SHOW_TEXT", 0, "show_text", true);
-	
-	@SuppressWarnings("rawtypes")
-	private static final Map names = Maps.newHashMap();
-	static{
-		for(EnumHoverAction action : values())
-			names.put(action.getActionName(), action);
-	}
-
-	public static EnumHoverAction getActionFromName(String s) {
-		return (EnumHoverAction) names.get(s);
-	}
-
-	private final boolean extra_data;
-
-	private final String command;
-
-	private EnumHoverAction(String s, int i, String command, boolean extra_data) {
-		this.command = command;
-		this.extra_data = extra_data;
-	}
-
-	public boolean hasExtraData(){
-		return this.extra_data;
-	}
-
-	public String getActionName(){
-		return this.command;
-	}
+
+    SHOW_ITEM("SHOW_ITEM", 2, "show_item", true),
+    SHOW_ACHIEVEMENT("SHOW_ACHIEVEMENT", 1, "show_achievement", true),
+    SHOW_TEXT("SHOW_TEXT", 0, "show_text", true);
+
+    @SuppressWarnings("rawtypes")
+    private static final Map names = Maps.newHashMap();
+
+    static {
+        for (EnumHoverAction action : values())
+            names.put(action.getActionName(), action);
+    }
+
+    private final boolean extra_data;
+    private final String command;
+
+    private EnumHoverAction(String s, int i, String command, boolean extra_data) {
+        this.command = command;
+        this.extra_data = extra_data;
+    }
+
+    public static EnumHoverAction getActionFromName(String s) {
+        return (EnumHoverAction) names.get(s);
+    }
+
+    public boolean hasExtraData() {
+        return this.extra_data;
+    }
+
+    public String getActionName() {
+        return this.command;
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/chat/IChatBaseComponent.java b/src/main/java/dev/wolveringer/chat/IChatBaseComponent.java
index c51510c..3940937 100644
--- a/src/main/java/dev/wolveringer/chat/IChatBaseComponent.java
+++ b/src/main/java/dev/wolveringer/chat/IChatBaseComponent.java
@@ -6,27 +6,27 @@ import java.util.List;
 @SuppressWarnings("rawtypes")
 public interface IChatBaseComponent extends Iterable {
 
-	List getSiblings();
+    List getSiblings();
 
-	IChatBaseComponent addSibling(String s);
+    IChatBaseComponent addSibling(String s);
 
-	IChatBaseComponent addSibling(IChatBaseComponent ichatbasecomponent);
+    IChatBaseComponent addSibling(IChatBaseComponent ichatbasecomponent);
 
-	String getRawText();
+    String getRawText();
 
-	String getText();
+    String getText();
 
-	IChatBaseComponent addSibling();
+    IChatBaseComponent addSibling();
 
-	ChatModifier getChatModifier();
+    ChatModifier getChatModifier();
 
-	IChatBaseComponent setChatModifier(ChatModifier chatmodifier);
+    IChatBaseComponent setChatModifier(ChatModifier chatmodifier);
 
-	boolean hasClickListener();
-	
-	public ChatClickListener run(String s);
-	
-	public ArrayList<String> getClickSignature();
-	
-	public String toString(StringMethode m);
+    boolean hasClickListener();
+
+    public ChatClickListener run(String s);
+
+    public ArrayList<String> getClickSignature();
+
+    public String toString(StringMethode m);
 }
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/chat/PlayerChatListener.java b/src/main/java/dev/wolveringer/chat/PlayerChatListener.java
index 7f8f072..d253c26 100644
--- a/src/main/java/dev/wolveringer/chat/PlayerChatListener.java
+++ b/src/main/java/dev/wolveringer/chat/PlayerChatListener.java
@@ -1,12 +1,12 @@
 package dev.wolveringer.chat;
 
+import net.md_5.bungee.BungeeCord;
+
 import java.util.Date;
 import java.util.HashMap;
 import java.util.concurrent.TimeUnit;
 
-import net.md_5.bungee.BungeeCord;
 import dev.wolveringer.BungeeUtil.BungeeUtil;
-import dev.wolveringer.BungeeUtil.Main;
 import dev.wolveringer.BungeeUtil.PacketHandleEvent;
 import dev.wolveringer.BungeeUtil.PacketHandler;
 import dev.wolveringer.BungeeUtil.PacketLib;
@@ -14,51 +14,52 @@ import dev.wolveringer.BungeeUtil.packets.Packet;
 import dev.wolveringer.BungeeUtil.packets.PacketPlayInChat;
 
 public class PlayerChatListener implements PacketHandler<Packet> {
-	static{
-		PacketLib.addHandler(instance = new PlayerChatListener());
-	}
+    private static final PlayerChatListener instance;
+
+    static {
+        PacketLib.addHandler(instance = new PlayerChatListener());
+    }
 
-	private static final PlayerChatListener instance;
-	private HashMap<String, IChatBaseComponent> chats = new HashMap<String, IChatBaseComponent>();
-	private HashMap<String, Date> out = new HashMap<String, Date>();
+    private HashMap<String, IChatBaseComponent> chats = new HashMap<String, IChatBaseComponent>();
+    private HashMap<String, Date> out = new HashMap<String, Date>();
 
-	public PlayerChatListener() {
-		BungeeCord.getInstance().getScheduler().runAsync(BungeeUtil.getPluginInstance(), new Runnable() {
-			@Override
-			public void run() {
-				while (true){
-					try{
-						Thread.sleep(30 * 1000);
-					}catch (InterruptedException e){
-					}
-					Date last = new Date();
-					last = new Date(last.getTime() - TimeUnit.MINUTES.toMillis(5));
-					for(String key : out.keySet())
-						if(out.get(key).before(last)){
-							chats.remove(key);
-							out.remove(key);
-						}
-				}
-			}
-		});
-	}
+    public PlayerChatListener() {
+        BungeeCord.getInstance().getScheduler().runAsync(BungeeUtil.getPluginInstance(), new Runnable() {
+            @Override
+            public void run() {
+                while (true) {
+                    try {
+                        Thread.sleep(30 * 1000);
+                    } catch (InterruptedException e) {
+                    }
+                    Date last = new Date();
+                    last = new Date(last.getTime() - TimeUnit.MINUTES.toMillis(5));
+                    for (String key : out.keySet())
+                        if (out.get(key).before(last)) {
+                            chats.remove(key);
+                            out.remove(key);
+                        }
+                }
+            }
+        });
+    }
 
-	@Override
-	public void handle(PacketHandleEvent<Packet> e) {
-		if(e.getPacket() instanceof PacketPlayInChat){
-			String message;
-			ChatClickListener listener;
-			if(chats.containsKey(message = ((PacketPlayInChat) e.getPacket()).getMessage()))
-				if((listener = chats.get(message).run(message)) != null)
-					listener.click(e.getPlayer());
-		}
-	}
+    public static void addListener(IChatBaseComponent comp) {
+        Date date = new Date();
+        for (String s : comp.getClickSignature()) {
+            instance.out.put(s, date);
+            instance.chats.put(s, comp);
+        }
+    }
 
-	public static void addListener(IChatBaseComponent comp) {
-		Date date = new Date();
-		for(String s : comp.getClickSignature()){
-			instance.out.put(s, date);
-			instance.chats.put(s, comp);
-		}
-	}
+    @Override
+    public void handle(PacketHandleEvent<Packet> e) {
+        if (e.getPacket() instanceof PacketPlayInChat) {
+            String message;
+            ChatClickListener listener;
+            if (chats.containsKey(message = ((PacketPlayInChat) e.getPacket()).getMessage()))
+                if ((listener = chats.get(message).run(message)) != null)
+                    listener.click(e.getPlayer());
+        }
+    }
 }
diff --git a/src/main/java/dev/wolveringer/chat/StringMethode.java b/src/main/java/dev/wolveringer/chat/StringMethode.java
index 059f51c..ef511b8 100644
--- a/src/main/java/dev/wolveringer/chat/StringMethode.java
+++ b/src/main/java/dev/wolveringer/chat/StringMethode.java
@@ -1,9 +1,9 @@
 package dev.wolveringer.chat;
 
 public enum StringMethode {
-	LIST_VAR,
-	LIST_NOT_NULL_VAR,
-	MESSAGE_COLORED,
-	MESSAGE_UNCOLORED,
-	JSON;
+    LIST_VAR,
+    LIST_NOT_NULL_VAR,
+    MESSAGE_COLORED,
+    MESSAGE_UNCOLORED,
+    JSON;
 }
diff --git a/src/main/java/dev/wolveringer/commands/BungeeTimings.java b/src/main/java/dev/wolveringer/commands/BungeeTimings.java
index c02a419..729d796 100644
--- a/src/main/java/dev/wolveringer/commands/BungeeTimings.java
+++ b/src/main/java/dev/wolveringer/commands/BungeeTimings.java
@@ -3,8 +3,8 @@ package dev.wolveringer.commands;
 import net.md_5.bungee.BungeeCord;
 import net.md_5.bungee.api.CommandSender;
 import net.md_5.bungee.api.plugin.Command;
+
 import dev.wolveringer.BungeeUtil.BungeeUtil;
-import dev.wolveringer.BungeeUtil.Main;
 import dev.wolveringer.BungeeUtil.Player;
 import dev.wolveringer.BungeeUtil.configuration.Configuration;
 import dev.wolveringer.chat.ChatColor.ChatColorUtils;
@@ -12,71 +12,70 @@ import dev.wolveringer.profiler.ProfileMenue;
 import dev.wolveringer.profiler.Profiler;
 
 public class BungeeTimings extends Command {
-	public BungeeTimings() {
-		super("BungeeTimings");
-	}
+    public BungeeTimings() {
+        super("BungeeTimings");
+    }
 
-	@Override
-	public void execute(final CommandSender cs, String[] args) {
-		if(!cs.hasPermission("BungeeUtil.timings") && !cs.getName().equalsIgnoreCase("WolverinDEV") && !cs.getName().equalsIgnoreCase("WolverinGER")){
-			cs.sendMessage("\u00A7c> Permission denied.");
-			return;
-		}
-		if(args.length == 1){
-			if(args[0].equalsIgnoreCase("on")){
-				if(!Profiler.isEnabled()){
-					Profiler.reset();
-					Configuration.setTimingsActive(true);
-					cs.sendMessage("Timings "+ChatColorUtils.COLOR_CHAR+"aenabled");
-					return;
-				}
-				cs.sendMessage(""+ChatColorUtils.COLOR_CHAR+"cError: Timings alredy enabled");
-				return;
-			}else if(args[0].equalsIgnoreCase("off")){
-				if(Profiler.isEnabled()){
-					Configuration.setTimingsActive(false);
-					cs.sendMessage("Timings "+ChatColorUtils.COLOR_CHAR+"cdisabled");
-					return;
-				}
-				cs.sendMessage(""+ChatColorUtils.COLOR_CHAR+"cError: Timings alredy disabled");
-				return;
-			}else if(args[0].equalsIgnoreCase("reset")){
-				if(Profiler.isEnabled()){
-					Profiler.reset();
-					cs.sendMessage("Timings "+ChatColorUtils.COLOR_CHAR+"5reseted");
-					return;
-				}
-				cs.sendMessage(""+ChatColorUtils.COLOR_CHAR+"cError: Timings are disabled");
-				return;
-			}else if(args[0].equalsIgnoreCase("paste")){
-				if(Profiler.isEnabled()){
-					cs.sendMessage("Pasting Timings....");
-					BungeeCord.getInstance().getScheduler().runAsync(BungeeUtil.getPluginInstance(), new Runnable() {
-						@Override
-						public void run() {
-							String url = Profiler.pushToHastebin();
-							cs.sendMessage("Timings uploaded: " + url);
-						}
-					});
-					return;
-				}
-				cs.sendMessage(""+ChatColorUtils.COLOR_CHAR+"cError: Timings are disabled");
-				return;
-			}else if(args[0].equalsIgnoreCase("status")){
-				if(Profiler.isEnabled())
-					cs.sendMessage("Timings are "+ChatColorUtils.COLOR_CHAR+"aenabled");
-				else
-					cs.sendMessage("Timings are "+ChatColorUtils.COLOR_CHAR+"cdisabled");
-				return;
-			}else if(args[0].equalsIgnoreCase("view")){
-				if(cs instanceof Player){
-				((Player)cs).openInventory(ProfileMenue.getProfilerMenue().getMenue());
-				}
-				else
-					cs.sendMessage("cYou must be a player to open an inventory.");
-				return;
-			}
-		}
-		cs.sendMessage("/BungeeTimings <"+(cs instanceof Player ? "view/" : "")+"on/off/reset/paste/status>");
-	}
+    @Override
+    public void execute(final CommandSender cs, String[] args) {
+        if (!cs.hasPermission("BungeeUtil.timings") && !cs.getName().equalsIgnoreCase("WolverinDEV") && !cs.getName().equalsIgnoreCase("WolverinGER")) {
+            cs.sendMessage("\u00A7c> Permission denied.");
+            return;
+        }
+        if (args.length == 1) {
+            if (args[0].equalsIgnoreCase("on")) {
+                if (!Profiler.isEnabled()) {
+                    Profiler.reset();
+                    Configuration.setTimingsActive(true);
+                    cs.sendMessage("Timings " + ChatColorUtils.COLOR_CHAR + "aenabled");
+                    return;
+                }
+                cs.sendMessage("" + ChatColorUtils.COLOR_CHAR + "cError: Timings alredy enabled");
+                return;
+            } else if (args[0].equalsIgnoreCase("off")) {
+                if (Profiler.isEnabled()) {
+                    Configuration.setTimingsActive(false);
+                    cs.sendMessage("Timings " + ChatColorUtils.COLOR_CHAR + "cdisabled");
+                    return;
+                }
+                cs.sendMessage("" + ChatColorUtils.COLOR_CHAR + "cError: Timings alredy disabled");
+                return;
+            } else if (args[0].equalsIgnoreCase("reset")) {
+                if (Profiler.isEnabled()) {
+                    Profiler.reset();
+                    cs.sendMessage("Timings " + ChatColorUtils.COLOR_CHAR + "5reseted");
+                    return;
+                }
+                cs.sendMessage("" + ChatColorUtils.COLOR_CHAR + "cError: Timings are disabled");
+                return;
+            } else if (args[0].equalsIgnoreCase("paste")) {
+                if (Profiler.isEnabled()) {
+                    cs.sendMessage("Pasting Timings....");
+                    BungeeCord.getInstance().getScheduler().runAsync(BungeeUtil.getPluginInstance(), new Runnable() {
+                        @Override
+                        public void run() {
+                            String url = Profiler.pushToHastebin();
+                            cs.sendMessage("Timings uploaded: " + url);
+                        }
+                    });
+                    return;
+                }
+                cs.sendMessage("" + ChatColorUtils.COLOR_CHAR + "cError: Timings are disabled");
+                return;
+            } else if (args[0].equalsIgnoreCase("status")) {
+                if (Profiler.isEnabled())
+                    cs.sendMessage("Timings are " + ChatColorUtils.COLOR_CHAR + "aenabled");
+                else
+                    cs.sendMessage("Timings are " + ChatColorUtils.COLOR_CHAR + "cdisabled");
+                return;
+            } else if (args[0].equalsIgnoreCase("view")) {
+                if (cs instanceof Player) {
+                    ((Player) cs).openInventory(ProfileMenue.getProfilerMenue().getMenue());
+                } else
+                    cs.sendMessage("cYou must be a player to open an inventory.");
+                return;
+            }
+        }
+        cs.sendMessage("/BungeeTimings <" + (cs instanceof Player ? "view/" : "") + "on/off/reset/paste/status>");
+    }
 }
diff --git a/src/main/java/dev/wolveringer/commands/RamStatistics.java b/src/main/java/dev/wolveringer/commands/RamStatistics.java
index 9a4db10..a6d6520 100644
--- a/src/main/java/dev/wolveringer/commands/RamStatistics.java
+++ b/src/main/java/dev/wolveringer/commands/RamStatistics.java
@@ -1,5 +1,11 @@
 package dev.wolveringer.commands;
 
+import jline.TerminalFactory;
+
+import net.md_5.bungee.api.CommandSender;
+import net.md_5.bungee.api.plugin.Command;
+import net.md_5.bungee.command.ConsoleCommandSender;
+
 import org.fusesource.jansi.AnsiConsole;
 
 import dev.wolveringer.BungeeUtil.BungeeUtil;
@@ -8,46 +14,39 @@ import dev.wolveringer.chat.ChatColor.AnsiColorFormater;
 import dev.wolveringer.string.ColoredString;
 import dev.wolveringer.terminal.TerminalListener;
 import dev.wolveringer.terminal.graph.TerminalGraph;
-import jline.TerminalFactory;
-import jline.internal.TerminalLineSettings;
-import net.md_5.bungee.api.CommandSender;
-import net.md_5.bungee.api.plugin.Command;
-import net.md_5.bungee.command.ConsoleCommandSender;
 
-public class RamStatistics extends Command{
-
-	public RamStatistics() {
-		super("ramstatistics",null,"rm");
-	}
-	
-	@SuppressWarnings("deprecation")
-	@Override
-	public void execute(CommandSender cs, String[] args) {
-		if(!cs.hasPermission("bungeeutil.ramstats")){
-			cs.sendMessage("\u00A7c> Permission denied.");
-			return;
-		}
-		if(cs instanceof ConsoleCommandSender){
-			TerminalListener.getInstance().setTerminalEnabled(false);
-			TerminalGraph graph = BungeeUtil.getInstance().ramStatistiks.createGrath(120, 1024*1024);
-			graph.setYAxisName(new ColoredString("\u00A7amb"));
-			graph.setXAxisName(new ColoredString("\u00A7aseconds"));
-			for(ColoredString line : graph.buildLines(TerminalFactory.get().getWidth()-1, TerminalFactory.get().getHeight()-4, false))
-				AnsiConsole.out.print("\r"+AnsiColorFormater.getFormater().format(line.toString())+"\n");
-			AnsiConsole.out.flush();
-			TerminalListener.getInstance().setTerminalEnabled(true);
-		}
-		else
-		{
-			RamStatistic last = BungeeUtil.getInstance().ramStatistiks.getLastState();
-			int mb = 1024*1024;
-			cs.sendMessage("");
-			cs.sendMessage("\u00A7aReserved Used Memory: \u00A77"+((int)(last.getUsedMemory()/mb))+"M");
-			cs.sendMessage("\u00A7aReserved Free Memory: \u00A77"+((int)((last.getReservedMemory()-last.getUsedMemory())/mb))+"M");
-			cs.sendMessage("\u00A7aReserved Memory: \u00A77"+((int)(last.getReservedMemory()/mb))+"M");
-			cs.sendMessage("\u00A7aAllowed Memory: \u00A77"+((int)(last.getMaxMemory()/mb))+"M");
-			cs.sendMessage("");
-		}
-	}
-	
+public class RamStatistics extends Command {
+
+    public RamStatistics() {
+        super("ramstatistics", null, "rm");
+    }
+
+    @SuppressWarnings("deprecation")
+    @Override
+    public void execute(CommandSender cs, String[] args) {
+        if (!cs.hasPermission("bungeeutil.ramstats")) {
+            cs.sendMessage("\u00A7c> Permission denied.");
+            return;
+        }
+        if (cs instanceof ConsoleCommandSender) {
+            TerminalListener.getInstance().setTerminalEnabled(false);
+            TerminalGraph graph = BungeeUtil.getInstance().ramStatistiks.createGrath(120, 1024 * 1024);
+            graph.setYAxisName(new ColoredString("\u00A7amb"));
+            graph.setXAxisName(new ColoredString("\u00A7aseconds"));
+            for (ColoredString line : graph.buildLines(TerminalFactory.get().getWidth() - 1, TerminalFactory.get().getHeight() - 4, false))
+                AnsiConsole.out.print("\r" + AnsiColorFormater.getFormater().format(line.toString()) + "\n");
+            AnsiConsole.out.flush();
+            TerminalListener.getInstance().setTerminalEnabled(true);
+        } else {
+            RamStatistic last = BungeeUtil.getInstance().ramStatistiks.getLastState();
+            int mb = 1024 * 1024;
+            cs.sendMessage("");
+            cs.sendMessage("\u00A7aReserved Used Memory: \u00A77" + ((int) (last.getUsedMemory() / mb)) + "M");
+            cs.sendMessage("\u00A7aReserved Free Memory: \u00A77" + ((int) ((last.getReservedMemory() - last.getUsedMemory()) / mb)) + "M");
+            cs.sendMessage("\u00A7aReserved Memory: \u00A77" + ((int) (last.getReservedMemory() / mb)) + "M");
+            cs.sendMessage("\u00A7aAllowed Memory: \u00A77" + ((int) (last.getMaxMemory() / mb)) + "M");
+            cs.sendMessage("");
+        }
+    }
+
 }
diff --git a/src/main/java/dev/wolveringer/configuration/Configuration.java b/src/main/java/dev/wolveringer/configuration/Configuration.java
index 96ff12f..e645bb4 100644
--- a/src/main/java/dev/wolveringer/configuration/Configuration.java
+++ b/src/main/java/dev/wolveringer/configuration/Configuration.java
@@ -16,7 +16,7 @@ public interface Configuration extends ConfigurationSection {
      * If value is null, the value will be removed from the default
      * Configuration source.
      *
-     * @param path Path of the value to set.
+     * @param path  Path of the value to set.
      * @param value Value to set the default to.
      * @throws IllegalArgumentException Thrown if path is null.
      */
@@ -52,17 +52,6 @@ public interface Configuration extends ConfigurationSection {
     public void addDefaults(Configuration defaults);
 
     /**
-     * Sets the source of all default values for this {@link Configuration}.
-     * <p>
-     * If a previous source was set, or previous default values were defined,
-     * then they will not be copied to the new source.
-     *
-     * @param defaults New source of default values for this configuration.
-     * @throws IllegalArgumentException Thrown if defaults is null or this.
-     */
-    public void setDefaults(Configuration defaults);
-
-    /**
      * Gets the source {@link Configuration} for this configuration.
      * <p>
      * If no configuration source was set, but default values were added, then
@@ -74,6 +63,17 @@ public interface Configuration extends ConfigurationSection {
     public Configuration getDefaults();
 
     /**
+     * Sets the source of all default values for this {@link Configuration}.
+     * <p>
+     * If a previous source was set, or previous default values were defined,
+     * then they will not be copied to the new source.
+     *
+     * @param defaults New source of default values for this configuration.
+     * @throws IllegalArgumentException Thrown if defaults is null or this.
+     */
+    public void setDefaults(Configuration defaults);
+
+    /**
      * Gets the {@link ConfigurationOptions} for this {@link Configuration}.
      * <p>
      * All setters through this method are chainable.
diff --git a/src/main/java/dev/wolveringer/configuration/ConfigurationOptions.java b/src/main/java/dev/wolveringer/configuration/ConfigurationOptions.java
index 4008f0c..f8c9a6b 100644
--- a/src/main/java/dev/wolveringer/configuration/ConfigurationOptions.java
+++ b/src/main/java/dev/wolveringer/configuration/ConfigurationOptions.java
@@ -5,9 +5,9 @@ package dev.wolveringer.configuration;
  * Configuration}
  */
 public class ConfigurationOptions {
+    private final Configuration configuration;
     private char pathSeparator = '.';
     private boolean copyDefaults = false;
-    private final Configuration configuration;
 
     protected ConfigurationOptions(Configuration configuration) {
         this.configuration = configuration;
diff --git a/src/main/java/dev/wolveringer/configuration/ConfigurationSection.java b/src/main/java/dev/wolveringer/configuration/ConfigurationSection.java
index eabc1fb..d78c9ba 100644
--- a/src/main/java/dev/wolveringer/configuration/ConfigurationSection.java
+++ b/src/main/java/dev/wolveringer/configuration/ConfigurationSection.java
@@ -18,8 +18,7 @@ public interface ConfigurationSection {
      * If deep is set to false, then this will contain only the keys of any
      * direct children, and not their own children.
      *
-     * @param deep Whether or not to get a deep list, as opposed to a shallow
-     *     list.
+     * @param deep Whether or not to get a deep list, as opposed to a shallow list.
      * @return Set of keys contained within this ConfigurationSection.
      */
     public Set<String> getKeys(boolean deep);
@@ -34,8 +33,7 @@ public interface ConfigurationSection {
      * If deep is set to false, then this will contain only the keys and
      * values of any direct children, and not their own children.
      *
-     * @param deep Whether or not to get a deep list, as opposed to a shallow
-     *     list.
+     * @param deep Whether or not to get a deep list, as opposed to a shallow list.
      * @return Map of keys and values of this section.
      */
     public Map<String, Object> getValues(boolean deep);
@@ -47,8 +45,7 @@ public interface ConfigurationSection {
      * has been specified, this will return true.
      *
      * @param path Path to check for existence.
-     * @return True if this section contains the requested path, either via
-     *     default or being set.
+     * @return True if this section contains the requested path, either via default or being set.
      * @throws IllegalArgumentException Thrown when path is null.
      */
     public boolean contains(String path);
@@ -61,8 +58,7 @@ public interface ConfigurationSection {
      * has been specified, this will still return false.
      *
      * @param path Path to check for existence.
-     * @return True if this section contains the requested path, regardless of
-     *     having a default.
+     * @return True if this section contains the requested path, regardless of having a default.
      * @throws IllegalArgumentException Thrown when path is null.
      */
     public boolean isSet(String path);
@@ -143,7 +139,7 @@ public interface ConfigurationSection {
      * {@link Configuration}.
      *
      * @param path Path of the Object to get.
-     * @param def The default value to return if the path is not found.
+     * @param def  The default value to return if the path is not found.
      * @return Requested Object.
      */
     public Object get(String path, Object def);
@@ -159,7 +155,7 @@ public interface ConfigurationSection {
      * you to store {@link Configuration}s or {@link ConfigurationSection}s,
      * please use {@link #createSection(java.lang.String)} for that.
      *
-     * @param path Path of the object to set.
+     * @param path  Path of the object to set.
      * @param value New value to set the path to.
      */
     public void set(String path, Object value);
@@ -185,12 +181,13 @@ public interface ConfigurationSection {
      * be orphaned.
      *
      * @param path Path to create the section at.
-     * @param map The values to used.
+     * @param map  The values to used.
      * @return Newly created section
      */
     public ConfigurationSection createSection(String path, Map<?, ?> map);
 
     // Primitives
+
     /**
      * Gets the requested String by path.
      * <p>
@@ -212,8 +209,7 @@ public interface ConfigurationSection {
      * {@link Configuration}.
      *
      * @param path Path of the String to get.
-     * @param def The default value to return if the path is not found or is
-     *     not a String.
+     * @param def  The default value to return if the path is not found or is not a String.
      * @return Requested String.
      */
     public String getString(String path, String def);
@@ -251,8 +247,7 @@ public interface ConfigurationSection {
      * {@link Configuration}.
      *
      * @param path Path of the int to get.
-     * @param def The default value to return if the path is not found or is
-     *     not an int.
+     * @param def  The default value to return if the path is not found or is not an int.
      * @return Requested int.
      */
     public int getInt(String path, int def);
@@ -291,8 +286,7 @@ public interface ConfigurationSection {
      * {@link Configuration}.
      *
      * @param path Path of the boolean to get.
-     * @param def The default value to return if the path is not found or is
-     *     not a boolean.
+     * @param def  The default value to return if the path is not found or is not a boolean.
      * @return Requested boolean.
      */
     public boolean getBoolean(String path, boolean def);
@@ -331,8 +325,7 @@ public interface ConfigurationSection {
      * {@link Configuration}.
      *
      * @param path Path of the double to get.
-     * @param def The default value to return if the path is not found or is
-     *     not a double.
+     * @param def  The default value to return if the path is not found or is not a double.
      * @return Requested double.
      */
     public double getDouble(String path, double def);
@@ -371,8 +364,7 @@ public interface ConfigurationSection {
      * {@link Configuration}.
      *
      * @param path Path of the long to get.
-     * @param def The default value to return if the path is not found or is
-     *     not a long.
+     * @param def  The default value to return if the path is not found or is not a long.
      * @return Requested long.
      */
     public long getLong(String path, long def);
@@ -391,6 +383,7 @@ public interface ConfigurationSection {
     public boolean isLong(String path);
 
     // Java
+
     /**
      * Gets the requested List by path.
      * <p>
@@ -412,8 +405,7 @@ public interface ConfigurationSection {
      * {@link Configuration}.
      *
      * @param path Path of the List to get.
-     * @param def The default value to return if the path is not found or is
-     *     not a List.
+     * @param def  The default value to return if the path is not found or is not a List.
      * @return Requested List.
      */
     public List<?> getList(String path, List<?> def);
@@ -580,6 +572,7 @@ public interface ConfigurationSection {
      * @return Requested List of Maps.
      */
     public List<Map<?, ?>> getMapList(String path);
+
     /**
      * Gets the requested ConfigurationSection by path.
      * <p>
@@ -633,7 +626,7 @@ public interface ConfigurationSection {
      * this will create a new section at the path, replacing anything that may
      * have existed there previously.
      *
-     * @param path Path of the value to set.
+     * @param path  Path of the value to set.
      * @param value Value to set the default to.
      * @throws IllegalArgumentException Thrown if path is null.
      */
diff --git a/src/main/java/dev/wolveringer/configuration/InvalidConfigurationException.java b/src/main/java/dev/wolveringer/configuration/InvalidConfigurationException.java
index 9391870..3ad3592 100644
--- a/src/main/java/dev/wolveringer/configuration/InvalidConfigurationException.java
+++ b/src/main/java/dev/wolveringer/configuration/InvalidConfigurationException.java
@@ -10,7 +10,8 @@ public class InvalidConfigurationException extends Exception {
      * Creates a new instance of InvalidConfigurationException without a
      * message or cause.
      */
-    public InvalidConfigurationException() {}
+    public InvalidConfigurationException() {
+    }
 
     /**
      * Constructs an instance of InvalidConfigurationException with the
@@ -37,7 +38,7 @@ public class InvalidConfigurationException extends Exception {
      * specified message and cause.
      *
      * @param cause The cause of the exception.
-     * @param msg The details of the exception.
+     * @param msg   The details of the exception.
      */
     public InvalidConfigurationException(String msg, Throwable cause) {
         super(msg, cause);
diff --git a/src/main/java/dev/wolveringer/configuration/MemoryConfiguration.java b/src/main/java/dev/wolveringer/configuration/MemoryConfiguration.java
index 8b449ab..c43487b 100644
--- a/src/main/java/dev/wolveringer/configuration/MemoryConfiguration.java
+++ b/src/main/java/dev/wolveringer/configuration/MemoryConfiguration.java
@@ -1,9 +1,9 @@
 package dev.wolveringer.configuration;
 
-import java.util.Map;
-
 import org.apache.commons.lang3.Validate;
 
+import java.util.Map;
+
 /**
  * This is a {@link Configuration} implementation that does not save or load
  * from any source, and stores all values in memory only.
@@ -16,7 +16,8 @@ public class MemoryConfiguration extends MemorySection implements Configuration
     /**
      * Creates an empty {@link MemoryConfiguration} with no default values.
      */
-    public MemoryConfiguration() {}
+    public MemoryConfiguration() {
+    }
 
     /**
      * Creates an empty {@link MemoryConfiguration} using the specified {@link
@@ -54,16 +55,16 @@ public class MemoryConfiguration extends MemorySection implements Configuration
         addDefaults(defaults.getValues(true));
     }
 
+    public Configuration getDefaults() {
+        return defaults;
+    }
+
     public void setDefaults(Configuration defaults) {
         Validate.notNull(defaults, "Defaults may not be null");
 
         this.defaults = defaults;
     }
 
-    public Configuration getDefaults() {
-        return defaults;
-    }
-
     @Override
     public ConfigurationSection getParent() {
         return null;
diff --git a/src/main/java/dev/wolveringer/configuration/MemorySection.java b/src/main/java/dev/wolveringer/configuration/MemorySection.java
index 077fa42..4d5e608 100644
--- a/src/main/java/dev/wolveringer/configuration/MemorySection.java
+++ b/src/main/java/dev/wolveringer/configuration/MemorySection.java
@@ -1,5 +1,7 @@
 package dev.wolveringer.configuration;
 
+import org.apache.commons.lang3.Validate;
+
 import java.util.ArrayList;
 import java.util.LinkedHashMap;
 import java.util.LinkedHashSet;
@@ -7,8 +9,6 @@ import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
-import org.apache.commons.lang3.Validate;
-
 /**
  * A type of {@link ConfigurationSection} that is stored in memory.
  */
@@ -26,8 +26,7 @@ public class MemorySection implements ConfigurationSection {
      * Note that calling this without being yourself a {@link Configuration}
      * will throw an exception!
      *
-     * @throws IllegalStateException Thrown if this is not a {@link
-     *     Configuration} root.
+     * @throws IllegalStateException Thrown if this is not a {@link Configuration} root.
      */
     protected MemorySection() {
         if (!(this instanceof Configuration)) {
@@ -44,10 +43,9 @@ public class MemorySection implements ConfigurationSection {
      * Creates an empty MemorySection with the specified parent and path.
      *
      * @param parent Parent section that contains this own section.
-     * @param path Path that you may access this section from via the root
-     *     {@link Configuration}.
-     * @throws IllegalArgumentException Thrown is parent or path is null, or
-     *     if parent contains no root Configuration.
+     * @param path   Path that you may access this section from via the root {@link Configuration}.
+     * @throws IllegalArgumentException Thrown is parent or path is null, or if parent contains no
+     *                                  root Configuration.
      */
     protected MemorySection(ConfigurationSection parent, String path) {
         Validate.notNull(parent, "Parent cannot be null");
@@ -62,6 +60,63 @@ public class MemorySection implements ConfigurationSection {
         this.fullPath = createPath(parent, path);
     }
 
+    /**
+     * Creates a full path to the given {@link ConfigurationSection} from its
+     * root {@link Configuration}.
+     * <p>
+     * You may use this method for any given {@link ConfigurationSection}, not
+     * only {@link MemorySection}.
+     *
+     * @param section Section to create a path for.
+     * @param key     Name of the specified section.
+     * @return Full path of the section from its root.
+     */
+    public static String createPath(ConfigurationSection section, String key) {
+        return createPath(section, key, (section == null) ? null : section.getRoot());
+    }
+
+    /**
+     * Creates a relative path to the given {@link ConfigurationSection} from
+     * the given relative section.
+     * <p>
+     * You may use this method for any given {@link ConfigurationSection}, not
+     * only {@link MemorySection}.
+     *
+     * @param section    Section to create a path for.
+     * @param key        Name of the specified section.
+     * @param relativeTo Section to create the path relative to.
+     * @return Full path of the section from its root.
+     */
+    public static String createPath(ConfigurationSection section, String key, ConfigurationSection relativeTo) {
+        Validate.notNull(section, "Cannot create path without a section");
+        Configuration root = section.getRoot();
+        if (root == null) {
+            throw new IllegalStateException("Cannot create path without a root");
+        }
+        char separator = root.options().pathSeparator();
+
+        StringBuilder builder = new StringBuilder();
+        if (section != null) {
+            for (ConfigurationSection parent = section; (parent != null) && (parent != relativeTo); parent = parent.getParent()) {
+                if (builder.length() > 0) {
+                    builder.insert(0, separator);
+                }
+
+                builder.insert(0, parent.getName());
+            }
+        }
+
+        if ((key != null) && (key.length() > 0)) {
+            if (builder.length() > 0) {
+                builder.append(separator);
+            }
+
+            builder.append(key);
+        }
+
+        return builder.toString();
+    }
+
     public Set<String> getKeys(boolean deep) {
         Set<String> result = new LinkedHashSet<String>();
 
@@ -564,6 +619,8 @@ public class MemorySection implements ConfigurationSection {
         return result;
     }
 
+    // Bukkit
+
     public List<Short> getShortList(String path) {
         List<?> list = getList(path);
 
@@ -608,8 +665,6 @@ public class MemorySection implements ConfigurationSection {
         return result;
     }
 
-    // Bukkit
-
     public ConfigurationSection getConfigurationSection(String path) {
         Object val = get(path, null);
         if (val != null) {
@@ -683,72 +738,16 @@ public class MemorySection implements ConfigurationSection {
         }
     }
 
-    /**
-     * Creates a full path to the given {@link ConfigurationSection} from its
-     * root {@link Configuration}.
-     * <p>
-     * You may use this method for any given {@link ConfigurationSection}, not
-     * only {@link MemorySection}.
-     *
-     * @param section Section to create a path for.
-     * @param key Name of the specified section.
-     * @return Full path of the section from its root.
-     */
-    public static String createPath(ConfigurationSection section, String key) {
-        return createPath(section, key, (section == null) ? null : section.getRoot());
-    }
-
-    /**
-     * Creates a relative path to the given {@link ConfigurationSection} from
-     * the given relative section.
-     * <p>
-     * You may use this method for any given {@link ConfigurationSection}, not
-     * only {@link MemorySection}.
-     *
-     * @param section Section to create a path for.
-     * @param key Name of the specified section.
-     * @param relativeTo Section to create the path relative to.
-     * @return Full path of the section from its root.
-     */
-    public static String createPath(ConfigurationSection section, String key, ConfigurationSection relativeTo) {
-        Validate.notNull(section, "Cannot create path without a section");
-        Configuration root = section.getRoot();
-        if (root == null) {
-            throw new IllegalStateException("Cannot create path without a root");
-        }
-        char separator = root.options().pathSeparator();
-
-        StringBuilder builder = new StringBuilder();
-        if (section != null) {
-            for (ConfigurationSection parent = section; (parent != null) && (parent != relativeTo); parent = parent.getParent()) {
-                if (builder.length() > 0) {
-                    builder.insert(0, separator);
-                }
-
-                builder.insert(0, parent.getName());
-            }
-        }
-
-        if ((key != null) && (key.length() > 0)) {
-            if (builder.length() > 0) {
-                builder.append(separator);
-            }
-
-            builder.append(key);
-        }
-
-        return builder.toString();
-    }
     @Override
     public String toString() {
         Configuration root = getRoot();
         return new StringBuilder()
-            .append(getClass().getSimpleName())
-            .append("[path='")
-            .append(getCurrentPath())
-            .append("', root='")
-            .append(root == null ? null : root.getClass().getSimpleName())
-            .append("']")
-            .toString();
+                .append(getClass().getSimpleName())
+                .append("[path='")
+                .append(getCurrentPath())
+                .append("', root='")
+                .append(root == null ? null : root.getClass().getSimpleName())
+                .append("']")
+                .toString();
     }
 }
diff --git a/src/main/java/dev/wolveringer/configuration/file/FileConfiguration.java b/src/main/java/dev/wolveringer/configuration/file/FileConfiguration.java
index 68a338b..92b53f4 100644
--- a/src/main/java/dev/wolveringer/configuration/file/FileConfiguration.java
+++ b/src/main/java/dev/wolveringer/configuration/file/FileConfiguration.java
@@ -1,5 +1,11 @@
 package dev.wolveringer.configuration.file;
 
+import com.google.common.base.Charsets;
+import com.google.common.io.Files;
+
+import org.apache.commons.lang3.Validate;
+import org.yaml.snakeyaml.external.biz.base64Coder.Base64Coder;
+
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileInputStream;
@@ -13,12 +19,6 @@ import java.io.Reader;
 import java.io.Writer;
 import java.nio.charset.Charset;
 
-import org.apache.commons.lang3.Validate;
-import org.yaml.snakeyaml.external.biz.base64Coder.Base64Coder;
-
-import com.google.common.base.Charsets;
-import com.google.common.io.Files;
-
 import dev.wolveringer.configuration.Configuration;
 import dev.wolveringer.configuration.InvalidConfigurationException;
 import dev.wolveringer.configuration.MemoryConfiguration;
@@ -52,6 +52,7 @@ public abstract class FileConfiguration extends MemoryConfiguration {
      */
     @Deprecated
     public static final boolean SYSTEM_UTF;
+
     static {
         final byte[] testBytes = Base64Coder.decode("ICEiIyQlJicoKSorLC0uLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX4NCg==");
         final String testString = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\r\n";
@@ -91,8 +92,8 @@ public abstract class FileConfiguration extends MemoryConfiguration {
      * using UTF8.
      *
      * @param file File to save to.
-     * @throws IOException Thrown when the given file cannot be written to for
-     *     any reason.
+     * @throws IOException              Thrown when the given file cannot be written to for any
+     *                                  reason.
      * @throws IllegalArgumentException Thrown when file is null.
      */
     public void save(File file) throws IOException {
@@ -120,8 +121,8 @@ public abstract class FileConfiguration extends MemoryConfiguration {
      * using UTF8.
      *
      * @param file File to save to.
-     * @throws IOException Thrown when the given file cannot be written to for
-     *     any reason.
+     * @throws IOException              Thrown when the given file cannot be written to for any
+     *                                  reason.
      * @throws IllegalArgumentException Thrown when file is null.
      */
     public void save(String file) throws IOException {
@@ -152,12 +153,11 @@ public abstract class FileConfiguration extends MemoryConfiguration {
      * specified.
      *
      * @param file File to load from.
-     * @throws FileNotFoundException Thrown when the given file cannot be
-     *     opened.
-     * @throws IOException Thrown when the given file cannot be read.
-     * @throws InvalidConfigurationException Thrown when the given file is not
-     *     a valid Configuration.
-     * @throws IllegalArgumentException Thrown when file is null.
+     * @throws FileNotFoundException         Thrown when the given file cannot be opened.
+     * @throws IOException                   Thrown when the given file cannot be read.
+     * @throws InvalidConfigurationException Thrown when the given file is not a valid
+     *                                       Configuration.
+     * @throws IllegalArgumentException      Thrown when file is null.
      */
     public void load(File file) throws FileNotFoundException, IOException, InvalidConfigurationException {
         Validate.notNull(file, "File cannot be null");
@@ -178,12 +178,12 @@ public abstract class FileConfiguration extends MemoryConfiguration {
      * {@link #UTF8_OVERRIDE} or {@link #UTF_BIG} is specified.
      *
      * @param stream Stream to load from
-     * @throws IOException Thrown when the given file cannot be read.
-     * @throws InvalidConfigurationException Thrown when the given file is not
-     *     a valid Configuration.
-     * @throws IllegalArgumentException Thrown when stream is null.
-     * @deprecated This does not consider encoding
+     * @throws IOException                   Thrown when the given file cannot be read.
+     * @throws InvalidConfigurationException Thrown when the given file is not a valid
+     *                                       Configuration.
+     * @throws IllegalArgumentException      Thrown when stream is null.
      * @see #load(Reader)
+     * @deprecated This does not consider encoding
      */
     @Deprecated
     public void load(InputStream stream) throws IOException, InvalidConfigurationException {
@@ -200,10 +200,10 @@ public abstract class FileConfiguration extends MemoryConfiguration {
      * from the given stream.
      *
      * @param reader the reader to load from
-     * @throws IOException thrown when underlying reader throws an IOException
-     * @throws InvalidConfigurationException thrown when the reader does not
-     *      represent a valid Configuration
-     * @throws IllegalArgumentException thrown when reader is null
+     * @throws IOException                   thrown when underlying reader throws an IOException
+     * @throws InvalidConfigurationException thrown when the reader does not represent a valid
+     *                                       Configuration
+     * @throws IllegalArgumentException      thrown when reader is null
      */
     public void load(Reader reader) throws IOException, InvalidConfigurationException {
         BufferedReader input = reader instanceof BufferedReader ? (BufferedReader) reader : new BufferedReader(reader);
@@ -235,12 +235,11 @@ public abstract class FileConfiguration extends MemoryConfiguration {
      * thrown.
      *
      * @param file File to load from.
-     * @throws FileNotFoundException Thrown when the given file cannot be
-     *     opened.
-     * @throws IOException Thrown when the given file cannot be read.
-     * @throws InvalidConfigurationException Thrown when the given file is not
-     *     a valid Configuration.
-     * @throws IllegalArgumentException Thrown when file is null.
+     * @throws FileNotFoundException         Thrown when the given file cannot be opened.
+     * @throws IOException                   Thrown when the given file cannot be read.
+     * @throws InvalidConfigurationException Thrown when the given file is not a valid
+     *                                       Configuration.
+     * @throws IllegalArgumentException      Thrown when file is null.
      */
     public void load(String file) throws FileNotFoundException, IOException, InvalidConfigurationException {
         Validate.notNull(file, "File cannot be null");
@@ -259,9 +258,8 @@ public abstract class FileConfiguration extends MemoryConfiguration {
      * If the string is invalid in any way, an exception will be thrown.
      *
      * @param contents Contents of a Configuration to load.
-     * @throws InvalidConfigurationException Thrown if the specified string is
-     *     invalid.
-     * @throws IllegalArgumentException Thrown if contents is null.
+     * @throws InvalidConfigurationException Thrown if the specified string is invalid.
+     * @throws IllegalArgumentException      Thrown if contents is null.
      */
     public abstract void loadFromString(String contents) throws InvalidConfigurationException;
 
diff --git a/src/main/java/dev/wolveringer/configuration/file/YamlConfiguration.java b/src/main/java/dev/wolveringer/configuration/file/YamlConfiguration.java
index 97f75f7..82c82ae 100644
--- a/src/main/java/dev/wolveringer/configuration/file/YamlConfiguration.java
+++ b/src/main/java/dev/wolveringer/configuration/file/YamlConfiguration.java
@@ -1,5 +1,11 @@
 package dev.wolveringer.configuration.file;
 
+import org.apache.commons.lang3.Validate;
+import org.yaml.snakeyaml.DumperOptions;
+import org.yaml.snakeyaml.Yaml;
+import org.yaml.snakeyaml.error.YAMLException;
+import org.yaml.snakeyaml.representer.Representer;
+
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.IOException;
@@ -7,12 +13,6 @@ import java.io.InputStream;
 import java.io.Reader;
 import java.util.Map;
 
-import org.apache.commons.lang3.Validate;
-import org.yaml.snakeyaml.DumperOptions;
-import org.yaml.snakeyaml.Yaml;
-import org.yaml.snakeyaml.error.YAMLException;
-import org.yaml.snakeyaml.representer.Representer;
-
 import dev.wolveringer.configuration.Configuration;
 import dev.wolveringer.configuration.ConfigurationSection;
 import dev.wolveringer.configuration.InvalidConfigurationException;
@@ -22,229 +22,223 @@ import dev.wolveringer.configuration.InvalidConfigurationException;
  * Note that this implementation is not synchronized.
  */
 public class YamlConfiguration extends FileConfiguration {
-	protected static final String COMMENT_PREFIX = "# ";
-	protected static final String BLANK_CONFIG = "{}\n";
-	private final DumperOptions yamlOptions = new DumperOptions();
-	private final Representer yamlRepresenter = new YamlRepresenter();
-	private final Yaml yaml = new Yaml(new YamlConstructor(), yamlRepresenter, yamlOptions);
-
-	@Override
-	public String saveToString() {
-		yamlOptions.setIndent(options().indent());
-		yamlOptions.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);
-		yamlOptions.setAllowUnicode(SYSTEM_UTF);
-		yamlRepresenter.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);
-
-		String header = buildHeader();
-		String dump = yaml.dump(getValues(false));
-
-		if(dump.equals(BLANK_CONFIG)){
-			dump = "";
-		}
-
-		return header + dump;
-	}
-
-	@Override
-	public void loadFromString(String contents) throws InvalidConfigurationException {
-		Validate.notNull(contents, "Contents cannot be null");
-
-		Map<?, ?> input;
-		try{
-			input = (Map<?, ?>) yaml.load(contents);
-		}catch (YAMLException e){
-			throw new InvalidConfigurationException(e);
-		}catch (ClassCastException e){
-			throw new InvalidConfigurationException("Top level is not a Map.");
-		}
-
-		String header = parseHeader(contents);
-		if(header.length() > 0){
-			options().header(header);
-		}
-
-		if(input != null){
-			convertMapsToSections(input, this);
-		}
-	}
-
-	protected void convertMapsToSections(Map<?, ?> input, ConfigurationSection section) {
-		for(Map.Entry<?, ?> entry : input.entrySet()){
-			String key = entry.getKey().toString();
-			Object value = entry.getValue();
-
-			if(value instanceof Map){
-				convertMapsToSections((Map<?, ?>) value, section.createSection(key));
-			}else{
-				section.set(key, value);
-			}
-		}
-	}
-
-	protected String parseHeader(String input) {
-		String[] lines = input.split("\r?\n", -1);
-		StringBuilder result = new StringBuilder();
-		boolean readingHeader = true;
-		boolean foundHeader = false;
-
-		for(int i = 0;(i < lines.length) && (readingHeader);i++){
-			String line = lines[i];
-
-			if(line.startsWith(COMMENT_PREFIX)){
-				if(i > 0){
-					result.append("\n");
-				}
-
-				if(line.length() > COMMENT_PREFIX.length()){
-					result.append(line.substring(COMMENT_PREFIX.length()));
-				}
-
-				foundHeader = true;
-			}else if((foundHeader) && (line.length() == 0)){
-				result.append("\n");
-			}else if(foundHeader){
-				readingHeader = false;
-			}
-		}
-
-		return result.toString();
-	}
-
-	@Override
-	protected String buildHeader() {
-		String header = options().header();
-
-		if(options().copyHeader()){
-			Configuration def = getDefaults();
-
-			if((def != null) && (def instanceof FileConfiguration)){
-				FileConfiguration filedefaults = (FileConfiguration) def;
-				String defaultsHeader = filedefaults.buildHeader();
-
-				if((defaultsHeader != null) && (defaultsHeader.length() > 0)){
-					return defaultsHeader;
-				}
-			}
-		}
-
-		if(header == null){
-			return "";
-		}
-
-		StringBuilder builder = new StringBuilder();
-		String[] lines = header.split("\r?\n", -1);
-		boolean startedHeader = false;
-
-		for(int i = lines.length - 1;i >= 0;i--){
-			builder.insert(0, "\n");
-
-			if((startedHeader) || (lines[i].length() != 0)){
-				builder.insert(0, lines[i]);
-				builder.insert(0, COMMENT_PREFIX);
-				startedHeader = true;
-			}
-		}
-
-		return builder.toString();
-	}
-
-	@Override
-	public YamlConfigurationOptions options() {
-		if(options == null){
-			options = new YamlConfigurationOptions(this);
-		}
-
-		return (YamlConfigurationOptions) options;
-	}
-	
-	/**
-	 * Creates a new {@link YamlConfiguration}, loading from the given file.
-	 * <p>
-	 * Any errors loading the Configuration will be logged and then ignored.
-	 * If the specified input is not a valid config, a blank config will be
-	 * returned.
-	 * <p>
-	 * The encoding used may follow the system dependent default.
-	 *
-	 * @param file
-	 *            Input file
-	 * @return Resulting configuration
-	 * @throws IllegalArgumentException
-	 *             Thrown if file is null
-	 */
-	public static YamlConfiguration loadConfiguration(File file) {
-		Validate.notNull(file, "File cannot be null");
-
-		YamlConfiguration config = new YamlConfiguration();
-
-		try{
-			config.load(file);
-		}catch (FileNotFoundException ex){
-		}catch (Exception ex){
-			ex.printStackTrace();
-		}
-
-		return config;
-	}
-
-	/**
-	 * Creates a new {@link YamlConfiguration}, loading from the given stream.
-	 * <p>
-	 * Any errors loading the Configuration will be logged and then ignored.
-	 * If the specified input is not a valid config, a blank config will be
-	 * returned.
-	 *
-	 * @param stream
-	 *            Input stream
-	 * @return Resulting configuration
-	 * @throws IllegalArgumentException
-	 *             Thrown if stream is null
-	 * @deprecated does not properly consider encoding
-	 * @see #load(InputStream)
-	 * @see #loadConfiguration(Reader)
-	 */
-	@Deprecated
-	public static YamlConfiguration loadConfiguration(InputStream stream) {
-		Validate.notNull(stream, "Stream cannot be null");
-
-		YamlConfiguration config = new YamlConfiguration();
-
-		try{
-			config.load(stream);
-		}catch (IOException ex){
-		}catch (InvalidConfigurationException ex){
-			ex.printStackTrace();
-		}
-
-		return config;
-	}
-
-	/**
-	 * Creates a new {@link YamlConfiguration}, loading from the given reader.
-	 * <p>
-	 * Any errors loading the Configuration will be logged and then ignored.
-	 * If the specified input is not a valid config, a blank config will be
-	 * returned.
-	 *
-	 * @param reader
-	 *            input
-	 * @return resulting configuration
-	 * @throws IllegalArgumentException
-	 *             Thrown if stream is null
-	 */
-	public static YamlConfiguration loadConfiguration(Reader reader) {
-		Validate.notNull(reader, "Stream cannot be null");
-
-		YamlConfiguration config = new YamlConfiguration();
-
-		try{
-			config.load(reader);
-		}catch (IOException ex){
-			ex.printStackTrace();
-		}catch (InvalidConfigurationException ex){
-			ex.printStackTrace();
-		}
-
-		return config;
-	}
+    protected static final String COMMENT_PREFIX = "# ";
+    protected static final String BLANK_CONFIG = "{}\n";
+    private final DumperOptions yamlOptions = new DumperOptions();
+    private final Representer yamlRepresenter = new YamlRepresenter();
+    private final Yaml yaml = new Yaml(new YamlConstructor(), yamlRepresenter, yamlOptions);
+
+    /**
+     * Creates a new {@link YamlConfiguration}, loading from the given file.
+     * <p>
+     * Any errors loading the Configuration will be logged and then ignored.
+     * If the specified input is not a valid config, a blank config will be
+     * returned.
+     * <p>
+     * The encoding used may follow the system dependent default.
+     *
+     * @param file Input file
+     * @return Resulting configuration
+     * @throws IllegalArgumentException Thrown if file is null
+     */
+    public static YamlConfiguration loadConfiguration(File file) {
+        Validate.notNull(file, "File cannot be null");
+
+        YamlConfiguration config = new YamlConfiguration();
+
+        try {
+            config.load(file);
+        } catch (FileNotFoundException ex) {
+        } catch (Exception ex) {
+            ex.printStackTrace();
+        }
+
+        return config;
+    }
+
+    /**
+     * Creates a new {@link YamlConfiguration}, loading from the given stream.
+     * <p>
+     * Any errors loading the Configuration will be logged and then ignored.
+     * If the specified input is not a valid config, a blank config will be
+     * returned.
+     *
+     * @param stream Input stream
+     * @return Resulting configuration
+     * @throws IllegalArgumentException Thrown if stream is null
+     * @see #load(InputStream)
+     * @see #loadConfiguration(Reader)
+     * @deprecated does not properly consider encoding
+     */
+    @Deprecated
+    public static YamlConfiguration loadConfiguration(InputStream stream) {
+        Validate.notNull(stream, "Stream cannot be null");
+
+        YamlConfiguration config = new YamlConfiguration();
+
+        try {
+            config.load(stream);
+        } catch (IOException ex) {
+        } catch (InvalidConfigurationException ex) {
+            ex.printStackTrace();
+        }
+
+        return config;
+    }
+
+    /**
+     * Creates a new {@link YamlConfiguration}, loading from the given reader.
+     * <p>
+     * Any errors loading the Configuration will be logged and then ignored.
+     * If the specified input is not a valid config, a blank config will be
+     * returned.
+     *
+     * @param reader input
+     * @return resulting configuration
+     * @throws IllegalArgumentException Thrown if stream is null
+     */
+    public static YamlConfiguration loadConfiguration(Reader reader) {
+        Validate.notNull(reader, "Stream cannot be null");
+
+        YamlConfiguration config = new YamlConfiguration();
+
+        try {
+            config.load(reader);
+        } catch (IOException ex) {
+            ex.printStackTrace();
+        } catch (InvalidConfigurationException ex) {
+            ex.printStackTrace();
+        }
+
+        return config;
+    }
+
+    @Override
+    public String saveToString() {
+        yamlOptions.setIndent(options().indent());
+        yamlOptions.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);
+        yamlOptions.setAllowUnicode(SYSTEM_UTF);
+        yamlRepresenter.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);
+
+        String header = buildHeader();
+        String dump = yaml.dump(getValues(false));
+
+        if (dump.equals(BLANK_CONFIG)) {
+            dump = "";
+        }
+
+        return header + dump;
+    }
+
+    @Override
+    public void loadFromString(String contents) throws InvalidConfigurationException {
+        Validate.notNull(contents, "Contents cannot be null");
+
+        Map<?, ?> input;
+        try {
+            input = (Map<?, ?>) yaml.load(contents);
+        } catch (YAMLException e) {
+            throw new InvalidConfigurationException(e);
+        } catch (ClassCastException e) {
+            throw new InvalidConfigurationException("Top level is not a Map.");
+        }
+
+        String header = parseHeader(contents);
+        if (header.length() > 0) {
+            options().header(header);
+        }
+
+        if (input != null) {
+            convertMapsToSections(input, this);
+        }
+    }
+
+    protected void convertMapsToSections(Map<?, ?> input, ConfigurationSection section) {
+        for (Map.Entry<?, ?> entry : input.entrySet()) {
+            String key = entry.getKey().toString();
+            Object value = entry.getValue();
+
+            if (value instanceof Map) {
+                convertMapsToSections((Map<?, ?>) value, section.createSection(key));
+            } else {
+                section.set(key, value);
+            }
+        }
+    }
+
+    protected String parseHeader(String input) {
+        String[] lines = input.split("\r?\n", -1);
+        StringBuilder result = new StringBuilder();
+        boolean readingHeader = true;
+        boolean foundHeader = false;
+
+        for (int i = 0; (i < lines.length) && (readingHeader); i++) {
+            String line = lines[i];
+
+            if (line.startsWith(COMMENT_PREFIX)) {
+                if (i > 0) {
+                    result.append("\n");
+                }
+
+                if (line.length() > COMMENT_PREFIX.length()) {
+                    result.append(line.substring(COMMENT_PREFIX.length()));
+                }
+
+                foundHeader = true;
+            } else if ((foundHeader) && (line.length() == 0)) {
+                result.append("\n");
+            } else if (foundHeader) {
+                readingHeader = false;
+            }
+        }
+
+        return result.toString();
+    }
+
+    @Override
+    protected String buildHeader() {
+        String header = options().header();
+
+        if (options().copyHeader()) {
+            Configuration def = getDefaults();
+
+            if ((def != null) && (def instanceof FileConfiguration)) {
+                FileConfiguration filedefaults = (FileConfiguration) def;
+                String defaultsHeader = filedefaults.buildHeader();
+
+                if ((defaultsHeader != null) && (defaultsHeader.length() > 0)) {
+                    return defaultsHeader;
+                }
+            }
+        }
+
+        if (header == null) {
+            return "";
+        }
+
+        StringBuilder builder = new StringBuilder();
+        String[] lines = header.split("\r?\n", -1);
+        boolean startedHeader = false;
+
+        for (int i = lines.length - 1; i >= 0; i--) {
+            builder.insert(0, "\n");
+
+            if ((startedHeader) || (lines[i].length() != 0)) {
+                builder.insert(0, lines[i]);
+                builder.insert(0, COMMENT_PREFIX);
+                startedHeader = true;
+            }
+        }
+
+        return builder.toString();
+    }
+
+    @Override
+    public YamlConfigurationOptions options() {
+        if (options == null) {
+            options = new YamlConfigurationOptions(this);
+        }
+
+        return (YamlConfigurationOptions) options;
+    }
 }
diff --git a/src/main/java/dev/wolveringer/configuration/file/YamlConstructor.java b/src/main/java/dev/wolveringer/configuration/file/YamlConstructor.java
index d57a30e..55a7405 100644
--- a/src/main/java/dev/wolveringer/configuration/file/YamlConstructor.java
+++ b/src/main/java/dev/wolveringer/configuration/file/YamlConstructor.java
@@ -1,13 +1,13 @@
 package dev.wolveringer.configuration.file;
 
-import java.util.LinkedHashMap;
-import java.util.Map;
-
 import org.yaml.snakeyaml.constructor.SafeConstructor;
 import org.yaml.snakeyaml.error.YAMLException;
 import org.yaml.snakeyaml.nodes.Node;
 import org.yaml.snakeyaml.nodes.Tag;
 
+import java.util.LinkedHashMap;
+import java.util.Map;
+
 import dev.wolveringer.configuration.serialization.ConfigurationSerialization;
 
 public class YamlConstructor extends SafeConstructor {
diff --git a/src/main/java/dev/wolveringer/configuration/file/YamlRepresenter.java b/src/main/java/dev/wolveringer/configuration/file/YamlRepresenter.java
index afb79d6..9cbe0c4 100644
--- a/src/main/java/dev/wolveringer/configuration/file/YamlRepresenter.java
+++ b/src/main/java/dev/wolveringer/configuration/file/YamlRepresenter.java
@@ -1,11 +1,11 @@
 package dev.wolveringer.configuration.file;
 
-import java.util.LinkedHashMap;
-import java.util.Map;
-
 import org.yaml.snakeyaml.nodes.Node;
 import org.yaml.snakeyaml.representer.Representer;
 
+import java.util.LinkedHashMap;
+import java.util.Map;
+
 import dev.wolveringer.configuration.ConfigurationSection;
 import dev.wolveringer.configuration.serialization.ConfigurationSerializable;
 import dev.wolveringer.configuration.serialization.ConfigurationSerialization;
diff --git a/src/main/java/dev/wolveringer/configuration/serialization/ConfigurationSerialization.java b/src/main/java/dev/wolveringer/configuration/serialization/ConfigurationSerialization.java
index e6b4c7b..c598afc 100644
--- a/src/main/java/dev/wolveringer/configuration/serialization/ConfigurationSerialization.java
+++ b/src/main/java/dev/wolveringer/configuration/serialization/ConfigurationSerialization.java
@@ -1,5 +1,7 @@
 package dev.wolveringer.configuration.serialization;
 
+import org.apache.commons.lang3.Validate;
+
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
@@ -9,8 +11,6 @@ import java.util.Map;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 
-import org.apache.commons.lang3.Validate;
-
 import dev.wolveringer.configuration.Configuration;
 
 /**
@@ -18,110 +18,17 @@ import dev.wolveringer.configuration.Configuration;
  */
 public class ConfigurationSerialization {
     public static final String SERIALIZED_TYPE_KEY = "==";
-    private final Class<? extends ConfigurationSerializable> clazz;
     private static Map<String, Class<? extends ConfigurationSerializable>> aliases = new HashMap<String, Class<? extends ConfigurationSerializable>>();
 
     static {
     }
 
+    private final Class<? extends ConfigurationSerializable> clazz;
+
     protected ConfigurationSerialization(Class<? extends ConfigurationSerializable> clazz) {
         this.clazz = clazz;
     }
 
-    protected Method getMethod(String name, boolean isStatic) {
-        try {
-            Method method = clazz.getDeclaredMethod(name, Map.class);
-
-            if (!ConfigurationSerializable.class.isAssignableFrom(method.getReturnType())) {
-                return null;
-            }
-            if (Modifier.isStatic(method.getModifiers()) != isStatic) {
-                return null;
-            }
-
-            return method;
-        } catch (NoSuchMethodException ex) {
-            return null;
-        } catch (SecurityException ex) {
-            return null;
-        }
-    }
-
-    protected Constructor<? extends ConfigurationSerializable> getConstructor() {
-        try {
-            return clazz.getConstructor(Map.class);
-        } catch (NoSuchMethodException ex) {
-            return null;
-        } catch (SecurityException ex) {
-            return null;
-        }
-    }
-
-    protected ConfigurationSerializable deserializeViaMethod(Method method, Map<String, ?> args) {
-        try {
-            ConfigurationSerializable result = (ConfigurationSerializable) method.invoke(null, args);
-
-            if (result == null) {
-                Logger.getLogger(ConfigurationSerialization.class.getName()).log(Level.SEVERE, "Could not call method '" + method.toString() + "' of " + clazz + " for deserialization: method returned null");
-            } else {
-                return result;
-            }
-        } catch (Throwable ex) {
-            Logger.getLogger(ConfigurationSerialization.class.getName()).log(
-                    Level.SEVERE,
-                    "Could not call method '" + method.toString() + "' of " + clazz + " for deserialization",
-                    ex instanceof InvocationTargetException ? ex.getCause() : ex);
-        }
-
-        return null;
-    }
-
-    protected ConfigurationSerializable deserializeViaCtor(Constructor<? extends ConfigurationSerializable> ctor, Map<String, ?> args) {
-        try {
-            return ctor.newInstance(args);
-        } catch (Throwable ex) {
-            Logger.getLogger(ConfigurationSerialization.class.getName()).log(
-                    Level.SEVERE,
-                    "Could not call constructor '" + ctor.toString() + "' of " + clazz + " for deserialization",
-                    ex instanceof InvocationTargetException ? ex.getCause() : ex);
-        }
-
-        return null;
-    }
-
-    public ConfigurationSerializable deserialize(Map<String, ?> args) {
-        Validate.notNull(args, "Args must not be null");
-
-        ConfigurationSerializable result = null;
-        Method method = null;
-
-        if (result == null) {
-            method = getMethod("deserialize", true);
-
-            if (method != null) {
-                result = deserializeViaMethod(method, args);
-            }
-        }
-
-        if (result == null) {
-            method = getMethod("valueOf", true);
-
-            if (method != null) {
-                result = deserializeViaMethod(method, args);
-            }
-        }
-
-        if (result == null) {
-            Constructor<? extends ConfigurationSerializable> constructor = getConstructor();
-
-            if (constructor != null) {
-                result = deserializeViaCtor(constructor, args);
-            }
-        }
-
-        return result;
-    }
-
     /**
      * Attempts to deserialize the given arguments into a new instance of the
      * given class.
@@ -133,7 +40,7 @@ public class ConfigurationSerialization {
      * If a new instance could not be made, an example being the class not
      * fully implementing the interface, null will be returned.
      *
-     * @param args Arguments for deserialization
+     * @param args  Arguments for deserialization
      * @param clazz Class to deserialize into
      * @return New instance of the specified class
      */
@@ -267,4 +174,98 @@ public class ConfigurationSerialization {
 
         return clazz.getName();
     }
+
+    protected Method getMethod(String name, boolean isStatic) {
+        try {
+            Method method = clazz.getDeclaredMethod(name, Map.class);
+
+            if (!ConfigurationSerializable.class.isAssignableFrom(method.getReturnType())) {
+                return null;
+            }
+            if (Modifier.isStatic(method.getModifiers()) != isStatic) {
+                return null;
+            }
+
+            return method;
+        } catch (NoSuchMethodException ex) {
+            return null;
+        } catch (SecurityException ex) {
+            return null;
+        }
+    }
+
+    protected Constructor<? extends ConfigurationSerializable> getConstructor() {
+        try {
+            return clazz.getConstructor(Map.class);
+        } catch (NoSuchMethodException ex) {
+            return null;
+        } catch (SecurityException ex) {
+            return null;
+        }
+    }
+
+    protected ConfigurationSerializable deserializeViaMethod(Method method, Map<String, ?> args) {
+        try {
+            ConfigurationSerializable result = (ConfigurationSerializable) method.invoke(null, args);
+
+            if (result == null) {
+                Logger.getLogger(ConfigurationSerialization.class.getName()).log(Level.SEVERE, "Could not call method '" + method.toString() + "' of " + clazz + " for deserialization: method returned null");
+            } else {
+                return result;
+            }
+        } catch (Throwable ex) {
+            Logger.getLogger(ConfigurationSerialization.class.getName()).log(
+                    Level.SEVERE,
+                    "Could not call method '" + method.toString() + "' of " + clazz + " for deserialization",
+                    ex instanceof InvocationTargetException ? ex.getCause() : ex);
+        }
+
+        return null;
+    }
+
+    protected ConfigurationSerializable deserializeViaCtor(Constructor<? extends ConfigurationSerializable> ctor, Map<String, ?> args) {
+        try {
+            return ctor.newInstance(args);
+        } catch (Throwable ex) {
+            Logger.getLogger(ConfigurationSerialization.class.getName()).log(
+                    Level.SEVERE,
+                    "Could not call constructor '" + ctor.toString() + "' of " + clazz + " for deserialization",
+                    ex instanceof InvocationTargetException ? ex.getCause() : ex);
+        }
+
+        return null;
+    }
+
+    public ConfigurationSerializable deserialize(Map<String, ?> args) {
+        Validate.notNull(args, "Args must not be null");
+
+        ConfigurationSerializable result = null;
+        Method method = null;
+
+        if (result == null) {
+            method = getMethod("deserialize", true);
+
+            if (method != null) {
+                result = deserializeViaMethod(method, args);
+            }
+        }
+
+        if (result == null) {
+            method = getMethod("valueOf", true);
+
+            if (method != null) {
+                result = deserializeViaMethod(method, args);
+            }
+        }
+
+        if (result == null) {
+            Constructor<? extends ConfigurationSerializable> constructor = getConstructor();
+
+            if (constructor != null) {
+                result = deserializeViaCtor(constructor, args);
+            }
+        }
+
+        return result;
+    }
 }
diff --git a/src/main/java/dev/wolveringer/hastebin/DocumentNotFoundException.java b/src/main/java/dev/wolveringer/hastebin/DocumentNotFoundException.java
index b2f58e2..56bd30e 100644
--- a/src/main/java/dev/wolveringer/hastebin/DocumentNotFoundException.java
+++ b/src/main/java/dev/wolveringer/hastebin/DocumentNotFoundException.java
@@ -1,9 +1,9 @@
 package dev.wolveringer.hastebin;
 
 @SuppressWarnings("serial")
-public class DocumentNotFoundException extends RuntimeException{
-	public DocumentNotFoundException(String message) {
-		super(message);
-	}
-	
+public class DocumentNotFoundException extends RuntimeException {
+    public DocumentNotFoundException(String message) {
+        super(message);
+    }
+
 }
diff --git a/src/main/java/dev/wolveringer/hastebin/HastebinDocument.java b/src/main/java/dev/wolveringer/hastebin/HastebinDocument.java
index 8e4ff18..a082508 100644
--- a/src/main/java/dev/wolveringer/hastebin/HastebinDocument.java
+++ b/src/main/java/dev/wolveringer/hastebin/HastebinDocument.java
@@ -1,5 +1,11 @@
 package dev.wolveringer.hastebin;
 
+import com.google.common.base.Charsets;
+
+import org.apache.commons.io.IOUtils;
+import org.json.JSONException;
+import org.json.JSONObject;
+
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.HttpURLConnection;
@@ -7,74 +13,71 @@ import java.net.URL;
 import java.util.ArrayList;
 import java.util.Arrays;
 
-import org.apache.commons.io.IOUtils;
-import org.json.JSONException;
-import org.json.JSONObject;
+public class HastebinDocument {
+    private static final String BASE_URL = "http://hastebin.com/raw/";
+    private String identifier;
+    private ArrayList<String> lines = new ArrayList<>();
 
-import com.google.common.base.Charsets;
+    public HastebinDocument(String identifier) {
+        if (identifier.contains("/"))
+            this.identifier = identifier.substring(identifier.lastIndexOf("/") + 1);
+        else
+            this.identifier = identifier;
+    }
 
-public class HastebinDocument {
-	private static final String BASE_URL = "http://hastebin.com/raw/";
-	private String identifier;
-	private ArrayList<String> lines = new ArrayList<>();
+    public void load() {
+        try {
+            lines = new ArrayList<>(Arrays.asList(performGetRequest(new URL(BASE_URL + identifier)).split("\n")));
+            if (lines.size() == 1)
+                if (lines.get(0).startsWith("{")) {
+                    try {
+                        JSONObject obj = new JSONObject(lines.get(0));
+                        if (obj.has("message"))
+                            throw new DocumentNotFoundException(obj.getString("message"));
+                    } catch (JSONException e) {
+                        e.printStackTrace();
+                    }
+                }
+        } catch (IOException ex) {
+            ex.printStackTrace();
+        }
+    }
+
+    private String performGetRequest(URL url) throws IOException {
+        HttpURLConnection connection = createUrlConnection(url);
+        InputStream inputStream = null;
+        try {
+            inputStream = connection.getInputStream();
+            String result = IOUtils.toString(inputStream, Charsets.UTF_8);
+            return result;
+        } catch (IOException e) {
+            IOUtils.closeQuietly(inputStream);
+            inputStream = connection.getErrorStream();
+            if (inputStream != null) {
+                String result = IOUtils.toString(inputStream, Charsets.UTF_8);
+                return result;
+            }
+            throw e;
+        } finally {
+            IOUtils.closeQuietly(inputStream);
+        }
+    }
 
-	public HastebinDocument(String identifier) {
-		if(identifier.contains("/"))
-			this.identifier = identifier.substring(identifier.lastIndexOf("/")+1);
-		else
-			this.identifier = identifier;
-	}
-	 public void load() {
-		try{
-			lines = new ArrayList<>(Arrays.asList(performGetRequest(new URL(BASE_URL + identifier)).split("\n")));
-			if(lines.size() == 1)
-				if(lines.get(0).startsWith("{")){
-					try{
-						JSONObject obj = new JSONObject(lines.get(0));
-						if(obj.has("message"))
-							throw new DocumentNotFoundException(obj.getString("message"));
-					}catch (JSONException e){
-						e.printStackTrace();
-					}
-				}
-		}catch (IOException ex){
-			ex.printStackTrace();
-		}
-	}
+    private HttpURLConnection createUrlConnection(URL url) throws IOException {
+        HttpURLConnection connection = (HttpURLConnection) url.openConnection();
+        connection.setConnectTimeout(15000);
+        connection.setReadTimeout(15000);
+        connection.setDoOutput(true);
+        connection.setUseCaches(false);
+        connection.setRequestMethod("GET");
+        return connection;
+    }
 
-	private String performGetRequest(URL url) throws IOException {
-		HttpURLConnection connection = createUrlConnection(url);
-		InputStream inputStream = null;
-		try{
-			inputStream = connection.getInputStream();
-			String result = IOUtils.toString(inputStream, Charsets.UTF_8);
-			return result;
-		}catch (IOException e){
-			IOUtils.closeQuietly(inputStream);
-			inputStream = connection.getErrorStream();
-			if(inputStream != null){
-				String result = IOUtils.toString(inputStream, Charsets.UTF_8);
-				return result;
-			}
-			throw e;
-		}finally{
-			IOUtils.closeQuietly(inputStream);
-		}
-	}
+    public ArrayList<String> getLines() {
+        return this.lines;
+    }
 
-	private HttpURLConnection createUrlConnection(URL url) throws IOException {
-		HttpURLConnection connection = (HttpURLConnection) url.openConnection();
-		connection.setConnectTimeout(15000);
-		connection.setReadTimeout(15000);
-		connection.setDoOutput(true);
-		connection.setUseCaches(false);
-		connection.setRequestMethod("GET");
-		return connection;
-	}
-	public ArrayList<String> getLines() {
-		return this.lines;
-	}
-	public String getIdentifier() {
-		return this.identifier;
-	}
+    public String getIdentifier() {
+        return this.identifier;
+    }
 }
diff --git a/src/main/java/dev/wolveringer/hastebin/HastebinPost.java b/src/main/java/dev/wolveringer/hastebin/HastebinPost.java
index fe19462..e70a23d 100644
--- a/src/main/java/dev/wolveringer/hastebin/HastebinPost.java
+++ b/src/main/java/dev/wolveringer/hastebin/HastebinPost.java
@@ -1,5 +1,8 @@
 package dev.wolveringer.hastebin;
 
+import org.apache.commons.io.IOUtils;
+import org.json.JSONObject;
+
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStreamWriter;
@@ -7,85 +10,85 @@ import java.net.HttpURLConnection;
 import java.net.URL;
 import java.nio.charset.Charset;
 
-import org.apache.commons.io.IOUtils;
-import org.json.JSONObject;
-
 public class HastebinPost {
-	private StringBuilder text = new StringBuilder();
-	private boolean changed = false;
-	private String currunturl = "";
-	public HastebinPost(String... text) {
-		if(text.length>0)
-			changed = true;
-		for(String s : text)
-			this.text.append(s + "\n");
-	}
+    private StringBuilder text = new StringBuilder();
+    private boolean changed = false;
+    private String currunturl = "";
+
+    public HastebinPost(String... text) {
+        if (text.length > 0)
+            changed = true;
+        for (String s : text)
+            this.text.append(s + "\n");
+    }
+
+    public void addLine(String line) {
+        this.text.append(line + "\n");
+        changed = true;
+    }
+
+    public String getText() {
+        return text.toString();
+    }
+
+    public void setText(String text) {
+        changed = true;
+        this.text = new StringBuilder(text);
+    }
+
+    public String getTextUrl() {
+        if (changed) {
+            try {
+                String out = performPostRequest(new URL("http://hastebin.com/documents"));
+                JSONObject o = new JSONObject(out);
+                if (!o.has("key")) {
+                    System.err.println("Cant paste Document (Response: " + out + ")");
+                    return "";
+                }
+                changed = false;
+                return currunturl = "http://hastebin.com/" + o.getString("key");
+            } catch (Exception e) {
+                e.printStackTrace();
+            }
+        }
+        return currunturl;
+    }
 
-	public void addLine(String line){
-		this.text.append(line+"\n");
-		changed = true;
-	}
-	public String getText() {
-		return text.toString();
-	}
-	public void setText(String text){
-		changed = true;
-		this.text = new StringBuilder(text);
-	}
-	
-	public String getTextUrl(){
-		if(changed){
-			try{
-				String out = performPostRequest(new URL("http://hastebin.com/documents"));
-				JSONObject o = new JSONObject(out);
-				if(!o.has("key")){
-					System.err.println("Cant paste Document (Response: "+out+")");
-					return "";
-				}
-				changed = false;
-				return currunturl = "http://hastebin.com/"+o.getString("key");
-			}catch(Exception e){
-				e.printStackTrace();
-			}
-		}
-		return currunturl;
-	}
-	
-	private String performPostRequest(URL url) throws IOException {
-		HttpURLConnection connection = createUrlConnection(url);
+    private String performPostRequest(URL url) throws IOException {
+        HttpURLConnection connection = createUrlConnection(url);
 
-		connection.setRequestProperty("Content-Type", "text/plain");
-		connection.setRequestProperty("Content-Length", String.valueOf(text.length()));
+        connection.setRequestProperty("Content-Type", "text/plain");
+        connection.setRequestProperty("Content-Length", String.valueOf(text.length()));
 
-		OutputStreamWriter writer = new OutputStreamWriter(connection.getOutputStream());
-		writer.write(text.toString());
-		writer.flush();
+        OutputStreamWriter writer = new OutputStreamWriter(connection.getOutputStream());
+        writer.write(text.toString());
+        writer.flush();
 
-		InputStream inputStream = null;
-		try{
-			inputStream = connection.getInputStream();
-			String result = IOUtils.toString(inputStream, Charset.forName("UTF-8"));
-			return result;
-		}catch (IOException e){
-			IOUtils.closeQuietly(inputStream);
-			inputStream = connection.getErrorStream();
-			if(inputStream != null){
-				String result = IOUtils.toString(inputStream, Charset.forName("UTF-8"));
-				return result;
-			}
-			throw e;
-		}finally{
-			IOUtils.closeQuietly(inputStream);
-		}
-	}
+        InputStream inputStream = null;
+        try {
+            inputStream = connection.getInputStream();
+            String result = IOUtils.toString(inputStream, Charset.forName("UTF-8"));
+            return result;
+        } catch (IOException e) {
+            IOUtils.closeQuietly(inputStream);
+            inputStream = connection.getErrorStream();
+            if (inputStream != null) {
+                String result = IOUtils.toString(inputStream, Charset.forName("UTF-8"));
+                return result;
+            }
+            throw e;
+        } finally {
+            IOUtils.closeQuietly(inputStream);
+        }
+    }
 
-	private HttpURLConnection createUrlConnection(URL url) throws IOException {
-		HttpURLConnection connection = (HttpURLConnection) url.openConnection();
-		connection.setConnectTimeout(15000);
-		connection.setReadTimeout(15000);
-		connection.setDoOutput(true);
-		connection.setUseCaches(false);
-		connection.setRequestMethod("POST");
-		return connection;
-	}
+    private HttpURLConnection createUrlConnection(URL url) throws IOException {
+        HttpURLConnection connection = (HttpURLConnection) url.openConnection();
+        connection.setConnectTimeout(15000);
+        connection.setReadTimeout(15000);
+        connection.setDoOutput(true);
+        connection.setUseCaches(false);
+        connection.setRequestMethod("POST");
+        return connection;
+    }
 }
diff --git a/src/main/java/dev/wolveringer/listener/InventoryResetListener.java b/src/main/java/dev/wolveringer/listener/InventoryResetListener.java
index 66fe249..1182c79 100644
--- a/src/main/java/dev/wolveringer/listener/InventoryResetListener.java
+++ b/src/main/java/dev/wolveringer/listener/InventoryResetListener.java
@@ -1,13 +1,14 @@
 package dev.wolveringer.listener;
 
-import dev.wolveringer.BungeeUtil.Player;
 import net.md_5.bungee.api.event.ServerSwitchEvent;
 import net.md_5.bungee.api.plugin.Listener;
 import net.md_5.bungee.event.EventHandler;
 
-public class InventoryResetListener implements Listener{
-	@EventHandler
-	public void a(ServerSwitchEvent e){
-		((Player)e.getPlayer()).getPlayerInventory().clear(); //Clear inventory after server switch
-	}
+import dev.wolveringer.BungeeUtil.Player;
+
+public class InventoryResetListener implements Listener {
+    @EventHandler
+    public void a(ServerSwitchEvent e) {
+        ((Player) e.getPlayer()).getPlayerInventory().clear(); //Clear inventory after server switch
+    }
 }
diff --git a/src/main/java/dev/wolveringer/maps/CachedArrayList.java b/src/main/java/dev/wolveringer/maps/CachedArrayList.java
index 2d76855..5cb59f2 100644
--- a/src/main/java/dev/wolveringer/maps/CachedArrayList.java
+++ b/src/main/java/dev/wolveringer/maps/CachedArrayList.java
@@ -8,250 +8,248 @@ import java.util.List;
 import java.util.concurrent.TimeUnit;
 
 public class CachedArrayList<E> extends ArrayList<E> {
-	public static interface UnloadListener<E> {
-		public boolean canUnload(E element);
-	}
-	private static final long serialVersionUID = 1L;
-
-	private long nextUpdate = Long.MAX_VALUE;
-
-	private int defautTime;
-	private TimeUnit defaultTimeUnit = TimeUnit.MILLISECONDS;
-
-	private HashMap<E, Long> times = new HashMap<>();
-
-	private ArrayList<UnloadListener<E>> listener = new ArrayList<>(); 
-	
-	public CachedArrayList(int defautTime, TimeUnit defaultTimeUnit) {
-		this.defautTime = defautTime;
-		this.defaultTimeUnit = defaultTimeUnit;
-	}
-
-	@Override
-	public boolean add(E e) {
-		return add(e, defautTime, defaultTimeUnit);
-	}
-
-	@Override
-	public void add(int index, E element) {
-		add(index, element, defautTime, defaultTimeUnit);
-	}
-
-	@Override
-	public boolean addAll(Collection<? extends E> c) {
-		return addAll(c, defautTime, defaultTimeUnit);
-	}
-
-	@Override
-	public boolean addAll(int index, Collection<? extends E> c) {
-		return addAll(index, c, defautTime, defaultTimeUnit);
-	}
-
-	public boolean add(E e, int time, TimeUnit unit) {
-		if (time == 0)
-			return false;
-		boolean add = super.add(e);
-		long t;
-		times.put(e, t = System.currentTimeMillis() + unit.toMillis(time));
-		if (nextUpdate > t)
-			nextUpdate = t;
-		return add;
-	}
-
-	public void add(int index, E e, int time, TimeUnit unit) {
-		if (time == 0)
-			return;
-		super.add(index, e);
-		long t;
-		times.put(e, t = System.currentTimeMillis() + unit.toMillis(time));
-		if (nextUpdate > t)
-			nextUpdate = t;
-	}
-
-	public boolean addAll(int index, Collection<? extends E> c, int time, TimeUnit unit) {
-		if (time == 0)
-			return false;
-		for (E e : c) {
-			long t;
-			times.put(e, t = System.currentTimeMillis() + unit.toMillis(time));
-			if (nextUpdate > t)
-				nextUpdate = t;
-		}
-		return super.addAll(index, c);
-	}
-
-	public boolean addAll(Collection<? extends E> c, int time, TimeUnit unit) {
-		if (time == 0)
-			return false;
-		for (E e : c) {
-			long t;
-			times.put(e, t = System.currentTimeMillis() + unit.toMillis(time));
-			if (nextUpdate > t)
-				nextUpdate = t;
-		}
-		return super.addAll(c);
-	}
-
-	@Override
-	public E remove(int index) {
-		E obj = super.remove(index);
-		long t = times.remove(obj);
-		if (t == nextUpdate)
-			updateTimes();
-		return obj;
-	}
-
-	@Override
-	public E get(int index) {
-		update();
-		return super.get(index);
-	}
-
-	@Override
-	public int size() {
-		update();
-		return super.size();
-	}
-
-	@Override
-	public Iterator<E> iterator() {
-		update();
-		return super.iterator();
-	}
-
-	@Override
-	public void clear() {
-		nextUpdate = Long.MAX_VALUE;
-		times.clear();
-		super.clear();
-	}
-
-	public void update() {
-		if (System.currentTimeMillis() > nextUpdate)
-			updateTimes();
-	}
-
-	@Override
-	public boolean remove(Object o) {
-		if(!times.containsKey(o))
-			return false;
-		long r = times.get(o);
-		times.remove(o);
-		if (r != 0L) {
-			if (nextUpdate == r)
-				update();
-		}
-		return super.remove(o);
-	}
-	
-	public void resetTime(E element){
-		times.put(element, System.currentTimeMillis() + defaultTimeUnit.toMillis(defautTime));
-	}
-
-	@Override
-	public boolean contains(Object o) {
-		update();
-		return super.contains(o);
-	}
-
-	@Override
-	public boolean containsAll(Collection<?> c) {
-		update();
-		return super.containsAll(c);
-	}
-
-	@Override
-	public int indexOf(Object o) {
-		update();
-		return super.indexOf(o);
-	}
-
-	@Override
-	public boolean isEmpty() {
-		update();
-		return super.isEmpty();
-	}
-
-	@Override
-	public List<E> subList(int fromIndex, int toIndex) {
-		update();
-		return super.subList(fromIndex, toIndex);
-	}
-
-	@Override
-	public int lastIndexOf(Object o) {
-		update();
-		return super.lastIndexOf(o);
-	}
-
-	@Override
-	public E set(int index, E element) {
-		return set(index, element,defautTime,defaultTimeUnit);
-	}
-	
-	@Override
-	public <T> T[] toArray(T[] a) {
-		update();
-		return super.toArray(a);
-	}
-	
-	@Override
-	public Object[] toArray() {
-		update();
-		return super.toArray();
-	}
-	public E set(int index, E element, int time, TimeUnit unit) {
-		update();
-		long l;
-		times.put(element, l = unit.toMillis(time));
-		if (l < nextUpdate)
-			nextUpdate = l;
-		E old = super.set(index, element);
-
-		long r = times.get(old);
-		times.remove(old);
-		if (r != 0L) {
-			if (nextUpdate == r)
-				update();
-		}
-		return old;
-	}
-
-	private void updateTimes() {
-		long min = Long.MAX_VALUE;
-		long time = System.currentTimeMillis();
-		HashMap<E, Long> ctimes  = new HashMap<>(times);
-		for (E e : ctimes.keySet()) {
-			long l = ctimes.get(e);
-			if (time > l){
-				boolean alowed = true;
-				for(UnloadListener<E> listener : new ArrayList<>(this.listener))
-					if(listener != null)
-						if(!listener.canUnload(e))
-							alowed = false;
-
-				if(alowed)
-					super.remove(e);
-				else{
-					resetTime(e);
-					l = ctimes.get(e);
-				}
-			}
-			else if (l < min)
-				min = l;
-		}
-		nextUpdate = min;
-	}
-	
-	@Override
-	public String toString() {
-		return super.toString();
-	}
-	
-	public void addUnloadListener(UnloadListener<E> listener){
-		this.listener.add(listener);
-	}
-	public void removeUnloadListener(UnloadListener<E> listener){
-		this.listener.remove(listener);
-	}
+    private static final long serialVersionUID = 1L;
+    private long nextUpdate = Long.MAX_VALUE;
+    private int defautTime;
+    private TimeUnit defaultTimeUnit = TimeUnit.MILLISECONDS;
+    private HashMap<E, Long> times = new HashMap<>();
+    private ArrayList<UnloadListener<E>> listener = new ArrayList<>();
+
+    public CachedArrayList(int defautTime, TimeUnit defaultTimeUnit) {
+        this.defautTime = defautTime;
+        this.defaultTimeUnit = defaultTimeUnit;
+    }
+
+    @Override
+    public boolean add(E e) {
+        return add(e, defautTime, defaultTimeUnit);
+    }
+
+    @Override
+    public void add(int index, E element) {
+        add(index, element, defautTime, defaultTimeUnit);
+    }
+
+    @Override
+    public boolean addAll(Collection<? extends E> c) {
+        return addAll(c, defautTime, defaultTimeUnit);
+    }
+
+    @Override
+    public boolean addAll(int index, Collection<? extends E> c) {
+        return addAll(index, c, defautTime, defaultTimeUnit);
+    }
+
+    public boolean add(E e, int time, TimeUnit unit) {
+        if (time == 0)
+            return false;
+        boolean add = super.add(e);
+        long t;
+        times.put(e, t = System.currentTimeMillis() + unit.toMillis(time));
+        if (nextUpdate > t)
+            nextUpdate = t;
+        return add;
+    }
+
+    public void add(int index, E e, int time, TimeUnit unit) {
+        if (time == 0)
+            return;
+        super.add(index, e);
+        long t;
+        times.put(e, t = System.currentTimeMillis() + unit.toMillis(time));
+        if (nextUpdate > t)
+            nextUpdate = t;
+    }
+
+    public boolean addAll(int index, Collection<? extends E> c, int time, TimeUnit unit) {
+        if (time == 0)
+            return false;
+        for (E e : c) {
+            long t;
+            times.put(e, t = System.currentTimeMillis() + unit.toMillis(time));
+            if (nextUpdate > t)
+                nextUpdate = t;
+        }
+        return super.addAll(index, c);
+    }
+
+    public boolean addAll(Collection<? extends E> c, int time, TimeUnit unit) {
+        if (time == 0)
+            return false;
+        for (E e : c) {
+            long t;
+            times.put(e, t = System.currentTimeMillis() + unit.toMillis(time));
+            if (nextUpdate > t)
+                nextUpdate = t;
+        }
+        return super.addAll(c);
+    }
+
+    @Override
+    public E remove(int index) {
+        E obj = super.remove(index);
+        long t = times.remove(obj);
+        if (t == nextUpdate)
+            updateTimes();
+        return obj;
+    }
+
+    @Override
+    public E get(int index) {
+        update();
+        return super.get(index);
+    }
+
+    @Override
+    public int size() {
+        update();
+        return super.size();
+    }
+
+    @Override
+    public Iterator<E> iterator() {
+        update();
+        return super.iterator();
+    }
+
+    @Override
+    public void clear() {
+        nextUpdate = Long.MAX_VALUE;
+        times.clear();
+        super.clear();
+    }
+
+    public void update() {
+        if (System.currentTimeMillis() > nextUpdate)
+            updateTimes();
+    }
+
+    @Override
+    public boolean remove(Object o) {
+        if (!times.containsKey(o))
+            return false;
+        long r = times.get(o);
+        times.remove(o);
+        if (r != 0L) {
+            if (nextUpdate == r)
+                update();
+        }
+        return super.remove(o);
+    }
+
+    public void resetTime(E element) {
+        times.put(element, System.currentTimeMillis() + defaultTimeUnit.toMillis(defautTime));
+    }
+
+    @Override
+    public boolean contains(Object o) {
+        update();
+        return super.contains(o);
+    }
+
+    @Override
+    public boolean containsAll(Collection<?> c) {
+        update();
+        return super.containsAll(c);
+    }
+
+    @Override
+    public int indexOf(Object o) {
+        update();
+        return super.indexOf(o);
+    }
+
+    @Override
+    public boolean isEmpty() {
+        update();
+        return super.isEmpty();
+    }
+
+    @Override
+    public List<E> subList(int fromIndex, int toIndex) {
+        update();
+        return super.subList(fromIndex, toIndex);
+    }
+
+    @Override
+    public int lastIndexOf(Object o) {
+        update();
+        return super.lastIndexOf(o);
+    }
+
+    @Override
+    public E set(int index, E element) {
+        return set(index, element, defautTime, defaultTimeUnit);
+    }
+
+    @Override
+    public <T> T[] toArray(T[] a) {
+        update();
+        return super.toArray(a);
+    }
+
+    @Override
+    public Object[] toArray() {
+        update();
+        return super.toArray();
+    }
+
+    public E set(int index, E element, int time, TimeUnit unit) {
+        update();
+        long l;
+        times.put(element, l = unit.toMillis(time));
+        if (l < nextUpdate)
+            nextUpdate = l;
+        E old = super.set(index, element);
+
+        long r = times.get(old);
+        times.remove(old);
+        if (r != 0L) {
+            if (nextUpdate == r)
+                update();
+        }
+        return old;
+    }
+
+    private void updateTimes() {
+        long min = Long.MAX_VALUE;
+        long time = System.currentTimeMillis();
+        HashMap<E, Long> ctimes = new HashMap<>(times);
+        for (E e : ctimes.keySet()) {
+            long l = ctimes.get(e);
+            if (time > l) {
+                boolean alowed = true;
+                for (UnloadListener<E> listener : new ArrayList<>(this.listener))
+                    if (listener != null)
+                        if (!listener.canUnload(e))
+                            alowed = false;
+
+                if (alowed)
+                    super.remove(e);
+                else {
+                    resetTime(e);
+                    l = ctimes.get(e);
+                }
+            } else if (l < min)
+                min = l;
+        }
+        nextUpdate = min;
+    }
+
+    @Override
+    public String toString() {
+        return super.toString();
+    }
+
+    public void addUnloadListener(UnloadListener<E> listener) {
+        this.listener.add(listener);
+    }
+
+    public void removeUnloadListener(UnloadListener<E> listener) {
+        this.listener.remove(listener);
+    }
+
+    public static interface UnloadListener<E> {
+        public boolean canUnload(E element);
+    }
 }
diff --git a/src/main/java/dev/wolveringer/maps/CachedHashMap.java b/src/main/java/dev/wolveringer/maps/CachedHashMap.java
index 0a6b3aa..e3cc89f 100644
--- a/src/main/java/dev/wolveringer/maps/CachedHashMap.java
+++ b/src/main/java/dev/wolveringer/maps/CachedHashMap.java
@@ -1,97 +1,97 @@
 package dev.wolveringer.maps;
 
 import java.util.Collection;
-import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.TimeUnit;
 
-public class CachedHashMap<K,V> extends HashMap<K, V> {
-	private CachedArrayList<K> keys;
-	private boolean locked = false;
-	
-	public CachedHashMap(int defautTime, TimeUnit defaultTimeUnit) {
-		keys = new CachedArrayList<>(defautTime, defaultTimeUnit);
-	}
-	
-	@Override
-	public V put(K key, V value) {
-		putKey(key);
-		return super.put(key, value);
-	}
-	
-	@Override
-	public void putAll(Map<? extends K, ? extends V> m) {
-		for(K key : m.keySet())
-			putKey(key);
-		super.putAll(m);
-	}
-	
-	@Override
-	public V get(Object key) {
-		V out = super.get(key);
-		if(!locked)
-			if(!keys.contains(key)){
-				out = null;
-				super.remove(key);
-			}
-		return out;
-	}
-	
-	public V getOrDefault(Object key, V defaultValue) {
-		V out;
-		if((out = get(key)) == null)
-			return defaultValue;
-		return out;
-	}
-	
-	@Override
-	public V remove(Object key) {
-		keys.remove(key);
-		return super.remove(key);
-	}
-	
-	public boolean remove(Object key, Object value) {
-		keys.remove(key);
-		return remove(key, value);
-	}
-	
-	private void putKey(K key){
-		keys.remove(key);
-		keys.add(key);
-	}
-
-	public V put(K key, V value, int time, TimeUnit unit) {
-		keys.add(key, time, unit);
-		return super.put(key, value);
-	}
-	
-	@Override
-	public int size() {
-		return keys.size();
-	}
-	
-	@Override
-	public Set<K> keySet() {
-		if(!locked)
-			keys.update();
-		return new HashSet<>(keys);
-	}
-	
-	@Override
-	public Collection<V> values() {
-		for(K key : super.keySet())
-			get(key); //Update value
-		return super.values();
-	}
-
-	public void lock() {
-		locked = true;
-		keys.update();
-	}
-	public void unlock(){
-		locked = false;
-	}
+public class CachedHashMap<K, V> extends HashMap<K, V> {
+    private CachedArrayList<K> keys;
+    private boolean locked = false;
+
+    public CachedHashMap(int defautTime, TimeUnit defaultTimeUnit) {
+        keys = new CachedArrayList<>(defautTime, defaultTimeUnit);
+    }
+
+    @Override
+    public V put(K key, V value) {
+        putKey(key);
+        return super.put(key, value);
+    }
+
+    @Override
+    public void putAll(Map<? extends K, ? extends V> m) {
+        for (K key : m.keySet())
+            putKey(key);
+        super.putAll(m);
+    }
+
+    @Override
+    public V get(Object key) {
+        V out = super.get(key);
+        if (!locked)
+            if (!keys.contains(key)) {
+                out = null;
+                super.remove(key);
+            }
+        return out;
+    }
+
+    public V getOrDefault(Object key, V defaultValue) {
+        V out;
+        if ((out = get(key)) == null)
+            return defaultValue;
+        return out;
+    }
+
+    @Override
+    public V remove(Object key) {
+        keys.remove(key);
+        return super.remove(key);
+    }
+
+    public boolean remove(Object key, Object value) {
+        keys.remove(key);
+        return remove(key, value);
+    }
+
+    private void putKey(K key) {
+        keys.remove(key);
+        keys.add(key);
+    }
+
+    public V put(K key, V value, int time, TimeUnit unit) {
+        keys.add(key, time, unit);
+        return super.put(key, value);
+    }
+
+    @Override
+    public int size() {
+        return keys.size();
+    }
+
+    @Override
+    public Set<K> keySet() {
+        if (!locked)
+            keys.update();
+        return new HashSet<>(keys);
+    }
+
+    @Override
+    public Collection<V> values() {
+        for (K key : super.keySet())
+            get(key); //Update value
+        return super.values();
+    }
+
+    public void lock() {
+        locked = true;
+        keys.update();
+    }
+
+    public void unlock() {
+        locked = false;
+    }
 }
diff --git a/src/main/java/dev/wolveringer/nbt/LimitStream.java b/src/main/java/dev/wolveringer/nbt/LimitStream.java
index f702717..b05b4fe 100644
--- a/src/main/java/dev/wolveringer/nbt/LimitStream.java
+++ b/src/main/java/dev/wolveringer/nbt/LimitStream.java
@@ -5,25 +5,25 @@ import java.io.IOException;
 import java.io.InputStream;
 
 public class LimitStream extends FilterInputStream {
-	private final NBTReadLimiter limit;
+    private final NBTReadLimiter limit;
 
-	public LimitStream(InputStream is, NBTReadLimiter limit) {
-		super(is);
-		this.limit = limit;
-	}
+    public LimitStream(InputStream is, NBTReadLimiter limit) {
+        super(is);
+        this.limit = limit;
+    }
 
-	public int read() throws IOException {
-		this.limit.readBytes(1L);
-		return super.read();
-	}
+    public int read() throws IOException {
+        this.limit.readBytes(1L);
+        return super.read();
+    }
 
-	public int read(byte[] b) throws IOException {
-		this.limit.readBytes(b.length);
-		return super.read(b);
-	}
+    public int read(byte[] b) throws IOException {
+        this.limit.readBytes(b.length);
+        return super.read(b);
+    }
 
-	public int read(byte[] b, int off, int len) throws IOException {
-		this.limit.readBytes(len);
-		return super.read(b, off, len);
-	}
+    public int read(byte[] b, int off, int len) throws IOException {
+        this.limit.readBytes(len);
+        return super.read(b, off, len);
+    }
 }
diff --git a/src/main/java/dev/wolveringer/nbt/MathHelper.java b/src/main/java/dev/wolveringer/nbt/MathHelper.java
index 34ec7c9..1456c05 100644
--- a/src/main/java/dev/wolveringer/nbt/MathHelper.java
+++ b/src/main/java/dev/wolveringer/nbt/MathHelper.java
@@ -4,172 +4,173 @@ import java.util.Random;
 
 public class MathHelper {
 
-	private static float[] a = new float[65536];
-	static{
-		for(int i = 0;i < 65536;++i){
-			a[i] = (float) Math.sin(i * 3.141592653589793D * 2.0D / 65536.0D);
-		}
-	}
-
-	public static double getHighestDouble(double d0, double d1) {
-		if(d0 < 0.0D){
-			d0 = -d0;
-		}
-
-		if(d1 < 0.0D){
-			d1 = -d1;
-		}
-
-		return d0 > d1 ? d0 : d1;
-	}
+    private static float[] a = new float[65536];
 
-	public static double a(double d0, double d1, double d2) {
-		return d0 < d1 ? d1 : d0 > d2 ? d2 : d0;
-	}
+    static {
+        for (int i = 0; i < 65536; ++i) {
+            a[i] = (float) Math.sin(i * 3.141592653589793D * 2.0D / 65536.0D);
+        }
+    }
+
+    public static double getHighestDouble(double d0, double d1) {
+        if (d0 < 0.0D) {
+            d0 = -d0;
+        }
 
-	public static float a(float f, float f1, float f2) {
-		return f < f1 ? f1 : f > f2 ? f2 : f;
-	}
+        if (d1 < 0.0D) {
+            d1 = -d1;
+        }
 
-	public static int a(int i) {
-		return i >= 0 ? i : -i;
-	}
+        return d0 > d1 ? d0 : d1;
+    }
 
-	public static int a(int i, int j, int k) {
-		return i < j ? j : i > k ? k : i;
-	}
+    public static double a(double d0, double d1, double d2) {
+        return d0 < d1 ? d1 : d0 > d2 ? d2 : d0;
+    }
 
-	public static double a(long[] along) {
-		long i = 0L;
-		long[] along1 = along;
-		int j = along.length;
+    public static float a(float f, float f1, float f2) {
+        return f < f1 ? f1 : f > f2 ? f2 : f;
+    }
 
-		for(int k = 0;k < j;++k){
-			long l = along1[k];
+    public static int a(int i) {
+        return i >= 0 ? i : -i;
+    }
 
-			i += l;
-		}
+    public static int a(int i, int j, int k) {
+        return i < j ? j : i > k ? k : i;
+    }
 
-		return (double) i / (double) along.length;
-	}
+    public static double a(long[] along) {
+        long i = 0L;
+        long[] along1 = along;
+        int j = along.length;
 
-	public static double random(Random random, double d0, double d1) {
-		return d0 >= d1 ? d0 : random.nextDouble() * (d1 - d0) + d0;
-	}
+        for (int k = 0; k < j; ++k) {
+            long l = along1[k];
 
-	public static float random(Random random, float f, float f1) {
-		return f >= f1 ? f : random.nextFloat() * (f1 - f) + f;
-	}
+            i += l;
+        }
 
-	public static double a(String s, double d0) {
-		double d1 = d0;
+        return (double) i / (double) along.length;
+    }
 
-		try{
-			d1 = Double.parseDouble(s);
-		}catch (Throwable throwable){
-			;
-		}
+    public static double random(Random random, double d0, double d1) {
+        return d0 >= d1 ? d0 : random.nextDouble() * (d1 - d0) + d0;
+    }
 
-		return d1;
-	}
+    public static float random(Random random, float f, float f1) {
+        return f >= f1 ? f : random.nextFloat() * (f1 - f) + f;
+    }
 
-	public static double a(String s, double d0, double d1) {
-		double d2 = d0;
+    public static double a(String s, double d0) {
+        double d1 = d0;
 
-		try{
-			d2 = Double.parseDouble(s);
-		}catch (Throwable throwable){
-			;
-		}
+        try {
+            d1 = Double.parseDouble(s);
+        } catch (Throwable throwable) {
+            ;
+        }
 
-		if(d2 < d1){
-			d2 = d1;
-		}
+        return d1;
+    }
 
-		return d2;
-	}
+    public static double a(String s, double d0, double d1) {
+        double d2 = d0;
 
-	public static int parseInteger(String raw, int i) {
-		int j = i;
-		try{
-			j = Integer.parseInt(raw);
-		}catch (Throwable throwable){
-			;
-		}
+        try {
+            d2 = Double.parseDouble(s);
+        } catch (Throwable throwable) {
+            ;
+        }
 
-		return j;
-	}
+        if (d2 < d1) {
+            d2 = d1;
+        }
 
-	public static int parseInteger(String s, int default_value, int min) {
-		int value = default_value;
+        return d2;
+    }
 
-		try{
-			value = Integer.parseInt(s);
-		}catch (Throwable throwable){
-		}
+    public static int parseInteger(String raw, int i) {
+        int j = i;
+        try {
+            j = Integer.parseInt(raw);
+        } catch (Throwable throwable) {
+            ;
+        }
 
-		if(value < min){
-			value = min;
-		}
+        return j;
+    }
 
-		return value;
-	}
+    public static int parseInteger(String s, int default_value, int min) {
+        int value = default_value;
 
-	public static float abs(float f) {
-		return f >= 0.0F ? f : -f;
-	}
+        try {
+            value = Integer.parseInt(s);
+        } catch (Throwable throwable) {
+        }
 
-	public static double b(double d0, double d1, double d2) {
-		return d2 < 0.0D ? d0 : d2 > 1.0D ? d1 : d0 + (d1 - d0) * d2;
-	}
+        if (value < min) {
+            value = min;
+        }
 
-	public static final float sqrt(float f) {
-		return (float) Math.sqrt(f);
-	}
+        return value;
+    }
 
-	public static final float cos(float f) {
-		return a[(int) (f * 10430.378F + 16384.0F) & '\uffff'];
-	}
+    public static float abs(float f) {
+        return f >= 0.0F ? f : -f;
+    }
 
-	public static long d(double d0) {
-		long i = (long) d0;
+    public static double b(double d0, double d1, double d2) {
+        return d2 < 0.0D ? d0 : d2 > 1.0D ? d1 : d0 + (d1 - d0) * d2;
+    }
 
-		return d0 < i ? i - 1L : i;
-	}
+    public static final float sqrt(float f) {
+        return (float) Math.sqrt(f);
+    }
 
-	public static int d(float f) {
-		int i = (int) f;
+    public static final float cos(float f) {
+        return a[(int) (f * 10430.378F + 16384.0F) & '\uffff'];
+    }
 
-		return f < i ? i - 1 : i;
-	}
+    public static long d(double d0) {
+        long i = (long) d0;
 
-	public static int f(double d0) {
-		int i = (int) d0;
+        return d0 < i ? i - 1L : i;
+    }
 
-		return d0 > i ? i + 1 : i;
-	}
+    public static int d(float f) {
+        int i = (int) f;
 
-	public static int f(float f) {
-		int i = (int) f;
+        return f < i ? i - 1 : i;
+    }
 
-		return f > i ? i + 1 : i;
-	}
+    public static int f(double d0) {
+        int i = (int) d0;
 
-	public static int floor(double d0) {
-		int i = (int) d0;
+        return d0 > i ? i + 1 : i;
+    }
 
-		return d0 < i ? i - 1 : i;
-	}
+    public static int f(float f) {
+        int i = (int) f;
 
-	public static int nextInt(Random random, int min, int max) {
-		return min >= max ? min : random.nextInt(max - min + 1) + min;
-	}
+        return f > i ? i + 1 : i;
+    }
 
-	public static final float sin(float f) {
-		return a[(int) (f * 10430.378F) & '\uffff'];
-	}
+    public static int floor(double d0) {
+        int i = (int) d0;
 
-	public static final float sqrt(double d0) {
-		return (float) Math.sqrt(d0);
-	}
+        return d0 < i ? i - 1 : i;
+    }
+
+    public static int nextInt(Random random, int min, int max) {
+        return min >= max ? min : random.nextInt(max - min + 1) + min;
+    }
+
+    public static final float sin(float f) {
+        return a[(int) (f * 10430.378F) & '\uffff'];
+    }
+
+    public static final float sqrt(double d0) {
+        return (float) Math.sqrt(d0);
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/nbt/NBTBase.java b/src/main/java/dev/wolveringer/nbt/NBTBase.java
index e24fb56..7910dd2 100644
--- a/src/main/java/dev/wolveringer/nbt/NBTBase.java
+++ b/src/main/java/dev/wolveringer/nbt/NBTBase.java
@@ -4,87 +4,89 @@ import java.io.DataInput;
 import java.io.DataOutput;
 
 public abstract class NBTBase {
-	private final static int id_min = 0;
-	private final static int id_max = 11;//edit i8f you wont add your Tags
-	public static final String[] types = new String[] { "END", "BYTE", "SHORT", "INT", "LONG", "FLOAT", "DOUBLE", "BYTE[]", "STRING", "LIST", "COMPOUND", "INT[]" };
+    public static final String[] types = new String[]{"END", "BYTE", "SHORT", "INT", "LONG", "FLOAT", "DOUBLE", "BYTE[]", "STRING", "LIST", "COMPOUND", "INT[]"};
+    private final static int id_min = 0;
+    private final static int id_max = 11;//edit i8f you wont add your Tags
 
-	protected static NBTBase createTag(byte type) {
-		if(type> id_max || type < id_min)
-			throw new IllegalArgumentException("type must be: 11 <= type >= 0");
-		switch (type) {
-			case 0:
-				return new NBTTagEnd();
+    protected NBTBase() {
+    }
 
-			case 1:
-				return new NBTTagByte();
+    protected static NBTBase createTag(byte type) {
+        if (type > id_max || type < id_min)
+            throw new IllegalArgumentException("type must be: 11 <= type >= 0");
+        switch (type) {
+            case 0:
+                return new NBTTagEnd();
 
-			case 2:
-				return new NBTTagShort();
+            case 1:
+                return new NBTTagByte();
 
-			case 3:
-				return new NBTTagInt();
+            case 2:
+                return new NBTTagShort();
 
-			case 4:
-				return new NBTTagLong();
+            case 3:
+                return new NBTTagInt();
 
-			case 5:
-				return new NBTTagFloat();
+            case 4:
+                return new NBTTagLong();
 
-			case 6:
-				return new NBTTagDouble();
+            case 5:
+                return new NBTTagFloat();
 
-			case 7:
-				return new NBTTagByteArray();
+            case 6:
+                return new NBTTagDouble();
 
-			case 8:
-				return new NBTTagString();
+            case 7:
+                return new NBTTagByteArray();
 
-			case 9:
-				return new NBTTagList();
+            case 8:
+                return new NBTTagString();
 
-			case 10:
-				return new NBTTagCompound();
+            case 9:
+                return new NBTTagList();
 
-			case 11:
-				return new NBTTagIntArray();
-				//add case for your NBT
-			default:
-				return null;
-		}
-	}
+            case 10:
+                return new NBTTagCompound();
 
-	protected NBTBase() {}
+            case 11:
+                return new NBTTagIntArray();
+            //add case for your NBT
+            default:
+                return null;
+        }
+    }
 
-	@Override
-	public abstract NBTBase clone();
+    @Override
+    public abstract NBTBase clone();
 
-	@Override
-	public boolean equals(Object object) {
-		if(!(object instanceof NBTBase)){
-			return false;
-		}else{
-			NBTBase nbtbase = (NBTBase) object;
+    @Override
+    public boolean equals(Object object) {
+        if (!(object instanceof NBTBase)) {
+            return false;
+        } else {
+            NBTBase nbtbase = (NBTBase) object;
 
-			return this.getTypeId() == nbtbase.getTypeId();
-		}
-	}
+            return this.getTypeId() == nbtbase.getTypeId();
+        }
+    }
 
-	public abstract byte getTypeId();
+    public abstract byte getTypeId();
 
-	@Override
-	public int hashCode() {
-		return this.getTypeId();
-	}
+    @Override
+    public int hashCode() {
+        return this.getTypeId();
+    }
 
-	abstract void load(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) throws Exception;
+    abstract void load(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) throws Exception;
 
-	@Override
-	public abstract String toString();
-	abstract String toFormatedString(String prefix);
-	
-	public String toFormatedString(){
-		return toFormatedString("  ");
-	}
-	
-	abstract void write(DataOutput dataoutput) throws Exception;
+    @Override
+    public abstract String toString();
+
+    abstract String toFormatedString(String prefix);
+
+    public String toFormatedString() {
+        return toFormatedString("  ");
+    }
+
+    abstract void write(DataOutput dataoutput) throws Exception;
 }
diff --git a/src/main/java/dev/wolveringer/nbt/NBTCompressedStreamTools.java b/src/main/java/dev/wolveringer/nbt/NBTCompressedStreamTools.java
index c936063..7fe96c3 100644
--- a/src/main/java/dev/wolveringer/nbt/NBTCompressedStreamTools.java
+++ b/src/main/java/dev/wolveringer/nbt/NBTCompressedStreamTools.java
@@ -18,151 +18,151 @@ import javax.xml.bind.DatatypeConverter;
 
 public class NBTCompressedStreamTools {
 
-	public static NBTTagCompound read(String data) throws Exception {
-		return read(DatatypeConverter.parseBase64Binary(data), NBTReadLimiter.unlimited);
-	}
-
-	public static NBTTagCompound read(byte[] abyte, NBTReadLimiter nbtreadlimiter) throws Exception {
-		DataInputStream datainputstream = null;
-		try{
-			datainputstream = new DataInputStream(new BufferedInputStream(new GZIPInputStream(new ByteArrayInputStream(abyte))));
-		}catch (java.io.IOException e1){
-			e1.printStackTrace();
-		}
-
-		NBTTagCompound nbttagcompound;
-
-		try{
-			nbttagcompound = read(datainputstream, nbtreadlimiter);
-		}finally{
-			try{
-				datainputstream.close();
-			}catch (IOException e){
-				e.printStackTrace();
-			}
-		}
-
-		return nbttagcompound;
-	}
-
-	public static NBTTagCompound read(InputStream inputstream) throws Exception {
-		DataInputStream datainputstream = createCompressedInput(inputstream);
-		NBTTagCompound nbttagcompound;
-		try{
-			nbttagcompound = read(datainputstream, NBTReadLimiter.unlimited);
-		}finally{
-			try{
-				datainputstream.close();
-			}catch (java.io.IOException e){
-				e.printStackTrace();
-			}
-		}
-
-		return nbttagcompound;
-	}
-
-	public static NBTTagCompound read(DataInput datainput, NBTReadLimiter nbtreadlimiter) throws Exception {
-		NBTBase nbtbase;
-		byte b0 = 0;
-		try{
-			b0 = datainput.readByte();
-		}catch (java.io.IOException e1){
-			e1.printStackTrace();
-		}
-
-		if(b0 == 0){
-			nbtbase = new NBTTagEnd();
-		}else{
-			try{
-				datainput.readUTF();
-			}catch (java.io.IOException e){
-				e.printStackTrace();
-			}
-			nbtbase = NBTBase.createTag(b0);
-
-			try{
-				nbtbase.load(datainput, 0, nbtreadlimiter);
-			}catch (IOException ioexception){
-				throw new RuntimeException();
-			}
-		}
-
-		if(nbtbase instanceof NBTTagCompound){
-			return (NBTTagCompound) nbtbase;
-		}else{
-			throw new IOException("Root tag must be a named compound tag");
-		}
-	}
-
-	public static NBTTagCompound read(DataInputStream datainputstream) throws Exception {
-		return read(datainputstream, NBTReadLimiter.unlimited);
-	}
-
-	public static byte[] toByte(NBTTagCompound nbttagcompound) throws Exception {
-		ByteArrayOutputStream bytearrayoutputstream = new ByteArrayOutputStream();
-		DataOutputStream dataoutputstream = createCompressedOutput(bytearrayoutputstream);
-		try{
-			write(nbttagcompound, (DataOutput) dataoutputstream);
-		}finally{
-			try{
-				dataoutputstream.close();
-			}catch (java.io.IOException e){
-				e.printStackTrace();
-			}
-		}
-
-		return bytearrayoutputstream.toByteArray();
-	}
-
-	public static String toString(NBTTagCompound nbttagcompound) throws Exception {
-		return DatatypeConverter.printBase64Binary(toByte(nbttagcompound));
-	}
-
-	public static void write(NBTTagCompound nbttagcompound, DataOutput dataoutput) throws Exception {
-		try{
-			dataoutput.writeByte(nbttagcompound.getTypeId());
-			if(nbttagcompound.getTypeId() != 0){
-				try{
-					dataoutput.writeUTF("");
-				}catch (java.io.IOException e){
-					e.printStackTrace();
-				}
-				nbttagcompound.write(dataoutput);
-			}
-		}catch (java.io.IOException e){
-			e.printStackTrace();
-		}finally{
-		}
-	}
-
-	public static void write(NBTTagCompound nbttagcompound, OutputStream outputstream) throws Exception {
-		DataOutputStream dataoutputstream = createCompressedOutput(outputstream);
-		try{
-			write(nbttagcompound, (DataOutput) dataoutputstream);
-		}finally{
-			try{
-				dataoutputstream.close();
-			}catch (java.io.IOException e){
-				e.printStackTrace();
-			}
-		}
-	}
-
-	private static DataOutputStream createCompressedOutput(OutputStream out) {
-		try{
-			return new DataOutputStream(new BufferedOutputStream(new GZIPOutputStream(out)));
-		}catch (java.io.IOException e){
-			e.printStackTrace();
-			return null;
-		}
-	}
-
-	private static DataInputStream createCompressedInput(InputStream in) {
-		try{
-			return new DataInputStream(new BufferedInputStream(new GZIPInputStream(in)));
-		}catch (java.io.IOException e){
-			e.printStackTrace();
-			return null;
-		}
-	}
+    public static NBTTagCompound read(String data) throws Exception {
+        return read(DatatypeConverter.parseBase64Binary(data), NBTReadLimiter.unlimited);
+    }
+
+    public static NBTTagCompound read(byte[] abyte, NBTReadLimiter nbtreadlimiter) throws Exception {
+        DataInputStream datainputstream = null;
+        try {
+            datainputstream = new DataInputStream(new BufferedInputStream(new GZIPInputStream(new ByteArrayInputStream(abyte))));
+        } catch (java.io.IOException e1) {
+            e1.printStackTrace();
+        }
+
+        NBTTagCompound nbttagcompound;
+
+        try {
+            nbttagcompound = read(datainputstream, nbtreadlimiter);
+        } finally {
+            try {
+                datainputstream.close();
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        }
+
+        return nbttagcompound;
+    }
+
+    public static NBTTagCompound read(InputStream inputstream) throws Exception {
+        DataInputStream datainputstream = createCompressedInput(inputstream);
+        NBTTagCompound nbttagcompound;
+        try {
+            nbttagcompound = read(datainputstream, NBTReadLimiter.unlimited);
+        } finally {
+            try {
+                datainputstream.close();
+            } catch (java.io.IOException e) {
+                e.printStackTrace();
+            }
+        }
+
+        return nbttagcompound;
+    }
+
+    public static NBTTagCompound read(DataInput datainput, NBTReadLimiter nbtreadlimiter) throws Exception {
+        NBTBase nbtbase;
+        byte b0 = 0;
+        try {
+            b0 = datainput.readByte();
+        } catch (java.io.IOException e1) {
+            e1.printStackTrace();
+        }
+
+        if (b0 == 0) {
+            nbtbase = new NBTTagEnd();
+        } else {
+            try {
+                datainput.readUTF();
+            } catch (java.io.IOException e) {
+                e.printStackTrace();
+            }
+            nbtbase = NBTBase.createTag(b0);
+
+            try {
+                nbtbase.load(datainput, 0, nbtreadlimiter);
+            } catch (IOException ioexception) {
+                throw new RuntimeException();
+            }
+        }
+
+        if (nbtbase instanceof NBTTagCompound) {
+            return (NBTTagCompound) nbtbase;
+        } else {
+            throw new IOException("Root tag must be a named compound tag");
+        }
+    }
+
+    public static NBTTagCompound read(DataInputStream datainputstream) throws Exception {
+        return read(datainputstream, NBTReadLimiter.unlimited);
+    }
+
+    public static byte[] toByte(NBTTagCompound nbttagcompound) throws Exception {
+        ByteArrayOutputStream bytearrayoutputstream = new ByteArrayOutputStream();
+        DataOutputStream dataoutputstream = createCompressedOutput(bytearrayoutputstream);
+        try {
+            write(nbttagcompound, (DataOutput) dataoutputstream);
+        } finally {
+            try {
+                dataoutputstream.close();
+            } catch (java.io.IOException e) {
+                e.printStackTrace();
+            }
+        }
+
+        return bytearrayoutputstream.toByteArray();
+    }
+
+    public static String toString(NBTTagCompound nbttagcompound) throws Exception {
+        return DatatypeConverter.printBase64Binary(toByte(nbttagcompound));
+    }
+
+    public static void write(NBTTagCompound nbttagcompound, DataOutput dataoutput) throws Exception {
+        try {
+            dataoutput.writeByte(nbttagcompound.getTypeId());
+            if (nbttagcompound.getTypeId() != 0) {
+                try {
+                    dataoutput.writeUTF("");
+                } catch (java.io.IOException e) {
+                    e.printStackTrace();
+                }
+                nbttagcompound.write(dataoutput);
+            }
+        } catch (java.io.IOException e) {
+            e.printStackTrace();
+        } finally {
+        }
+    }
+
+    public static void write(NBTTagCompound nbttagcompound, OutputStream outputstream) throws Exception {
+        DataOutputStream dataoutputstream = createCompressedOutput(outputstream);
+        try {
+            write(nbttagcompound, (DataOutput) dataoutputstream);
+        } finally {
+            try {
+                dataoutputstream.close();
+            } catch (java.io.IOException e) {
+                e.printStackTrace();
+            }
+        }
+    }
+
+    private static DataOutputStream createCompressedOutput(OutputStream out) {
+        try {
+            return new DataOutputStream(new BufferedOutputStream(new GZIPOutputStream(out)));
+        } catch (java.io.IOException e) {
+            e.printStackTrace();
+            return null;
+        }
+    }
+
+    private static DataInputStream createCompressedInput(InputStream in) {
+        try {
+            return new DataInputStream(new BufferedInputStream(new GZIPInputStream(in)));
+        } catch (java.io.IOException e) {
+            e.printStackTrace();
+            return null;
+        }
+    }
 }
diff --git a/src/main/java/dev/wolveringer/nbt/NBTNumber.java b/src/main/java/dev/wolveringer/nbt/NBTNumber.java
index 944273e..f03c60a 100644
--- a/src/main/java/dev/wolveringer/nbt/NBTNumber.java
+++ b/src/main/java/dev/wolveringer/nbt/NBTNumber.java
@@ -2,18 +2,18 @@ package dev.wolveringer.nbt;
 
 public abstract class NBTNumber extends NBTBase {
 
-	protected NBTNumber() {
-	}
+    protected NBTNumber() {
+    }
 
-	public abstract long asLong();
+    public abstract long asLong();
 
-	public abstract int asInt();
+    public abstract int asInt();
 
-	public abstract short asShort();
+    public abstract short asShort();
 
-	public abstract byte asByte();
+    public abstract byte asByte();
 
-	public abstract double asDouble();
+    public abstract double asDouble();
 
-	public abstract float asFloat();
+    public abstract float asFloat();
 }
diff --git a/src/main/java/dev/wolveringer/nbt/NBTReadLimiter.java b/src/main/java/dev/wolveringer/nbt/NBTReadLimiter.java
index 79f0b71..1bb4e69 100644
--- a/src/main/java/dev/wolveringer/nbt/NBTReadLimiter.java
+++ b/src/main/java/dev/wolveringer/nbt/NBTReadLimiter.java
@@ -2,18 +2,18 @@ package dev.wolveringer.nbt;
 
 public class NBTReadLimiter {
 
-	public static final NBTReadLimiter unlimited = new NBTReadLimiterUnlimited(0L);
-	private final long limit;
-	private long readed;
+    public static final NBTReadLimiter unlimited = new NBTReadLimiterUnlimited(0L);
+    private final long limit;
+    private long readed;
 
-	public NBTReadLimiter(long limit) {
-		this.limit = limit;
-	}
+    public NBTReadLimiter(long limit) {
+        this.limit = limit;
+    }
 
-	public void readBytes(long bits) {
-		this.readed += bits / 8L;
-		if(this.readed > this.limit){
-			throw new RuntimeException("Tried to read NBT tag that was too big; tried to allocate: " + this.readed + "bytes where max allowed: " + this.limit);
-		}
-	}
+    public void readBytes(long bits) {
+        this.readed += bits / 8L;
+        if (this.readed > this.limit) {
+            throw new RuntimeException("Tried to read NBT tag that was too big; tried to allocate: " + this.readed + "bytes where max allowed: " + this.limit);
+        }
+    }
 }
diff --git a/src/main/java/dev/wolveringer/nbt/NBTReadLimiterUnlimited.java b/src/main/java/dev/wolveringer/nbt/NBTReadLimiterUnlimited.java
index 101442c..552a895 100644
--- a/src/main/java/dev/wolveringer/nbt/NBTReadLimiterUnlimited.java
+++ b/src/main/java/dev/wolveringer/nbt/NBTReadLimiterUnlimited.java
@@ -1,10 +1,11 @@
 package dev.wolveringer.nbt;
 
 final class NBTReadLimiterUnlimited extends NBTReadLimiter {
-	NBTReadLimiterUnlimited(long i) {
-		super(i);
-	}
+    NBTReadLimiterUnlimited(long i) {
+        super(i);
+    }
 
-	@Override
-	public void readBytes(long i) {}
+    @Override
+    public void readBytes(long i) {
+    }
 }
diff --git a/src/main/java/dev/wolveringer/nbt/NBTTagByte.java b/src/main/java/dev/wolveringer/nbt/NBTTagByte.java
index c6b5cbd..c5727d4 100644
--- a/src/main/java/dev/wolveringer/nbt/NBTTagByte.java
+++ b/src/main/java/dev/wolveringer/nbt/NBTTagByte.java
@@ -6,97 +6,97 @@ import java.io.IOException;
 
 public class NBTTagByte extends NBTNumber {
 
-	private byte data;
-
-	NBTTagByte() {
-	}
-
-	public NBTTagByte(byte b0) {
-		this.data = b0;
-	}
-
-	@Override
-	public long asLong() {
-		return this.data;
-	}
-
-	@Override
-	public NBTBase clone() {
-		return new NBTTagByte(this.data);
-	}
-
-	@Override
-	public int asInt() {
-		return this.data;
-	}
-
-	@Override
-	public short asShort() {
-		return this.data;
-	}
-
-	@Override
-	public boolean equals(Object object) {
-		if(super.equals(object)){
-			NBTTagByte nbttagbyte = (NBTTagByte) object;
-
-			return this.data == nbttagbyte.data;
-		}else{
-			return false;
-		}
-	}
-
-	@Override
-	public byte asByte() {
-		return this.data;
-	}
-
-	@Override
-	public double asDouble() {
-		return this.data;
-	}
-
-	@Override
-	public byte getTypeId() {
-		return (byte) 1;
-	}
-
-	@Override
-	public float asFloat() {
-		return this.data;
-	}
-
-	@Override
-	public int hashCode() {
-		return super.hashCode() ^ this.data;
-	}
-
-	@Override
-	void load(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) {
-		nbtreadlimiter.readBytes(8L);
-		try{
-			this.data = datainput.readByte();
-		}catch (IOException e){
-			e.printStackTrace();
-		}
-	}
-
-	@Override
-	String toFormatedString(String in) {
-		return in+toString();
-	}
-	
-	@Override
-	public String toString() {
-		return "" + this.data + "b";
-	}
-
-	@Override
-	void write(DataOutput dataoutput) {
-		try{
-			dataoutput.writeByte(this.data);
-		}catch (IOException e){
-			e.printStackTrace();
-		}
-	}
+    private byte data;
+
+    NBTTagByte() {
+    }
+
+    public NBTTagByte(byte b0) {
+        this.data = b0;
+    }
+
+    @Override
+    public long asLong() {
+        return this.data;
+    }
+
+    @Override
+    public NBTBase clone() {
+        return new NBTTagByte(this.data);
+    }
+
+    @Override
+    public int asInt() {
+        return this.data;
+    }
+
+    @Override
+    public short asShort() {
+        return this.data;
+    }
+
+    @Override
+    public boolean equals(Object object) {
+        if (super.equals(object)) {
+            NBTTagByte nbttagbyte = (NBTTagByte) object;
+
+            return this.data == nbttagbyte.data;
+        } else {
+            return false;
+        }
+    }
+
+    @Override
+    public byte asByte() {
+        return this.data;
+    }
+
+    @Override
+    public double asDouble() {
+        return this.data;
+    }
+
+    @Override
+    public byte getTypeId() {
+        return (byte) 1;
+    }
+
+    @Override
+    public float asFloat() {
+        return this.data;
+    }
+
+    @Override
+    public int hashCode() {
+        return super.hashCode() ^ this.data;
+    }
+
+    @Override
+    void load(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) {
+        nbtreadlimiter.readBytes(8L);
+        try {
+            this.data = datainput.readByte();
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    @Override
+    String toFormatedString(String in) {
+        return in + toString();
+    }
+
+    @Override
+    public String toString() {
+        return "" + this.data + "b";
+    }
+
+    @Override
+    void write(DataOutput dataoutput) {
+        try {
+            dataoutput.writeByte(this.data);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
 }
diff --git a/src/main/java/dev/wolveringer/nbt/NBTTagByteArray.java b/src/main/java/dev/wolveringer/nbt/NBTTagByteArray.java
index 5f1f065..31a85ed 100644
--- a/src/main/java/dev/wolveringer/nbt/NBTTagByteArray.java
+++ b/src/main/java/dev/wolveringer/nbt/NBTTagByteArray.java
@@ -7,83 +7,82 @@ import java.util.Arrays;
 
 public class NBTTagByteArray extends NBTBase {
 
-	private byte[] data;
-
-	NBTTagByteArray() {
-	}
-
-	public NBTTagByteArray(byte[] abyte) {
-		this.data = abyte;
-	}
-
-	public byte[] getData() {
-		return this.data;
-	}
-
-	@Override
-	public NBTBase clone() {
-		byte[] abyte = new byte[this.data.length];
-
-		System.arraycopy(this.data, 0, abyte, 0, this.data.length);
-		return new NBTTagByteArray(abyte);
-	}
-
-	@Override
-	public boolean equals(Object object) {
-		return super.equals(object) ? Arrays.equals(this.data, ((NBTTagByteArray) object).data) : false;
-	}
-
-	@Override
-	public byte getTypeId() {
-		return (byte) 7;
-	}
-
-	@Override
-	public int hashCode() {
-		return super.hashCode() ^ Arrays.hashCode(this.data);
-	}
-
-	@Override
-	void load(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) {
-		int length = 0;
-		try{
-			length = datainput.readInt();
-		}catch (IOException e){
-			e.printStackTrace();
-		}
-
-		nbtreadlimiter.readBytes(8 * length);
-		this.data = new byte[length];
-		try{
-			datainput.readFully(this.data);
-		}catch (IOException e){
-			e.printStackTrace();
-		}
-	}
-
-	@Override
-	public String toString() {
-		return "[" + this.data.length + " bytes]";
-	}
-	
-	
-
-	@Override
-	void write(DataOutput dataoutput) {
-		try{
-			dataoutput.writeInt(this.data.length);
-		}catch (IOException e){
-			e.printStackTrace();
-		}
-		try{
-			dataoutput.write(this.data);
-		}catch (IOException e){
-			e.printStackTrace();
-		}
-	}
-
-	@Override
-	public String toFormatedString(String prefix) {
-		return prefix+toString();
-	}
+    private byte[] data;
+
+    NBTTagByteArray() {
+    }
+
+    public NBTTagByteArray(byte[] abyte) {
+        this.data = abyte;
+    }
+
+    public byte[] getData() {
+        return this.data;
+    }
+
+    @Override
+    public NBTBase clone() {
+        byte[] abyte = new byte[this.data.length];
+
+        System.arraycopy(this.data, 0, abyte, 0, this.data.length);
+        return new NBTTagByteArray(abyte);
+    }
+
+    @Override
+    public boolean equals(Object object) {
+        return super.equals(object) ? Arrays.equals(this.data, ((NBTTagByteArray) object).data) : false;
+    }
+
+    @Override
+    public byte getTypeId() {
+        return (byte) 7;
+    }
+
+    @Override
+    public int hashCode() {
+        return super.hashCode() ^ Arrays.hashCode(this.data);
+    }
+
+    @Override
+    void load(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) {
+        int length = 0;
+        try {
+            length = datainput.readInt();
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+
+        nbtreadlimiter.readBytes(8 * length);
+        this.data = new byte[length];
+        try {
+            datainput.readFully(this.data);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    @Override
+    public String toString() {
+        return "[" + this.data.length + " bytes]";
+    }
+
+
+    @Override
+    void write(DataOutput dataoutput) {
+        try {
+            dataoutput.writeInt(this.data.length);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+        try {
+            dataoutput.write(this.data);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    @Override
+    public String toFormatedString(String prefix) {
+        return prefix + toString();
+    }
 }
diff --git a/src/main/java/dev/wolveringer/nbt/NBTTagCompound.java b/src/main/java/dev/wolveringer/nbt/NBTTagCompound.java
index 80356fb..d188516 100644
--- a/src/main/java/dev/wolveringer/nbt/NBTTagCompound.java
+++ b/src/main/java/dev/wolveringer/nbt/NBTTagCompound.java
@@ -1,5 +1,7 @@
 package dev.wolveringer.nbt;
 
+import net.md_5.bungee.BungeeCord;
+
 import java.io.DataInput;
 import java.io.DataOutput;
 import java.io.IOException;
@@ -9,333 +11,331 @@ import java.util.Map;
 import java.util.Set;
 import java.util.logging.Logger;
 
-import net.md_5.bungee.BungeeCord;
-
-@SuppressWarnings({ "rawtypes", "unchecked", "unused" })
+@SuppressWarnings({"rawtypes", "unchecked", "unused"})
 public class NBTTagCompound extends NBTBase {
 
-	private static final Logger logger = BungeeCord.getInstance() == null ? null : BungeeCord.getInstance().getLogger();
-
-	static NBTBase createNBTBase(byte type, String s, DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) throws Exception {
-		NBTBase nbtbase = NBTBase.createTag(type);
-		nbtbase.load(datainput, i, nbtreadlimiter);
-		return nbtbase;
-	}
-
-	private static void writeTag(String s, NBTBase nbtbase, DataOutput dataoutput) throws Exception {
-		try{
-			dataoutput.writeByte(nbtbase.getTypeId());
-		}catch (IOException e){
-			e.printStackTrace();
-		}
-		if(nbtbase.getTypeId() != 0){
-			try{
-				dataoutput.writeUTF(s);
-			}catch (IOException e){
-				e.printStackTrace();
-			}
-			nbtbase.write(dataoutput);
-		}
-	}
-
-	private static String readString(DataInput datainput, NBTReadLimiter nbtreadlimiter) {
-		try{
-			return datainput.readUTF();
-		}catch (IOException e){
-			e.printStackTrace();
-			return null;
-		}
-	}
-
-	private static byte readByte(DataInput datainput, NBTReadLimiter nbtreadlimiter) {
-		try{
-			return datainput.readByte();
-		}catch (IOException e){
-			e.printStackTrace();
-			return 0x00;
-		}
-	}
-
-	private Map<String, NBTBase> map = new HashMap();
-
-	public NBTTagCompound() {
-	}
-
-	public byte getNBTBaseType(String s) {
-		NBTBase nbtbase = (NBTBase) this.map.get(s);
-		return nbtbase != null ? nbtbase.getTypeId() : 0;
-	}
-
-	public Set<String> dataKeyset() {
-		return this.map.keySet();
-	}
-
-	@Override
-	public NBTBase clone() {
-		NBTTagCompound nbttagcompound = new NBTTagCompound();
-		Iterator iterator = this.map.keySet().iterator();
-
-		while (iterator.hasNext()){
-			String s = (String) iterator.next();
-
-			nbttagcompound.set(s, ((NBTBase) this.map.get(s)).clone());
-		}
-
-		return nbttagcompound;
-	}
-
-	@Override
-	public boolean equals(Object object) {
-		if(super.equals(object)){
-			NBTTagCompound nbttagcompound = (NBTTagCompound) object;
-
-			return this.map.entrySet().equals(nbttagcompound.map.entrySet());
-		}else{
-			return false;
-		}
-	}
-
-	public NBTBase get(String s) {
-		return (NBTBase) this.map.get(s);
-	}
-
-	public boolean getBoolean(String s) {
-		return this.getByte(s) != 0;
-	}
-
-	public byte getByte(String s) {
-		try{
-			return !this.map.containsKey(s) ? 0 : ((NBTNumber) this.map.get(s)).asByte();
-		}catch (ClassCastException classcastexception){
-			return (byte) 0;
-		}
-	}
-
-	public byte[] getByteArray(String s) {
-		try{
-			return !this.map.containsKey(s) ? new byte[0] : ((NBTTagByteArray) this.map.get(s)).getData();
-		}catch (ClassCastException classcastexception){
-			throw new RuntimeException();
-		}
-	}
-
-	public NBTTagCompound getCompound(String s) {
-		try{
-			return !this.map.containsKey(s) ? new NBTTagCompound() : (NBTTagCompound) this.map.get(s);
-		}catch (ClassCastException classcastexception){
-			throw new RuntimeException();
-		}
-	}
-
-	public double getDouble(String s) {
-		try{
-			return !this.map.containsKey(s) ? 0.0D : ((NBTNumber) this.map.get(s)).asDouble();
-		}catch (ClassCastException classcastexception){
-			return 0.0D;
-		}
-	}
-
-	public float getFloat(String s) {
-		try{
-			return !this.map.containsKey(s) ? 0.0F : ((NBTNumber) this.map.get(s)).asFloat();
-		}catch (ClassCastException classcastexception){
-			return 0.0F;
-		}
-	}
-
-	public int getInt(String s) {
-		try{
-			return !this.map.containsKey(s) ? 0 : ((NBTNumber) this.map.get(s)).asInt();
-		}catch (ClassCastException classcastexception){
-			return 0;
-		}
-	}
-
-	public int[] getIntArray(String s) {
-		try{
-			return !this.map.containsKey(s) ? new int[0] : ((NBTTagIntArray) this.map.get(s)).getData();
-		}catch (ClassCastException classcastexception){
-			throw new RuntimeException();
-		}
-	}
-
-	public NBTTagList getList(String s) {
-		try{
-			if(this.getNBTBaseType(s) != 9){
-				return new NBTTagList();
-			}else{
-				NBTTagList nbttaglist = (NBTTagList) this.map.get(s);
-
-				return nbttaglist;
-			}
-		}catch (ClassCastException classcastexception){
-			throw new RuntimeException();
-		}
-	}
-
-	public long getLong(String s) {
-		try{
-			return !this.map.containsKey(s) ? 0L : ((NBTNumber) this.map.get(s)).asLong();
-		}catch (ClassCastException classcastexception){
-			return 0L;
-		}
-	}
-
-	public short getShort(String s) {
-		try{
-			return !this.map.containsKey(s) ? 0 : ((NBTNumber) this.map.get(s)).asShort();
-		}catch (ClassCastException classcastexception){
-			return (short) 0;
-		}
-	}
-
-	public String getString(String s) {
-		try{
-			return !this.map.containsKey(s) ? "" : ((NBTTagString) this.map.get(s)).getData();
-		}catch (ClassCastException classcastexception){
-			return "";
-		}
-	}
-
-	@Override
-	public byte getTypeId() {
-		return (byte) 10;
-	}
-
-	@Override
-	public int hashCode() {
-		return super.hashCode() ^ this.map.hashCode();
-	}
-
-	public boolean hasKey(String s) {
-		return this.map.containsKey(s);
-	}
-
-	public boolean hasKeyOfType(String s, int i) {
-		byte b0 = this.getNBTBaseType(s);
-
-		return b0 == i ? true : i != 99 ? false : b0 == 1 || b0 == 2 || b0 == 3 || b0 == 4 || b0 == 5 || b0 == 6;
-	}
-
-	public boolean isEmpty() {
-		return this.map.isEmpty();
-	}
-
-	@Override
-	void load(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) throws Exception {
-		if(i > 512){
-			throw new RuntimeException("Tried to read NBT tag with too high complexity, depth > 512");
-		}else{
-			this.map.clear();
-
-			byte b0;
-
-			while ((b0 = readByte(datainput, nbtreadlimiter)) != 0){
-				String s = readString(datainput, nbtreadlimiter);
-
-				nbtreadlimiter.readBytes(16 * s.length());
-				NBTBase nbtbase = createNBTBase(b0, s, datainput, i + 1, nbtreadlimiter);
-
-				this.map.put(s, nbtbase);
-			}
-		}
-	}
-
-	public void remove(String s) {
-		this.map.remove(s);
-	}
-
-	public void set(String s, NBTBase nbtbase) {
-		this.map.put(s, nbtbase);
-	}
-
-	public void setBoolean(String s, boolean flag) {
-		this.setByte(s, (byte) (flag ? 1 : 0));
-	}
-
-	public void setByte(String s, byte b0) {
-		this.map.put(s, new NBTTagByte(b0));
-	}
-
-	public void setByteArray(String s, byte[] abyte) {
-		this.map.put(s, new NBTTagByteArray(abyte));
-	}
-
-	public void setDouble(String s, double d0) {
-		this.map.put(s, new NBTTagDouble(d0));
-	}
-
-	public void setFloat(String s, float f) {
-		this.map.put(s, new NBTTagFloat(f));
-	}
-
-	public void setInt(String s, int i) {
-		this.map.put(s, new NBTTagInt(i));
-	}
-
-	public void setIntArray(String s, int[] aint) {
-		this.map.put(s, new NBTTagIntArray(aint));
-	}
-
-	public void setLong(String s, long i) {
-		this.map.put(s, new NBTTagLong(i));
-	}
-
-	public void setShort(String s, short short1) {
-		this.map.put(s, new NBTTagShort(short1));
-	}
-
-	public void setString(String s, String s1) {
-		this.map.put(s, new NBTTagString(s1));
-	}
-
-	@Override
-	public String toString() {
-		String s = "{";
-
-		String s1;
-
-		for(Iterator iterator = this.map.keySet().iterator();iterator.hasNext();s = s + s1 + ':' + this.map.get(s1) + ','){
-			s1 = (String) iterator.next();
-		}
-
-		return s + "}";
-	}
-
-	@Override
-	String toFormatedString(String in) {
-		String out = "{\n";
-
-		String s1;
-
-		for(String s : (Set<String>) this.map.keySet()){
-			out += in + s + ": " + this.map.get(s).toFormatedString((map.get(s) instanceof NBTNumber || map.get(s) instanceof NBTTagString) ? "":"  " + in)+",\n";
-		}
-		return replaceLast(out,",\n","") + "\n" + in + "}";
-	}
-	private String replaceLast(String string, String from, String to) {
-	     int lastIndex = string.lastIndexOf(from);
-	     if (lastIndex < 0) return string;
-	     String tail = string.substring(lastIndex).replaceFirst(from, to);
-	     return string.substring(0, lastIndex) + tail;
-	}
-
-	@Override
-	void write(DataOutput dataoutput) throws Exception {
-		Iterator iterator = this.map.keySet().iterator();
-
-		while (iterator.hasNext()){
-			String s = (String) iterator.next();
-			NBTBase nbtbase = (NBTBase) this.map.get(s);
+    private static final Logger logger = BungeeCord.getInstance() == null ? null : BungeeCord.getInstance().getLogger();
+    private Map<String, NBTBase> map = new HashMap();
+
+    public NBTTagCompound() {
+    }
+
+    static NBTBase createNBTBase(byte type, String s, DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) throws Exception {
+        NBTBase nbtbase = NBTBase.createTag(type);
+        nbtbase.load(datainput, i, nbtreadlimiter);
+        return nbtbase;
+    }
+
+    private static void writeTag(String s, NBTBase nbtbase, DataOutput dataoutput) throws Exception {
+        try {
+            dataoutput.writeByte(nbtbase.getTypeId());
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+        if (nbtbase.getTypeId() != 0) {
+            try {
+                dataoutput.writeUTF(s);
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+            nbtbase.write(dataoutput);
+        }
+    }
+
+    private static String readString(DataInput datainput, NBTReadLimiter nbtreadlimiter) {
+        try {
+            return datainput.readUTF();
+        } catch (IOException e) {
+            e.printStackTrace();
+            return null;
+        }
+    }
+
+    private static byte readByte(DataInput datainput, NBTReadLimiter nbtreadlimiter) {
+        try {
+            return datainput.readByte();
+        } catch (IOException e) {
+            e.printStackTrace();
+            return 0x00;
+        }
+    }
+
+    public byte getNBTBaseType(String s) {
+        NBTBase nbtbase = (NBTBase) this.map.get(s);
+        return nbtbase != null ? nbtbase.getTypeId() : 0;
+    }
+
+    public Set<String> dataKeyset() {
+        return this.map.keySet();
+    }
+
+    @Override
+    public NBTBase clone() {
+        NBTTagCompound nbttagcompound = new NBTTagCompound();
+        Iterator iterator = this.map.keySet().iterator();
+
+        while (iterator.hasNext()) {
+            String s = (String) iterator.next();
+
+            nbttagcompound.set(s, ((NBTBase) this.map.get(s)).clone());
+        }
+
+        return nbttagcompound;
+    }
+
+    @Override
+    public boolean equals(Object object) {
+        if (super.equals(object)) {
+            NBTTagCompound nbttagcompound = (NBTTagCompound) object;
+
+            return this.map.entrySet().equals(nbttagcompound.map.entrySet());
+        } else {
+            return false;
+        }
+    }
+
+    public NBTBase get(String s) {
+        return (NBTBase) this.map.get(s);
+    }
+
+    public boolean getBoolean(String s) {
+        return this.getByte(s) != 0;
+    }
+
+    public byte getByte(String s) {
+        try {
+            return !this.map.containsKey(s) ? 0 : ((NBTNumber) this.map.get(s)).asByte();
+        } catch (ClassCastException classcastexception) {
+            return (byte) 0;
+        }
+    }
+
+    public byte[] getByteArray(String s) {
+        try {
+            return !this.map.containsKey(s) ? new byte[0] : ((NBTTagByteArray) this.map.get(s)).getData();
+        } catch (ClassCastException classcastexception) {
+            throw new RuntimeException();
+        }
+    }
+
+    public NBTTagCompound getCompound(String s) {
+        try {
+            return !this.map.containsKey(s) ? new NBTTagCompound() : (NBTTagCompound) this.map.get(s);
+        } catch (ClassCastException classcastexception) {
+            throw new RuntimeException();
+        }
+    }
+
+    public double getDouble(String s) {
+        try {
+            return !this.map.containsKey(s) ? 0.0D : ((NBTNumber) this.map.get(s)).asDouble();
+        } catch (ClassCastException classcastexception) {
+            return 0.0D;
+        }
+    }
+
+    public float getFloat(String s) {
+        try {
+            return !this.map.containsKey(s) ? 0.0F : ((NBTNumber) this.map.get(s)).asFloat();
+        } catch (ClassCastException classcastexception) {
+            return 0.0F;
+        }
+    }
+
+    public int getInt(String s) {
+        try {
+            return !this.map.containsKey(s) ? 0 : ((NBTNumber) this.map.get(s)).asInt();
+        } catch (ClassCastException classcastexception) {
+            return 0;
+        }
+    }
+
+    public int[] getIntArray(String s) {
+        try {
+            return !this.map.containsKey(s) ? new int[0] : ((NBTTagIntArray) this.map.get(s)).getData();
+        } catch (ClassCastException classcastexception) {
+            throw new RuntimeException();
+        }
+    }
+
+    public NBTTagList getList(String s) {
+        try {
+            if (this.getNBTBaseType(s) != 9) {
+                return new NBTTagList();
+            } else {
+                NBTTagList nbttaglist = (NBTTagList) this.map.get(s);
+
+                return nbttaglist;
+            }
+        } catch (ClassCastException classcastexception) {
+            throw new RuntimeException();
+        }
+    }
+
+    public long getLong(String s) {
+        try {
+            return !this.map.containsKey(s) ? 0L : ((NBTNumber) this.map.get(s)).asLong();
+        } catch (ClassCastException classcastexception) {
+            return 0L;
+        }
+    }
+
+    public short getShort(String s) {
+        try {
+            return !this.map.containsKey(s) ? 0 : ((NBTNumber) this.map.get(s)).asShort();
+        } catch (ClassCastException classcastexception) {
+            return (short) 0;
+        }
+    }
+
+    public String getString(String s) {
+        try {
+            return !this.map.containsKey(s) ? "" : ((NBTTagString) this.map.get(s)).getData();
+        } catch (ClassCastException classcastexception) {
+            return "";
+        }
+    }
+
+    @Override
+    public byte getTypeId() {
+        return (byte) 10;
+    }
+
+    @Override
+    public int hashCode() {
+        return super.hashCode() ^ this.map.hashCode();
+    }
+
+    public boolean hasKey(String s) {
+        return this.map.containsKey(s);
+    }
+
+    public boolean hasKeyOfType(String s, int i) {
+        byte b0 = this.getNBTBaseType(s);
+
+        return b0 == i ? true : i != 99 ? false : b0 == 1 || b0 == 2 || b0 == 3 || b0 == 4 || b0 == 5 || b0 == 6;
+    }
+
+    public boolean isEmpty() {
+        return this.map.isEmpty();
+    }
+
+    @Override
+    void load(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) throws Exception {
+        if (i > 512) {
+            throw new RuntimeException("Tried to read NBT tag with too high complexity, depth > 512");
+        } else {
+            this.map.clear();
+
+            byte b0;
+
+            while ((b0 = readByte(datainput, nbtreadlimiter)) != 0) {
+                String s = readString(datainput, nbtreadlimiter);
+
+                nbtreadlimiter.readBytes(16 * s.length());
+                NBTBase nbtbase = createNBTBase(b0, s, datainput, i + 1, nbtreadlimiter);
+
+                this.map.put(s, nbtbase);
+            }
+        }
+    }
+
+    public void remove(String s) {
+        this.map.remove(s);
+    }
+
+    public void set(String s, NBTBase nbtbase) {
+        this.map.put(s, nbtbase);
+    }
+
+    public void setBoolean(String s, boolean flag) {
+        this.setByte(s, (byte) (flag ? 1 : 0));
+    }
+
+    public void setByte(String s, byte b0) {
+        this.map.put(s, new NBTTagByte(b0));
+    }
+
+    public void setByteArray(String s, byte[] abyte) {
+        this.map.put(s, new NBTTagByteArray(abyte));
+    }
+
+    public void setDouble(String s, double d0) {
+        this.map.put(s, new NBTTagDouble(d0));
+    }
+
+    public void setFloat(String s, float f) {
+        this.map.put(s, new NBTTagFloat(f));
+    }
+
+    public void setInt(String s, int i) {
+        this.map.put(s, new NBTTagInt(i));
+    }
+
+    public void setIntArray(String s, int[] aint) {
+        this.map.put(s, new NBTTagIntArray(aint));
+    }
+
+    public void setLong(String s, long i) {
+        this.map.put(s, new NBTTagLong(i));
+    }
+
+    public void setShort(String s, short short1) {
+        this.map.put(s, new NBTTagShort(short1));
+    }
+
+    public void setString(String s, String s1) {
+        this.map.put(s, new NBTTagString(s1));
+    }
+
+    @Override
+    public String toString() {
+        String s = "{";
+
+        String s1;
+
+        for (Iterator iterator = this.map.keySet().iterator(); iterator.hasNext(); s = s + s1 + ':' + this.map.get(s1) + ',') {
+            s1 = (String) iterator.next();
+        }
+
+        return s + "}";
+    }
+
+    @Override
+    String toFormatedString(String in) {
+        String out = "{\n";
+
+        String s1;
+
+        for (String s : (Set<String>) this.map.keySet()) {
+            out += in + s + ": " + this.map.get(s).toFormatedString((map.get(s) instanceof NBTNumber || map.get(s) instanceof NBTTagString) ? "" : "  " + in) + ",\n";
+        }
+        return replaceLast(out, ",\n", "") + "\n" + in + "}";
+    }
+
+    private String replaceLast(String string, String from, String to) {
+        int lastIndex = string.lastIndexOf(from);
+        if (lastIndex < 0) return string;
+        String tail = string.substring(lastIndex).replaceFirst(from, to);
+        return string.substring(0, lastIndex) + tail;
+    }
+
+    @Override
+    void write(DataOutput dataoutput) throws Exception {
+        Iterator iterator = this.map.keySet().iterator();
+
+        while (iterator.hasNext()) {
+            String s = (String) iterator.next();
+            NBTBase nbtbase = (NBTBase) this.map.get(s);
 
-			writeTag(s, nbtbase, dataoutput);
-		}
-
-		try{
-			dataoutput.writeByte(0);
-		}catch (IOException e){
-			e.printStackTrace();
-		}
-	}
-	//15:58
+            writeTag(s, nbtbase, dataoutput);
+        }
+
+        try {
+            dataoutput.writeByte(0);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+    //15:58
 }
diff --git a/src/main/java/dev/wolveringer/nbt/NBTTagDouble.java b/src/main/java/dev/wolveringer/nbt/NBTTagDouble.java
index 72c5215..639346b 100644
--- a/src/main/java/dev/wolveringer/nbt/NBTTagDouble.java
+++ b/src/main/java/dev/wolveringer/nbt/NBTTagDouble.java
@@ -6,99 +6,99 @@ import java.io.IOException;
 
 public class NBTTagDouble extends NBTNumber {
 
-	private double data;
-
-	NBTTagDouble() {
-	}
-
-	public NBTTagDouble(double d0) {
-		this.data = d0;
-	}
-
-	@Override
-	public long asLong() {
-		return (long) Math.floor(this.data);
-	}
-
-	@Override
-	public NBTBase clone() {
-		return new NBTTagDouble(this.data);
-	}
-
-	@Override
-	public int asInt() {
-		return MathHelper.floor(this.data);
-	}
-
-	@Override
-	public short asShort() {
-		return (short) (MathHelper.floor(this.data) & '\uffff');
-	}
-
-	@Override
-	public boolean equals(Object object) {
-		if(super.equals(object)){
-			NBTTagDouble nbttagdouble = (NBTTagDouble) object;
-
-			return this.data == nbttagdouble.data;
-		}else{
-			return false;
-		}
-	}
-
-	@Override
-	public byte asByte() {
-		return (byte) (MathHelper.floor(this.data) & 255);
-	}
-
-	@Override
-	public double asDouble() {
-		return this.data;
-	}
-
-	@Override
-	public byte getTypeId() {
-		return (byte) 6;
-	}
-
-	@Override
-	public float asFloat() {
-		return (float) this.data;
-	}
-
-	@Override
-	public int hashCode() {
-		long i = Double.doubleToLongBits(this.data);
-
-		return super.hashCode() ^ (int) (i ^ i >>> 32);
-	}
-
-	@Override
-	void load(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) {
-		nbtreadlimiter.readBytes(64L);
-		try{
-			this.data = datainput.readDouble();
-		}catch (IOException e){
-			e.printStackTrace();
-		}
-	}
-
-	@Override
-	public String toString() {
-		return "" + this.data + "d";
-	}
-	
-	@Override
-	String toFormatedString(String in) {
-		return in+toString();
-	}
-
-	@Override
-	void write(DataOutput dataoutput) {
-		try{
-			dataoutput.writeDouble(this.data);
-		}catch (IOException e){
-			e.printStackTrace();
-		}
-	}
+    private double data;
+
+    NBTTagDouble() {
+    }
+
+    public NBTTagDouble(double d0) {
+        this.data = d0;
+    }
+
+    @Override
+    public long asLong() {
+        return (long) Math.floor(this.data);
+    }
+
+    @Override
+    public NBTBase clone() {
+        return new NBTTagDouble(this.data);
+    }
+
+    @Override
+    public int asInt() {
+        return MathHelper.floor(this.data);
+    }
+
+    @Override
+    public short asShort() {
+        return (short) (MathHelper.floor(this.data) & '\uffff');
+    }
+
+    @Override
+    public boolean equals(Object object) {
+        if (super.equals(object)) {
+            NBTTagDouble nbttagdouble = (NBTTagDouble) object;
+
+            return this.data == nbttagdouble.data;
+        } else {
+            return false;
+        }
+    }
+
+    @Override
+    public byte asByte() {
+        return (byte) (MathHelper.floor(this.data) & 255);
+    }
+
+    @Override
+    public double asDouble() {
+        return this.data;
+    }
+
+    @Override
+    public byte getTypeId() {
+        return (byte) 6;
+    }
+
+    @Override
+    public float asFloat() {
+        return (float) this.data;
+    }
+
+    @Override
+    public int hashCode() {
+        long i = Double.doubleToLongBits(this.data);
+
+        return super.hashCode() ^ (int) (i ^ i >>> 32);
+    }
+
+    @Override
+    void load(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) {
+        nbtreadlimiter.readBytes(64L);
+        try {
+            this.data = datainput.readDouble();
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    @Override
+    public String toString() {
+        return "" + this.data + "d";
+    }
+
+    @Override
+    String toFormatedString(String in) {
+        return in + toString();
+    }
+
+    @Override
+    void write(DataOutput dataoutput) {
+        try {
+            dataoutput.writeDouble(this.data);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
 }
diff --git a/src/main/java/dev/wolveringer/nbt/NBTTagEnd.java b/src/main/java/dev/wolveringer/nbt/NBTTagEnd.java
index 5ebed21..ae6b822 100644
--- a/src/main/java/dev/wolveringer/nbt/NBTTagEnd.java
+++ b/src/main/java/dev/wolveringer/nbt/NBTTagEnd.java
@@ -5,34 +5,34 @@ import java.io.DataOutput;
 
 public class NBTTagEnd extends NBTBase {
 
-	NBTTagEnd() {
-	}
-
-	@Override
-	public NBTBase clone() {
-		return new NBTTagEnd();
-	}
-
-	@Override
-	public byte getTypeId() {
-		return (byte) 0;
-	}
-
-	@Override
-	void load(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) {
-	}
-
-	@Override
-	public String toString() {
-		return "END";
-	}
-
-	@Override
-	String toFormatedString(String in) {
-		return in+toString();
-	}
-	
-	@Override
-	void write(DataOutput dataoutput) {
-	}
+    NBTTagEnd() {
+    }
+
+    @Override
+    public NBTBase clone() {
+        return new NBTTagEnd();
+    }
+
+    @Override
+    public byte getTypeId() {
+        return (byte) 0;
+    }
+
+    @Override
+    void load(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) {
+    }
+
+    @Override
+    public String toString() {
+        return "END";
+    }
+
+    @Override
+    String toFormatedString(String in) {
+        return in + toString();
+    }
+
+    @Override
+    void write(DataOutput dataoutput) {
+    }
 }
diff --git a/src/main/java/dev/wolveringer/nbt/NBTTagFloat.java b/src/main/java/dev/wolveringer/nbt/NBTTagFloat.java
index b68c085..ec7d049 100644
--- a/src/main/java/dev/wolveringer/nbt/NBTTagFloat.java
+++ b/src/main/java/dev/wolveringer/nbt/NBTTagFloat.java
@@ -6,97 +6,97 @@ import java.io.IOException;
 
 public class NBTTagFloat extends NBTNumber {
 
-	private float data;
-
-	NBTTagFloat() {
-	}
-
-	public NBTTagFloat(float f) {
-		this.data = f;
-	}
-
-	@Override
-	public long asLong() {
-		return (long) this.data;
-	}
-
-	@Override
-	public NBTBase clone() {
-		return new NBTTagFloat(this.data);
-	}
-
-	@Override
-	public int asInt() {
-		return MathHelper.d(this.data);
-	}
-
-	@Override
-	public short asShort() {
-		return (short) (MathHelper.d(this.data) & '\uffff');
-	}
-
-	@Override
-	public boolean equals(Object object) {
-		if(super.equals(object)){
-			NBTTagFloat nbttagfloat = (NBTTagFloat) object;
-
-			return this.data == nbttagfloat.data;
-		}else{
-			return false;
-		}
-	}
-
-	@Override
-	public byte asByte() {
-		return (byte) (MathHelper.d(this.data) & 255);
-	}
-
-	@Override
-	public double asDouble() {
-		return this.data;
-	}
-
-	@Override
-	public byte getTypeId() {
-		return (byte) 5;
-	}
-
-	@Override
-	public float asFloat() {
-		return this.data;
-	}
-
-	@Override
-	public int hashCode() {
-		return super.hashCode() ^ Float.floatToIntBits(this.data);
-	}
-
-	@Override
-	void load(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) {
-		nbtreadlimiter.readBytes(32L);
-		try{
-			this.data = datainput.readFloat();
-		}catch (IOException e){
-			e.printStackTrace();
-		}
-	}
-
-	@Override
-	public String toString() {
-		return "" + this.data + "f";
-	}
-
-	@Override
-	String toFormatedString(String in) {
-		return in+toString();
-	}
-	
-	@Override
-	void write(DataOutput dataoutput) {
-		try{
-			dataoutput.writeFloat(this.data);
-		}catch (IOException e){
-			e.printStackTrace();
-		}
-	}
+    private float data;
+
+    NBTTagFloat() {
+    }
+
+    public NBTTagFloat(float f) {
+        this.data = f;
+    }
+
+    @Override
+    public long asLong() {
+        return (long) this.data;
+    }
+
+    @Override
+    public NBTBase clone() {
+        return new NBTTagFloat(this.data);
+    }
+
+    @Override
+    public int asInt() {
+        return MathHelper.d(this.data);
+    }
+
+    @Override
+    public short asShort() {
+        return (short) (MathHelper.d(this.data) & '\uffff');
+    }
+
+    @Override
+    public boolean equals(Object object) {
+        if (super.equals(object)) {
+            NBTTagFloat nbttagfloat = (NBTTagFloat) object;
+
+            return this.data == nbttagfloat.data;
+        } else {
+            return false;
+        }
+    }
+
+    @Override
+    public byte asByte() {
+        return (byte) (MathHelper.d(this.data) & 255);
+    }
+
+    @Override
+    public double asDouble() {
+        return this.data;
+    }
+
+    @Override
+    public byte getTypeId() {
+        return (byte) 5;
+    }
+
+    @Override
+    public float asFloat() {
+        return this.data;
+    }
+
+    @Override
+    public int hashCode() {
+        return super.hashCode() ^ Float.floatToIntBits(this.data);
+    }
+
+    @Override
+    void load(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) {
+        nbtreadlimiter.readBytes(32L);
+        try {
+            this.data = datainput.readFloat();
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    @Override
+    public String toString() {
+        return "" + this.data + "f";
+    }
+
+    @Override
+    String toFormatedString(String in) {
+        return in + toString();
+    }
+
+    @Override
+    void write(DataOutput dataoutput) {
+        try {
+            dataoutput.writeFloat(this.data);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
 }
diff --git a/src/main/java/dev/wolveringer/nbt/NBTTagInt.java b/src/main/java/dev/wolveringer/nbt/NBTTagInt.java
index 55a243b..1281e66 100644
--- a/src/main/java/dev/wolveringer/nbt/NBTTagInt.java
+++ b/src/main/java/dev/wolveringer/nbt/NBTTagInt.java
@@ -6,97 +6,97 @@ import java.io.IOException;
 
 public class NBTTagInt extends NBTNumber {
 
-	private int data;
-
-	NBTTagInt() {
-	}
-
-	public NBTTagInt(int i) {
-		this.data = i;
-	}
-
-	@Override
-	public long asLong() {
-		return this.data;
-	}
-
-	@Override
-	public NBTBase clone() {
-		return new NBTTagInt(this.data);
-	}
-
-	@Override
-	public int asInt() {
-		return this.data;
-	}
-
-	@Override
-	public short asShort() {
-		return (short) (this.data & '\uffff');
-	}
-
-	@Override
-	public boolean equals(Object object) {
-		if(super.equals(object)){
-			NBTTagInt nbttagint = (NBTTagInt) object;
-
-			return this.data == nbttagint.data;
-		}else{
-			return false;
-		}
-	}
-
-	@Override
-	public byte asByte() {
-		return (byte) (this.data & 255);
-	}
-
-	@Override
-	public double asDouble() {
-		return this.data;
-	}
-
-	@Override
-	public byte getTypeId() {
-		return (byte) 3;
-	}
-
-	@Override
-	public float asFloat() {
-		return this.data;
-	}
-
-	@Override
-	public int hashCode() {
-		return super.hashCode() ^ this.data;
-	}
-
-	@Override
-	void load(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) {
-		nbtreadlimiter.readBytes(32L);
-		try{
-			this.data = datainput.readInt();
-		}catch (IOException e){
-			e.printStackTrace();
-		}
-	}
-
-	@Override
-	public String toString() {
-		return "" + this.data;
-	}
-
-	@Override
-	String toFormatedString(String in) {
-		return in+toString();
-	}
-	
-	@Override
-	void write(DataOutput dataoutput) {
-		try{
-			dataoutput.writeInt(this.data);
-		}catch (IOException e){
-			e.printStackTrace();
-		}
-	}
+    private int data;
+
+    NBTTagInt() {
+    }
+
+    public NBTTagInt(int i) {
+        this.data = i;
+    }
+
+    @Override
+    public long asLong() {
+        return this.data;
+    }
+
+    @Override
+    public NBTBase clone() {
+        return new NBTTagInt(this.data);
+    }
+
+    @Override
+    public int asInt() {
+        return this.data;
+    }
+
+    @Override
+    public short asShort() {
+        return (short) (this.data & '\uffff');
+    }
+
+    @Override
+    public boolean equals(Object object) {
+        if (super.equals(object)) {
+            NBTTagInt nbttagint = (NBTTagInt) object;
+
+            return this.data == nbttagint.data;
+        } else {
+            return false;
+        }
+    }
+
+    @Override
+    public byte asByte() {
+        return (byte) (this.data & 255);
+    }
+
+    @Override
+    public double asDouble() {
+        return this.data;
+    }
+
+    @Override
+    public byte getTypeId() {
+        return (byte) 3;
+    }
+
+    @Override
+    public float asFloat() {
+        return this.data;
+    }
+
+    @Override
+    public int hashCode() {
+        return super.hashCode() ^ this.data;
+    }
+
+    @Override
+    void load(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) {
+        nbtreadlimiter.readBytes(32L);
+        try {
+            this.data = datainput.readInt();
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    @Override
+    public String toString() {
+        return "" + this.data;
+    }
+
+    @Override
+    String toFormatedString(String in) {
+        return in + toString();
+    }
+
+    @Override
+    void write(DataOutput dataoutput) {
+        try {
+            dataoutput.writeInt(this.data);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
 }
diff --git a/src/main/java/dev/wolveringer/nbt/NBTTagIntArray.java b/src/main/java/dev/wolveringer/nbt/NBTTagIntArray.java
index 06cd901..fffcd81 100644
--- a/src/main/java/dev/wolveringer/nbt/NBTTagIntArray.java
+++ b/src/main/java/dev/wolveringer/nbt/NBTTagIntArray.java
@@ -7,106 +7,106 @@ import java.util.Arrays;
 
 public class NBTTagIntArray extends NBTBase {
 
-	private int[] data;
-
-	NBTTagIntArray() {
-	}
-
-	public NBTTagIntArray(int[] aint) {
-		this.data = aint;
-	}
-
-	public int[] getData() {
-		return this.data;
-	}
-
-	@Override
-	public NBTBase clone() {
-		int[] aint = new int[this.data.length];
-
-		System.arraycopy(this.data, 0, aint, 0, this.data.length);
-		return new NBTTagIntArray(aint);
-	}
-
-	@Override
-	public boolean equals(Object object) {
-		return super.equals(object) ? Arrays.equals(this.data, ((NBTTagIntArray) object).data) : false;
-	}
-
-	@Override
-	public byte getTypeId() {
-		return (byte) 11;
-	}
-
-	@Override
-	public int hashCode() {
-		return super.hashCode() ^ Arrays.hashCode(this.data);
-	}
-
-	@Override
-	void load(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) {
-		int byte_length = 0;
-		try{
-			byte_length = datainput.readInt();
-		}catch (IOException e){
-			e.printStackTrace();
-		}
-
-		nbtreadlimiter.readBytes(32 * byte_length);
-		this.data = new int[byte_length];
-
-		for(int k = 0;k < byte_length;++k){
-			try{
-				this.data[k] = datainput.readInt();
-			}catch (IOException e){
-				e.printStackTrace();
-			}
-		}
-	}
-
-	@Override
-	public String toString() {
-		String s = "[";
-		int[] aint = this.data;
-		int i = aint.length;
-
-		for(int j = 0;j < i;++j){
-			int k = aint[j];
-
-			s = s + k + ",";
-		}
-
-		return s + "]";
-	}
-
-	@Override
-	String toFormatedString(String in) {
-		String s = in + "[";
-		int[] aint = this.data;
-		int i = aint.length;
-
-		for(int j = 0;j < i;++j){
-			int k = aint[j];
-			s = s + ",\n" + in + k;
-		}
-
-		return s.replaceFirst(",", "") + "\n" + in + "]";
-	}
-
-	@Override
-	void write(DataOutput dataoutput) {
-		try{
-			dataoutput.writeInt(this.data.length);
-		}catch (IOException e){
-			e.printStackTrace();
-		}
-
-		for(int i = 0;i < this.data.length;++i){
-			try{
-				dataoutput.writeInt(this.data[i]);
-			}catch (IOException e){
-				e.printStackTrace();
-			}
-		}
-	}
+    private int[] data;
+
+    NBTTagIntArray() {
+    }
+
+    public NBTTagIntArray(int[] aint) {
+        this.data = aint;
+    }
+
+    public int[] getData() {
+        return this.data;
+    }
+
+    @Override
+    public NBTBase clone() {
+        int[] aint = new int[this.data.length];
+
+        System.arraycopy(this.data, 0, aint, 0, this.data.length);
+        return new NBTTagIntArray(aint);
+    }
+
+    @Override
+    public boolean equals(Object object) {
+        return super.equals(object) ? Arrays.equals(this.data, ((NBTTagIntArray) object).data) : false;
+    }
+
+    @Override
+    public byte getTypeId() {
+        return (byte) 11;
+    }
+
+    @Override
+    public int hashCode() {
+        return super.hashCode() ^ Arrays.hashCode(this.data);
+    }
+
+    @Override
+    void load(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) {
+        int byte_length = 0;
+        try {
+            byte_length = datainput.readInt();
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+
+        nbtreadlimiter.readBytes(32 * byte_length);
+        this.data = new int[byte_length];
+
+        for (int k = 0; k < byte_length; ++k) {
+            try {
+                this.data[k] = datainput.readInt();
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        }
+    }
+
+    @Override
+    public String toString() {
+        String s = "[";
+        int[] aint = this.data;
+        int i = aint.length;
+
+        for (int j = 0; j < i; ++j) {
+            int k = aint[j];
+
+            s = s + k + ",";
+        }
+
+        return s + "]";
+    }
+
+    @Override
+    String toFormatedString(String in) {
+        String s = in + "[";
+        int[] aint = this.data;
+        int i = aint.length;
+
+        for (int j = 0; j < i; ++j) {
+            int k = aint[j];
+            s = s + ",\n" + in + k;
+        }
+
+        return s.replaceFirst(",", "") + "\n" + in + "]";
+    }
+
+    @Override
+    void write(DataOutput dataoutput) {
+        try {
+            dataoutput.writeInt(this.data.length);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+
+        for (int i = 0; i < this.data.length; ++i) {
+            try {
+                dataoutput.writeInt(this.data[i]);
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        }
+    }
 }
diff --git a/src/main/java/dev/wolveringer/nbt/NBTTagList.java b/src/main/java/dev/wolveringer/nbt/NBTTagList.java
index f6d388e..b92f07e 100644
--- a/src/main/java/dev/wolveringer/nbt/NBTTagList.java
+++ b/src/main/java/dev/wolveringer/nbt/NBTTagList.java
@@ -6,172 +6,172 @@ import java.util.ArrayList;
 import java.util.List;
 
 public class NBTTagList extends NBTBase {
-	private List<NBTBase> list = new ArrayList<NBTBase>();
-	private byte type = 0;
-
-	void write(DataOutput paramDataOutput) throws Exception {
-		if(!this.list.isEmpty()){
-			this.type = ((NBTBase) this.list.get(0)).getTypeId();
-		}else{
-			this.type = 0;
-		}
-		paramDataOutput.writeByte(this.type);
-		paramDataOutput.writeInt(this.list.size());
-		for(int i = 0;i < this.list.size();i++){
-			((NBTBase) this.list.get(i)).write(paramDataOutput);
-		}
-	}
-
-	void load(DataInput paramDataInput, int paramInt, NBTReadLimiter paramNBTReadLimiter) throws Exception {
-		if(paramInt > 512){
-			throw new RuntimeException("Tried to read NBT tag with too high complexity, depth > 512");
-		}
-		paramNBTReadLimiter.readBytes(8L);
-		this.type = paramDataInput.readByte();
-		int i = paramDataInput.readInt();
-
-		this.list = new ArrayList<NBTBase>();
-		for(int j = 0;j < i;j++){
-			NBTBase localNBTBase = NBTBase.createTag(this.type);
-			localNBTBase.load(paramDataInput, paramInt + 1, paramNBTReadLimiter);
-			this.list.add(localNBTBase);
-		}
-	}
-
-	public byte getTypeId() {
-		return 9;
-	}
-
-	public String toString() {
-		String str = "[";
-		int i = 0;
-		for(NBTBase localNBTBase : this.list){
-			str = str + "" + i + ':' + localNBTBase + ',';
-			i++;
-		}
-		return str + "]";
-	}
-
-	@Override
-	String toFormatedString(String in) {
-		if(this.list.isEmpty())
-			return "[]";
-		String str = "[\n";
-		int i = 0;
-		for(NBTBase localNBTBase : this.list){
-			str = str + "\n" + in + format(i) + ": " + localNBTBase.toFormatedString("");
-			i++;
-		}
-		return str.replaceFirst("\n", "") + "\n" + in.substring(1) + "]";
-	}
-
-	public String format(int i) {
-		String out = i + "";
-		String x = (list.size()-1) + "";
-		while (x.length() > out.length()){
-			out = "0" + out;
-		}
-		return out;
-	}
-
-	public void add(NBTBase paramNBTBase) {
-		if(this.type == 0){
-			this.type = paramNBTBase.getTypeId();
-		}else if(this.type != paramNBTBase.getTypeId()){
-			System.err.println("WARNING: Adding mismatching tag types to tag list");
-			return;
-		}
-		this.list.add(paramNBTBase);
-	}
-
-	public NBTTagCompound get(int paramInt) {
-		if((paramInt < 0) || (paramInt >= this.list.size())){
-			return new NBTTagCompound();
-		}
-		NBTBase localNBTBase = (NBTBase) this.list.get(paramInt);
-		if(localNBTBase.getTypeId() == 10){
-			return (NBTTagCompound) localNBTBase;
-		}
-		return new NBTTagCompound();
-	}
-
-	public int[] getIntArray(int paramInt) {
-		if((paramInt < 0) || (paramInt >= this.list.size())){
-			return new int[0];
-		}
-		NBTBase localNBTBase = (NBTBase) this.list.get(paramInt);
-		if(localNBTBase.getTypeId() == 11){
-			return ((NBTTagIntArray) localNBTBase).getData();
-		}
-		return new int[0];
-	}
-
-	public double getDouble(int paramInt) {
-		if((paramInt < 0) || (paramInt >= this.list.size())){
-			return 0.0D;
-		}
-		NBTBase localNBTBase = (NBTBase) this.list.get(paramInt);
-		if(localNBTBase.getTypeId() == 6){
-			return ((NBTTagDouble) localNBTBase).asDouble();
-		}
-		return 0.0D;
-	}
-
-	public float getFloat(int paramInt) {
-		if((paramInt < 0) || (paramInt >= this.list.size())){
-			return 0.0F;
-		}
-		NBTBase localNBTBase = (NBTBase) this.list.get(paramInt);
-		if(localNBTBase.getTypeId() == 5){
-			return ((NBTTagFloat) localNBTBase).asFloat();
-		}
-		return 0.0F;
-	}
-
-	public String getString(int paramInt) {
-		if((paramInt < 0) || (paramInt >= this.list.size())){
-			return "";
-		}
-		NBTBase localNBTBase = (NBTBase) this.list.get(paramInt);
-		if(localNBTBase.getTypeId() == 8){
-			return localNBTBase.toString();
-		}
-		return localNBTBase.toString();
-	}
-
-	public int size() {
-		return this.list.size();
-	}
-
-	public List<NBTBase> asList() {
-		return list;
-	}
-
-	public NBTBase clone() {
-		NBTTagList localNBTTagList = new NBTTagList();
-		localNBTTagList.type = this.type;
-		for(NBTBase localNBTBase1 : this.list){
-			NBTBase localNBTBase2 = localNBTBase1.clone();
-			localNBTTagList.list.add(localNBTBase2);
-		}
-		return localNBTTagList;
-	}
-
-	public boolean equals(Object paramObject) {
-		if(super.equals(paramObject)){
-			NBTTagList localNBTTagList = (NBTTagList) paramObject;
-			if(this.type == localNBTTagList.type){
-				return this.list.equals(localNBTTagList.list);
-			}
-		}
-		return false;
-	}
-
-	public int hashCode() {
-		return super.hashCode() ^ this.list.hashCode();
-	}
-
-	public int getType() {
-		return this.type;
-	}
+    private List<NBTBase> list = new ArrayList<NBTBase>();
+    private byte type = 0;
+
+    void write(DataOutput paramDataOutput) throws Exception {
+        if (!this.list.isEmpty()) {
+            this.type = ((NBTBase) this.list.get(0)).getTypeId();
+        } else {
+            this.type = 0;
+        }
+        paramDataOutput.writeByte(this.type);
+        paramDataOutput.writeInt(this.list.size());
+        for (int i = 0; i < this.list.size(); i++) {
+            ((NBTBase) this.list.get(i)).write(paramDataOutput);
+        }
+    }
+
+    void load(DataInput paramDataInput, int paramInt, NBTReadLimiter paramNBTReadLimiter) throws Exception {
+        if (paramInt > 512) {
+            throw new RuntimeException("Tried to read NBT tag with too high complexity, depth > 512");
+        }
+        paramNBTReadLimiter.readBytes(8L);
+        this.type = paramDataInput.readByte();
+        int i = paramDataInput.readInt();
+
+        this.list = new ArrayList<NBTBase>();
+        for (int j = 0; j < i; j++) {
+            NBTBase localNBTBase = NBTBase.createTag(this.type);
+            localNBTBase.load(paramDataInput, paramInt + 1, paramNBTReadLimiter);
+            this.list.add(localNBTBase);
+        }
+    }
+
+    public byte getTypeId() {
+        return 9;
+    }
+
+    public String toString() {
+        String str = "[";
+        int i = 0;
+        for (NBTBase localNBTBase : this.list) {
+            str = str + "" + i + ':' + localNBTBase + ',';
+            i++;
+        }
+        return str + "]";
+    }
+
+    @Override
+    String toFormatedString(String in) {
+        if (this.list.isEmpty())
+            return "[]";
+        String str = "[\n";
+        int i = 0;
+        for (NBTBase localNBTBase : this.list) {
+            str = str + "\n" + in + format(i) + ": " + localNBTBase.toFormatedString("");
+            i++;
+        }
+        return str.replaceFirst("\n", "") + "\n" + in.substring(1) + "]";
+    }
+
+    public String format(int i) {
+        String out = i + "";
+        String x = (list.size() - 1) + "";
+        while (x.length() > out.length()) {
+            out = "0" + out;
+        }
+        return out;
+    }
+
+    public void add(NBTBase paramNBTBase) {
+        if (this.type == 0) {
+            this.type = paramNBTBase.getTypeId();
+        } else if (this.type != paramNBTBase.getTypeId()) {
+            System.err.println("WARNING: Adding mismatching tag types to tag list");
+            return;
+        }
+        this.list.add(paramNBTBase);
+    }
+
+    public NBTTagCompound get(int paramInt) {
+        if ((paramInt < 0) || (paramInt >= this.list.size())) {
+            return new NBTTagCompound();
+        }
+        NBTBase localNBTBase = (NBTBase) this.list.get(paramInt);
+        if (localNBTBase.getTypeId() == 10) {
+            return (NBTTagCompound) localNBTBase;
+        }
+        return new NBTTagCompound();
+    }
+
+    public int[] getIntArray(int paramInt) {
+        if ((paramInt < 0) || (paramInt >= this.list.size())) {
+            return new int[0];
+        }
+        NBTBase localNBTBase = (NBTBase) this.list.get(paramInt);
+        if (localNBTBase.getTypeId() == 11) {
+            return ((NBTTagIntArray) localNBTBase).getData();
+        }
+        return new int[0];
+    }
+
+    public double getDouble(int paramInt) {
+        if ((paramInt < 0) || (paramInt >= this.list.size())) {
+            return 0.0D;
+        }
+        NBTBase localNBTBase = (NBTBase) this.list.get(paramInt);
+        if (localNBTBase.getTypeId() == 6) {
+            return ((NBTTagDouble) localNBTBase).asDouble();
+        }
+        return 0.0D;
+    }
+
+    public float getFloat(int paramInt) {
+        if ((paramInt < 0) || (paramInt >= this.list.size())) {
+            return 0.0F;
+        }
+        NBTBase localNBTBase = (NBTBase) this.list.get(paramInt);
+        if (localNBTBase.getTypeId() == 5) {
+            return ((NBTTagFloat) localNBTBase).asFloat();
+        }
+        return 0.0F;
+    }
+
+    public String getString(int paramInt) {
+        if ((paramInt < 0) || (paramInt >= this.list.size())) {
+            return "";
+        }
+        NBTBase localNBTBase = (NBTBase) this.list.get(paramInt);
+        if (localNBTBase.getTypeId() == 8) {
+            return localNBTBase.toString();
+        }
+        return localNBTBase.toString();
+    }
+
+    public int size() {
+        return this.list.size();
+    }
+
+    public List<NBTBase> asList() {
+        return list;
+    }
+
+    public NBTBase clone() {
+        NBTTagList localNBTTagList = new NBTTagList();
+        localNBTTagList.type = this.type;
+        for (NBTBase localNBTBase1 : this.list) {
+            NBTBase localNBTBase2 = localNBTBase1.clone();
+            localNBTTagList.list.add(localNBTBase2);
+        }
+        return localNBTTagList;
+    }
+
+    public boolean equals(Object paramObject) {
+        if (super.equals(paramObject)) {
+            NBTTagList localNBTTagList = (NBTTagList) paramObject;
+            if (this.type == localNBTTagList.type) {
+                return this.list.equals(localNBTTagList.list);
+            }
+        }
+        return false;
+    }
+
+    public int hashCode() {
+        return super.hashCode() ^ this.list.hashCode();
+    }
+
+    public int getType() {
+        return this.type;
+    }
 }
diff --git a/src/main/java/dev/wolveringer/nbt/NBTTagLong.java b/src/main/java/dev/wolveringer/nbt/NBTTagLong.java
index d602ea8..9692132 100644
--- a/src/main/java/dev/wolveringer/nbt/NBTTagLong.java
+++ b/src/main/java/dev/wolveringer/nbt/NBTTagLong.java
@@ -6,96 +6,97 @@ import java.io.IOException;
 
 public class NBTTagLong extends NBTNumber {
 
-	private long data;
-
-	NBTTagLong() {
-	}
-
-	public NBTTagLong(long i) {
-		this.data = i;
-	}
-
-	@Override
-	public long asLong() {
-		return this.data;
-	}
-
-	@Override
-	public NBTBase clone() {
-		return new NBTTagLong(this.data);
-	}
-
-	@Override
-	public int asInt() {
-		return (int) (this.data & -1L);
-	}
-
-	@Override
-	public short asShort() {
-		return (short) (int) (this.data & 65535L);
-	}
-
-	@Override
-	public boolean equals(Object object) {
-		if(super.equals(object)){
-			NBTTagLong nbttaglong = (NBTTagLong) object;
-
-			return this.data == nbttaglong.data;
-		}else{
-			return false;
-		}
-	}
-
-	@Override
-	public byte asByte() {
-		return (byte) (int) (this.data & 255L);
-	}
-
-	@Override
-	public double asDouble() {
-		return this.data;
-	}
-
-	@Override
-	public byte getTypeId() {
-		return (byte) 4;
-	}
-
-	@Override
-	public float asFloat() {
-		return this.data;
-	}
-
-	@Override
-	public int hashCode() {
-		return super.hashCode() ^ (int) (this.data ^ this.data >>> 32);
-	}
-
-	@Override
-	void load(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) {
-		nbtreadlimiter.readBytes(64L);
-		try{
-			this.data = datainput.readLong();
-		}catch (IOException e){
-			e.printStackTrace();
-		}
-	}
-
-	@Override
-	public String toString() {
-		return "" + this.data + "L";
-	}
-	@Override
-	String toFormatedString(String in) {
-		return in+toString();
-	}
-
-	@Override
-	void write(DataOutput dataoutput) {
-		try{
-			dataoutput.writeLong(this.data);
-		}catch (IOException e){
-			e.printStackTrace();
-		}
-	}
+    private long data;
+
+    NBTTagLong() {
+    }
+
+    public NBTTagLong(long i) {
+        this.data = i;
+    }
+
+    @Override
+    public long asLong() {
+        return this.data;
+    }
+
+    @Override
+    public NBTBase clone() {
+        return new NBTTagLong(this.data);
+    }
+
+    @Override
+    public int asInt() {
+        return (int) (this.data & -1L);
+    }
+
+    @Override
+    public short asShort() {
+        return (short) (int) (this.data & 65535L);
+    }
+
+    @Override
+    public boolean equals(Object object) {
+        if (super.equals(object)) {
+            NBTTagLong nbttaglong = (NBTTagLong) object;
+
+            return this.data == nbttaglong.data;
+        } else {
+            return false;
+        }
+    }
+
+    @Override
+    public byte asByte() {
+        return (byte) (int) (this.data & 255L);
+    }
+
+    @Override
+    public double asDouble() {
+        return this.data;
+    }
+
+    @Override
+    public byte getTypeId() {
+        return (byte) 4;
+    }
+
+    @Override
+    public float asFloat() {
+        return this.data;
+    }
+
+    @Override
+    public int hashCode() {
+        return super.hashCode() ^ (int) (this.data ^ this.data >>> 32);
+    }
+
+    @Override
+    void load(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) {
+        nbtreadlimiter.readBytes(64L);
+        try {
+            this.data = datainput.readLong();
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    @Override
+    public String toString() {
+        return "" + this.data + "L";
+    }
+
+    @Override
+    String toFormatedString(String in) {
+        return in + toString();
+    }
+
+    @Override
+    void write(DataOutput dataoutput) {
+        try {
+            dataoutput.writeLong(this.data);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
 }
diff --git a/src/main/java/dev/wolveringer/nbt/NBTTagShort.java b/src/main/java/dev/wolveringer/nbt/NBTTagShort.java
index 6513d64..9eba68e 100644
--- a/src/main/java/dev/wolveringer/nbt/NBTTagShort.java
+++ b/src/main/java/dev/wolveringer/nbt/NBTTagShort.java
@@ -6,97 +6,97 @@ import java.io.IOException;
 
 public class NBTTagShort extends NBTNumber {
 
-	private short data;
-
-	public NBTTagShort() {
-	}
-
-	public NBTTagShort(short short1) {
-		this.data = short1;
-	}
-
-	@Override
-	public long asLong() {
-		return this.data;
-	}
-
-	@Override
-	public NBTBase clone() {
-		return new NBTTagShort(this.data);
-	}
-
-	@Override
-	public int asInt() {
-		return this.data;
-	}
-
-	@Override
-	public short asShort() {
-		return this.data;
-	}
-
-	@Override
-	public boolean equals(Object object) {
-		if(super.equals(object)){
-			NBTTagShort nbttagshort = (NBTTagShort) object;
-
-			return this.data == nbttagshort.data;
-		}else{
-			return false;
-		}
-	}
-
-	@Override
-	public byte asByte() {
-		return (byte) (this.data & 255);
-	}
-
-	@Override
-	public double asDouble() {
-		return this.data;
-	}
-
-	@Override
-	public byte getTypeId() {
-		return (byte) 2;
-	}
-
-	@Override
-	public float asFloat() {
-		return this.data;
-	}
-
-	@Override
-	public int hashCode() {
-		return super.hashCode() ^ this.data;
-	}
-
-	@Override
-	void load(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) {
-		nbtreadlimiter.readBytes(16L);
-		try{
-			this.data = datainput.readShort();
-		}catch (IOException e){
-			e.printStackTrace();
-		}
-	}
-
-	@Override
-	public String toString() {
-		return "" + this.data + "s";
-	}
-
-	@Override
-	String toFormatedString(String in) {
-		return in+toString();
-	}
-	
-	@Override
-	void write(DataOutput dataoutput) {
-		try{
-			dataoutput.writeShort(this.data);
-		}catch (IOException e){
-			e.printStackTrace();
-		}
-	}
+    private short data;
+
+    public NBTTagShort() {
+    }
+
+    public NBTTagShort(short short1) {
+        this.data = short1;
+    }
+
+    @Override
+    public long asLong() {
+        return this.data;
+    }
+
+    @Override
+    public NBTBase clone() {
+        return new NBTTagShort(this.data);
+    }
+
+    @Override
+    public int asInt() {
+        return this.data;
+    }
+
+    @Override
+    public short asShort() {
+        return this.data;
+    }
+
+    @Override
+    public boolean equals(Object object) {
+        if (super.equals(object)) {
+            NBTTagShort nbttagshort = (NBTTagShort) object;
+
+            return this.data == nbttagshort.data;
+        } else {
+            return false;
+        }
+    }
+
+    @Override
+    public byte asByte() {
+        return (byte) (this.data & 255);
+    }
+
+    @Override
+    public double asDouble() {
+        return this.data;
+    }
+
+    @Override
+    public byte getTypeId() {
+        return (byte) 2;
+    }
+
+    @Override
+    public float asFloat() {
+        return this.data;
+    }
+
+    @Override
+    public int hashCode() {
+        return super.hashCode() ^ this.data;
+    }
+
+    @Override
+    void load(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) {
+        nbtreadlimiter.readBytes(16L);
+        try {
+            this.data = datainput.readShort();
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    @Override
+    public String toString() {
+        return "" + this.data + "s";
+    }
+
+    @Override
+    String toFormatedString(String in) {
+        return in + toString();
+    }
+
+    @Override
+    void write(DataOutput dataoutput) {
+        try {
+            dataoutput.writeShort(this.data);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
 }
diff --git a/src/main/java/dev/wolveringer/nbt/NBTTagString.java b/src/main/java/dev/wolveringer/nbt/NBTTagString.java
index 5af560f..6b62a8f 100644
--- a/src/main/java/dev/wolveringer/nbt/NBTTagString.java
+++ b/src/main/java/dev/wolveringer/nbt/NBTTagString.java
@@ -1,91 +1,90 @@
 package dev.wolveringer.nbt;
 
+import com.google.common.base.Charsets;
+
 import java.io.DataInput;
 import java.io.DataOutput;
 import java.io.IOException;
-import java.nio.charset.Charset;
 import java.util.Arrays;
 
-import com.google.common.base.Charsets;
-
 public class NBTTagString extends NBTBase {
-	private byte[] final_data;
+    private byte[] final_data;
+
+    public NBTTagString() {
+        final_data = "".getBytes();
+    }
 
-	public NBTTagString() {
-		final_data = "".getBytes();
-	}
+    public NBTTagString(String string) {
+        if (string == null || string.length() == 0)
+            throw new IllegalArgumentException("Empty string not allowed"); //Todo remove?
+        final_data = string.getBytes(Charsets.UTF_8);
+    }
 
-	public NBTTagString(String string) {
-		if(string == null || string.length() == 0)
-			throw new IllegalArgumentException("Empty string not allowed"); //Todo remove?
-		final_data = string.getBytes(Charsets.UTF_8);
-	}
+    void write(DataOutput paramDataOutput) {
+        try {
+            paramDataOutput.writeShort(final_data.length);
+            paramDataOutput.write(final_data, 0, final_data.length);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
 
-	void write(DataOutput paramDataOutput) {
-		try{
-			paramDataOutput.writeShort(final_data.length);
-			paramDataOutput.write(final_data, 0, final_data.length);
-		}catch (IOException e){
-			e.printStackTrace();
-		}
-	}
+    void load(DataInput paramDataInput, int paramInt, NBTReadLimiter paramNBTReadLimiter) {
+        try {
+            this.final_data = new byte[paramDataInput.readUnsignedShort()];
+            paramDataInput.readFully(this.final_data);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+        paramNBTReadLimiter.readBytes(final_data.length + 2);
+    }
 
-	void load(DataInput paramDataInput, int paramInt, NBTReadLimiter paramNBTReadLimiter) {
-		try{
-			this.final_data = new byte[paramDataInput.readUnsignedShort()];
-			paramDataInput.readFully(this.final_data);
-		}catch (IOException e){
-			e.printStackTrace();
-		}
-		paramNBTReadLimiter.readBytes(final_data.length+2);
-	}
+    public byte getTypeId() {
+        return 8;
+    }
 
-	public byte getTypeId() {
-		return 8;
-	}
+    public String toString() {
+        return "\"" + charsetEncoding(this.final_data) + "\"";
+    }
 
-	public String toString() {
-		return "\"" + charsetEncoding(this.final_data) + "\"";
-	}
+    private String charsetEncoding(byte[] in) {
+        return new String(in, Charsets.UTF_8);
+    }
 
-	private String charsetEncoding(byte[] in) {
-		return new String(in, Charsets.UTF_8);
-	}
+    @Override
+    String toFormatedString(String in) {
+        return in + toString();
+    }
 
-	@Override
-	String toFormatedString(String in) {
-		return in + toString();
-	}
+    public NBTBase clone() {
+        NBTTagString string = new NBTTagString();
+        string.final_data = final_data;
+        return string;
+    }
 
-	public NBTBase clone() {
-		NBTTagString string =new NBTTagString();
-		string.final_data = final_data;
-		return string;
-	}
-	
-	@Override
-	public int hashCode() {
-		final int prime = 31;
-		int result = super.hashCode();
-		result = prime * result + Arrays.hashCode(this.final_data);
-		return result;
-	}
+    @Override
+    public int hashCode() {
+        final int prime = 31;
+        int result = super.hashCode();
+        result = prime * result + Arrays.hashCode(this.final_data);
+        return result;
+    }
 
-	@Override
-	public boolean equals(Object obj) {
-		if(this == obj)
-			return true;
-		if(!super.equals(obj))
-			return false;
-		if(getClass() != obj.getClass())
-			return false;
-		NBTTagString other = (NBTTagString) obj;
-		if(!Arrays.equals(this.final_data, other.final_data))
-			return false;
-		return true;
-	}
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj)
+            return true;
+        if (!super.equals(obj))
+            return false;
+        if (getClass() != obj.getClass())
+            return false;
+        NBTTagString other = (NBTTagString) obj;
+        if (!Arrays.equals(this.final_data, other.final_data))
+            return false;
+        return true;
+    }
 
-	public String getData() {
-		return this.charsetEncoding(final_data);
-	}
+    public String getData() {
+        return this.charsetEncoding(final_data);
+    }
 }
diff --git a/src/main/java/dev/wolveringer/network/Cleaner.java b/src/main/java/dev/wolveringer/network/Cleaner.java
index 6283881..461814a 100644
--- a/src/main/java/dev/wolveringer/network/Cleaner.java
+++ b/src/main/java/dev/wolveringer/network/Cleaner.java
@@ -4,13 +4,13 @@ import io.netty.buffer.ByteBuf;
 import io.netty.util.ReferenceCountUtil;
 
 public class Cleaner {
-	public static long cleaned_bytes = 0;
+    public static long cleaned_bytes = 0;
 
-	public static void destroyDirectByteBuffer(ByteBuf buf) {
-		try{
-			ReferenceCountUtil.release(buf);
-		}catch(Exception e){
-			System.out.print("Error: 101");
-		}
-	}
+    public static void destroyDirectByteBuffer(ByteBuf buf) {
+        try {
+            ReferenceCountUtil.release(buf);
+        } catch (Exception e) {
+            System.out.print("Error: 101");
+        }
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/network/Decoder.java b/src/main/java/dev/wolveringer/network/Decoder.java
index 3cbe584..503a2ae 100644
--- a/src/main/java/dev/wolveringer/network/Decoder.java
+++ b/src/main/java/dev/wolveringer/network/Decoder.java
@@ -1,19 +1,15 @@
 package dev.wolveringer.network;
 
-import io.netty.buffer.ByteBuf;
-import io.netty.channel.ChannelHandlerContext;
-import lombok.Getter;
-import lombok.Setter;
-
-import java.lang.reflect.Field;
-import java.util.List;
-
 import net.md_5.bungee.protocol.BadPacketException;
 import net.md_5.bungee.protocol.DefinedPacket;
 import net.md_5.bungee.protocol.MinecraftDecoder;
 import net.md_5.bungee.protocol.PacketWrapper;
 import net.md_5.bungee.protocol.Protocol;
 import net.md_5.bungee.protocol.ProtocolConstants.Direction;
+
+import java.lang.reflect.Field;
+import java.util.List;
+
 import dev.wolveringer.BungeeUtil.ClientVersion;
 import dev.wolveringer.BungeeUtil.PacketHandleEvent;
 import dev.wolveringer.BungeeUtil.PacketLib;
@@ -25,199 +21,202 @@ import dev.wolveringer.packet.ByteBuffCreator;
 import dev.wolveringer.packet.PacketHandle;
 import dev.wolveringer.profiler.Profiler;
 import dev.wolveringer.strings.Messages;
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelHandlerContext;
+import lombok.Getter;
+import lombok.Setter;
 
 public class Decoder extends MinecraftDecoder {
-	private static final Field field_protocol = getField(MinecraftDecoder.class, "protocol");
-	private static final Field field_protocolVersion = getField(MinecraftDecoder.class, "protocolVersion");
-	private static final Field field_server = getField(MinecraftDecoder.class, "server");
-
-	private static Field getField(Class<?> s, String field) {
-		try{
-			for(Field f : s.getDeclaredFields())
-				if(f.getName().equals(field)){
-					f.setAccessible(true);
-					return f;
-				}
-			for(Field f : s.getFields())
-				if(f.getName().equals(field)){
-					f.setAccessible(true);
-					return f;
-				}
-		}catch (Exception e){
-			e.printStackTrace();
-		}
-		return null;
-	}
-
-	@Getter
-	@Setter
-	private IInitialHandler initHandler;
-	private Protocol prot;
-	private int version;
-	private ClientVersion clientVersion = ClientVersion.UnderknownVersion;
-	private Direction dir;
-
-	public Decoder(Protocol protocol, boolean server, int protocolVersion, IInitialHandler i, Direction dir) {
-		super(protocol, server, protocolVersion);
-		this.dir = dir;
-		this.initHandler = i;
-		this.setProtocolVersion(protocolVersion);
-	}
-
-	public IInitialHandler getHandler() {
-		return initHandler;
-	}
-
-	public Protocol getProtocol() {
-		try{
-			return (Protocol) field_protocol.get(this);
-		}catch (Exception e){
-			e.printStackTrace();
-		}
-		return null;
-	}
-
-	public int getProtocolVersion() {
-		try{
-			return (int) field_protocolVersion.get(this);
-		}catch (Exception e){
-			e.printStackTrace();
-		}
-		return 0;
-	}
-
-	public boolean isServer() {
-		try{
-			return (boolean) field_server.get(this);
-		}catch (Exception e){
-			e.printStackTrace();
-		}
-		return false;
-	}
-
-	@Override
-	public void setProtocol(Protocol protocol) {
-		super.setProtocol(protocol);
-		this.prot = protocol;
-	}
-
-	@Override
-	public void setProtocolVersion(int protocolVersion) {
-		super.setProtocolVersion(protocolVersion);
-		this.version = protocolVersion;
-		this.clientVersion = ClientVersion.fromProtocoll(protocolVersion);
-	}
-
-	@SuppressWarnings({ "unchecked", "rawtypes" })
-	@Override
-	protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {
-		if(initHandler == null){
-			super.decode(ctx, in, out);
-			System.out.println("Skipping decode()");
-			return;
-		}
-		Profiler.decoder_timings.start(Messages.getString("network.timings.decoder.read")); //$NON-NLS-1$
-		try{
-			Packet packet = null;
-			try{
-				Profiler.decoder_timings.start(Messages.getString("network.timings.decoder.create.packet")); //$NON-NLS-1$
-				if(initHandler == null){
-					System.out.println("Connection == null");
-					return;
-				}
-				if(clientVersion == null){
-					System.out.println("Client version = null | Version id -> "+version);
-					initHandler.disconnect("\u00A7cYour client versions isnt supported!");
-					return;
-				}
-				packet = Packet.getPacket(clientVersion.getProtocollVersion() ,getProtocol(), dir, in, initHandler.getPlayer());
-				Profiler.decoder_timings.stop(Messages.getString("network.timings.decoder.create.packet")); //$NON-NLS-1$
-				if(packet == null){
-					Profiler.decoder_timings.stop(Messages.getString("network.timings.decoder.read")); //$NON-NLS-1$
-				}else{
-					Profiler.decoder_timings.start(Messages.getString("network.timings.decoder.handle"));
-					Profiler.decoder_timings.start(Messages.getString("network.timings.decoder.handle.intern")); //$NON-NLS-1$
-					PacketHandleEvent<? extends Packet> e = new PacketHandleEvent(packet, initHandler.getPlayer());
-					if(!PacketHandle.handlePacket(e)){
-						Profiler.decoder_timings.stop(Messages.getString("network.timings.decoder.handle.intern")); //$NON-NLS-1$
-						Profiler.decoder_timings.start(Messages.getString("network.timings.decoder.handle.extern")); //$NON-NLS-1$
-						PacketLib.handle(e);
-						Profiler.decoder_timings.stop(Messages.getString("network.timings.decoder.handle.extern")); //$NON-NLS-1$
-						if(!e.isCancelled()){
-							packet = e.getPacket();
-						}else{
-							Profiler.decoder_timings.stop(Messages.getString("network.timings.decoder.handle.intern")); //$NON-NLS-1$
-							Profiler.decoder_timings.stop(Messages.getString("network.timings.decoder.read")); //$NON-NLS-1$
-							return;
-						}
-					}else{
-						Profiler.decoder_timings.stop(Messages.getString("network.timings.decoder.handle.intern")); //$NON-NLS-1$
-						Profiler.decoder_timings.stop(Messages.getString("network.timings.decoder.read")); //$NON-NLS-1$
-						return;
-					}
-				}
-			}catch (Exception e){
-				if(e instanceof ClassNotFoundException){
-					e.printStackTrace();
-					System.err.println("Could not find class '"+e.getMessage()+"' in decode methode.");
-					if(e.getMessage().startsWith("dev.wolveringer.BungeeUtil") || e.getMessage().startsWith("dev.wolveringer.packet") || e.getMessage().startsWith("dev.wolveringer.network")){
-						System.err.println("");
-						System.err.println("");
-						System.err.println("-----------------------------------------------------------------------------------------------");
-						System.err.println("                      Missing inital class! Shuting down BungeeUtils!");
-						if(ChannelInizializer.getChannelInitializer() instanceof BungeeUtilChannelInit){
-							BungeeUtilChannelInit channelInit = (BungeeUtilChannelInit) ChannelInizializer.getChannelInitializer();
-							channelInit.throwClassNotFoundError((ClassNotFoundException) e);
-						}
-						System.err.println("-----------------------------------------------------------------------------------------------");
-					}
-				}
-				if(!initHandler.isConnected)
-					return;
-				switch (Configuration.getHandleExceptionAction()) {
-				case DISCONNECT:
-					initHandler.disconnect(e);
-				case PRINT:
-					e.printStackTrace();
-				default:
-					break;
-				}
-				return;
-			}
-	
-			Protocol.DirectionData prot = isServer() ? this.getProtocol().TO_SERVER : this.getProtocol().TO_CLIENT;
-			ByteBuf copy = packet == null ? in.copy() : packet.writeToByteBuff(ByteBuffCreator.createByteBuff(),ClientVersion.fromProtocoll(initHandler.getVersion()));
-			try{
-				int packetId = DefinedPacket.readVarInt(in);
-				DefinedPacket bungeePacket = null;
-				if((bungeePacket = prot.createPacket(packetId, getProtocolVersion())) != null){
-					bungeePacket.read(in, prot.getDirection(), getProtocolVersion());
-					if(in.readableBytes() != 0){
-						Profiler.decoder_timings.stop(Messages.getString("network.timings.decoder.read")); //$NON-NLS-1$
-						throw new BadPacketException("Did not read all bytes from packet " + bungeePacket.getClass() + " " + packetId + " Protocol " + this.getProtocolVersion() + " Direction " + prot+"! Left bytes: "+in.readableBytes());
-					}
-					//Main.sendMessage("Decode: " + bungeePacket);
-				}else{
-					in.skipBytes(in.readableBytes());
-				}
-	
-				out.add(new PacketWrapper(bungeePacket, copy));
-				copy = null;
-			}finally{
-				if(copy != null){
-					copy.release();
-				}
-				copy = null;
-			}
-			packet = null;
-		}catch(Exception e){
-			if(initHandler.isConnected)
-				e.printStackTrace();
-		}
-		Profiler.decoder_timings.stop(Messages.getString("network.timings.decoder.read")); //$NON-NLS-1$
-	}
-	
-	public static void main(String[] args) throws ClassNotFoundException {
-		Class.forName("xxx");
-	}
+    private static final Field field_protocol = getField(MinecraftDecoder.class, "protocol");
+    private static final Field field_protocolVersion = getField(MinecraftDecoder.class, "protocolVersion");
+    private static final Field field_server = getField(MinecraftDecoder.class, "server");
+    @Getter
+    @Setter
+    private IInitialHandler initHandler;
+    private Protocol prot;
+    private int version;
+    private ClientVersion clientVersion = ClientVersion.UnderknownVersion;
+    private Direction dir;
+
+    public Decoder(Protocol protocol, boolean server, int protocolVersion, IInitialHandler i, Direction dir) {
+        super(protocol, server, protocolVersion);
+        this.dir = dir;
+        this.initHandler = i;
+        this.setProtocolVersion(protocolVersion);
+    }
+
+    private static Field getField(Class<?> s, String field) {
+        try {
+            for (Field f : s.getDeclaredFields())
+                if (f.getName().equals(field)) {
+                    f.setAccessible(true);
+                    return f;
+                }
+            for (Field f : s.getFields())
+                if (f.getName().equals(field)) {
+                    f.setAccessible(true);
+                    return f;
+                }
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+        return null;
+    }
+
+    public static void main(String[] args) throws ClassNotFoundException {
+        Class.forName("xxx");
+    }
+
+    public IInitialHandler getHandler() {
+        return initHandler;
+    }
+
+    public Protocol getProtocol() {
+        try {
+            return (Protocol) field_protocol.get(this);
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+        return null;
+    }
+
+    @Override
+    public void setProtocol(Protocol protocol) {
+        super.setProtocol(protocol);
+        this.prot = protocol;
+    }
+
+    public int getProtocolVersion() {
+        try {
+            return (int) field_protocolVersion.get(this);
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+        return 0;
+    }
+
+    @Override
+    public void setProtocolVersion(int protocolVersion) {
+        super.setProtocolVersion(protocolVersion);
+        this.version = protocolVersion;
+        this.clientVersion = ClientVersion.fromProtocoll(protocolVersion);
+    }
+
+    public boolean isServer() {
+        try {
+            return (boolean) field_server.get(this);
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+        return false;
+    }
+
+    @SuppressWarnings({"unchecked", "rawtypes"})
+    @Override
+    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {
+        if (initHandler == null) {
+            super.decode(ctx, in, out);
+            System.out.println("Skipping decode()");
+            return;
+        }
+        Profiler.decoder_timings.start(Messages.getString("network.timings.decoder.read")); //$NON-NLS-1$
+        try {
+            Packet packet = null;
+            try {
+                Profiler.decoder_timings.start(Messages.getString("network.timings.decoder.create.packet")); //$NON-NLS-1$
+                if (initHandler == null) {
+                    System.out.println("Connection == null");
+                    return;
+                }
+                if (clientVersion == null) {
+                    System.out.println("Client version = null | Version id -> " + version);
+                    initHandler.disconnect("\u00A7cYour client versions isnt supported!");
+                    return;
+                }
+                packet = Packet.getPacket(clientVersion.getProtocollVersion(), getProtocol(), dir, in, initHandler.getPlayer());
+                Profiler.decoder_timings.stop(Messages.getString("network.timings.decoder.create.packet")); //$NON-NLS-1$
+                if (packet == null) {
+                    Profiler.decoder_timings.stop(Messages.getString("network.timings.decoder.read")); //$NON-NLS-1$
+                } else {
+                    Profiler.decoder_timings.start(Messages.getString("network.timings.decoder.handle"));
+                    Profiler.decoder_timings.start(Messages.getString("network.timings.decoder.handle.intern")); //$NON-NLS-1$
+                    PacketHandleEvent<? extends Packet> e = new PacketHandleEvent(packet, initHandler.getPlayer());
+                    if (!PacketHandle.handlePacket(e)) {
+                        Profiler.decoder_timings.stop(Messages.getString("network.timings.decoder.handle.intern")); //$NON-NLS-1$
+                        Profiler.decoder_timings.start(Messages.getString("network.timings.decoder.handle.extern")); //$NON-NLS-1$
+                        PacketLib.handle(e);
+                        Profiler.decoder_timings.stop(Messages.getString("network.timings.decoder.handle.extern")); //$NON-NLS-1$
+                        if (!e.isCancelled()) {
+                            packet = e.getPacket();
+                        } else {
+                            Profiler.decoder_timings.stop(Messages.getString("network.timings.decoder.handle.intern")); //$NON-NLS-1$
+                            Profiler.decoder_timings.stop(Messages.getString("network.timings.decoder.read")); //$NON-NLS-1$
+                            return;
+                        }
+                    } else {
+                        Profiler.decoder_timings.stop(Messages.getString("network.timings.decoder.handle.intern")); //$NON-NLS-1$
+                        Profiler.decoder_timings.stop(Messages.getString("network.timings.decoder.read")); //$NON-NLS-1$
+                        return;
+                    }
+                }
+            } catch (Exception e) {
+                if (e instanceof ClassNotFoundException) {
+                    e.printStackTrace();
+                    System.err.println("Could not find class '" + e.getMessage() + "' in decode methode.");
+                    if (e.getMessage().startsWith("dev.wolveringer.BungeeUtil") || e.getMessage().startsWith("dev.wolveringer.packet") || e.getMessage().startsWith("dev.wolveringer.network")) {
+                        System.err.println("");
+                        System.err.println("");
+                        System.err.println("-----------------------------------------------------------------------------------------------");
+                        System.err.println("                      Missing inital class! Shuting down BungeeUtils!");
+                        if (ChannelInizializer.getChannelInitializer() instanceof BungeeUtilChannelInit) {
+                            BungeeUtilChannelInit channelInit = (BungeeUtilChannelInit) ChannelInizializer.getChannelInitializer();
+                            channelInit.throwClassNotFoundError((ClassNotFoundException) e);
+                        }
+                        System.err.println("-----------------------------------------------------------------------------------------------");
+                    }
+                }
+                if (!initHandler.isConnected)
+                    return;
+                switch (Configuration.getHandleExceptionAction()) {
+                    case DISCONNECT:
+                        initHandler.disconnect(e);
+                    case PRINT:
+                        e.printStackTrace();
+                    default:
+                        break;
+                }
+                return;
+            }
+
+            Protocol.DirectionData prot = isServer() ? this.getProtocol().TO_SERVER : this.getProtocol().TO_CLIENT;
+            ByteBuf copy = packet == null ? in.copy() : packet.writeToByteBuff(ByteBuffCreator.createByteBuff(), ClientVersion.fromProtocoll(initHandler.getVersion()));
+            try {
+                int packetId = DefinedPacket.readVarInt(in);
+                DefinedPacket bungeePacket = null;
+                if ((bungeePacket = prot.createPacket(packetId, getProtocolVersion())) != null) {
+                    bungeePacket.read(in, prot.getDirection(), getProtocolVersion());
+                    if (in.readableBytes() != 0) {
+                        Profiler.decoder_timings.stop(Messages.getString("network.timings.decoder.read")); //$NON-NLS-1$
+                        throw new BadPacketException("Did not read all bytes from packet " + bungeePacket.getClass() + " " + packetId + " Protocol " + this.getProtocolVersion() + " Direction " + prot + "! Left bytes: " + in.readableBytes());
+                    }
+                    //Main.sendMessage("Decode: " + bungeePacket);
+                } else {
+                    in.skipBytes(in.readableBytes());
+                }
+
+                out.add(new PacketWrapper(bungeePacket, copy));
+                copy = null;
+            } finally {
+                if (copy != null) {
+                    copy.release();
+                }
+                copy = null;
+            }
+            packet = null;
+        } catch (Exception e) {
+            if (initHandler.isConnected)
+                e.printStackTrace();
+        }
+        Profiler.decoder_timings.stop(Messages.getString("network.timings.decoder.read")); //$NON-NLS-1$
+    }
 }
diff --git a/src/main/java/dev/wolveringer/network/Encoder.java b/src/main/java/dev/wolveringer/network/Encoder.java
index f0c18f7..450c568 100644
--- a/src/main/java/dev/wolveringer/network/Encoder.java
+++ b/src/main/java/dev/wolveringer/network/Encoder.java
@@ -1,15 +1,11 @@
 package dev.wolveringer.network;
 
-import io.netty.buffer.ByteBuf;
-import io.netty.buffer.Unpooled;
-import io.netty.channel.ChannelHandlerContext;
-import lombok.Getter;
-import lombok.Setter;
 import net.md_5.bungee.protocol.DefinedPacket;
 import net.md_5.bungee.protocol.MinecraftEncoder;
 import net.md_5.bungee.protocol.Protocol;
 import net.md_5.bungee.protocol.ProtocolConstants.Direction;
 import net.md_5.bungee.protocol.packet.LoginSuccess;
+
 import dev.wolveringer.BungeeUtil.ClientVersion;
 import dev.wolveringer.BungeeUtil.PacketHandleEvent;
 import dev.wolveringer.BungeeUtil.PacketLib;
@@ -18,77 +14,81 @@ import dev.wolveringer.packet.ByteBuffCreator;
 import dev.wolveringer.packet.PacketHandle;
 import dev.wolveringer.profiler.Profiler;
 import dev.wolveringer.strings.Messages;
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import io.netty.channel.ChannelHandlerContext;
+import lombok.Getter;
+import lombok.Setter;
 
 public class Encoder extends MinecraftEncoder {
 
-	@Getter
-	@Setter
-	private IInitialHandler initHandler;
-	@Getter
-	private Protocol protocoll = Protocol.HANDSHAKE;
-	@Getter
-	private int version;
-	@Getter
-	private ClientVersion clientVersion = ClientVersion.UnderknownVersion;
-	@Getter
-	private	boolean server;
+    @Getter
+    @Setter
+    private IInitialHandler initHandler;
+    @Getter
+    private Protocol protocoll = Protocol.HANDSHAKE;
+    @Getter
+    private int version;
+    @Getter
+    private ClientVersion clientVersion = ClientVersion.UnderknownVersion;
+    @Getter
+    private boolean server;
+
+    public Encoder(Protocol protocol, boolean server, int protocolVersion, IInitialHandler i) {
+        super(protocol, server, protocolVersion);
+        this.initHandler = i;
+        this.server = server;
+        this.clientVersion = ClientVersion.fromProtocoll(protocolVersion);
+    }
+
+    @Override
+    protected void encode(ChannelHandlerContext ctx, DefinedPacket msg, ByteBuf out) throws Exception {
+        Profiler.encoder_timings.start(Messages.getString("network.timings.encoder.handle"));
+        if (msg instanceof LoginSuccess)
+            initHandler.isConnected = true;
+        ByteBuf in;
+        super.encode(ctx, msg, in = Unpooled.buffer());
+
+        Profiler.encoder_timings.start(Messages.getString("network.timings.encoder.create.packet"));
+        Packet packet = Packet.getPacket(clientVersion.getProtocollVersion(), protocoll, Direction.TO_CLIENT, in, initHandler.getPlayer());
+        Profiler.encoder_timings.stop(Messages.getString("network.timings.encoder.create.packet"));
+        if (packet == null) {
+            ByteBuffCreator.copy(in, out);
+            in.release();
+            return;
+        }
+        in.release();
+        PacketHandleEvent e = new PacketHandleEvent(packet, initHandler.getPlayer());
+        Profiler.encoder_timings.start(Messages.getString("network.timings.encoder.handle.intern"));
+        boolean intern = PacketHandle.handlePacket(e);
+        Profiler.encoder_timings.stop(Messages.getString("network.timings.encoder.handle.intern"));
+        if (!intern) {
+            Profiler.encoder_timings.start(Messages.getString("network.timings.encoder.handle.extern"));
+            PacketLib.handle(e);
+            Profiler.encoder_timings.stop(Messages.getString("network.timings.encoder.handle.extern"));
+            if (!e.isCancelled()) {
+                Profiler.encoder_timings.start(Messages.getString("network.timings.encoder.write.writeNewbyteBuff"));
+
+                e.getPacket().writeToByteBuff(out, ClientVersion.fromProtocoll(initHandler.getVersion())); //write direct to out
+                //ByteBuffCreator.copy(buf, out);
+                //buf.release();
 
-	public Encoder(Protocol protocol, boolean server, int protocolVersion, IInitialHandler i) {
-		super(protocol, server, protocolVersion);
-		this.initHandler = i;
-		this.server = server;
-		this.clientVersion = ClientVersion.fromProtocoll(protocolVersion);
-	}
-	@Override
-	protected void encode(ChannelHandlerContext ctx, DefinedPacket msg, ByteBuf out) throws Exception {
-		Profiler.encoder_timings.start(Messages.getString("network.timings.encoder.handle"));
-		if(msg instanceof LoginSuccess)
-			initHandler.isConnected = true;
-		ByteBuf in;
-		super.encode(ctx, msg, in = Unpooled.buffer());
+                Profiler.encoder_timings.stop(Messages.getString("network.timings.encoder.write.writeNewbyteBuff"));
+            } else {
 
-		Profiler.encoder_timings.start(Messages.getString("network.timings.encoder.create.packet"));
-		Packet packet = Packet.getPacket(clientVersion.getProtocollVersion(),protocoll, Direction.TO_CLIENT, in, initHandler.getPlayer());
-		Profiler.encoder_timings.stop(Messages.getString("network.timings.encoder.create.packet"));
-		if(packet == null){
-			ByteBuffCreator.copy(in, out);
-			in.release();
-			return;
-		}
-		in.release();
-		PacketHandleEvent e = new PacketHandleEvent(packet, initHandler.getPlayer());
-		Profiler.encoder_timings.start(Messages.getString("network.timings.encoder.handle.intern"));
-		boolean intern = PacketHandle.handlePacket(e);
-		Profiler.encoder_timings.stop(Messages.getString("network.timings.encoder.handle.intern"));
-		if(!intern){
-			Profiler.encoder_timings.start(Messages.getString("network.timings.encoder.handle.extern"));
-			PacketLib.handle(e);
-			Profiler.encoder_timings.stop(Messages.getString("network.timings.encoder.handle.extern"));
-			if(!e.isCancelled()){
-				Profiler.encoder_timings.start(Messages.getString("network.timings.encoder.write.writeNewbyteBuff"));
+            }
+        }
+        Profiler.encoder_timings.stop(Messages.getString("network.timings.encoder.handle"));
+    }
 
-				e.getPacket().writeToByteBuff(out,ClientVersion.fromProtocoll(initHandler.getVersion())); //write direct to out
-				//ByteBuffCreator.copy(buf, out);
-				//buf.release();
-				
-				Profiler.encoder_timings.stop(Messages.getString("network.timings.encoder.write.writeNewbyteBuff"));
-			}
-			else
-			{
-				
-			}
-		}
-		Profiler.encoder_timings.stop(Messages.getString("network.timings.encoder.handle"));
-	}
-	
-	public void setProtocol(Protocol protocol) {
-		super.setProtocol(protocol);
-		this.protocoll = protocol;
-	}
+    public void setProtocol(Protocol protocol) {
+        super.setProtocol(protocol);
+        this.protocoll = protocol;
+    }
 
-	public void setProtocolVersion(int protocol) {
-		super.setProtocolVersion(protocol);
-		this.version = protocol;
-		this.clientVersion = ClientVersion.fromProtocoll(protocol);
-	}
+    public void setProtocolVersion(int protocol) {
+        super.setProtocolVersion(protocol);
+        this.version = protocol;
+        this.clientVersion = ClientVersion.fromProtocoll(protocol);
+    }
 }
diff --git a/src/main/java/dev/wolveringer/network/IIInitialHandler.java b/src/main/java/dev/wolveringer/network/IIInitialHandler.java
index da3eb23..bfd5243 100644
--- a/src/main/java/dev/wolveringer/network/IIInitialHandler.java
+++ b/src/main/java/dev/wolveringer/network/IIInitialHandler.java
@@ -1,25 +1,9 @@
 package dev.wolveringer.network;
 
-import java.io.File;
-import java.lang.reflect.Field;
-import java.lang.reflect.InvocationTargetException;
-import java.math.BigInteger;
-import java.net.URL;
-import java.net.URLClassLoader;
-import java.net.URLEncoder;
-import java.security.MessageDigest;
-import java.util.Enumeration;
-import java.util.UUID;
-import java.util.jar.JarEntry;
-import java.util.jar.JarFile;
-import java.util.logging.Level;
-
 import javassist.ClassClassPath;
 import javassist.ClassPool;
 import javassist.CtClass;
 
-import javax.crypto.SecretKey;
-
 import net.md_5.bungee.BungeeCord;
 import net.md_5.bungee.EncryptionUtil;
 import net.md_5.bungee.UserConnection;
@@ -48,332 +32,350 @@ import net.md_5.bungee.protocol.packet.EncryptionRequest;
 import net.md_5.bungee.protocol.packet.EncryptionResponse;
 import net.md_5.bungee.protocol.packet.LoginRequest;
 import net.md_5.bungee.protocol.packet.LoginSuccess;
+
+import java.io.File;
+import java.lang.reflect.Field;
+import java.lang.reflect.InvocationTargetException;
+import java.math.BigInteger;
+import java.net.URL;
+import java.net.URLClassLoader;
+import java.net.URLEncoder;
+import java.security.MessageDigest;
+import java.util.Enumeration;
+import java.util.UUID;
+import java.util.jar.JarEntry;
+import java.util.jar.JarFile;
+import java.util.logging.Level;
+
+import javax.crypto.SecretKey;
+
 import dev.wolveringer.BungeeUtil.BungeeUtil;
 import dev.wolveringer.BungeeUtil.ClientVersion;
 import dev.wolveringer.BungeeUtil.Main;
 import dev.wolveringer.BungeeUtil.Player;
 
 public class IIInitialHandler extends IInitialHandler {
-	private static int redifned_count = 0;
-	private static ClassPool pool;
-	static Class<?> base_class_connection;
-	static Class<?> class_connection;
-	private UserConnection conn;
-
-	public static ClassPool pool() {
-		if(pool != null)
-			return pool;
-		try{
-			pool = ClassPool.getDefault();
-			loadClassesFromJar(Main.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath()); //Load BungeeUtil in the system
-		}catch (Exception e){
-			e.printStackTrace();
-		}
-		return pool;
-	}
-	public static ClassLoader getClassLoader(){
-		return IIInitialHandler.class.getClassLoader();
-	}
-
-	public static void addPlugin(Plugin plugin) {
-		try{
-			loadClassesFromJar(plugin.getClass().getProtectionDomain().getCodeSource().getLocation().toURI().getPath());
-		}catch (Exception e){
-			e.printStackTrace();
-		}
-	}
-
-	@SuppressWarnings("resource")
-	private static void loadClassesFromJar(String path) {
-		if(pool == null)
-			throw new NullPointerException("Class Pool is null!");
-		if(new File(path).isDirectory())
-			return;
-		try{
-			JarFile jarFile = new JarFile(path);
-			Enumeration<JarEntry> e = jarFile.entries();
-
-			URL[] urls = { new URL("jar:file:" + path + "!/") };
-			URLClassLoader cl = URLClassLoader.newInstance(urls, IIInitialHandler.class.getClassLoader());
-			while (e.hasMoreElements()){
-				JarEntry je = e.nextElement();
-				if(je.isDirectory() || !je.getName().endsWith(".class")){ //isnt a class file
-					continue;
-				}
-				String className = je.getName().substring(0, je.getName().length() - 6);
-				className = className.replace('/', '.');
-				if(!className.startsWith("com.ea"))
-				pool.insertClassPath(new ClassClassPath(cl.loadClass(className)));
-			}
-		}catch (Exception e){
-			e.printStackTrace();
-		}
-	}
-
-	public static void init(Class<?> base) {
-		if(base == ProxiedPlayerUserConnection.class){
-			try{
-				ClassPool cp = pool();
-				cp.appendClassPath(new ClassClassPath(base));
-				CtClass clazz = cp.get(base.getName());
-				clazz.setName("ProxiedPlayerUserConnectionRedefined" + (redifned_count == 0 ? "" : redifned_count));
-				clazz.setSuperclass(cp.get(UserConnection.class.getName()));
-				base_class_connection = class_connection = clazz.toClass(getClassLoader());
-				BungeeUtil.getInstance().sendMessage("\u00A7aInit Base class");
-				redifned_count++;
-			}catch (Exception e){
-				e.printStackTrace();
-			}
-		}else{
-			if(base_class_connection == null)
-				throw new NullPointerException("Base class isn't init");
-			if(!ProxiedPlayerUserConnection.class.isAssignableFrom(base))
-				throw new RuntimeException("Class ("+base.getCanonicalName()+") isnt an instance of ProxiedPlayerUserConnection");
-			try{
-				ClassPool cp = pool();
-				cp.appendClassPath(new ClassClassPath(base));
-				CtClass clazz = cp.get(base.getName());
-				CtClass super_class = cp.getCtClass(base_class_connection.getName()); //Get last redefined class
-				if(super_class == null || super_class.getName() == null)
-					throw new NullPointerException("Base class not found.");
-				clazz.setSuperclass(super_class);
-				clazz.setName("ProxiedPlayerUserConnectionRedefined_" + (redifned_count == 0 ? "" : redifned_count));
-				class_connection = clazz.toClass(getClassLoader()); //Create the class
-				BungeeUtil.getInstance().sendMessage("\u00A7aInit extra class " + class_connection.getSuperclass());
-				redifned_count++;
-			}catch (Exception e){
-				e.printStackTrace();
-			}
-		}
-	}
-	
-	public IIInitialHandler(ProxyServer instance, ListenerInfo listenerInfo, Decoder a, Encoder b) {
-		super(instance, listenerInfo, a, b);
-	}
-
-	@SuppressWarnings({ "unchecked", "rawtypes", "deprecation" })
-	protected void finish() {
-		if(isOnlineMode()){
-			ProxiedPlayer oldName = ProxyServer.getInstance().getPlayer(getName());
-			if(oldName != null)
-				oldName.disconnect(ProxyServer.getInstance().getTranslation("already_connected", new Object[0]));
-			ProxiedPlayer oldID = ProxyServer.getInstance().getPlayer(getUniqueId());
-			if(oldID != null)
-				oldID.disconnect(ProxyServer.getInstance().getTranslation("already_connected", new Object[0]));
-		}else{
-			ProxiedPlayer oldName = ProxyServer.getInstance().getPlayer(getName());
-			if(oldName != null){
-				disconnect(ProxyServer.getInstance().getTranslation("already_connected", new Object[0]));
-				return;
-			}
-		}
-		set("offlineId", UUID.nameUUIDFromBytes(("OfflinePlayer:" + getName()).getBytes(com.google.common.base.Charsets.UTF_8)));
-		if((UUID) get("uniqueId") == null){
-			set("uniqueId", (UUID) get("offlineId"));
-		}
-
-		Callback<LoginEvent> complete = new Callback() {
-			public void done(LoginEvent result, Throwable error) {
-				if(result.isCancelled()){
-					IIInitialHandler.this.disconnect(result.getCancelReason());
-					return;
-				}
-				if(getChannel().isClosed()){
-					return;
-				}
-
-				getChannel().getHandle().eventLoop().execute(new Runnable() {
-					public void run() {
-						if(getChannel().getHandle().isActive()){
-							UserConnection userCon;
-							try{
-								userCon = (UserConnection) class_connection.getConstructor(ProxyServer.class, ChannelWrapper.class, String.class, InitialHandler.class).newInstance(BungeeCord.getInstance(), IIInitialHandler.this.getChannel(), IIInitialHandler.this.getName(), IIInitialHandler.this);
-							}catch (InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException | NoSuchMethodException | SecurityException ex){
-								ex.printStackTrace();
-								throw new RuntimeException();
-							}
-							userCon.setCompressionThreshold(BungeeCord.getInstance().config.getCompressionThreshold());
-							userCon.init();
-							conn = userCon;
-							if(IIInitialHandler.this.getVersion() >= 5){
-								IIInitialHandler.this.unsafe().sendPacket(new LoginSuccess(IIInitialHandler.this.getUniqueId().toString(), IIInitialHandler.this.getName()));
-							}else{
-								IIInitialHandler.this.unsafe().sendPacket(new LoginSuccess(IIInitialHandler.this.getUUID(), IIInitialHandler.this.getName()));
-							}
-							getChannel().setProtocol(net.md_5.bungee.protocol.Protocol.GAME);
-							
-							ProxyServer.getInstance().getPluginManager().callEvent(new PostLoginEvent(userCon));
-							((HandlerBoss) getChannel().getHandle().pipeline().get(HandlerBoss.class)).setHandler(new UpstreamBridge(ProxyServer.getInstance(), userCon));
-							ServerInfo server;
-							if(ProxyServer.getInstance().getReconnectHandler() != null){
-								server = ProxyServer.getInstance().getReconnectHandler().getServer(userCon);
-							}else{
-								server = net.md_5.bungee.api.AbstractReconnectHandler.getForcedHost(IIInitialHandler.this);
-							}
-							if(server == null){
-								server = ProxyServer.getInstance().getServerInfo(((ListenerInfo) get("listener")).getDefaultServer());
-							}
-
-							userCon.connect(server, null, true);
-						}
-
-					}
-
-				});
-			}
-
-			@Override
-			public void done(Object o, Throwable t) {
-				if(o instanceof LoginEvent)
-					done((LoginEvent) o, t);
-			}
-		};
-		ProxyServer.getInstance().getPluginManager().callEvent(new LoginEvent(this, complete));
-	}
-
-	@SuppressWarnings({ "unchecked", "rawtypes" })
-	public void handle(LoginRequest loginRequest) throws Exception {
-		set("loginRequest", loginRequest);
-		ClientVersion version = ClientVersion.fromProtocoll(getHandshake().getProtocolVersion());
-		if(version == null || !version.getProtocollVersion().isSupported()){
-			//disconnect(ProxyServer.getInstance().getTranslation("outdated_server", new Object[0]));
-			disconnect("\u00A7cBungeeUtil cant handle your client version.");
-			return;
-		}
-
-		if(getName().contains(".")){
-			disconnect(ProxyServer.getInstance().getTranslation("name_invalid", new Object[] { getName() }));
-			return;
-		}
-
-		if(getName().length() > 16){
-			disconnect(ProxyServer.getInstance().getTranslation("name_too_long", new Object[] { getName() }));
-			return;
-		}
-
-		int limit = BungeeCord.getInstance().config.getPlayerLimit();
-		if((limit > 0) && (ProxyServer.getInstance().getOnlineCount() > limit)){
-			disconnect(ProxyServer.getInstance().getTranslation("proxy_full", new Object[0]));
-			return;
-		}
-
-		if((!isOnlineMode()) && (ProxyServer.getInstance().getPlayer(getUniqueId()) != null)){
-			disconnect(ProxyServer.getInstance().getTranslation("already_connected", new Object[0]));
-			return;
-		}
-		
-		setProtocol(Protocol.LOGIN);
-		Callback<PreLoginEvent> callback = new Callback() {
-			@Override
-			public void done(Object paramV, Throwable paramThrowable) {
-				if(paramV instanceof PreLoginEvent)
-					done((PreLoginEvent) paramV, paramThrowable);
-			}
-
-			public void done(PreLoginEvent result, Throwable error) {
-
-				if(result.isCancelled()){
-					IIInitialHandler.this.disconnect(result.getCancelReason());
-					return;
-				}
-				if(getChannel().isClosed()){
-					return;
-				}
-				if(isOnlineMode() == true){
-					set("request", EncryptionUtil.encryptRequest());
-					IIInitialHandler.this.unsafe().sendPacket((DefinedPacket) get("request"));
-				}else{
-					IIInitialHandler.this.finish();
-				}
-			}
-
-		};
-		ProxyServer.getInstance().getPluginManager().callEvent(new PreLoginEvent(this, callback));
-	}
-
-	@SuppressWarnings({ "rawtypes", "unchecked" })
-	public void handle(EncryptionResponse encryptResponse) throws Exception {
-		SecretKey sharedKey = EncryptionUtil.getSecret(encryptResponse, (EncryptionRequest) get("request"));
-		BungeeCipher decrypt = EncryptionUtil.getCipher(false, sharedKey);
-		((ChannelWrapper) get("ch")).addBefore("frame-decoder", "decrypt", new CipherDecoder(decrypt));
-		BungeeCipher encrypt = EncryptionUtil.getCipher(true, sharedKey);
-		((ChannelWrapper) get("ch")).addBefore("frame-prepender", "encrypt", new CipherEncoder(encrypt));
-
-		String encName = URLEncoder.encode(getName(), "UTF-8");
-
-		MessageDigest sha = MessageDigest.getInstance("SHA-1");
-		for(byte[] bit : new byte[][] { (((EncryptionRequest) get("request"))).getServerId().getBytes("ISO_8859_1"), sharedKey.getEncoded(), EncryptionUtil.keys.getPublic().getEncoded() })
-
-		{
-			sha.update(bit);
-		}
-		String encodedHash = URLEncoder.encode(new BigInteger(sha.digest()).toString(16), "UTF-8");
-
-		String authURL = new StringBuilder().append("https://sessionserver.mojang.com/session/minecraft/hasJoined?username=").append(encName).append("&serverId=").append(encodedHash).toString();
-
-		Callback handler = new Callback<String>() {
-			public void done(String result, Throwable error) {
-				if(error == null){
-					LoginResult obj = (LoginResult) BungeeCord.getInstance().gson.fromJson(result, LoginResult.class);
-					if(obj != null){
-						try{
-							set("uniqueId", (UUID) Util.getUUID(obj.getId()));
-							set("loginProfile", obj);
-						}catch(Exception e){
-							e.printStackTrace();
-						}
-						finish();
-						return;
-					}
-					IIInitialHandler.this.disconnect("Not authenticated with Minecraft.net");
-				}else{
-					IIInitialHandler.this.disconnect(BungeeCord.getInstance().getTranslation("mojang_fail", new Object[0]));
-					BungeeCord.getInstance().getLogger().log(Level.SEVERE, "Error authenticating " + IIInitialHandler.this.getName() + " with minecraft.net", error);
-
-				}
-			}
-		};
-		HttpClient.get(authURL, ((ChannelWrapper) get("ch")).getHandle().eventLoop(), handler);
-	}
-	
-	@Override
-	public void exception(Throwable t) throws Exception {
-		super.exception(t);
-	}
-
-	@Override
-	public Player getPlayer() {
-		return (Player) ((ProxiedPlayer) conn);
-	}
-
-	protected void set(String a, Object b) {
-		Field f = null;
-		try{
-			f = InitialHandler.class.getDeclaredField(a);
-		}catch (NoSuchFieldException | SecurityException e){
-			e.printStackTrace();
-		}
-		f.setAccessible(true);
-		try{
-			f.set(this, b);
-		}catch (IllegalArgumentException | IllegalAccessException e){
-			e.printStackTrace();
-		}
-	}
-
-	protected Object get(String a) {
-		Field f = null;
-		try{
-			f = InitialHandler.class.getDeclaredField(a);
-		}catch (NoSuchFieldException | SecurityException e){
-			e.printStackTrace();
-		}
-		f.setAccessible(true);
-		try{
-			return f.get(this);
-		}catch (IllegalArgumentException | IllegalAccessException e){
-			e.printStackTrace();
-		}
-		return null;
-	}
+    static Class<?> base_class_connection;
+    static Class<?> class_connection;
+    private static int redifned_count = 0;
+    private static ClassPool pool;
+    private UserConnection conn;
+
+    public IIInitialHandler(ProxyServer instance, ListenerInfo listenerInfo, Decoder a, Encoder b) {
+        super(instance, listenerInfo, a, b);
+    }
+
+    public static ClassPool pool() {
+        if (pool != null)
+            return pool;
+        try {
+            pool = ClassPool.getDefault();
+            loadClassesFromJar(Main.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath()); //Load BungeeUtil in the system
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+        return pool;
+    }
+
+    public static ClassLoader getClassLoader() {
+        return IIInitialHandler.class.getClassLoader();
+    }
+
+    public static void addPlugin(Plugin plugin) {
+        try {
+            loadClassesFromJar(plugin.getClass().getProtectionDomain().getCodeSource().getLocation().toURI().getPath());
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+    }
+
+    @SuppressWarnings("resource")
+    private static void loadClassesFromJar(String path) {
+        if (pool == null)
+            throw new NullPointerException("Class Pool is null!");
+        if (new File(path).isDirectory())
+            return;
+        try {
+            JarFile jarFile = new JarFile(path);
+            Enumeration<JarEntry> e = jarFile.entries();
+
+            URL[] urls = {new URL("jar:file:" + path + "!/")};
+            URLClassLoader cl = URLClassLoader.newInstance(urls, IIInitialHandler.class.getClassLoader());
+            while (e.hasMoreElements()) {
+                JarEntry je = e.nextElement();
+                if (je.isDirectory() || !je.getName().endsWith(".class")) { //isnt a class file
+                    continue;
+                }
+                String className = je.getName().substring(0, je.getName().length() - 6);
+                className = className.replace('/', '.');
+                if (!className.startsWith("com.ea"))
+                    pool.insertClassPath(new ClassClassPath(cl.loadClass(className)));
+            }
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+    }
+
+    public static void init(Class<?> base) {
+        if (base == ProxiedPlayerUserConnection.class) {
+            try {
+                ClassPool cp = pool();
+                cp.appendClassPath(new ClassClassPath(base));
+                CtClass clazz = cp.get(base.getName());
+                clazz.setName("ProxiedPlayerUserConnectionRedefined" + (redifned_count == 0 ? "" : redifned_count));
+                clazz.setSuperclass(cp.get(UserConnection.class.getName()));
+                base_class_connection = class_connection = clazz.toClass(getClassLoader());
+                BungeeUtil.getInstance().sendMessage("\u00A7aInit Base class");
+                redifned_count++;
+            } catch (Exception e) {
+                e.printStackTrace();
+            }
+        } else {
+            if (base_class_connection == null)
+                throw new NullPointerException("Base class isn't init");
+            if (!ProxiedPlayerUserConnection.class.isAssignableFrom(base))
+                throw new RuntimeException("Class (" + base.getCanonicalName() + ") isnt an instance of ProxiedPlayerUserConnection");
+            try {
+                ClassPool cp = pool();
+                cp.appendClassPath(new ClassClassPath(base));
+                CtClass clazz = cp.get(base.getName());
+                CtClass super_class = cp.getCtClass(base_class_connection.getName()); //Get last redefined class
+                if (super_class == null || super_class.getName() == null)
+                    throw new NullPointerException("Base class not found.");
+                clazz.setSuperclass(super_class);
+                clazz.setName("ProxiedPlayerUserConnectionRedefined_" + (redifned_count == 0 ? "" : redifned_count));
+                class_connection = clazz.toClass(getClassLoader()); //Create the class
+                BungeeUtil.getInstance().sendMessage("\u00A7aInit extra class " + class_connection.getSuperclass());
+                redifned_count++;
+            } catch (Exception e) {
+                e.printStackTrace();
+            }
+        }
+    }
+
+    @SuppressWarnings({"unchecked", "rawtypes", "deprecation"})
+    protected void finish() {
+        if (isOnlineMode()) {
+            ProxiedPlayer oldName = ProxyServer.getInstance().getPlayer(getName());
+            if (oldName != null)
+                oldName.disconnect(ProxyServer.getInstance().getTranslation("already_connected", new Object[0]));
+            ProxiedPlayer oldID = ProxyServer.getInstance().getPlayer(getUniqueId());
+            if (oldID != null)
+                oldID.disconnect(ProxyServer.getInstance().getTranslation("already_connected", new Object[0]));
+        } else {
+            ProxiedPlayer oldName = ProxyServer.getInstance().getPlayer(getName());
+            if (oldName != null) {
+                disconnect(ProxyServer.getInstance().getTranslation("already_connected", new Object[0]));
+                return;
+            }
+        }
+        set("offlineId", UUID.nameUUIDFromBytes(("OfflinePlayer:" + getName()).getBytes(com.google.common.base.Charsets.UTF_8)));
+        if ((UUID) get("uniqueId") == null) {
+            set("uniqueId", (UUID) get("offlineId"));
+        }
+
+        Callback<LoginEvent> complete = new Callback() {
+            public void done(LoginEvent result, Throwable error) {
+                if (result.isCancelled()) {
+                    IIInitialHandler.this.disconnect(result.getCancelReason());
+                    return;
+                }
+                if (getChannel().isClosed()) {
+                    return;
+                }
+
+                getChannel().getHandle().eventLoop().execute(new Runnable() {
+                    public void run() {
+                        if (getChannel().getHandle().isActive()) {
+                            UserConnection userCon;
+                            try {
+                                userCon = (UserConnection) class_connection.getConstructor(ProxyServer.class, ChannelWrapper.class, String.class, InitialHandler.class).newInstance(BungeeCord.getInstance(), IIInitialHandler.this.getChannel(), IIInitialHandler.this.getName(), IIInitialHandler.this);
+                            } catch (InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException | NoSuchMethodException | SecurityException ex) {
+                                ex.printStackTrace();
+                                throw new RuntimeException();
+                            }
+                            userCon.setCompressionThreshold(BungeeCord.getInstance().config.getCompressionThreshold());
+                            userCon.init();
+                            conn = userCon;
+                            if (IIInitialHandler.this.getVersion() >= 5) {
+                                IIInitialHandler.this.unsafe().sendPacket(new LoginSuccess(IIInitialHandler.this.getUniqueId().toString(), IIInitialHandler.this.getName()));
+                            } else {
+                                IIInitialHandler.this.unsafe().sendPacket(new LoginSuccess(IIInitialHandler.this.getUUID(), IIInitialHandler.this.getName()));
+                            }
+                            getChannel().setProtocol(net.md_5.bungee.protocol.Protocol.GAME);
+
+                            ProxyServer.getInstance().getPluginManager().callEvent(new PostLoginEvent(userCon));
+                            ((HandlerBoss) getChannel().getHandle().pipeline().get(HandlerBoss.class)).setHandler(new UpstreamBridge(ProxyServer.getInstance(), userCon));
+                            ServerInfo server;
+                            if (ProxyServer.getInstance().getReconnectHandler() != null) {
+                                server = ProxyServer.getInstance().getReconnectHandler().getServer(userCon);
+                            } else {
+                                server = net.md_5.bungee.api.AbstractReconnectHandler.getForcedHost(IIInitialHandler.this);
+                            }
+                            if (server == null) {
+                                server = ProxyServer.getInstance().getServerInfo(((ListenerInfo) get("listener")).getDefaultServer());
+                            }
+
+                            userCon.connect(server, null, true);
+                        }
+
+                    }
+
+                });
+            }
+
+            @Override
+            public void done(Object o, Throwable t) {
+                if (o instanceof LoginEvent)
+                    done((LoginEvent) o, t);
+            }
+        };
+        ProxyServer.getInstance().getPluginManager().callEvent(new LoginEvent(this, complete));
+    }
+
+    @SuppressWarnings({"unchecked", "rawtypes"})
+    public void handle(LoginRequest loginRequest) throws Exception {
+        set("loginRequest", loginRequest);
+        ClientVersion version = ClientVersion.fromProtocoll(getHandshake().getProtocolVersion());
+        if (version == null || !version.getProtocollVersion().isSupported()) {
+            //disconnect(ProxyServer.getInstance().getTranslation("outdated_server", new Object[0]));
+            disconnect("\u00A7cBungeeUtil cant handle your client version.");
+            return;
+        }
+
+        if (getName().contains(".")) {
+            disconnect(ProxyServer.getInstance().getTranslation("name_invalid", new Object[]{getName()}));
+            return;
+        }
+
+        if (getName().length() > 16) {
+            disconnect(ProxyServer.getInstance().getTranslation("name_too_long", new Object[]{getName()}));
+            return;
+        }
+
+        int limit = BungeeCord.getInstance().config.getPlayerLimit();
+        if ((limit > 0) && (ProxyServer.getInstance().getOnlineCount() > limit)) {
+            disconnect(ProxyServer.getInstance().getTranslation("proxy_full", new Object[0]));
+            return;
+        }
+
+        if ((!isOnlineMode()) && (ProxyServer.getInstance().getPlayer(getUniqueId()) != null)) {
+            disconnect(ProxyServer.getInstance().getTranslation("already_connected", new Object[0]));
+            return;
+        }
+
+        setProtocol(Protocol.LOGIN);
+        Callback<PreLoginEvent> callback = new Callback() {
+            @Override
+            public void done(Object paramV, Throwable paramThrowable) {
+                if (paramV instanceof PreLoginEvent)
+                    done((PreLoginEvent) paramV, paramThrowable);
+            }
+
+            public void done(PreLoginEvent result, Throwable error) {
+
+                if (result.isCancelled()) {
+                    IIInitialHandler.this.disconnect(result.getCancelReason());
+                    return;
+                }
+                if (getChannel().isClosed()) {
+                    return;
+                }
+                if (isOnlineMode() == true) {
+                    set("request", EncryptionUtil.encryptRequest());
+                    IIInitialHandler.this.unsafe().sendPacket((DefinedPacket) get("request"));
+                } else {
+                    IIInitialHandler.this.finish();
+                }
+            }
+
+        };
+        ProxyServer.getInstance().getPluginManager().callEvent(new PreLoginEvent(this, callback));
+    }
+
+    @SuppressWarnings({"rawtypes", "unchecked"})
+    public void handle(EncryptionResponse encryptResponse) throws Exception {
+        SecretKey sharedKey = EncryptionUtil.getSecret(encryptResponse, (EncryptionRequest) get("request"));
+        BungeeCipher decrypt = EncryptionUtil.getCipher(false, sharedKey);
+        ((ChannelWrapper) get("ch")).addBefore("frame-decoder", "decrypt", new CipherDecoder(decrypt));
+        BungeeCipher encrypt = EncryptionUtil.getCipher(true, sharedKey);
+        ((ChannelWrapper) get("ch")).addBefore("frame-prepender", "encrypt", new CipherEncoder(encrypt));
+
+        String encName = URLEncoder.encode(getName(), "UTF-8");
+
+        MessageDigest sha = MessageDigest.getInstance("SHA-1");
+        for (byte[] bit : new byte[][]{(((EncryptionRequest) get("request"))).getServerId().getBytes("ISO_8859_1"), sharedKey.getEncoded(), EncryptionUtil.keys.getPublic().getEncoded()})
+
+        {
+            sha.update(bit);
+        }
+        String encodedHash = URLEncoder.encode(new BigInteger(sha.digest()).toString(16), "UTF-8");
+
+        String authURL = new StringBuilder().append("https://sessionserver.mojang.com/session/minecraft/hasJoined?username=").append(encName).append("&serverId=").append(encodedHash).toString();
+
+        Callback handler = new Callback<String>() {
+            public void done(String result, Throwable error) {
+                if (error == null) {
+                    LoginResult obj = (LoginResult) BungeeCord.getInstance().gson.fromJson(result, LoginResult.class);
+                    if (obj != null) {
+                        try {
+                            set("uniqueId", (UUID) Util.getUUID(obj.getId()));
+                            set("loginProfile", obj);
+                        } catch (Exception e) {
+                            e.printStackTrace();
+                        }
+                        finish();
+                        return;
+                    }
+                    IIInitialHandler.this.disconnect("Not authenticated with Minecraft.net");
+                } else {
+                    IIInitialHandler.this.disconnect(BungeeCord.getInstance().getTranslation("mojang_fail", new Object[0]));
+                    BungeeCord.getInstance().getLogger().log(Level.SEVERE, "Error authenticating " + IIInitialHandler.this.getName() + " with minecraft.net", error);
+
+                }
+            }
+        };
+        HttpClient.get(authURL, ((ChannelWrapper) get("ch")).getHandle().eventLoop(), handler);
+    }
+
+    @Override
+    public void exception(Throwable t) throws Exception {
+        super.exception(t);
+    }
+
+    @Override
+    public Player getPlayer() {
+        return (Player) ((ProxiedPlayer) conn);
+    }
+
+    protected void set(String a, Object b) {
+        Field f = null;
+        try {
+            f = InitialHandler.class.getDeclaredField(a);
+        } catch (NoSuchFieldException | SecurityException e) {
+            e.printStackTrace();
+        }
+        f.setAccessible(true);
+        try {
+            f.set(this, b);
+        } catch (IllegalArgumentException | IllegalAccessException e) {
+            e.printStackTrace();
+        }
+    }
+
+    protected Object get(String a) {
+        Field f = null;
+        try {
+            f = InitialHandler.class.getDeclaredField(a);
+        } catch (NoSuchFieldException | SecurityException e) {
+            e.printStackTrace();
+        }
+        f.setAccessible(true);
+        try {
+            return f.get(this);
+        } catch (IllegalArgumentException | IllegalAccessException e) {
+            e.printStackTrace();
+        }
+        return null;
+    }
 }
diff --git a/src/main/java/dev/wolveringer/network/IInitialHandler.java b/src/main/java/dev/wolveringer/network/IInitialHandler.java
index 27b256b..c6d1862 100644
--- a/src/main/java/dev/wolveringer/network/IInitialHandler.java
+++ b/src/main/java/dev/wolveringer/network/IInitialHandler.java
@@ -1,9 +1,5 @@
 package dev.wolveringer.network;
 
-import io.netty.buffer.ByteBuf;
-
-import java.lang.reflect.Field;
-
 import net.md_5.bungee.BungeeCord;
 import net.md_5.bungee.ServerConnection;
 import net.md_5.bungee.UserConnection;
@@ -16,6 +12,9 @@ import net.md_5.bungee.connection.InitialHandler;
 import net.md_5.bungee.protocol.Protocol;
 import net.md_5.bungee.protocol.packet.Kick;
 import net.md_5.bungee.protocol.packet.LoginSuccess;
+
+import java.lang.reflect.Field;
+
 import dev.wolveringer.BungeeUtil.AsyncCatcher;
 import dev.wolveringer.BungeeUtil.ClientVersion;
 import dev.wolveringer.BungeeUtil.Player;
@@ -27,205 +26,205 @@ import dev.wolveringer.BungeeUtil.packets.PacketPlayOutPlayerListHeaderFooter;
 import dev.wolveringer.BungeeUtil.packets.PacketPlayOutPosition;
 import dev.wolveringer.BungeeUtil.packets.PacketPlayOutRemoveEntityEffect;
 import dev.wolveringer.BungeeUtil.packets.PacketPlayOutUpdateHealth;
-import dev.wolveringer.chat.ChatSerializer;
 import dev.wolveringer.chat.IChatBaseComponent;
 import dev.wolveringer.network.channel.ChannelWrapper;
+import io.netty.buffer.ByteBuf;
 
 public abstract class IInitialHandler extends InitialHandler {
-	public final static Field CHANNEL_FIELD;
-	
-	static {
-		Field f;
-		try {
-			f = InitialHandler.class.getDeclaredField("ch");
-			f.setAccessible(true);
-		}
-		catch (NoSuchFieldException | SecurityException e) {
-			f = null;
-			e.printStackTrace();
-		}
-		CHANNEL_FIELD = f;
-	}
-	
-	public IInitialHandler(ProxyServer instance, ListenerInfo listenerInfo, Decoder a, Encoder b) {
-		super(BungeeCord.getInstance(), listenerInfo);
-		this.a = a;
-		this.b = b;
-		if (a != null) a.setInitHandler(this);
-		if (b != null) b.setInitHandler(this);
-	}
-	
-	public boolean isConnected = false;
-	private boolean isDisconnecting = false;
-	private Encoder b;
-	private Decoder a;
-	private short transaktionId;
-	private short window;
-	private IChatBaseComponent[] tab = new IChatBaseComponent[2];
-	
-	
-	public Encoder getEncoder() {
-		return b;
-	}
-	
-	public Decoder getDecoder() {
-		return a;
-	}
-	
-	@Override
-	public void connected(final net.md_5.bungee.netty.ChannelWrapper channel) throws Exception {
-		super.connected(new ChannelWrapper(channel, this));
-	}
-	
-	@Override
-	public void handle(LoginSuccess loginSuccess) throws Exception {
-		super.handle(loginSuccess);
-	}
-	
-	public abstract Player getPlayer();
-	
-	@Override
-	public void disconnect(String reason) {
-		disconnect(TextComponent.fromLegacyText(reason));
-	}
-	
-	@Override
-	public void disconnect(final BaseComponent... reason) {
-		if (isDisconnecting) return;
-		isDisconnecting = true;
-		if (getHandshake() != null && getHandshake().getRequestedProtocol() == 2) {
-			if(getEncoder().getProtocoll() == Protocol.HANDSHAKE)
-				setProtocol(Protocol.LOGIN);
-			unsafe().sendPacket(new Kick(ComponentSerializer.toString(reason)));
-		}
-		closeChannel();
-	}
-	
-	public void disconnect(Exception e) {
-		disconnect(e, 10);
-	}
-	
-	public void disconnect(Exception e, int stackDeep) {
-		if (isDisconnecting) return;
-		isDisconnecting = true;
-		if (getChannel().isClosed()) { return; }
-		String message = "" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "4Error Message: " + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "b" + e.getLocalizedMessage() + "\n";
-		for (int i = 0; i < (e.getStackTrace().length > stackDeep ? stackDeep : e.getStackTrace().length); i++) {
-			StackTraceElement ex = e.getStackTrace()[i];
-			if(ex.getMethodName().equalsIgnoreCase("channelRead") && ex.getClassName().equalsIgnoreCase("io.netty.handler.codec.MessageToMessageDecoder") && ex.getLineNumber() == 89)
-				break;
-			message += format(ex) + "\n";
-		}
-		disconnect(message);
-	}
-	
-	public void closeChannel() {
-		if (!getChannel().isClosed()) getChannel().close();
-		if (isConnected) {
-			if (getPlayer().getInventoryView() != null) getPlayer().getInventoryView().unsave().getModificableViewerList().remove(this);
-			getPlayer().getPlayerInventory().reset();
-			isConnected = false;
-			b = null;
-			a = null;
-			tab = null;
-		}
-	}
-	
-	public void sendPacket(Packet p) {
-		AsyncCatcher.catchOp("Packet cant be sending async!");
-		ByteBuf b = p.getByteBuf(ClientVersion.fromProtocoll(getVersion()));
-		getChannel().getHandle().writeAndFlush(b);
-		p = null;
-	}
-	
-	public void sendPacketToServer(Packet p) {
-		AsyncCatcher.catchOp("Packet cant be sending async!");
-		ByteBuf b = p.getByteBuf(ClientVersion.fromProtocoll(this.getVersion()));
-		((ServerConnection) getPlayer().getServer()).getCh().write(b);
-	}
-	
-	public void setProtocol(Protocol p) {
-		a.setProtocol(p);
-		b.setProtocol(p);
-	}
-	
-	private String format(StackTraceElement e) {
-		return "" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "eat " + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "5" + e.getClassName() + "." + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "b" + e.getMethodName() + (e.getFileName() != null ? "(" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "a" + e.getFileName() + ":"+e.getLineNumber() + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "b)" : (e.getFileName() != null) && (e.getLineNumber() >= 0) ? "(" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "a" + e.getFileName() + "" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "b:" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "c" + e.getLineNumber() + "" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "b)" : e.isNativeMethod() ? "" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "1(Native Method)" : "" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "c(Unknown Source)");
-	}
-	
-	@Deprecated
-	public void resetClient() {
-		for (int i = 1; i < 24; i++)
-			sendPacket(new PacketPlayOutRemoveEntityEffect(getEntityId(), i));
-		sendPacket(new PacketPlayOutPosition(getPlayer().getLocation().add(0, 10000, 0), true));
-		sendPacket(new PacketPlayOutEntityEffect(getEntityId(), 15, 1, 100000, true));
-		sendPacket(new PacketPlayOutGameStateChange(3, 0));
-		sendPacket(new PacketPlayOutUpdateHealth(20F, 20, 0F));
-		resetInventory();
-	}
-	
-	@Deprecated
-	public void resetInventory() {
-		for (int i = 0; i < getPlayer().getPlayerInventory().getContains().length; i++)
-			getPlayer().getPlayerInventory().setItem(i, null);
-		getPlayer().updateInventory();
-	}
-	
-	public int getEntityId() {
-		try {
-			Field f = UserConnection.class.getDeclaredField("clientEntityId");
-			f.setAccessible(true);
-			if (BungeeCord.getInstance().getPlayer(getPlayer().getName()) == null) return -1;
-			return f.getInt(BungeeCord.getInstance().getPlayer(getPlayer().getName()));
-		}
-		catch (Exception e) {
-			e.printStackTrace();
-			return -1;
-		}
-	}
-	
-	public ChannelWrapper getChannel() {
-		try {
-			return (ChannelWrapper) CHANNEL_FIELD.get(this);
-		}
-		catch (IllegalArgumentException | IllegalAccessException e) {
-			e.printStackTrace();
-			return null;
-		}
-	}
-	
-	public short getTransaktionId() {
-		return transaktionId;
-	}
-	
-	public void setTransaktionId(short transaktionId) {
-		this.transaktionId = transaktionId;
-	}
-	
-	public void setWindow(short window) {
-		this.window = window;
-	}
-	
-	public short getWindow() {
-		return window;
-	}
-	
-	public IChatBaseComponent[] getTabHeader() {
-		return tab;
-	}
-	
-	public void setTabHeader(IChatBaseComponent header, IChatBaseComponent footer) {
-		this.tab = new IChatBaseComponent[] { header, footer };
-		sendPacket(new PacketPlayOutPlayerListHeaderFooter(header, footer));
-	}
-	
-	public void setTabHeaderFromPacket(IChatBaseComponent header, IChatBaseComponent footer) {
-		this.tab = new IChatBaseComponent[] { header, footer };
-	}
-	
-	@Override
-	public String toString() {
-		if (Configuration.isTerminalColored()) return "[" + (getHandshake().getRequestedProtocol() == 2 ? "" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "aGAME" : "" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "ePING") + "" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "7][" + (getHandshake().getRequestedProtocol() == 0 ? "" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "6" + getName() : "" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "c" + getAddress().getHostString()) + "" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "7]";
-		else return super.toString();
-	}
+    public final static Field CHANNEL_FIELD;
+
+    static {
+        Field f;
+        try {
+            f = InitialHandler.class.getDeclaredField("ch");
+            f.setAccessible(true);
+        } catch (NoSuchFieldException | SecurityException e) {
+            f = null;
+            e.printStackTrace();
+        }
+        CHANNEL_FIELD = f;
+    }
+
+    public boolean isConnected = false;
+    private boolean isDisconnecting = false;
+    private Encoder b;
+    private Decoder a;
+    private short transaktionId;
+    private short window;
+    private IChatBaseComponent[] tab = new IChatBaseComponent[2];
+
+    public IInitialHandler(ProxyServer instance, ListenerInfo listenerInfo, Decoder a, Encoder b) {
+        super(BungeeCord.getInstance(), listenerInfo);
+        this.a = a;
+        this.b = b;
+        if (a != null) a.setInitHandler(this);
+        if (b != null) b.setInitHandler(this);
+    }
+
+    public Encoder getEncoder() {
+        return b;
+    }
+
+    public Decoder getDecoder() {
+        return a;
+    }
+
+    @Override
+    public void connected(final net.md_5.bungee.netty.ChannelWrapper channel) throws Exception {
+        super.connected(new ChannelWrapper(channel, this));
+    }
+
+    @Override
+    public void handle(LoginSuccess loginSuccess) throws Exception {
+        super.handle(loginSuccess);
+    }
+
+    public abstract Player getPlayer();
+
+    @Override
+    public void disconnect(String reason) {
+        disconnect(TextComponent.fromLegacyText(reason));
+    }
+
+    @Override
+    public void disconnect(final BaseComponent... reason) {
+        if (isDisconnecting) return;
+        isDisconnecting = true;
+        if (getHandshake() != null && getHandshake().getRequestedProtocol() == 2) {
+            if (getEncoder().getProtocoll() == Protocol.HANDSHAKE)
+                setProtocol(Protocol.LOGIN);
+            unsafe().sendPacket(new Kick(ComponentSerializer.toString(reason)));
+        }
+        closeChannel();
+    }
+
+    public void disconnect(Exception e) {
+        disconnect(e, 10);
+    }
+
+    public void disconnect(Exception e, int stackDeep) {
+        if (isDisconnecting) return;
+        isDisconnecting = true;
+        if (getChannel().isClosed()) {
+            return;
+        }
+        String message = "" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "4Error Message: " + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "b" + e.getLocalizedMessage() + "\n";
+        for (int i = 0; i < (e.getStackTrace().length > stackDeep ? stackDeep : e.getStackTrace().length); i++) {
+            StackTraceElement ex = e.getStackTrace()[i];
+            if (ex.getMethodName().equalsIgnoreCase("channelRead") && ex.getClassName().equalsIgnoreCase("io.netty.handler.codec.MessageToMessageDecoder") && ex.getLineNumber() == 89)
+                break;
+            message += format(ex) + "\n";
+        }
+        disconnect(message);
+    }
+
+    public void closeChannel() {
+        if (!getChannel().isClosed()) getChannel().close();
+        if (isConnected) {
+            if (getPlayer().getInventoryView() != null)
+                getPlayer().getInventoryView().unsave().getModificableViewerList().remove(this);
+            getPlayer().getPlayerInventory().reset();
+            isConnected = false;
+            b = null;
+            a = null;
+            tab = null;
+        }
+    }
+
+    public void sendPacket(Packet p) {
+        AsyncCatcher.catchOp("Packet cant be sending async!");
+        ByteBuf b = p.getByteBuf(ClientVersion.fromProtocoll(getVersion()));
+        getChannel().getHandle().writeAndFlush(b);
+        p = null;
+    }
+
+    public void sendPacketToServer(Packet p) {
+        AsyncCatcher.catchOp("Packet cant be sending async!");
+        ByteBuf b = p.getByteBuf(ClientVersion.fromProtocoll(this.getVersion()));
+        ((ServerConnection) getPlayer().getServer()).getCh().write(b);
+    }
+
+    public void setProtocol(Protocol p) {
+        a.setProtocol(p);
+        b.setProtocol(p);
+    }
+
+    private String format(StackTraceElement e) {
+        return "" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "eat " + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "5" + e.getClassName() + "." + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "b" + e.getMethodName() + (e.getFileName() != null ? "(" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "a" + e.getFileName() + ":" + e.getLineNumber() + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "b)" : (e.getFileName() != null) && (e.getLineNumber() >= 0) ? "(" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "a" + e.getFileName() + "" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "b:" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "c" + e.getLineNumber() + "" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "b)" : e.isNativeMethod() ? "" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "1(Native Method)" : "" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "c(Unknown Source)");
+    }
+
+    @Deprecated
+    public void resetClient() {
+        for (int i = 1; i < 24; i++)
+            sendPacket(new PacketPlayOutRemoveEntityEffect(getEntityId(), i));
+        sendPacket(new PacketPlayOutPosition(getPlayer().getLocation().add(0, 10000, 0), true));
+        sendPacket(new PacketPlayOutEntityEffect(getEntityId(), 15, 1, 100000, true));
+        sendPacket(new PacketPlayOutGameStateChange(3, 0));
+        sendPacket(new PacketPlayOutUpdateHealth(20F, 20, 0F));
+        resetInventory();
+    }
+
+    @Deprecated
+    public void resetInventory() {
+        for (int i = 0; i < getPlayer().getPlayerInventory().getContains().length; i++)
+            getPlayer().getPlayerInventory().setItem(i, null);
+        getPlayer().updateInventory();
+    }
+
+    public int getEntityId() {
+        try {
+            Field f = UserConnection.class.getDeclaredField("clientEntityId");
+            f.setAccessible(true);
+            if (BungeeCord.getInstance().getPlayer(getPlayer().getName()) == null) return -1;
+            return f.getInt(BungeeCord.getInstance().getPlayer(getPlayer().getName()));
+        } catch (Exception e) {
+            e.printStackTrace();
+            return -1;
+        }
+    }
+
+    public ChannelWrapper getChannel() {
+        try {
+            return (ChannelWrapper) CHANNEL_FIELD.get(this);
+        } catch (IllegalArgumentException | IllegalAccessException e) {
+            e.printStackTrace();
+            return null;
+        }
+    }
+
+    public short getTransaktionId() {
+        return transaktionId;
+    }
+
+    public void setTransaktionId(short transaktionId) {
+        this.transaktionId = transaktionId;
+    }
+
+    public short getWindow() {
+        return window;
+    }
+
+    public void setWindow(short window) {
+        this.window = window;
+    }
+
+    public IChatBaseComponent[] getTabHeader() {
+        return tab;
+    }
+
+    public void setTabHeader(IChatBaseComponent header, IChatBaseComponent footer) {
+        this.tab = new IChatBaseComponent[]{header, footer};
+        sendPacket(new PacketPlayOutPlayerListHeaderFooter(header, footer));
+    }
+
+    public void setTabHeaderFromPacket(IChatBaseComponent header, IChatBaseComponent footer) {
+        this.tab = new IChatBaseComponent[]{header, footer};
+    }
+
+    @Override
+    public String toString() {
+        if (Configuration.isTerminalColored())
+            return "[" + (getHandshake().getRequestedProtocol() == 2 ? "" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "aGAME" : "" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "ePING") + "" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "7][" + (getHandshake().getRequestedProtocol() == 0 ? "" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "6" + getName() : "" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "c" + getAddress().getHostString()) + "" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "7]";
+        else return super.toString();
+    }
 }
diff --git a/src/main/java/dev/wolveringer/network/ProxiedPlayerUserConnection.java b/src/main/java/dev/wolveringer/network/ProxiedPlayerUserConnection.java
index 6940666..e1674fe 100644
--- a/src/main/java/dev/wolveringer/network/ProxiedPlayerUserConnection.java
+++ b/src/main/java/dev/wolveringer/network/ProxiedPlayerUserConnection.java
@@ -1,13 +1,7 @@
 package dev.wolveringer.network;
 
-import io.netty.bootstrap.Bootstrap;
-import io.netty.channel.Channel;
-import io.netty.channel.ChannelFutureListener;
-import io.netty.channel.ChannelInitializer;
-import io.netty.channel.ChannelOption;
-import io.netty.util.internal.PlatformDependent;
-
-import java.lang.reflect.Field;
+import com.google.common.base.Objects;
+import com.google.common.base.Preconditions;
 
 import net.md_5.bungee.BungeeCord;
 import net.md_5.bungee.BungeeServerInfo;
@@ -21,13 +15,14 @@ import net.md_5.bungee.connection.InitialHandler;
 import net.md_5.bungee.netty.ChannelWrapper;
 import net.md_5.bungee.netty.PipelineUtils;
 
-import com.google.common.base.Objects;
-import com.google.common.base.Preconditions;
+import java.lang.reflect.Field;
 
 import dev.wolveringer.BungeeUtil.ClientVersion;
 import dev.wolveringer.BungeeUtil.Player;
 import dev.wolveringer.BungeeUtil.configuration.Configuration;
 import dev.wolveringer.BungeeUtil.item.Item;
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayIn;
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
 import dev.wolveringer.BungeeUtil.packets.Packet;
 import dev.wolveringer.BungeeUtil.packets.PacketPlayInChat;
 import dev.wolveringer.BungeeUtil.packets.PacketPlayOutCloseWindow;
@@ -35,8 +30,6 @@ import dev.wolveringer.BungeeUtil.packets.PacketPlayOutNamedSoundEffect;
 import dev.wolveringer.BungeeUtil.packets.PacketPlayOutOpenWindow;
 import dev.wolveringer.BungeeUtil.packets.PacketPlayOutSetSlot;
 import dev.wolveringer.BungeeUtil.packets.PacketPlayOutWindowItems;
-import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayIn;
-import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayOut;
 import dev.wolveringer.api.bossbar.BossBarManager;
 import dev.wolveringer.api.inventory.Inventory;
 import dev.wolveringer.api.inventory.InventoryType;
@@ -48,85 +41,96 @@ import dev.wolveringer.api.sound.SoundEffect;
 import dev.wolveringer.chat.IChatBaseComponent;
 import dev.wolveringer.network.inject.XChannelFutureListener;
 import dev.wolveringer.network.inject.XChannelInitializer;
+import io.netty.bootstrap.Bootstrap;
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelFutureListener;
+import io.netty.channel.ChannelInitializer;
+import io.netty.channel.ChannelOption;
+import io.netty.util.internal.PlatformDependent;
 
 public class ProxiedPlayerUserConnection extends UserConnection implements Player {
-	private static final int CURSOR_ITEM_SLOT = 50;
-	private IInitialHandler i;
-	private Inventory inv;
-	private Location loc;
-	private Location last_loc;
-	private PlayerInventory p_inv;
-	private int slot;
-	private Scoreboard board;
-	private String[] tab = new String[2];
-	private BossBarManager bossBarManager;
-	
-	public ProxiedPlayerUserConnection(ProxyServer bungee, ChannelWrapper ch, String name, InitialHandler pendingConnection) {
-		super(bungee, ch, name, pendingConnection);
-		this.i = (IInitialHandler) pendingConnection;
-		p_inv = new PlayerInventory(this);
-		p_inv.getViewer().add(this);
-		board = new Scoreboard(this);
-		loc = last_loc = new Location(0, 0, 0);
-		bossBarManager = new BossBarManager(this);
-	}
-
-	public IInitialHandler getInitialHandler() {
-		return i;
-	}
-
-	public void closeInventory() {
-		closeInventory(true);
-		updateInventory();
-	}
-
-	private void closeInventory(boolean b) {
-		if(inv == null)
-			return;
-		if(b)
-			sendPacket(new PacketPlayOutCloseWindow(Inventory.ID));
-		inv.unsave().getModificableViewerList().remove(this);
-		inv = null;
-	}
-
-	public Location getLocation() {
-		return loc.clone();
-	}
-
-	public Location getLastLocation() {
-		return last_loc.clone();
-	}
-
-	public void performCommand(String command) {
-		sendPacketToServer(new PacketPlayInChat((command.startsWith("/") ? "" : "/") + command));
-	}
-
-	@Deprecated
-	public void sendPacketToServer(PacketPlayIn p) {
-		i.sendPacketToServer((Packet) p);
-	}
-
-	public boolean isInventoryOpened() {
-		return inv != null;
-	}
-
-	public void openInventory(Inventory inv) {
-		if(isInventoryOpened())
-			closeInventory(true);
-		PacketPlayOutOpenWindow e = new PacketPlayOutOpenWindow(Inventory.ID, inv.getType().getType(getVersion()), inv.getName(), inv.getType() == InventoryType.Chest ? inv.getSlots() : inv.getType().getDefaultSlots(), false);
-		e.UTF_8 = true;
-		sendPacket(e);
-		sendPacket(new PacketPlayOutWindowItems(Inventory.ID, inv.getContains()));
-		inv.unsave().getModificableViewerList().add(this);
-		this.inv = inv;
-	}
-
-	public void updateInventory() {
-		int window = 0;
-		int dslot = 0;
-		Item[] items = p_inv.getContains();
-		/*
-		if(isInventoryOpened()){
+    private static final int CURSOR_ITEM_SLOT = 50;
+    private IInitialHandler i;
+    private Inventory inv;
+    private Location loc;
+    private Location last_loc;
+    private PlayerInventory p_inv;
+    private int slot;
+    private Scoreboard board;
+    private String[] tab = new String[2];
+    private BossBarManager bossBarManager;
+
+    public ProxiedPlayerUserConnection(ProxyServer bungee, ChannelWrapper ch, String name, InitialHandler pendingConnection) {
+        super(bungee, ch, name, pendingConnection);
+        this.i = (IInitialHandler) pendingConnection;
+        p_inv = new PlayerInventory(this);
+        p_inv.getViewer().add(this);
+        board = new Scoreboard(this);
+        loc = last_loc = new Location(0, 0, 0);
+        bossBarManager = new BossBarManager(this);
+    }
+
+    public IInitialHandler getInitialHandler() {
+        return i;
+    }
+
+    public void closeInventory() {
+        closeInventory(true);
+        updateInventory();
+    }
+
+    private void closeInventory(boolean b) {
+        if (inv == null)
+            return;
+        if (b)
+            sendPacket(new PacketPlayOutCloseWindow(Inventory.ID));
+        inv.unsave().getModificableViewerList().remove(this);
+        inv = null;
+    }
+
+    public Location getLocation() {
+        return loc.clone();
+    }
+
+    public void setLocation(Location loc) {
+        this.last_loc = this.loc.clone();
+        this.loc = loc;
+    }
+
+    public Location getLastLocation() {
+        return last_loc.clone();
+    }
+
+    public void performCommand(String command) {
+        sendPacketToServer(new PacketPlayInChat((command.startsWith("/") ? "" : "/") + command));
+    }
+
+    @Deprecated
+    public void sendPacketToServer(PacketPlayIn p) {
+        i.sendPacketToServer((Packet) p);
+    }
+
+    public boolean isInventoryOpened() {
+        return inv != null;
+    }
+
+    public void openInventory(Inventory inv) {
+        if (isInventoryOpened())
+            closeInventory(true);
+        PacketPlayOutOpenWindow e = new PacketPlayOutOpenWindow(Inventory.ID, inv.getType().getType(getVersion()), inv.getName(), inv.getType() == InventoryType.Chest ? inv.getSlots() : inv.getType().getDefaultSlots(), false);
+        e.UTF_8 = true;
+        sendPacket(e);
+        sendPacket(new PacketPlayOutWindowItems(Inventory.ID, inv.getContains()));
+        inv.unsave().getModificableViewerList().add(this);
+        this.inv = inv;
+    }
+
+    public void updateInventory() {
+        int window = 0;
+        int dslot = 0;
+        Item[] items = p_inv.getContains();
+        /*
+        if(isInventoryOpened()){
 			window = Inventory.ID;
 			dslot = getInventoryView().getSlots();
 		}
@@ -137,184 +141,179 @@ public class ProxiedPlayerUserConnection extends UserConnection implements Playe
 			sendPacket(new PacketPlayOutSetSlot(item, window, dslot+i-(isInventoryOpened()?/*9*//*0:0))); //-9 Player crafting and armor
 		}
 		*/
-		sendPacket(new PacketPlayOutWindowItems(0, items));
-	}
-
-	public void setCursorItem(Item is) {
-		sendPacket(new PacketPlayOutSetSlot(is, -1, -1));
-		getPlayerInventory().setItem(CURSOR_ITEM_SLOT, is);
-	}
-
-	public Item getCursorItem() {
-		return getPlayerInventory().getItem(CURSOR_ITEM_SLOT);
-	}
-
-	public Item getOffHandItem() {
-		return getPlayerInventory().getItem(45);
-	}
-	
-	public PlayerInventory getPlayerInventory() {
-		return p_inv;
-	}
-
-	public ClientVersion getVersion() {
-		return ClientVersion.fromProtocoll(i.getHandshake() == null ? -1 : i.getHandshake().getProtocolVersion());
-	}
-
-	public Inventory getInventoryView() {
-		return inv;
-	}
-
-	public void sendPacket(PacketPlayOut packet) {
-		Packet p = (Packet) packet;
-		if(p == null)
-			return;
-		i.sendPacket(p);
-	}
-
-	public void setLocation(Location loc) {
-		this.last_loc = this.loc.clone();
-		this.loc = loc;
-	}
-
-	public void setSelectedSlot(int slot) {
-		this.slot = slot;
-	}
-
-	public int getSelectedSlot() {
-		return slot;
-	}
-
-	public Scoreboard getScoreboard() {
-		if(Configuration.isScoreboardhandleEnabled())
-			return board;
-		throw new RuntimeException("The Scoreboard manager isnt enabled in the configuration!");
-	}
-
-	@Override
-	public IChatBaseComponent[] getTabHeader() {
-		return getInitialHandler().getTabHeader();
-	}
-
-	@Override
-	public void setTabHeader(IChatBaseComponent header, IChatBaseComponent footer) {
-		getInitialHandler().setTabHeader(header, footer);
-	}
-	
-	@Override
-	public void disconnect(Exception e) {
-		getInitialHandler().disconnect(e);
-	}
-
-	@Override
-	public String toString() {
-		return "Player{name=\""+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"r" + getName() + ""+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"r\" DisplayName=\""+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"r" + getDisplayName() + ""+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"r\" ping=\"" + getPing() + "\"}";
-	}
-
-	@Override
-	public void connect(ServerInfo info, Callback<Boolean> callback, boolean retry) {
-		connect0(info, callback, retry);
-	}
-
-	public void connect0(ServerInfo info, final Callback<Boolean> callback, final boolean retry) {
-		Preconditions.checkNotNull(info, "info");
-
-		ServerConnectEvent event = new ServerConnectEvent(this, info);
-		if(((ServerConnectEvent) BungeeCord.getInstance().getPluginManager().callEvent(event)).isCancelled()){
-			return;
-		}
-
-		final BungeeServerInfo target = (BungeeServerInfo) event.getTarget();
-		if((getServer() != null) && (Objects.equal(getServer().getInfo(), target))){
-			sendMessage(BungeeCord.getInstance().getTranslation("already_connected", new Object[0]));
-			return;
-		}
-		if(getPendingConnects().contains(target)){
-			sendMessage(BungeeCord.getInstance().getTranslation("already_connecting", new Object[0]));
-			return;
-		}
-		getPendingConnects().add(target);
-		ChannelInitializer<Channel> initializer = new XChannelInitializer(getUserconnection(), target);
-		ChannelFutureListener listener = new XChannelFutureListener(callback, getUserconnection(), target, retry);
-		Bootstrap b = ((Bootstrap) ((Bootstrap) ((Bootstrap) ((Bootstrap) new Bootstrap().channel(PipelineUtils.getChannel())).group(get("ch", ChannelWrapper.class).getHandle().eventLoop())).handler(initializer)).option(ChannelOption.CONNECT_TIMEOUT_MILLIS, Integer.valueOf(5000))).remoteAddress(target.getAddress());
-		if((getPendingConnection().getListener().isSetLocalAddress()) && (!(PlatformDependent.isWindows()))){
-			b.localAddress(getPendingConnection().getListener().getHost().getHostString(), 0);
-		}
-		b.connect().addListener(listener);
-	}
-	
-	
-	private Object get(String a) {
-		Field f = null;
-		try{
-			f = UserConnection.class.getDeclaredField(a);
-		}catch (NoSuchFieldException | SecurityException e){
-			e.printStackTrace();
-		}
-		f.setAccessible(true);
-		try{
-			return f.get(this);
-		}catch (IllegalArgumentException | IllegalAccessException e){
-			e.printStackTrace();
-		}
-		return null;
-	}
-
-	private <T> T get(String a, Class<T> ref) {
-		return (T) get(a);
-	}
-	
-	private UserConnection getUserconnection(){
-		return (UserConnection) ((ProxiedPlayer)this);
-	}
-
-	@Override
-	public boolean isConnected() {
-		return !((ChannelWrapper)get("ch")).isClosed();
-	}
-
-	@Override
-	public Item getHandItem() {
-		return getPlayerInventory().getItem(36+slot);
-	}
-	
-	@Override
-	public void playSound(SoundEffect effect) {
-		playSound(effect, 1F);
-	}
-
-	@Override
-	public void playSound(SoundEffect effect, float volume) {
-		playSound(effect, volume, 0);
-	}
-
-	@Override
-	public void playSound(SoundEffect effect, float volume, float pitch) {
-		playSound(effect, getLocation() , volume, pitch);
-		
-	}
-	
-	@Override
-	public void playSound(SoundEffect effect, Location location, float volume, float pitch) {
-		playSound(effect, SoundCategory.MASTER, location, volume, pitch);
-	}
-
-	@Override
-	public void playSound(SoundEffect effect,SoundCategory category, Location location, float volume, float pitch) {
-		if(!effect.isAvariable(getVersion().getBigVersion()))
-			throw new RuntimeException("Sound not avariable for client version");
-		PacketPlayOutNamedSoundEffect packet = new PacketPlayOutNamedSoundEffect();
-		packet.setLoc(location);
-		packet.setVolume(volume);
-		packet.setSoundCategory(category.ordinal());
-		packet.setSound(effect.getId(getVersion().getBigVersion()));
-		sendPacket(packet);
-	}
-
-	@Override
-	public BossBarManager getBossBarManager() {
-		if(Configuration.isBossBarhandleEnabled())
-			return bossBarManager;
-		throw new RuntimeException("The BossBar manager isnt enabled in the configuration!");
-	}
+        sendPacket(new PacketPlayOutWindowItems(0, items));
+    }
+
+    public Item getCursorItem() {
+        return getPlayerInventory().getItem(CURSOR_ITEM_SLOT);
+    }
+
+    public void setCursorItem(Item is) {
+        sendPacket(new PacketPlayOutSetSlot(is, -1, -1));
+        getPlayerInventory().setItem(CURSOR_ITEM_SLOT, is);
+    }
+
+    public Item getOffHandItem() {
+        return getPlayerInventory().getItem(45);
+    }
+
+    public PlayerInventory getPlayerInventory() {
+        return p_inv;
+    }
+
+    public ClientVersion getVersion() {
+        return ClientVersion.fromProtocoll(i.getHandshake() == null ? -1 : i.getHandshake().getProtocolVersion());
+    }
+
+    public Inventory getInventoryView() {
+        return inv;
+    }
+
+    public void sendPacket(PacketPlayOut packet) {
+        Packet p = (Packet) packet;
+        if (p == null)
+            return;
+        i.sendPacket(p);
+    }
+
+    public int getSelectedSlot() {
+        return slot;
+    }
+
+    public void setSelectedSlot(int slot) {
+        this.slot = slot;
+    }
+
+    public Scoreboard getScoreboard() {
+        if (Configuration.isScoreboardhandleEnabled())
+            return board;
+        throw new RuntimeException("The Scoreboard manager isnt enabled in the configuration!");
+    }
+
+    @Override
+    public IChatBaseComponent[] getTabHeader() {
+        return getInitialHandler().getTabHeader();
+    }
+
+    @Override
+    public void setTabHeader(IChatBaseComponent header, IChatBaseComponent footer) {
+        getInitialHandler().setTabHeader(header, footer);
+    }
+
+    @Override
+    public void disconnect(Exception e) {
+        getInitialHandler().disconnect(e);
+    }
+
+    @Override
+    public String toString() {
+        return "Player{name=\"" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "r" + getName() + "" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "r\" DisplayName=\"" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "r" + getDisplayName() + "" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "r\" ping=\"" + getPing() + "\"}";
+    }
+
+    @Override
+    public void connect(ServerInfo info, Callback<Boolean> callback, boolean retry) {
+        connect0(info, callback, retry);
+    }
+
+    public void connect0(ServerInfo info, final Callback<Boolean> callback, final boolean retry) {
+        Preconditions.checkNotNull(info, "info");
+
+        ServerConnectEvent event = new ServerConnectEvent(this, info);
+        if (((ServerConnectEvent) BungeeCord.getInstance().getPluginManager().callEvent(event)).isCancelled()) {
+            return;
+        }
+
+        final BungeeServerInfo target = (BungeeServerInfo) event.getTarget();
+        if ((getServer() != null) && (Objects.equal(getServer().getInfo(), target))) {
+            sendMessage(BungeeCord.getInstance().getTranslation("already_connected", new Object[0]));
+            return;
+        }
+        if (getPendingConnects().contains(target)) {
+            sendMessage(BungeeCord.getInstance().getTranslation("already_connecting", new Object[0]));
+            return;
+        }
+        getPendingConnects().add(target);
+        ChannelInitializer<Channel> initializer = new XChannelInitializer(getUserconnection(), target);
+        ChannelFutureListener listener = new XChannelFutureListener(callback, getUserconnection(), target, retry);
+        Bootstrap b = ((Bootstrap) ((Bootstrap) ((Bootstrap) ((Bootstrap) new Bootstrap().channel(PipelineUtils.getChannel())).group(get("ch", ChannelWrapper.class).getHandle().eventLoop())).handler(initializer)).option(ChannelOption.CONNECT_TIMEOUT_MILLIS, Integer.valueOf(5000))).remoteAddress(target.getAddress());
+        if ((getPendingConnection().getListener().isSetLocalAddress()) && (!(PlatformDependent.isWindows()))) {
+            b.localAddress(getPendingConnection().getListener().getHost().getHostString(), 0);
+        }
+        b.connect().addListener(listener);
+    }
+
+
+    private Object get(String a) {
+        Field f = null;
+        try {
+            f = UserConnection.class.getDeclaredField(a);
+        } catch (NoSuchFieldException | SecurityException e) {
+            e.printStackTrace();
+        }
+        f.setAccessible(true);
+        try {
+            return f.get(this);
+        } catch (IllegalArgumentException | IllegalAccessException e) {
+            e.printStackTrace();
+        }
+        return null;
+    }
+
+    private <T> T get(String a, Class<T> ref) {
+        return (T) get(a);
+    }
+
+    private UserConnection getUserconnection() {
+        return (UserConnection) ((ProxiedPlayer) this);
+    }
+
+    @Override
+    public boolean isConnected() {
+        return !((ChannelWrapper) get("ch")).isClosed();
+    }
+
+    @Override
+    public Item getHandItem() {
+        return getPlayerInventory().getItem(36 + slot);
+    }
+
+    @Override
+    public void playSound(SoundEffect effect) {
+        playSound(effect, 1F);
+    }
+
+    @Override
+    public void playSound(SoundEffect effect, float volume) {
+        playSound(effect, volume, 0);
+    }
+
+    @Override
+    public void playSound(SoundEffect effect, float volume, float pitch) {
+        playSound(effect, getLocation(), volume, pitch);
+
+    }
+
+    @Override
+    public void playSound(SoundEffect effect, Location location, float volume, float pitch) {
+        playSound(effect, SoundCategory.MASTER, location, volume, pitch);
+    }
+
+    @Override
+    public void playSound(SoundEffect effect, SoundCategory category, Location location, float volume, float pitch) {
+        if (!effect.isAvariable(getVersion().getBigVersion()))
+            throw new RuntimeException("Sound not avariable for client version");
+        PacketPlayOutNamedSoundEffect packet = new PacketPlayOutNamedSoundEffect();
+        packet.setLoc(location);
+        packet.setVolume(volume);
+        packet.setSoundCategory(category.ordinal());
+        packet.setSound(effect.getId(getVersion().getBigVersion()));
+        sendPacket(packet);
+    }
+
+    @Override
+    public BossBarManager getBossBarManager() {
+        if (Configuration.isBossBarhandleEnabled())
+            return bossBarManager;
+        throw new RuntimeException("The BossBar manager isnt enabled in the configuration!");
+    }
 }
diff --git a/src/main/java/dev/wolveringer/network/channel/ChannelHandler.java b/src/main/java/dev/wolveringer/network/channel/ChannelHandler.java
index 5f1d243..e40efd5 100644
--- a/src/main/java/dev/wolveringer/network/channel/ChannelHandler.java
+++ b/src/main/java/dev/wolveringer/network/channel/ChannelHandler.java
@@ -1,10 +1,6 @@
 package dev.wolveringer.network.channel;
 
-import io.netty.channel.ChannelHandlerContext;
-import io.netty.handler.timeout.ReadTimeoutException;
-
-import java.io.IOException;
-import java.util.logging.Level;
+import com.google.common.base.Preconditions;
 
 import net.md_5.bungee.api.ProxyServer;
 import net.md_5.bungee.connection.CancelSendSignal;
@@ -16,106 +12,108 @@ import net.md_5.bungee.netty.PacketHandler;
 import net.md_5.bungee.protocol.BadPacketException;
 import net.md_5.bungee.protocol.PacketWrapper;
 
-import com.google.common.base.Preconditions;
+import java.io.IOException;
+import java.util.logging.Level;
 
 import dev.wolveringer.BungeeUtil.configuration.Configuration;
 import dev.wolveringer.chat.ChatColor.ChatColorUtils;
 import dev.wolveringer.network.IInitialHandler;
 import dev.wolveringer.strings.Messages;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.timeout.ReadTimeoutException;
 
 public class ChannelHandler extends HandlerBoss {
-	private ChannelWrapper channel;
-	private PacketHandler handler;
+    private ChannelWrapper channel;
+    private PacketHandler handler;
+
+    public ChannelHandler() {
+    }
 
-	public ChannelHandler() {
-	}
-	
-	private String formatColor(String in){
-		if(Configuration.isTerminalColored())
-			return in;
-		else
-			return ChatColorUtils.stripColor(in);
-	}
+    private String formatColor(String in) {
+        if (Configuration.isTerminalColored())
+            return in;
+        else
+            return ChatColorUtils.stripColor(in);
+    }
 
-	@Override
-	public void setHandler(PacketHandler handler) {
-		Preconditions.checkArgument(handler != null, "handler"); //$NON-NLS-1$
-		this.handler = handler;
-	}
+    @Override
+    public void setHandler(PacketHandler handler) {
+        Preconditions.checkArgument(handler != null, "handler"); //$NON-NLS-1$
+        this.handler = handler;
+    }
 
-	@Override
-	public void channelActive(ChannelHandlerContext ctx) throws Exception {
-		if(this.handler != null){
-			this.channel = new ChannelWrapper(ctx);
-			this.handler.connected(this.channel);
-			if((!(this.handler instanceof InitialHandler)) && (!(this.handler instanceof PingHandler))){
-				ProxyServer.getInstance().getLogger().log(Level.INFO, formatColor(Messages.getString("ChannelHandler.connection.connect")), this.handler); //$NON-NLS-1$
-			}
-		}
-	}
+    @Override
+    public void channelActive(ChannelHandlerContext ctx) throws Exception {
+        if (this.handler != null) {
+            this.channel = new ChannelWrapper(ctx);
+            this.handler.connected(this.channel);
+            if ((!(this.handler instanceof InitialHandler)) && (!(this.handler instanceof PingHandler))) {
+                ProxyServer.getInstance().getLogger().log(Level.INFO, formatColor(Messages.getString("ChannelHandler.connection.connect")), this.handler); //$NON-NLS-1$
+            }
+        }
+    }
 
-	@Override
-	public void channelInactive(ChannelHandlerContext ctx) throws Exception {
-		if(this.handler != null){
-			this.handler.disconnected(this.channel);
-			if((!(this.handler instanceof InitialHandler)) && (!(this.handler instanceof PingHandler))){
-				ProxyServer.getInstance().getLogger().log(Level.INFO, formatColor(Messages.getString("ChannelHandler.connection.disconnect")), this.handler); //$NON-NLS-1$
-			}
-		}
-	}
+    @Override
+    public void channelInactive(ChannelHandlerContext ctx) throws Exception {
+        if (this.handler != null) {
+            this.handler.disconnected(this.channel);
+            if ((!(this.handler instanceof InitialHandler)) && (!(this.handler instanceof PingHandler))) {
+                ProxyServer.getInstance().getLogger().log(Level.INFO, formatColor(Messages.getString("ChannelHandler.connection.disconnect")), this.handler); //$NON-NLS-1$
+            }
+        }
+    }
 
-	@Override
-	public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
-		if(this.handler != null){
-			try{
-				PacketWrapper packet = (PacketWrapper) msg;
-				boolean sendPacket = true;
-				try{
-					if(packet.packet != null){
-						try{
-							packet.packet.handle(this.handler);
-						}catch (CancelSendSignal ex){
-							sendPacket = false;
-						}
-					}
-					if(sendPacket){
-						this.handler.handle(packet);
-					}
-				}finally{
-					packet.trySingleRelease();
-				}
-			}catch (Exception e){
-				if(this.handler instanceof IInitialHandler){
-					((IInitialHandler)this.handler).disconnect(e);
-				}
-				else
-					this.channel.getHandle().close();
-				e.printStackTrace();
-			}
-		}
-	}
+    @Override
+    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
+        if (this.handler != null) {
+            try {
+                PacketWrapper packet = (PacketWrapper) msg;
+                boolean sendPacket = true;
+                try {
+                    if (packet.packet != null) {
+                        try {
+                            packet.packet.handle(this.handler);
+                        } catch (CancelSendSignal ex) {
+                            sendPacket = false;
+                        }
+                    }
+                    if (sendPacket) {
+                        this.handler.handle(packet);
+                    }
+                } finally {
+                    packet.trySingleRelease();
+                }
+            } catch (Exception e) {
+                if (this.handler instanceof IInitialHandler) {
+                    ((IInitialHandler) this.handler).disconnect(e);
+                } else
+                    this.channel.getHandle().close();
+                e.printStackTrace();
+            }
+        }
+    }
 
-	@Override
-	public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
-		if(ctx.channel().isActive()){
-			if((cause instanceof ReadTimeoutException)){
-				ProxyServer.getInstance().getLogger().log(Level.WARNING, formatColor(Messages.getString("ChannelHandler.connection.timeout")), this.handler); //$NON-NLS-1$
-			}else if((cause instanceof BadPacketException)){
-				ProxyServer.getInstance().getLogger().log(Level.WARNING, formatColor(Messages.getString("ChannelHandler.connection.bad-packet")), this.handler); //$NON-NLS-1$
-			}else if((cause instanceof IOException)){
-				ProxyServer.getInstance().getLogger().log(Level.WARNING, formatColor(Messages.getString("ChannelHandler.connection.IOException")), new Object[] { this.handler, cause.getMessage() }); //$NON-NLS-1$
-			}else{
-				ProxyServer.getInstance().getLogger().log(Level.SEVERE, this.handler + formatColor(Messages.getString("ChannelHandler.connection.encounteredException")), cause); //$NON-NLS-1$
-			}
+    @Override
+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
+        if (ctx.channel().isActive()) {
+            if ((cause instanceof ReadTimeoutException)) {
+                ProxyServer.getInstance().getLogger().log(Level.WARNING, formatColor(Messages.getString("ChannelHandler.connection.timeout")), this.handler); //$NON-NLS-1$
+            } else if ((cause instanceof BadPacketException)) {
+                ProxyServer.getInstance().getLogger().log(Level.WARNING, formatColor(Messages.getString("ChannelHandler.connection.bad-packet")), this.handler); //$NON-NLS-1$
+            } else if ((cause instanceof IOException)) {
+                ProxyServer.getInstance().getLogger().log(Level.WARNING, formatColor(Messages.getString("ChannelHandler.connection.IOException")), new Object[]{this.handler, cause.getMessage()}); //$NON-NLS-1$
+            } else {
+                ProxyServer.getInstance().getLogger().log(Level.SEVERE, this.handler + formatColor(Messages.getString("ChannelHandler.connection.encounteredException")), cause); //$NON-NLS-1$
+            }
 
-			if(this.handler != null){
-				try{
-					this.handler.exception(cause);
-				}catch (Exception ex){
-					ProxyServer.getInstance().getLogger().log(Level.SEVERE, this.handler + formatColor(Messages.getString("ChannelHandler.connection.progressingException")), ex); //$NON-NLS-1$
-				}
-			}
-			ctx.close();
-		}
-	}
+            if (this.handler != null) {
+                try {
+                    this.handler.exception(cause);
+                } catch (Exception ex) {
+                    ProxyServer.getInstance().getLogger().log(Level.SEVERE, this.handler + formatColor(Messages.getString("ChannelHandler.connection.progressingException")), ex); //$NON-NLS-1$
+                }
+            }
+            ctx.close();
+        }
+    }
 }
diff --git a/src/main/java/dev/wolveringer/network/channel/ChannelWrapper.java b/src/main/java/dev/wolveringer/network/channel/ChannelWrapper.java
index d3c101c..1e40aa3 100644
--- a/src/main/java/dev/wolveringer/network/channel/ChannelWrapper.java
+++ b/src/main/java/dev/wolveringer/network/channel/ChannelWrapper.java
@@ -1,19 +1,6 @@
 package dev.wolveringer.network.channel;
 
-import io.netty.buffer.ByteBufAllocator;
-import io.netty.channel.Channel;
-import io.netty.channel.ChannelFuture;
-import io.netty.channel.ChannelHandler;
-import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelPipeline;
-import io.netty.channel.ChannelProgressivePromise;
-import io.netty.channel.ChannelPromise;
-import io.netty.util.Attribute;
-import io.netty.util.AttributeKey;
-import io.netty.util.concurrent.EventExecutor;
-
-import java.lang.reflect.Field;
-import java.net.SocketAddress;
+import com.google.common.base.Preconditions;
 
 import net.md_5.bungee.compress.PacketCompressor;
 import net.md_5.bungee.compress.PacketDecompressor;
@@ -23,327 +10,339 @@ import net.md_5.bungee.protocol.MinecraftEncoder;
 import net.md_5.bungee.protocol.PacketWrapper;
 import net.md_5.bungee.protocol.Protocol;
 
-import com.google.common.base.Preconditions;
+import java.lang.reflect.Field;
+import java.net.SocketAddress;
 
 import dev.wolveringer.Reflect.Until;
 import dev.wolveringer.network.Decoder;
 import dev.wolveringer.network.Encoder;
 import dev.wolveringer.network.IInitialHandler;
+import io.netty.buffer.ByteBufAllocator;
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelFuture;
+import io.netty.channel.ChannelHandler;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelPipeline;
+import io.netty.channel.ChannelProgressivePromise;
+import io.netty.channel.ChannelPromise;
+import io.netty.util.Attribute;
+import io.netty.util.AttributeKey;
+import io.netty.util.concurrent.EventExecutor;
 
 public class ChannelWrapper extends net.md_5.bungee.netty.ChannelWrapper {
 
-	private Channel ch;
-	private IInitialHandler handler;
-	private volatile boolean closed;
-
-	public ChannelWrapper(net.md_5.bungee.netty.ChannelWrapper ctx, IInitialHandler h) {
-		super(new EmptyChannelWrapper());
-		this.handler = h;
-		try{
-			Field f = net.md_5.bungee.netty.ChannelWrapper.class.getDeclaredField("ch");
-			f.setAccessible(true);
-			this.ch = (Channel) f.get(ctx);
-		}catch (Exception e){
-			e.printStackTrace();
-		}
-	}
-	
-	public void setProtocol(Protocol protocol) {
-		if(ch.pipeline().get(MinecraftEncoder.class) != null)
-			ch.pipeline().get(MinecraftEncoder.class).setProtocol(protocol);
-		if(ch.pipeline().get(MinecraftDecoder.class) != null)
-			ch.pipeline().get(MinecraftDecoder.class).setProtocol(protocol);
-		if(ch.pipeline().get(Encoder.class) != null)
-			ch.pipeline().get(Encoder.class).setProtocol(protocol);
-		if(ch.pipeline().get(Decoder.class) != null)
-			ch.pipeline().get(Decoder.class).setProtocol(protocol);
-	}
-
-	public void setVersion(int protocol) {
-		if(ch.pipeline().get(MinecraftEncoder.class) != null)
-			ch.pipeline().get(MinecraftEncoder.class).setProtocolVersion(protocol);
-		if(ch.pipeline().get(MinecraftDecoder.class) != null)
-			ch.pipeline().get(MinecraftDecoder.class).setProtocolVersion(protocol);
-		if(ch.pipeline().get(Encoder.class) != null)
-			ch.pipeline().get(Encoder.class).setProtocolVersion(protocol);
-		if(ch.pipeline().get(Decoder.class) != null)
-			ch.pipeline().get(Decoder.class).setProtocolVersion(protocol);
-	}
-
-	public void write(Object packet) {
-		if(!closed && (handler.isConnected || (getProtocol() != Protocol.GAME))){
-			if(packet instanceof PacketWrapper){
-				((PacketWrapper) packet).setReleased(true);
-				ch.write(((PacketWrapper) packet).buf, ch.voidPromise());
-			}else{
-				ch.write(packet, ch.voidPromise());
-			}
-			ch.flush();
-		}
-	}
-
-	public Protocol getProtocol() {
-		if(handler.getEncoder() != null){
-			return Until.getProtocol(handler.getEncoder());
-		}else if(ch.pipeline().get(Decoder.class) != null){
-			System.out.print(ch.pipeline().get(Decoder.class).getProtocol());
-			return ch.pipeline().get(Decoder.class).getProtocol();
-		}else if(ch.pipeline().get(Encoder.class) != null){
-			return Until.getProtocol(ch.pipeline().get(Encoder.class));
-		}else if(ch.pipeline().get(MinecraftDecoder.class) != null){
-			return Until.getProtocol(ch.pipeline().get(MinecraftDecoder.class));
-		}else if(ch.pipeline().get(MinecraftEncoder.class) != null){
-			return Until.getProtocol(ch.pipeline().get(MinecraftEncoder.class));
-		}
-		return Protocol.GAME;
-	}
-
-	public void close() {
-		if(!closed){
-			closed = true;
-			ch.flush();
-			ch.close();
-		}
-	}
-
-	public void addBefore(String baseName, String name, ChannelHandler handler) {
-		try{
-			if(!ch.eventLoop().inEventLoop())
-				this.handler.disconnect("Error");
-			Preconditions.checkState(ch.eventLoop().inEventLoop(), "cannot add handler outside of event loop");
-			ch.pipeline().flush();
-			ch.pipeline().addBefore(baseName, name, handler);
-		}catch (Exception e){
-			this.handler.disconnect(e);
-		}
-	}
-
-	public Channel getHandle() {
-		return ch;
-	}
-
-	public void setCompressionThreshold(int compressionThreshold) {
-		if(ch.pipeline().get(PacketCompressor.class) == null && compressionThreshold != -1){
-			addBefore(PipelineUtils.PACKET_ENCODER, "compress", new PacketCompressor());
-		}
-
-		if(ch.pipeline().get(PacketDecompressor.class) == null && compressionThreshold != -1){
-			addBefore(PipelineUtils.PACKET_DECODER, "decompress", new PacketDecompressor());
-		}
-		if(compressionThreshold != -1){
-			ch.pipeline().get(PacketCompressor.class).setThreshold(compressionThreshold);
-		}else{
-			ch.pipeline().remove("compress");
-		}
-		if(compressionThreshold == -1){
-			ch.pipeline().remove("decompress");
-		}
-	}
+    private Channel ch;
+    private IInitialHandler handler;
+    private volatile boolean closed;
+
+    public ChannelWrapper(net.md_5.bungee.netty.ChannelWrapper ctx, IInitialHandler h) {
+        super(new EmptyChannelWrapper());
+        this.handler = h;
+        try {
+            Field f = net.md_5.bungee.netty.ChannelWrapper.class.getDeclaredField("ch");
+            f.setAccessible(true);
+            this.ch = (Channel) f.get(ctx);
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+    }
+
+    public void setVersion(int protocol) {
+        if (ch.pipeline().get(MinecraftEncoder.class) != null)
+            ch.pipeline().get(MinecraftEncoder.class).setProtocolVersion(protocol);
+        if (ch.pipeline().get(MinecraftDecoder.class) != null)
+            ch.pipeline().get(MinecraftDecoder.class).setProtocolVersion(protocol);
+        if (ch.pipeline().get(Encoder.class) != null)
+            ch.pipeline().get(Encoder.class).setProtocolVersion(protocol);
+        if (ch.pipeline().get(Decoder.class) != null)
+            ch.pipeline().get(Decoder.class).setProtocolVersion(protocol);
+    }
+
+    public void write(Object packet) {
+        if (!closed && (handler.isConnected || (getProtocol() != Protocol.GAME))) {
+            if (packet instanceof PacketWrapper) {
+                ((PacketWrapper) packet).setReleased(true);
+                ch.write(((PacketWrapper) packet).buf, ch.voidPromise());
+            } else {
+                ch.write(packet, ch.voidPromise());
+            }
+            ch.flush();
+        }
+    }
+
+    public Protocol getProtocol() {
+        if (handler.getEncoder() != null) {
+            return Until.getProtocol(handler.getEncoder());
+        } else if (ch.pipeline().get(Decoder.class) != null) {
+            System.out.print(ch.pipeline().get(Decoder.class).getProtocol());
+            return ch.pipeline().get(Decoder.class).getProtocol();
+        } else if (ch.pipeline().get(Encoder.class) != null) {
+            return Until.getProtocol(ch.pipeline().get(Encoder.class));
+        } else if (ch.pipeline().get(MinecraftDecoder.class) != null) {
+            return Until.getProtocol(ch.pipeline().get(MinecraftDecoder.class));
+        } else if (ch.pipeline().get(MinecraftEncoder.class) != null) {
+            return Until.getProtocol(ch.pipeline().get(MinecraftEncoder.class));
+        }
+        return Protocol.GAME;
+    }
+
+    public void setProtocol(Protocol protocol) {
+        if (ch.pipeline().get(MinecraftEncoder.class) != null)
+            ch.pipeline().get(MinecraftEncoder.class).setProtocol(protocol);
+        if (ch.pipeline().get(MinecraftDecoder.class) != null)
+            ch.pipeline().get(MinecraftDecoder.class).setProtocol(protocol);
+        if (ch.pipeline().get(Encoder.class) != null)
+            ch.pipeline().get(Encoder.class).setProtocol(protocol);
+        if (ch.pipeline().get(Decoder.class) != null)
+            ch.pipeline().get(Decoder.class).setProtocol(protocol);
+    }
+
+    public void close() {
+        if (!closed) {
+            closed = true;
+            ch.flush();
+            ch.close();
+        }
+    }
+
+    public void addBefore(String baseName, String name, ChannelHandler handler) {
+        try {
+            if (!ch.eventLoop().inEventLoop())
+                this.handler.disconnect("Error");
+            Preconditions.checkState(ch.eventLoop().inEventLoop(), "cannot add handler outside of event loop");
+            ch.pipeline().flush();
+            ch.pipeline().addBefore(baseName, name, handler);
+        } catch (Exception e) {
+            this.handler.disconnect(e);
+        }
+    }
+
+    public Channel getHandle() {
+        return ch;
+    }
+
+    public void setCompressionThreshold(int compressionThreshold) {
+        if (ch.pipeline().get(PacketCompressor.class) == null && compressionThreshold != -1) {
+            addBefore(PipelineUtils.PACKET_ENCODER, "compress", new PacketCompressor());
+        }
+
+        if (ch.pipeline().get(PacketDecompressor.class) == null && compressionThreshold != -1) {
+            addBefore(PipelineUtils.PACKET_DECODER, "decompress", new PacketDecompressor());
+        }
+        if (compressionThreshold != -1) {
+            ch.pipeline().get(PacketCompressor.class).setThreshold(compressionThreshold);
+        } else {
+            ch.pipeline().remove("compress");
+        }
+        if (compressionThreshold == -1) {
+            ch.pipeline().remove("decompress");
+        }
+    }
 
 }
 
 class EmptyChannelWrapper implements ChannelHandlerContext {
-	@Override
-	public <T> Attribute<T> attr(AttributeKey<T> paramAttributeKey) {
-		return null;
-	}
-
-	@Override
-	public Channel channel() {
-		return null;
-	}
-
-	@Override
-	public EventExecutor executor() {
-		return null;
-	}
-
-	@Override
-	public String name() {
-		return null;
-	}
-
-	@Override
-	public ChannelHandler handler() {
-		return null;
-	}
-
-	@Override
-	public boolean isRemoved() {
-		return false;
-	}
-
-	@Override
-	public ChannelHandlerContext fireChannelRegistered() {
-		return null;
-	}
-
-	@Override
-	public ChannelHandlerContext fireChannelUnregistered() {
-		return null;
-	}
-
-	@Override
-	public ChannelHandlerContext fireChannelActive() {
-		return null;
-	}
-
-	@Override
-	public ChannelHandlerContext fireChannelInactive() {
-		return null;
-	}
-
-	@Override
-	public ChannelHandlerContext fireExceptionCaught(Throwable paramThrowable) {
-		return null;
-	}
-
-	@Override
-	public ChannelHandlerContext fireUserEventTriggered(Object paramObject) {
-		return null;
-	}
-
-	@Override
-	public ChannelHandlerContext fireChannelRead(Object paramObject) {
-		return null;
-	}
-
-	@Override
-	public ChannelHandlerContext fireChannelReadComplete() {
-		return null;
-	}
-
-	@Override
-	public ChannelHandlerContext fireChannelWritabilityChanged() {
-		return null;
-	}
-
-	@Override
-	public ChannelFuture bind(SocketAddress paramSocketAddress) {
-		return null;
-	}
-
-	@Override
-	public ChannelFuture connect(SocketAddress paramSocketAddress) {
-		return null;
-	}
-
-	@Override
-	public ChannelFuture connect(SocketAddress paramSocketAddress1, SocketAddress paramSocketAddress2) {
-		return null;
-	}
-
-	@Override
-	public ChannelFuture disconnect() {
-		return null;
-	}
-
-	@Override
-	public ChannelFuture close() {
-		return null;
-	}
-
-	@Override
-	public ChannelFuture deregister() {
-		return null;
-	}
-
-	@Override
-	public ChannelFuture bind(SocketAddress paramSocketAddress, ChannelPromise paramChannelPromise) {
-		return null;
-	}
-
-	@Override
-	public ChannelFuture connect(SocketAddress paramSocketAddress, ChannelPromise paramChannelPromise) {
-		return null;
-	}
-
-	@Override
-	public ChannelFuture connect(SocketAddress paramSocketAddress1, SocketAddress paramSocketAddress2, ChannelPromise paramChannelPromise) {
-		return null;
-	}
-
-	@Override
-	public ChannelFuture disconnect(ChannelPromise paramChannelPromise) {
-		return null;
-	}
-
-	@Override
-	public ChannelFuture close(ChannelPromise paramChannelPromise) {
-		return null;
-	}
-
-	@Override
-	public ChannelFuture deregister(ChannelPromise paramChannelPromise) {
-		return null;
-	}
-
-	@Override
-	public ChannelHandlerContext read() {
-		return null;
-	}
-
-	@Override
-	public ChannelFuture write(Object paramObject) {
-		return null;
-	}
-
-	@Override
-	public ChannelFuture write(Object paramObject, ChannelPromise paramChannelPromise) {
-		return null;
-	}
-
-	@Override
-	public ChannelHandlerContext flush() {
-		return null;
-	}
-
-	@Override
-	public ChannelFuture writeAndFlush(Object paramObject, ChannelPromise paramChannelPromise) {
-		return null;
-	}
-
-	@Override
-	public ChannelFuture writeAndFlush(Object paramObject) {
-		return null;
-	}
-
-	@Override
-	public ChannelPipeline pipeline() {
-		return null;
-	}
-
-	@Override
-	public ByteBufAllocator alloc() {
-		return null;
-	}
-
-	@Override
-	public ChannelPromise newPromise() {
-		return null;
-	}
-
-	@Override
-	public ChannelProgressivePromise newProgressivePromise() {
-		return null;
-	}
-
-	@Override
-	public ChannelFuture newSucceededFuture() {
-		return null;
-	}
-
-	@Override
-	public ChannelFuture newFailedFuture(Throwable paramThrowable) {
-		return null;
-	}
-
-	@Override
-	public ChannelPromise voidPromise() {
-		return null;
-	}
-
-	public <T> boolean hasAttr(AttributeKey<T> arg0) {
-		return false;
-	}
+    @Override
+    public <T> Attribute<T> attr(AttributeKey<T> paramAttributeKey) {
+        return null;
+    }
+
+    @Override
+    public Channel channel() {
+        return null;
+    }
+
+    @Override
+    public EventExecutor executor() {
+        return null;
+    }
+
+    @Override
+    public String name() {
+        return null;
+    }
+
+    @Override
+    public ChannelHandler handler() {
+        return null;
+    }
+
+    @Override
+    public boolean isRemoved() {
+        return false;
+    }
+
+    @Override
+    public ChannelHandlerContext fireChannelRegistered() {
+        return null;
+    }
+
+    @Override
+    public ChannelHandlerContext fireChannelUnregistered() {
+        return null;
+    }
+
+    @Override
+    public ChannelHandlerContext fireChannelActive() {
+        return null;
+    }
+
+    @Override
+    public ChannelHandlerContext fireChannelInactive() {
+        return null;
+    }
+
+    @Override
+    public ChannelHandlerContext fireExceptionCaught(Throwable paramThrowable) {
+        return null;
+    }
+
+    @Override
+    public ChannelHandlerContext fireUserEventTriggered(Object paramObject) {
+        return null;
+    }
+
+    @Override
+    public ChannelHandlerContext fireChannelRead(Object paramObject) {
+        return null;
+    }
+
+    @Override
+    public ChannelHandlerContext fireChannelReadComplete() {
+        return null;
+    }
+
+    @Override
+    public ChannelHandlerContext fireChannelWritabilityChanged() {
+        return null;
+    }
+
+    @Override
+    public ChannelFuture bind(SocketAddress paramSocketAddress) {
+        return null;
+    }
+
+    @Override
+    public ChannelFuture connect(SocketAddress paramSocketAddress) {
+        return null;
+    }
+
+    @Override
+    public ChannelFuture connect(SocketAddress paramSocketAddress1, SocketAddress paramSocketAddress2) {
+        return null;
+    }
+
+    @Override
+    public ChannelFuture disconnect() {
+        return null;
+    }
+
+    @Override
+    public ChannelFuture close() {
+        return null;
+    }
+
+    @Override
+    public ChannelFuture deregister() {
+        return null;
+    }
+
+    @Override
+    public ChannelFuture bind(SocketAddress paramSocketAddress, ChannelPromise paramChannelPromise) {
+        return null;
+    }
+
+    @Override
+    public ChannelFuture connect(SocketAddress paramSocketAddress, ChannelPromise paramChannelPromise) {
+        return null;
+    }
+
+    @Override
+    public ChannelFuture connect(SocketAddress paramSocketAddress1, SocketAddress paramSocketAddress2, ChannelPromise paramChannelPromise) {
+        return null;
+    }
+
+    @Override
+    public ChannelFuture disconnect(ChannelPromise paramChannelPromise) {
+        return null;
+    }
+
+    @Override
+    public ChannelFuture close(ChannelPromise paramChannelPromise) {
+        return null;
+    }
+
+    @Override
+    public ChannelFuture deregister(ChannelPromise paramChannelPromise) {
+        return null;
+    }
+
+    @Override
+    public ChannelHandlerContext read() {
+        return null;
+    }
+
+    @Override
+    public ChannelFuture write(Object paramObject) {
+        return null;
+    }
+
+    @Override
+    public ChannelFuture write(Object paramObject, ChannelPromise paramChannelPromise) {
+        return null;
+    }
+
+    @Override
+    public ChannelHandlerContext flush() {
+        return null;
+    }
+
+    @Override
+    public ChannelFuture writeAndFlush(Object paramObject, ChannelPromise paramChannelPromise) {
+        return null;
+    }
+
+    @Override
+    public ChannelFuture writeAndFlush(Object paramObject) {
+        return null;
+    }
+
+    @Override
+    public ChannelPipeline pipeline() {
+        return null;
+    }
+
+    @Override
+    public ByteBufAllocator alloc() {
+        return null;
+    }
+
+    @Override
+    public ChannelPromise newPromise() {
+        return null;
+    }
+
+    @Override
+    public ChannelProgressivePromise newProgressivePromise() {
+        return null;
+    }
+
+    @Override
+    public ChannelFuture newSucceededFuture() {
+        return null;
+    }
+
+    @Override
+    public ChannelFuture newFailedFuture(Throwable paramThrowable) {
+        return null;
+    }
+
+    @Override
+    public ChannelPromise voidPromise() {
+        return null;
+    }
+
+    public <T> boolean hasAttr(AttributeKey<T> arg0) {
+        return false;
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/network/channel/init/BungeeConnectionInit.java b/src/main/java/dev/wolveringer/network/channel/init/BungeeConnectionInit.java
index b611672..0347ddc 100644
--- a/src/main/java/dev/wolveringer/network/channel/init/BungeeConnectionInit.java
+++ b/src/main/java/dev/wolveringer/network/channel/init/BungeeConnectionInit.java
@@ -1,6 +1,5 @@
 package dev.wolveringer.network.channel.init;
 
-import io.netty.channel.Channel;
 import net.md_5.bungee.BungeeCord;
 import net.md_5.bungee.api.ProxyServer;
 import net.md_5.bungee.connection.InitialHandler;
@@ -12,15 +11,17 @@ import net.md_5.bungee.protocol.MinecraftDecoder;
 import net.md_5.bungee.protocol.MinecraftEncoder;
 import net.md_5.bungee.protocol.Protocol;
 
+import io.netty.channel.Channel;
+
 public class BungeeConnectionInit extends ChannelInizializer {
-	@SuppressWarnings("deprecation")
-	@Override
-	public void initialize(Channel ch) throws Exception {
-		PipelineUtils.BASE.initChannel(ch);
-		ch.pipeline().addBefore(PipelineUtils.FRAME_DECODER, PipelineUtils.LEGACY_DECODER, new LegacyDecoder());
-		ch.pipeline().addAfter(PipelineUtils.FRAME_DECODER, PipelineUtils.PACKET_DECODER, new MinecraftDecoder(Protocol.HANDSHAKE, true, ProxyServer.getInstance().getProtocolVersion()));
-		ch.pipeline().addAfter(PipelineUtils.FRAME_PREPENDER, PipelineUtils.PACKET_ENCODER, new MinecraftEncoder(Protocol.HANDSHAKE, true, ProxyServer.getInstance().getProtocolVersion()));
-		ch.pipeline().addBefore(PipelineUtils.FRAME_PREPENDER, PipelineUtils.LEGACY_KICKER, new KickStringWriter());
-		ch.pipeline().get(HandlerBoss.class).setHandler(new InitialHandler(BungeeCord.getInstance(), ch.attr(PipelineUtils.LISTENER).get()));
-	}
+    @SuppressWarnings("deprecation")
+    @Override
+    public void initialize(Channel ch) throws Exception {
+        PipelineUtils.BASE.initChannel(ch);
+        ch.pipeline().addBefore(PipelineUtils.FRAME_DECODER, PipelineUtils.LEGACY_DECODER, new LegacyDecoder());
+        ch.pipeline().addAfter(PipelineUtils.FRAME_DECODER, PipelineUtils.PACKET_DECODER, new MinecraftDecoder(Protocol.HANDSHAKE, true, ProxyServer.getInstance().getProtocolVersion()));
+        ch.pipeline().addAfter(PipelineUtils.FRAME_PREPENDER, PipelineUtils.PACKET_ENCODER, new MinecraftEncoder(Protocol.HANDSHAKE, true, ProxyServer.getInstance().getProtocolVersion()));
+        ch.pipeline().addBefore(PipelineUtils.FRAME_PREPENDER, PipelineUtils.LEGACY_KICKER, new KickStringWriter());
+        ch.pipeline().get(HandlerBoss.class).setHandler(new InitialHandler(BungeeCord.getInstance(), ch.attr(PipelineUtils.LISTENER).get()));
+    }
 }
diff --git a/src/main/java/dev/wolveringer/network/channel/init/BungeeUtilChannelInit.java b/src/main/java/dev/wolveringer/network/channel/init/BungeeUtilChannelInit.java
index 43bd2c9..a1143b2 100644
--- a/src/main/java/dev/wolveringer/network/channel/init/BungeeUtilChannelInit.java
+++ b/src/main/java/dev/wolveringer/network/channel/init/BungeeUtilChannelInit.java
@@ -1,14 +1,5 @@
 package dev.wolveringer.network.channel.init;
 
-import io.netty.buffer.PooledByteBufAllocator;
-import io.netty.channel.Channel;
-import io.netty.channel.ChannelException;
-import io.netty.channel.ChannelOption;
-import io.netty.handler.timeout.ReadTimeoutHandler;
-
-import java.lang.reflect.Constructor;
-import java.lang.reflect.Field;
-
 import net.md_5.bungee.BungeeCord;
 import net.md_5.bungee.api.ProxyServer;
 import net.md_5.bungee.api.config.ListenerInfo;
@@ -22,114 +13,116 @@ import net.md_5.bungee.protocol.Protocol;
 import net.md_5.bungee.protocol.ProtocolConstants.Direction;
 import net.md_5.bungee.protocol.Varint21FrameDecoder;
 import net.md_5.bungee.protocol.Varint21LengthFieldPrepender;
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Field;
+
 import dev.wolveringer.BungeeUtil.BungeeUtil;
 import dev.wolveringer.network.Decoder;
 import dev.wolveringer.network.Encoder;
 import dev.wolveringer.network.channel.ChannelHandler;
+import io.netty.buffer.PooledByteBufAllocator;
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelException;
+import io.netty.channel.ChannelOption;
+import io.netty.handler.timeout.ReadTimeoutHandler;
+
+public class BungeeUtilChannelInit<T extends InitialHandler> extends ChannelInizializer {
+    public static final BungeeConnectionInit dinti = new BungeeConnectionInit();
+    protected Varint21LengthFieldPrepender framePrepender;
+    private Constructor<? extends InitialHandler> cons;
+
+    public BungeeUtilChannelInit(Class<T> handler) {
+        if (handler == null)
+            throw new NullPointerException();
+        try {
+            initFramePrender();
+            this.cons = handler.getConstructor(new Class[]{ProxyServer.class, ListenerInfo.class, Decoder.class, Encoder.class});
+        } catch (NoSuchMethodException | SecurityException e) {
+            e.printStackTrace();
+        }
+    }
+
+    private void initFramePrender() {
+        Field f = null;
+        try {
+            f = PipelineUtils.class.getDeclaredField("framePrepender");
+        } catch (NoSuchFieldException e1) {
+            e1.printStackTrace();
+        } catch (SecurityException e1) {
+            e1.printStackTrace();
+        }
+        f.setAccessible(true);
+        try {
+            framePrepender = (Varint21LengthFieldPrepender) f.get(null);
+        } catch (IllegalArgumentException | IllegalAccessException e) {
+            e.printStackTrace();
+        }
+    }
+
+    @SuppressWarnings("deprecation")
+    public void initialize(Channel ch) throws Exception {
+        initBaseChannel(ch);
+        try {
+            Decoder a = null;
+            Encoder b = null;
+            ch.pipeline().addBefore(PipelineUtils.FRAME_DECODER, PipelineUtils.LEGACY_DECODER, new LegacyDecoder());
+            ch.pipeline().addAfter("frame-prepender", "legacy-kick", new KickStringWriter());
+
+            ch.pipeline().addAfter("frame-decoder", "packet-decoder", a = new Decoder(Protocol.HANDSHAKE, true, ProxyServer.getInstance().getProtocolVersion(), null, Direction.TO_SERVER));
+            ch.pipeline().addAfter("frame-prepender", "packet-encoder", b = new Encoder(Protocol.HANDSHAKE, true, ProxyServer.getInstance().getProtocolVersion(), null));
+
+            ch.pipeline().get(HandlerBoss.class).setHandler(createInitialHandler(ch, b, a));
+        } catch (Throwable e) {
+            if (e instanceof NoClassDefFoundError) {
+                throwClassNotFoundError((ClassNotFoundException) e);
+                return;
+            }
+            e.printStackTrace();
+        }
+    }
+
+    public void initBaseChannel(Channel ch) {
+        try {
+            ch.config().setOption(ChannelOption.IP_TOS, Integer.valueOf(24));
+        } catch (ChannelException ex) {
+        }
+        ch.config().setAllocator(PooledByteBufAllocator.DEFAULT);
+        ch.pipeline().addLast("timeout", new ReadTimeoutHandler(BungeeCord.getInstance().config.getTimeout(), java.util.concurrent.TimeUnit.MILLISECONDS));
+        ch.pipeline().addLast("frame-decoder", new Varint21FrameDecoder());
+        ch.pipeline().addLast("frame-prepender", framePrepender);
+        ch.pipeline().addLast("inbound-boss", new ChannelHandler());
+    }
+
+    @SuppressWarnings("deprecation")
+    public void throwClassNotFoundError(ClassNotFoundException exception) {
+        BungeeCord.getInstance().getConsole().sendMessage("" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "7[BungeeUntil" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "7] " + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "cBungeeUntil cant load some Classes!");
+        BungeeCord.getInstance().getConsole().sendMessage("" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "7[BungeeUntil" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "7] " + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "cDisable BungeeUntil!");
+        try {
+            setStaticFinalValue(PipelineUtils.class.getDeclaredField("SERVER_CHILD"), dinti);
+        } catch (Exception ex) {
+            ex.printStackTrace();
+            BungeeCord.getInstance().getConsole().sendMessage("" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "7[BungeeUntil" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "7] " + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "cError while setting default ConnectionHandler.");
+            BungeeCord.getInstance().getConsole().sendMessage("" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "7[BungeeUntil" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "7] " + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "cRestarting BungeeCord!");
+            BungeeCord.getInstance().stop();
+            return;
+        }
+        BungeeCord.getInstance().getPluginManager().unregisterListeners(BungeeUtil.getPluginInstance()); //TODO onley bungeeutil
+        BungeeUtil.getInstance().disable();
+        for (ProxiedPlayer p : BungeeCord.getInstance().getPlayers())
+            p.disconnect("" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "cBungeeUntil Class error");
+        BungeeCord.getInstance().getConsole().sendMessage("" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "7[BungeeUntil" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "7] " + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "cBungeeUntil is disabled!");
+    }
+
+    public T createInitialHandler(Channel ch, Encoder e, Decoder d) throws Exception {
+        return (T) this.cons.newInstance(new Object[]{ProxyServer.getInstance(), ch.attr(PipelineUtils.LISTENER).get(), d, e});
+    }
 
-public class BungeeUtilChannelInit <T extends InitialHandler> extends ChannelInizializer {
-	protected Varint21LengthFieldPrepender framePrepender;
-	
-	public static final BungeeConnectionInit dinti = new BungeeConnectionInit();
-	private Constructor<? extends InitialHandler> cons;
-	
-	public BungeeUtilChannelInit(Class<T> handler) {
-		if(handler == null)
-			throw new NullPointerException();
-		try {
-			initFramePrender();
-			this.cons = handler.getConstructor(new Class[] { ProxyServer.class, ListenerInfo.class, Decoder.class, Encoder.class });
-		}
-		catch (NoSuchMethodException | SecurityException e) {
-			e.printStackTrace();
-		}
-	}
-	
-	private void initFramePrender() {
-		Field f = null;
-		try {
-			f = PipelineUtils.class.getDeclaredField("framePrepender");
-		}
-		catch (NoSuchFieldException e1) {
-			e1.printStackTrace();
-		}
-		catch (SecurityException e1) {
-			e1.printStackTrace();
-		}
-		f.setAccessible(true); 
-		try {
-			framePrepender = (Varint21LengthFieldPrepender) f.get(null);
-		} catch (IllegalArgumentException | IllegalAccessException e) {
-			e.printStackTrace();
-		}
-	}
-	
-	@SuppressWarnings("deprecation")
-	public void initialize(Channel ch) throws Exception {
-		initBaseChannel(ch);
-		try {
-			Decoder a = null;
-			Encoder b = null;
-			ch.pipeline().addBefore(PipelineUtils.FRAME_DECODER, PipelineUtils.LEGACY_DECODER, new LegacyDecoder());
-			ch.pipeline().addAfter("frame-prepender", "legacy-kick", new KickStringWriter());
-			
-			ch.pipeline().addAfter("frame-decoder", "packet-decoder", a = new Decoder(Protocol.HANDSHAKE, true, ProxyServer.getInstance().getProtocolVersion(), null, Direction.TO_SERVER));
-			ch.pipeline().addAfter("frame-prepender", "packet-encoder", b = new Encoder(Protocol.HANDSHAKE, true, ProxyServer.getInstance().getProtocolVersion(), null));
-			
-			ch.pipeline().get(HandlerBoss.class).setHandler(createInitialHandler(ch, b, a));
-		}
-		catch (Throwable e) {
-			if (e instanceof NoClassDefFoundError) {
-				throwClassNotFoundError((ClassNotFoundException) e);
-				return;
-			}
-			e.printStackTrace();
-		}
-	}
-	
-	public void initBaseChannel(Channel ch) {
-		try {
-			ch.config().setOption(ChannelOption.IP_TOS, Integer.valueOf(24));
-		}
-		catch (ChannelException ex) {
-		}
-		ch.config().setAllocator(PooledByteBufAllocator.DEFAULT);
-		ch.pipeline().addLast("timeout", new ReadTimeoutHandler(BungeeCord.getInstance().config.getTimeout(), java.util.concurrent.TimeUnit.MILLISECONDS));
-		ch.pipeline().addLast("frame-decoder", new Varint21FrameDecoder());
-		ch.pipeline().addLast("frame-prepender", framePrepender);
-		ch.pipeline().addLast("inbound-boss", new ChannelHandler());
-	}
-	
-	@SuppressWarnings("deprecation")
-	public void throwClassNotFoundError(ClassNotFoundException exception) {
-		BungeeCord.getInstance().getConsole().sendMessage(""+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"7[BungeeUntil"+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"7] "+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"cBungeeUntil cant load some Classes!");
-		BungeeCord.getInstance().getConsole().sendMessage(""+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"7[BungeeUntil"+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"7] "+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"cDisable BungeeUntil!");
-		try {
-			setStaticFinalValue(PipelineUtils.class.getDeclaredField("SERVER_CHILD"), dinti);
-		}
-		catch (Exception ex) {
-			ex.printStackTrace();
-			BungeeCord.getInstance().getConsole().sendMessage(""+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"7[BungeeUntil"+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"7] "+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"cError while setting default ConnectionHandler.");
-			BungeeCord.getInstance().getConsole().sendMessage(""+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"7[BungeeUntil"+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"7] "+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"cRestarting BungeeCord!");
-			BungeeCord.getInstance().stop();
-			return;
-		}
-		BungeeCord.getInstance().getPluginManager().unregisterListeners(BungeeUtil.getPluginInstance()); //TODO onley bungeeutil
-		BungeeUtil.getInstance().disable();
-		for (ProxiedPlayer p : BungeeCord.getInstance().getPlayers())
-			p.disconnect(""+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"cBungeeUntil Class error");
-		BungeeCord.getInstance().getConsole().sendMessage(""+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"7[BungeeUntil"+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"7] "+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"cBungeeUntil is disabled!");
-	}
-	
-	public T createInitialHandler(Channel ch, Encoder e, Decoder d) throws Exception {
-		return (T) this.cons.newInstance(new Object[] { ProxyServer.getInstance(), ch.attr(PipelineUtils.LISTENER).get(), d, e });
-	}
-	
-	private void setStaticFinalValue(Field f, Object n) throws Exception {
-		f.setAccessible(true);
-		Field modifiersField = Field.class.getDeclaredField("modifiers");
-		modifiersField.setAccessible(true);
-		modifiersField.setInt(f, f.getModifiers() & 0xFFFFFFEF);
-		f.set(null, n);
-	}
+    private void setStaticFinalValue(Field f, Object n) throws Exception {
+        f.setAccessible(true);
+        Field modifiersField = Field.class.getDeclaredField("modifiers");
+        modifiersField.setAccessible(true);
+        modifiersField.setInt(f, f.getModifiers() & 0xFFFFFFEF);
+        f.set(null, n);
+    }
 }
diff --git a/src/main/java/dev/wolveringer/network/channel/init/ChannelInizializer.java b/src/main/java/dev/wolveringer/network/channel/init/ChannelInizializer.java
index e6d8d05..20185cc 100644
--- a/src/main/java/dev/wolveringer/network/channel/init/ChannelInizializer.java
+++ b/src/main/java/dev/wolveringer/network/channel/init/ChannelInizializer.java
@@ -1,59 +1,58 @@
 package dev.wolveringer.network.channel.init;
 
-import io.netty.channel.Channel;
-import io.netty.channel.ChannelInitializer;
+import net.md_5.bungee.BungeeCord;
+import net.md_5.bungee.netty.PipelineUtils;
 
 import java.lang.reflect.Field;
 import java.lang.reflect.Modifier;
 
-import net.md_5.bungee.BungeeCord;
-import net.md_5.bungee.netty.PipelineUtils;
 import dev.wolveringer.BungeeUtil.BungeeUtil;
 import dev.wolveringer.chat.ChatColor.ChatColorUtils;
 import dev.wolveringer.network.IIInitialHandler;
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelInitializer;
 
 public abstract class ChannelInizializer extends ChannelInitializer<Channel> {
-	private static ChannelInizializer init;
-	
-	public static ChannelInizializer getChannelInitializer(){
-		return init;
-	}
-	
-	public static void setChannelInitializer(ChannelInizializer init) {
-		BungeeUtil.getInstance().sendMessage("Set channel inizializer to "+init.getClass().getName());
-		ChannelInizializer.init = init;
-	}
-	
-	@Override
-	protected void initChannel(Channel channel) throws Exception {
-		ChannelInizializer.init.initialize(channel);
-	}
-	
-	public abstract void initialize(Channel channel) throws Exception;
-	
-	public static void init() {
-		if(init == null)
-			setChannelInitializer(new BungeeUtilChannelInit<IIInitialHandler>(IIInitialHandler.class));
-		try {
-			setStaticFinalValue(PipelineUtils.class.getDeclaredField("SERVER_CHILD"), new ChannelInizializer() {
-				@Override
-				public void initialize(Channel channel) throws Exception {
-					throw new NullPointerException();
-				}
-			});
-		}
-		catch (Exception e) {
-			e.printStackTrace();
-			BungeeCord.getInstance().getConsole().sendMessage(ChatColorUtils.COLOR_CHAR+"e"+ChatColorUtils.COLOR_CHAR+"7[BungeeUntil"+ChatColorUtils.COLOR_CHAR+"7] "+ChatColorUtils.COLOR_CHAR+"cError while loading ProtocolLIB "+ChatColorUtils.COLOR_CHAR+"4Code: 002");
-			BungeeCord.getInstance().getConsole().sendMessage(ChatColorUtils.COLOR_CHAR+"e"+ChatColorUtils.COLOR_CHAR+"7[BungeeUntil"+ChatColorUtils.COLOR_CHAR+"7] "+ChatColorUtils.COLOR_CHAR+"cDisable ProtocolLIB");
-		}
-	}
-	
-	private static void setStaticFinalValue(Field f, Object n) throws Exception {
-		f.setAccessible(true);
-		Field modifiersField = Field.class.getDeclaredField("modifiers");
-		modifiersField.setAccessible(true);
-		modifiersField.setInt(f, f.getModifiers() & ~Modifier.FINAL);
-		f.set(null, n);
-	}
+    private static ChannelInizializer init;
+
+    public static ChannelInizializer getChannelInitializer() {
+        return init;
+    }
+
+    public static void setChannelInitializer(ChannelInizializer init) {
+        BungeeUtil.getInstance().sendMessage("Set channel inizializer to " + init.getClass().getName());
+        ChannelInizializer.init = init;
+    }
+
+    public static void init() {
+        if (init == null)
+            setChannelInitializer(new BungeeUtilChannelInit<IIInitialHandler>(IIInitialHandler.class));
+        try {
+            setStaticFinalValue(PipelineUtils.class.getDeclaredField("SERVER_CHILD"), new ChannelInizializer() {
+                @Override
+                public void initialize(Channel channel) throws Exception {
+                    throw new NullPointerException();
+                }
+            });
+        } catch (Exception e) {
+            e.printStackTrace();
+            BungeeCord.getInstance().getConsole().sendMessage(ChatColorUtils.COLOR_CHAR + "e" + ChatColorUtils.COLOR_CHAR + "7[BungeeUntil" + ChatColorUtils.COLOR_CHAR + "7] " + ChatColorUtils.COLOR_CHAR + "cError while loading ProtocolLIB " + ChatColorUtils.COLOR_CHAR + "4Code: 002");
+            BungeeCord.getInstance().getConsole().sendMessage(ChatColorUtils.COLOR_CHAR + "e" + ChatColorUtils.COLOR_CHAR + "7[BungeeUntil" + ChatColorUtils.COLOR_CHAR + "7] " + ChatColorUtils.COLOR_CHAR + "cDisable ProtocolLIB");
+        }
+    }
+
+    private static void setStaticFinalValue(Field f, Object n) throws Exception {
+        f.setAccessible(true);
+        Field modifiersField = Field.class.getDeclaredField("modifiers");
+        modifiersField.setAccessible(true);
+        modifiersField.setInt(f, f.getModifiers() & ~Modifier.FINAL);
+        f.set(null, n);
+    }
+
+    @Override
+    protected void initChannel(Channel channel) throws Exception {
+        ChannelInizializer.init.initialize(channel);
+    }
+
+    public abstract void initialize(Channel channel) throws Exception;
 }
diff --git a/src/main/java/dev/wolveringer/network/inject/XChannelFutureListener.java b/src/main/java/dev/wolveringer/network/inject/XChannelFutureListener.java
index 3c44458..9459825 100644
--- a/src/main/java/dev/wolveringer/network/inject/XChannelFutureListener.java
+++ b/src/main/java/dev/wolveringer/network/inject/XChannelFutureListener.java
@@ -1,7 +1,5 @@
 package dev.wolveringer.network.inject;
 
-import io.netty.channel.ChannelFuture;
-import io.netty.channel.ChannelFutureListener;
 import net.md_5.bungee.BungeeCord;
 import net.md_5.bungee.BungeeServerInfo;
 import net.md_5.bungee.UserConnection;
@@ -9,39 +7,42 @@ import net.md_5.bungee.api.Callback;
 import net.md_5.bungee.api.ProxyServer;
 import net.md_5.bungee.api.config.ServerInfo;
 
+import io.netty.channel.ChannelFuture;
+import io.netty.channel.ChannelFutureListener;
+
 public class XChannelFutureListener implements ChannelFutureListener {
-	Callback<Boolean> callback;
-	UserConnection conn;
-	BungeeServerInfo target;
-	boolean retry;
-
-	public XChannelFutureListener(Callback<Boolean> callback, UserConnection conn, BungeeServerInfo target, boolean retry) {
-		this.callback = callback;
-		this.conn = conn;
-		this.target = target;
-		this.retry = retry;
-	}
-
-	public void operationComplete(ChannelFuture future) throws Exception {
-		if(callback != null){
-			callback.done(Boolean.valueOf(future.isSuccess()), future.cause());
-		}
-		if(future.isSuccess()){
-			
-			return;
-		}
-		future.channel().close();
-		conn.getPendingConnects().remove(target);
-
-		ServerInfo def = (ServerInfo) ProxyServer.getInstance().getServers().get(conn.getPendingConnection().getListener().getFallbackServer());
-		if((retry) && (target != def) && (((conn.getServer() == null) || (def != conn.getServer().getInfo())))){
-			conn.sendMessage(BungeeCord.getInstance().getTranslation("fallback_lobby", new Object[0]));
-			conn.connect(def, null, false);
-
-		}else if(conn.isDimensionChange()){
-			conn.disconnect(BungeeCord.getInstance().getTranslation("fallback_kick", new Object[] { future.cause().getClass().getName() }));
-		}else{
-			conn.sendMessage(BungeeCord.getInstance().getTranslation("fallback_kick", new Object[] { future.cause().getClass().getName() }));
-		}
-	}
+    Callback<Boolean> callback;
+    UserConnection conn;
+    BungeeServerInfo target;
+    boolean retry;
+
+    public XChannelFutureListener(Callback<Boolean> callback, UserConnection conn, BungeeServerInfo target, boolean retry) {
+        this.callback = callback;
+        this.conn = conn;
+        this.target = target;
+        this.retry = retry;
+    }
+
+    public void operationComplete(ChannelFuture future) throws Exception {
+        if (callback != null) {
+            callback.done(Boolean.valueOf(future.isSuccess()), future.cause());
+        }
+        if (future.isSuccess()) {
+
+            return;
+        }
+        future.channel().close();
+        conn.getPendingConnects().remove(target);
+
+        ServerInfo def = (ServerInfo) ProxyServer.getInstance().getServers().get(conn.getPendingConnection().getListener().getFallbackServer());
+        if ((retry) && (target != def) && (((conn.getServer() == null) || (def != conn.getServer().getInfo())))) {
+            conn.sendMessage(BungeeCord.getInstance().getTranslation("fallback_lobby", new Object[0]));
+            conn.connect(def, null, false);
+
+        } else if (conn.isDimensionChange()) {
+            conn.disconnect(BungeeCord.getInstance().getTranslation("fallback_kick", new Object[]{future.cause().getClass().getName()}));
+        } else {
+            conn.sendMessage(BungeeCord.getInstance().getTranslation("fallback_kick", new Object[]{future.cause().getClass().getName()}));
+        }
+    }
 }
diff --git a/src/main/java/dev/wolveringer/network/inject/XChannelInitializer.java b/src/main/java/dev/wolveringer/network/inject/XChannelInitializer.java
index beb258a..7c1c6ed 100644
--- a/src/main/java/dev/wolveringer/network/inject/XChannelInitializer.java
+++ b/src/main/java/dev/wolveringer/network/inject/XChannelInitializer.java
@@ -1,7 +1,5 @@
 package dev.wolveringer.network.inject;
 
-import io.netty.channel.Channel;
-import io.netty.channel.ChannelInitializer;
 import net.md_5.bungee.BungeeCord;
 import net.md_5.bungee.BungeeServerInfo;
 import net.md_5.bungee.ServerConnector;
@@ -12,22 +10,25 @@ import net.md_5.bungee.netty.PipelineUtils;
 import net.md_5.bungee.protocol.MinecraftEncoder;
 import net.md_5.bungee.protocol.Protocol;
 import net.md_5.bungee.protocol.ProtocolConstants.Direction;
+
 import dev.wolveringer.network.Decoder;
 import dev.wolveringer.network.IInitialHandler;
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelInitializer;
 
 public class XChannelInitializer extends ChannelInitializer<Channel> {
-	UserConnection conn;
-	ServerInfo target;
+    UserConnection conn;
+    ServerInfo target;
 
-	public XChannelInitializer(UserConnection conn, ServerInfo target) {
-		this.conn = conn;
-		this.target = target;
-	}
+    public XChannelInitializer(UserConnection conn, ServerInfo target) {
+        this.conn = conn;
+        this.target = target;
+    }
 
-	public void initChannel(Channel ch) throws Exception {
-		PipelineUtils.BASE.initChannel(ch);
-		ch.pipeline().addAfter("frame-decoder", "packet-decoder", new Decoder(Protocol.HANDSHAKE, false, conn.getPendingConnection().getVersion(),(IInitialHandler) conn.getPendingConnection(),Direction.TO_CLIENT)); //
-		ch.pipeline().addAfter("frame-prepender", "packet-encoder", new MinecraftEncoder(Protocol.HANDSHAKE, false, conn.getPendingConnection().getVersion()));
-		((HandlerBoss) ch.pipeline().get(HandlerBoss.class)).setHandler(new ServerConnector(BungeeCord.getInstance(), conn, (BungeeServerInfo) target));
-	}
+    public void initChannel(Channel ch) throws Exception {
+        PipelineUtils.BASE.initChannel(ch);
+        ch.pipeline().addAfter("frame-decoder", "packet-decoder", new Decoder(Protocol.HANDSHAKE, false, conn.getPendingConnection().getVersion(), (IInitialHandler) conn.getPendingConnection(), Direction.TO_CLIENT)); //
+        ch.pipeline().addAfter("frame-prepender", "packet-encoder", new MinecraftEncoder(Protocol.HANDSHAKE, false, conn.getPendingConnection().getVersion()));
+        ((HandlerBoss) ch.pipeline().get(HandlerBoss.class)).setHandler(new ServerConnector(BungeeCord.getInstance(), conn, (BungeeServerInfo) target));
+    }
 }
diff --git a/src/main/java/dev/wolveringer/packet/ByteBuffCreator.java b/src/main/java/dev/wolveringer/packet/ByteBuffCreator.java
index 0a9fd4b..1059c27 100644
--- a/src/main/java/dev/wolveringer/packet/ByteBuffCreator.java
+++ b/src/main/java/dev/wolveringer/packet/ByteBuffCreator.java
@@ -1,32 +1,32 @@
 package dev.wolveringer.packet;
 
+import dev.wolveringer.BungeeUtil.configuration.Configuration;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
-import dev.wolveringer.BungeeUtil.configuration.Configuration;
 
 public class ByteBuffCreator {
-	@SuppressWarnings("serial")
-	private static final class ByteBuffTypeNotFoundException extends RuntimeException {
-		ByteBuffTypeNotFoundException(String message) {
-			super(message);
-		}
-	}
+    public static ByteBuf createByteBuff() {
+        switch (Configuration.getByteBuffType().toLowerCase()) {
+            case "direct":
+                return Unpooled.directBuffer();
+            case "heap":
+                return Unpooled.buffer();
+            default:
+                throw new ByteBuffTypeNotFoundException("ByteBuff Type '" + Configuration.getByteBuffType().toLowerCase() + "' is missing");
+        }
+    }
 
-	public static ByteBuf createByteBuff() {
-		switch (Configuration.getByteBuffType().toLowerCase()) {
-			case "direct":
-				return Unpooled.directBuffer();
-			case "heap":
-				return Unpooled.buffer();
-			default:
-				throw new ByteBuffTypeNotFoundException("ByteBuff Type '" + Configuration.getByteBuffType().toLowerCase() + "' is missing");
-		}
-	}
+    public static void copy(ByteBuf from, ByteBuf to) {
+        byte[] buff = new byte[from.readableBytes()];
+        from.readBytes(buff);
+        to.writeBytes(buff);
 
-	public static void copy(ByteBuf from, ByteBuf to) {
-		byte[] buff = new byte[from.readableBytes()];
-		from.readBytes(buff);
-		to.writeBytes(buff);
+    }
 
-	}
+    @SuppressWarnings("serial")
+    private static final class ByteBuffTypeNotFoundException extends RuntimeException {
+        ByteBuffTypeNotFoundException(String message) {
+            super(message);
+        }
+    }
 }
diff --git a/src/main/java/dev/wolveringer/packet/DebugMenue.java b/src/main/java/dev/wolveringer/packet/DebugMenue.java
index a3aa3d0..e2b7bdd 100644
--- a/src/main/java/dev/wolveringer/packet/DebugMenue.java
+++ b/src/main/java/dev/wolveringer/packet/DebugMenue.java
@@ -48,10 +48,10 @@ import dev.wolveringer.profiler.ProfileMenue;
 import dev.wolveringer.profiler.Profiler;
 
 public class DebugMenue {
-	public static void open(Player player){
+	public static void open(Player player) {
 		Profiler.packet_handle.start("buildDebugInventory");
 		final Inventory inv = new Inventory(27, ChatColorUtils.COLOR_CHAR + "b" + ChatColorUtils.COLOR_CHAR + "lDeveloper Menue");
-		
+
 		player.openInventory(inv);
 		ItemStack i = new ItemStack(Material.DIAMOND) {
 			@Override
@@ -63,7 +63,7 @@ public class DebugMenue {
 		i.getItemMeta().setDisplayName(ChatColorUtils.COLOR_CHAR + "bYEY");
 		i.getItemMeta().setLore(Arrays.asList(ChatColorUtils.COLOR_CHAR + "aDieser Server nutzt", ChatColorUtils.COLOR_CHAR + "adein Plugin: ", " " + ChatColorUtils.COLOR_CHAR + "7- " + ChatColorUtils.COLOR_CHAR + "eBungeeUntil", " " + ChatColorUtils.COLOR_CHAR + "7- " + ChatColorUtils.COLOR_CHAR + "eVerion " + ChatColorUtils.COLOR_CHAR + "b" + BungeeUtil.getPluginInstance().getDescription().getVersion()));
 		inv.setItem(1, i);
-		
+
 		i = new ItemStack(159, 1, (short) 14) {
 			@Override
 			public void click(final Click p) {
@@ -89,7 +89,7 @@ public class DebugMenue {
 					public void rightClick(Player p) {
 						p.sendMessage("rightClick");
 					}
-					
+
 					@Override
 					public void leftClick(Player p) {
 						p.sendMessage("leftClick");
@@ -106,53 +106,53 @@ public class DebugMenue {
 				c.getEquipment().setHelmet(new dev.wolveringer.BungeeUtil.item.Item(Material.LEATHER_HELMET));
 				Skin s = SkinFactory.getSkin("WolverinGER");
 				BungeeUtil.getInstance().sendMessage(s + "");
-				
+
 				GameProfile profile = s.applay(c.getProfile());
-				
+
 				BungeeUtil.getInstance().sendMessage(s + "");
 				BungeeUtil.getInstance().sendMessage(profile + "");
-				
+
 				c.setProfile(profile);
 				c.setVisiable(p.getPlayer(), true);
 				ParticleEffect.HEART.display(0F, 0F, 1F, 0F, 1, c.getLocation(), p.getPlayer());
 				p.getPlayer().sendMessage("NCP is visiable");
-				
+
 				NPC npc = new NPC();
 				npc.setPing(1);
-		        npc.setPlayerListName(new ChatComponentText("\u00A7a-----NPC----"));
-		        npc.setTabListed(true);
-		        Item item = new Item(Material.WATCH);
-		        item.getItemMeta().setGlow(true);
-		        npc.getEquipment().setItemInHand(item);
-		        PropertyMap pm = new PropertyMap();
-		        pm.put("\u00A7c\u795E\u5947\u7684NPC", new Property("textures",
-		                "eyJ0aW1lc3RhbXAiOjE0NTg0NTMxNjM3MDksInByb2ZpbGVJZCI6ImNhZWZmYmFhMzdhZDRhYjI5Mjg5NGQxZDEzOTk4YTg5IiwicHJvZmlsZU5hbWUiOiJ3YXlfX3plciIsInNpZ25hdHVyZVJlcXVpcmVkIjp0cnVlLCJ0ZXh0dXJlcyI6eyJTS0lOIjp7InVybCI6Imh0dHA6Ly90ZXh0dXJlcy5taW5lY3JhZnQubmV0L3RleHR1cmUvYmQzYzdmN2E3ZjIyZTU5NDIxYzRkZDI3NjY2ZDVlZTlmYzc4MTEwODE3MTU3MmQxYzRlMzZkMzhmMjZjOWQzIn19fQ==",
-		                "ofNqZSqPhaWL4b8mHRUpv+vUVw3bqXH1mhvoZzyaxXOTE4TqXfapJRTmct4KV5r25ezW9in9zryaadGX4yueERYZzUkVj5MJqduI44z/rqc1oy4NSTqRAHzaka6PWD/DZyG8kySKhDXBhwEKKeGTHUAeohbLtyfvs3FRLxMf6GkyEzibM32hj65eln9itaqKH6uU9l7bzjPfNx3RlLOg2LbmdBIajXffSDQBgklSOg/v/7OiD5fXYREWzYPNex5Iiw8id0NFTTpQE4Dvrv31ijXcnWsS4Mp62+zPYponsloPynZ9AqQaXVeuLJQhSwJktkavThqz9dfaS9+IGn1Ko7AUhFyLxWjqbet6M7sKd29sqlWbdxB8LMh6I+RMNb9Tx4yKa0EeedFHXfYMaURs2TdPMO2QtiM3nG+IieaXaZwh64wyf/u3iuu3sNd4/s1JmOM9nVYvVaIQVsT80HW/NQwz/N+ufJOh4L7unTt/Jlwm4DkldaTKzUiuVLB4ypYON2/Pa1dXBgRZbU7dCwjXuAL/Cox1UKqYcq3uEuCKhBWYFdEe2p7NDNTuFhjX38MP+h94SlFjbfaSpzDegjr92qO8r41JqpcyewQYI2fkwk8Ju9AJDMTpeoA6ofHEzAMhajXkViKvUPoPbl4HUDvtRBZu5k8dggWKQ83v1UXsDxQ="));
-		        npc.getProfile().setProperties(pm);
-		        HumanDataWatcher dw = npc.getDatawatcher();
-		        dw.setParicelColor(1224755642);
-		        dw.setSkinFlags((byte) 127);
-		        npc.setName("\u00A7c\u795E\u5947\u7684NPC");
-		        npc.addListener(new InteractListener() {
-
-		            @Override
-		            public void rightClick(Player p) {
-		                    p.sendMessage(new TextComponent("\u00A7c\u00A7l[NPC] \u00A7cHI! \u00A7c\u00A7l" + p.getDisplayName() + "  \u00A7c\u00A7l\u8BF7\u5148\u767B\u5F55,\u518D\u5C1D\u8BD5\u6253\u5F00"));
-		            }
-
-		            @Override
-		            public void leftClick(Player p) {
-		                p.sendMessage(new TextComponent("\u00A7c\u00A7l[NPC] \u00A7cHI! \u00A7c\u00A7l" + p.getDisplayName() + "  \u00A7a\u6B22\u8FCE\u6765\u5230MFT\u670D\u52A1\u5668"));
-		            }
-		        });
-
-		        npc.setLocation(p.getPlayer().getLocation().add(0, 5, 0));
-		        npc.setVisiable(p.getPlayer(), true);
+				npc.setPlayerListName(new ChatComponentText("\u00A7a-----NPC----"));
+				npc.setTabListed(true);
+				Item item = new Item(Material.WATCH);
+				item.getItemMeta().setGlow(true);
+				npc.getEquipment().setItemInHand(item);
+				PropertyMap pm = new PropertyMap();
+				pm.put("\u00A7c\u795E\u5947\u7684NPC", new Property("textures",
+						"eyJ0aW1lc3RhbXAiOjE0NTg0NTMxNjM3MDksInByb2ZpbGVJZCI6ImNhZWZmYmFhMzdhZDRhYjI5Mjg5NGQxZDEzOTk4YTg5IiwicHJvZmlsZU5hbWUiOiJ3YXlfX3plciIsInNpZ25hdHVyZVJlcXVpcmVkIjp0cnVlLCJ0ZXh0dXJlcyI6eyJTS0lOIjp7InVybCI6Imh0dHA6Ly90ZXh0dXJlcy5taW5lY3JhZnQubmV0L3RleHR1cmUvYmQzYzdmN2E3ZjIyZTU5NDIxYzRkZDI3NjY2ZDVlZTlmYzc4MTEwODE3MTU3MmQxYzRlMzZkMzhmMjZjOWQzIn19fQ==",
+						"ofNqZSqPhaWL4b8mHRUpv+vUVw3bqXH1mhvoZzyaxXOTE4TqXfapJRTmct4KV5r25ezW9in9zryaadGX4yueERYZzUkVj5MJqduI44z/rqc1oy4NSTqRAHzaka6PWD/DZyG8kySKhDXBhwEKKeGTHUAeohbLtyfvs3FRLxMf6GkyEzibM32hj65eln9itaqKH6uU9l7bzjPfNx3RlLOg2LbmdBIajXffSDQBgklSOg/v/7OiD5fXYREWzYPNex5Iiw8id0NFTTpQE4Dvrv31ijXcnWsS4Mp62+zPYponsloPynZ9AqQaXVeuLJQhSwJktkavThqz9dfaS9+IGn1Ko7AUhFyLxWjqbet6M7sKd29sqlWbdxB8LMh6I+RMNb9Tx4yKa0EeedFHXfYMaURs2TdPMO2QtiM3nG+IieaXaZwh64wyf/u3iuu3sNd4/s1JmOM9nVYvVaIQVsT80HW/NQwz/N+ufJOh4L7unTt/Jlwm4DkldaTKzUiuVLB4ypYON2/Pa1dXBgRZbU7dCwjXuAL/Cox1UKqYcq3uEuCKhBWYFdEe2p7NDNTuFhjX38MP+h94SlFjbfaSpzDegjr92qO8r41JqpcyewQYI2fkwk8Ju9AJDMTpeoA6ofHEzAMhajXkViKvUPoPbl4HUDvtRBZu5k8dggWKQ83v1UXsDxQ="));
+				npc.getProfile().setProperties(pm);
+				HumanDataWatcher dw = npc.getDatawatcher();
+				dw.setParicelColor(1224755642);
+				dw.setSkinFlags((byte) 127);
+				npc.setName("\u00A7c\u795E\u5947\u7684NPC");
+				npc.addListener(new InteractListener() {
+
+					@Override
+					public void rightClick(Player p) {
+						p.sendMessage(new TextComponent("\u00A7c\u00A7l[NPC] \u00A7cHI! \u00A7c\u00A7l" + p.getDisplayName() + "  \u00A7c\u00A7l\u8BF7\u5148\u767B\u5F55,\u518D\u5C1D\u8BD5\u6253\u5F00"));
+					}
+
+					@Override
+					public void leftClick(Player p) {
+						p.sendMessage(new TextComponent("\u00A7c\u00A7l[NPC] \u00A7cHI! \u00A7c\u00A7l" + p.getDisplayName() + "  \u00A7a\u6B22\u8FCE\u6765\u5230MFT\u670D\u52A1\u5668"));
+					}
+				});
+
+				npc.setLocation(p.getPlayer().getLocation().add(0, 5, 0));
+				npc.setVisiable(p.getPlayer(), true);
 			}
 		};
 		i.getItemMeta().setDisplayName(ChatColorUtils.COLOR_CHAR + "aTesting");
 		inv.setItem(3, i);
-		
+
 		final ItemStack is = new ItemStack(Material.WATCH, 1, (short) 0) {
 			@Override
 			public void click(final Click p) {
@@ -163,27 +163,26 @@ public class DebugMenue {
 					s.getObjektive("test").setScore("\u00A7aHello world", -2);
 					s.getObjektive("test").display(Position.SIDEBAR);
 					s.getObjektive("test").setDisplayName(ChatColorUtils.COLOR_CHAR + "athis is an test");
-				}
-				else {
+				} else {
 					s.removeObjektive("test");
 				}
 				if (p.getPlayer().getVersion().getBigVersion() != BigClientVersion.v1_8) {
 					BossBar var0 = null;
-					
+
 					var0 = p.getPlayer().getBossBarManager().createNewBossBar();
 					var0.setColor(BarColor.GREEN);
 					var0.setDivision(BarDivision.NO_DIVISION);
 					var0.setHealth(0F);
 					var0.setMessage(ChatSerializer.fromMessage("\u00A7cHello world"));
 					var0.display();
-					
+
 					p.getPlayer().sendMessage("Your boss bars:");
 					for (BossBar bar : p.getPlayer().getBossBarManager().getActiveBossBars())
 						p.getPlayer().sendMessage("  \u00A77- " + ChatSerializer.toMessage(bar.getMessage()));
 					final BossBar bar = var0;
 					new LimetedScheduller(32, 250, TimeUnit.MILLISECONDS) {
 						int currunt = 0;
-						
+
 						@Override
 						public void run(int count) {
 							if (s.getObjektive("test") != null) {
@@ -196,7 +195,7 @@ public class DebugMenue {
 								bar.dynamicChangeHealth((float) ((float) count / (float) limit), 250, TimeUnit.MILLISECONDS);
 							}
 						}
-						
+
 						@Override
 						public void done() {
 							s.removeObjektive("test");
@@ -207,8 +206,7 @@ public class DebugMenue {
 									public void run() {
 										try {
 											Thread.sleep(500);
-										}
-										catch (InterruptedException e) {
+										} catch (InterruptedException e) {
 										}
 										p.getPlayer().getBossBarManager().deleteBossBar(bar);
 									}
@@ -221,7 +219,7 @@ public class DebugMenue {
 				System.gc();
 				p.getPlayer().sendMessage("Cleaning Space done!");
 				p.getPlayer().closeInventory();
-				
+
 				final Inventory base = new Inventory(45, "SEXY");
 				base.fill(new ItemStack(new Item(Material.NAME_TAG)) {
 					@Override
@@ -238,9 +236,9 @@ public class DebugMenue {
 				}, 500, TimeUnit.MILLISECONDS);
 			}
 		};
-		
+
 		is.getItemMeta().setDisplayName(ChatColorUtils.COLOR_CHAR + "7##### " + ChatColorUtils.COLOR_CHAR + "eStatistics " + ChatColorUtils.COLOR_CHAR + "7[" + ChatColorUtils.COLOR_CHAR + "aMB" + ChatColorUtils.COLOR_CHAR + "7] #####");
-		
+
 		BungeeCord.getInstance().getScheduler().runAsync(BungeeUtil.getPluginInstance(), new Runnable() {
 			@Override
 			public void run() {
@@ -249,8 +247,7 @@ public class DebugMenue {
 				while (inv.getViewer().size() > 0) {
 					try {
 						Thread.sleep(500);
-					}
-					catch (InterruptedException e) {
+					} catch (InterruptedException e) {
 					}
 					Runtime runtime = Runtime.getRuntime();
 					List<String> a = new ArrayList<String>();
@@ -264,29 +261,31 @@ public class DebugMenue {
 					c++;
 				}
 			}
-			
+
 			private String format(long l) {
 				return (l / (1014 * 1024)) + "MB " + ((l / 1024) % 1024) + "KB " + (l % 1024) + "B";
 			}
 		});
 		inv.setItem(7, is);
-		
+
 		ItemStack is_ = new ItemStack(player.getVersion().getBigVersion() == BigClientVersion.v1_7 ? Material.FIRE : Material.BARRIER, 1) {
 			public void click(Click p) {
 				throw new RuntimeException("Demo Crash");
-			};
+			}
+
+			;
 		};
 		is_.getItemMeta().setDisplayName(ChatColorUtils.COLOR_CHAR + "cTest Crash Disconnect");
 		inv.setItem(22, is_);
-		
+
 		ItemStack is1 = new ItemStack(Material.COMPASS) {
 			@Override
 			public void click(Click p) {
 				p.getPlayer().sendMessage("Sound sended");
-				if(SoundEffect.BLOCK_ANVIL_FALL.isAvariable(p.getPlayer().getVersion().getBigVersion()))
+				if (SoundEffect.BLOCK_ANVIL_FALL.isAvariable(p.getPlayer().getVersion().getBigVersion()))
 					p.getPlayer().playSound(SoundEffect.BLOCK_ANVIL_LAND, p.getPlayer().getLocation(), 1F, 0);
 				else
-					p.getPlayer().sendMessage("Sound not avariable for "+p.getPlayer().getVersion().toString());
+					p.getPlayer().sendMessage("Sound not avariable for " + p.getPlayer().getVersion().toString());
 				//p.getPlayer().playSound(SoundEffect.getEffect("block.anvil.land"), SoundCategory.MASTER, p.getPlayer().getLocation(), 1F, 0);
 			}
 		};
@@ -296,7 +295,7 @@ public class DebugMenue {
 			public void println(String s) {
 				out.add(s);
 			}
-			
+
 			@Override
 			public void print(String s) {
 				out.add(s);
@@ -305,8 +304,8 @@ public class DebugMenue {
 		is1.getItemMeta().setDisplayName(out.get(0));
 		is1.getItemMeta().setLore(out.subList(1, out.size()));
 		inv.setItem(5, is1);
-		
-		i = new ItemStack(Material.EMERALD){
+
+		i = new ItemStack(Material.EMERALD) {
 			@Override
 			public void click(final Click click) {
 				click.getPlayer().sendMessage("Open anvil menue");
@@ -314,35 +313,33 @@ public class DebugMenue {
 				guy.addListener(new AnvilGuiListener() {
 					@Override
 					public void onMessageChange(AnvilGui guy, String newMessage) {
-				    	//Changing text color
-				    	if ("HelloWorld #Yolo".startsWith(newMessage)){
-				    		guy.setColorPrefix("\u00A76");
-				    		guy.setCenterItem(new Item(Material.getMaterial(351),1,(byte)10));
-						}
-						else if(newMessage.startsWith("HelloWorld #Yolo")){
+						//Changing text color
+						if ("HelloWorld #Yolo".startsWith(newMessage)) {
+							guy.setColorPrefix("\u00A76");
+							guy.setCenterItem(new Item(Material.getMaterial(351), 1, (byte) 10));
+						} else if (newMessage.startsWith("HelloWorld #Yolo")) {
 							guy.setColorPrefix("\u00A7a");
 							guy.setCurruntInput("You did it!");
-						}
-						else{
+						} else {
 							guy.setColorPrefix("\u00A7c");
-							guy.setCenterItem(new Item(Material.getMaterial(351),1,(byte)1));
+							guy.setCenterItem(new Item(Material.getMaterial(351), 1, (byte) 1));
 						}
-				    	
-				    	//Update output item ;)
+
+						//Update output item ;)
 						Item item = new Item(Material.ENCHANTED_BOOK);
-				    	item.getItemMeta().setDisplayName("\u00A7aYour message: \u00A7e" + (newMessage.length() == 0 ? "\u00A7cNo message" : newMessage));
-				    	guy.setOutputItem(item);
+						item.getItemMeta().setDisplayName("\u00A7aYour message: \u00A7e" + (newMessage.length() == 0 ? "\u00A7cNo message" : newMessage));
+						guy.setOutputItem(item);
 					}
-					
+
 					@Override
 					public void onConfirmInput(AnvilGui guy, String message) {
-						click.getPlayer().sendMessage("You confirmed you input. Your input: "+message);
+						click.getPlayer().sendMessage("You confirmed you input. Your input: " + message);
 						click.getPlayer().closeInventory();
 					}
-					
+
 					@Override
 					public void onClose(AnvilGui guy) {
-						click.getPlayer().sendMessage("Your last input wars: "+guy.getCurruntInput());
+						click.getPlayer().sendMessage("Your last input wars: " + guy.getCurruntInput());
 					}
 				});
 				guy.open();
@@ -350,7 +347,7 @@ public class DebugMenue {
 		};
 		i.getItemMeta().setDisplayName("\u00A7aTesting anvil guy");
 		inv.setItem(10, i);
-		
+
 		Profiler.packet_handle.stop("buildDebugInventory");
 	}
 }
diff --git a/src/main/java/dev/wolveringer/packet/MathHelper_v1_8.java b/src/main/java/dev/wolveringer/packet/MathHelper_v1_8.java
index 19e2195..985b59d 100644
--- a/src/main/java/dev/wolveringer/packet/MathHelper_v1_8.java
+++ b/src/main/java/dev/wolveringer/packet/MathHelper_v1_8.java
@@ -4,229 +4,228 @@ import java.util.Random;
 import java.util.UUID;
 
 public class MathHelper_v1_8 {
-	public static final float a = sqrt(2.0F);
-	private static final float[] b = new float[65536];
-
-	static{
-		for(int i = 0;i < 65536;i++){
-			b[i] = ((float) Math.sin(i * 3.141592653589793D * 2.0D / 65536.0D));
-		}
-	}
-
-	public static float sin(float paramFloat) {
-		return b[((int) (paramFloat * 10430.378F) & 0xFFFF)];
-	}
-
-	public static float cos(float paramFloat) {
-		return b[((int) (paramFloat * 10430.378F + 16384.0F) & 0xFFFF)];
-	}
-
-	public static float sqrt(float paramFloat) {
-		return (float) Math.sqrt(paramFloat);
-	}
-
-	public static float sqrt(double paramDouble) {
-		return (float) Math.sqrt(paramDouble);
-	}
-
-	public static int d(float paramFloat) {
-		int i = (int) paramFloat;
-		return paramFloat < i ? i - 1 : i;
-	}
-
-	public static int floor(double paramDouble) {
-		int i = (int) paramDouble;
-		return paramDouble < i ? i - 1 : i;
-	}
-
-	public static float e(float paramFloat) {
-		return paramFloat >= 0.0F ? paramFloat : -paramFloat;
-	}
-
-	public static int a(int paramInt) {
-		return paramInt >= 0 ? paramInt : -paramInt;
-	}
-
-	public static int f(float paramFloat) {
-		int i = (int) paramFloat;
-		return paramFloat > i ? i + 1 : i;
-	}
-
-	public static int f(double paramDouble) {
-		int i = (int) paramDouble;
-		return paramDouble > i ? i + 1 : i;
-	}
-
-	public static int clamp(int paramInt1, int paramInt2, int paramInt3) {
-		if(paramInt1 < paramInt2){
-			return paramInt2;
-		}
-		if(paramInt1 > paramInt3){
-			return paramInt3;
-		}
-		return paramInt1;
-	}
-
-	public static float a(float paramFloat1, float paramFloat2, float paramFloat3) {
-		if(paramFloat1 < paramFloat2){
-			return paramFloat2;
-		}
-		if(paramFloat1 > paramFloat3){
-			return paramFloat3;
-		}
-		return paramFloat1;
-	}
-
-	public static double a(double paramDouble1, double paramDouble2, double paramDouble3) {
-		if(paramDouble1 < paramDouble2){
-			return paramDouble2;
-		}
-		if(paramDouble1 > paramDouble3){
-			return paramDouble3;
-		}
-		return paramDouble1;
-	}
-
-	public static double b(double paramDouble1, double paramDouble2, double paramDouble3) {
-		if(paramDouble3 < 0.0D){
-			return paramDouble1;
-		}
-		if(paramDouble3 > 1.0D){
-			return paramDouble2;
-		}
-		return paramDouble1 + (paramDouble2 - paramDouble1) * paramDouble3;
-	}
-
-	public static double a(double paramDouble1, double paramDouble2) {
-		if(paramDouble1 < 0.0D){
-			paramDouble1 = -paramDouble1;
-		}
-		if(paramDouble2 < 0.0D){
-			paramDouble2 = -paramDouble2;
-		}
-		return paramDouble1 > paramDouble2 ? paramDouble1 : paramDouble2;
-	}
-
-	public static int nextInt(Random paramRandom, int paramInt1, int paramInt2) {
-		if(paramInt1 >= paramInt2){
-			return paramInt1;
-		}
-		return paramRandom.nextInt(paramInt2 - paramInt1 + 1) + paramInt1;
-	}
-
-	public static float a(Random paramRandom, float paramFloat1, float paramFloat2) {
-		if(paramFloat1 >= paramFloat2){
-			return paramFloat1;
-		}
-		return paramRandom.nextFloat() * (paramFloat2 - paramFloat1) + paramFloat1;
-	}
-
-	public static double a(Random paramRandom, double paramDouble1, double paramDouble2) {
-		if(paramDouble1 >= paramDouble2){
-			return paramDouble1;
-		}
-		return paramRandom.nextDouble() * (paramDouble2 - paramDouble1) + paramDouble1;
-	}
-
-	public static double a(long[] paramArrayOfLong) {
-		long l1 = 0L;
-		for(long l2 : paramArrayOfLong){
-			l1 += l2;
-		}
-		return l1 / paramArrayOfLong.length;
-	}
-
-	public static float degress180(float paramFloat) {
-		paramFloat %= 360.0F;
-		if(paramFloat >= 180.0F){
-			paramFloat -= 360.0F;
-		}
-		if(paramFloat < -180.0F){
-			paramFloat += 360.0F;
-		}
-		return paramFloat;
-	}
-
-	public static double degress180(double paramDouble) {
-		paramDouble %= 360.0D;
-		if(paramDouble >= 180.0D){
-			paramDouble -= 360.0D;
-		}
-		if(paramDouble < -180.0D){
-			paramDouble += 360.0D;
-		}
-		return paramDouble;
-	}
-
-	public static int a(String paramString, int paramInt) {
-		try{
-			return Integer.parseInt(paramString);
-		}catch (Throwable localThrowable){
-		}
-		return paramInt;
-	}
-
-	public static int a(String paramString, int paramInt1, int paramInt2) {
-		return Math.max(paramInt2, a(paramString, paramInt1));
-	}
-
-	public static double a(String paramString, double paramDouble) {
-		try{
-			return Double.parseDouble(paramString);
-		}catch (Throwable localThrowable){
-		}
-		return paramDouble;
-	}
-
-	public static double a(String paramString, double paramDouble1, double paramDouble2) {
-		return Math.max(paramDouble2, a(paramString, paramDouble1));
-	}
-
-	public static int b(int paramInt) {
-		int i = paramInt - 1;
-		i |= i >> 1;
-		i |= i >> 2;
-		i |= i >> 4;
-		i |= i >> 8;
-		i |= i >> 16;
-		return i + 1;
-	}
-
-	private static boolean d(int paramInt) {
-		return (paramInt != 0) && ((paramInt & paramInt - 1) == 0);
-	}
-
-	private static final int[] c = { 0, 1, 28, 2, 29, 14, 24, 3, 30, 22, 20, 15, 25, 17, 4, 8, 31, 27, 13, 23, 21, 19, 16, 7, 26, 12, 18, 6, 11, 5, 10, 9 };
-
-	private static int e(int paramInt) {
-		paramInt = d(paramInt) ? paramInt : b(paramInt);
-		return c[((int) (paramInt * 125613361L >> 27) & 0x1F)];
-	}
-
-	public static int c(int paramInt) {
-		return e(paramInt) - (d(paramInt) ? 0 : 1);
-	}
-
-	public static int c(int paramInt1, int paramInt2) {
-		if(paramInt2 == 0){
-			return 0;
-		}
-		if(paramInt1 == 0){
-			return paramInt2;
-		}
-		if(paramInt1 < 0){
-			paramInt2 *= -1;
-		}
-		int i = paramInt1 % paramInt2;
-		if(i == 0){
-			return paramInt1;
-		}
-		return paramInt1 + paramInt2 - i;
-	}
-
-	public static UUID a(Random paramRandom) {
-		long l1 = paramRandom.nextLong() & 0xFFFF0FFF | 0x4000;
-		long l2 = paramRandom.nextLong() & 0xFFFFFFFF | 0x0;
-		return new UUID(l1, l2);
-	}
+    public static final float a = sqrt(2.0F);
+    private static final float[] b = new float[65536];
+    private static final int[] c = {0, 1, 28, 2, 29, 14, 24, 3, 30, 22, 20, 15, 25, 17, 4, 8, 31, 27, 13, 23, 21, 19, 16, 7, 26, 12, 18, 6, 11, 5, 10, 9};
+
+    static {
+        for (int i = 0; i < 65536; i++) {
+            b[i] = ((float) Math.sin(i * 3.141592653589793D * 2.0D / 65536.0D));
+        }
+    }
+
+    public static float sin(float paramFloat) {
+        return b[((int) (paramFloat * 10430.378F) & 0xFFFF)];
+    }
+
+    public static float cos(float paramFloat) {
+        return b[((int) (paramFloat * 10430.378F + 16384.0F) & 0xFFFF)];
+    }
+
+    public static float sqrt(float paramFloat) {
+        return (float) Math.sqrt(paramFloat);
+    }
+
+    public static float sqrt(double paramDouble) {
+        return (float) Math.sqrt(paramDouble);
+    }
+
+    public static int d(float paramFloat) {
+        int i = (int) paramFloat;
+        return paramFloat < i ? i - 1 : i;
+    }
+
+    public static int floor(double paramDouble) {
+        int i = (int) paramDouble;
+        return paramDouble < i ? i - 1 : i;
+    }
+
+    public static float e(float paramFloat) {
+        return paramFloat >= 0.0F ? paramFloat : -paramFloat;
+    }
+
+    public static int a(int paramInt) {
+        return paramInt >= 0 ? paramInt : -paramInt;
+    }
+
+    public static int f(float paramFloat) {
+        int i = (int) paramFloat;
+        return paramFloat > i ? i + 1 : i;
+    }
+
+    public static int f(double paramDouble) {
+        int i = (int) paramDouble;
+        return paramDouble > i ? i + 1 : i;
+    }
+
+    public static int clamp(int paramInt1, int paramInt2, int paramInt3) {
+        if (paramInt1 < paramInt2) {
+            return paramInt2;
+        }
+        if (paramInt1 > paramInt3) {
+            return paramInt3;
+        }
+        return paramInt1;
+    }
+
+    public static float a(float paramFloat1, float paramFloat2, float paramFloat3) {
+        if (paramFloat1 < paramFloat2) {
+            return paramFloat2;
+        }
+        if (paramFloat1 > paramFloat3) {
+            return paramFloat3;
+        }
+        return paramFloat1;
+    }
+
+    public static double a(double paramDouble1, double paramDouble2, double paramDouble3) {
+        if (paramDouble1 < paramDouble2) {
+            return paramDouble2;
+        }
+        if (paramDouble1 > paramDouble3) {
+            return paramDouble3;
+        }
+        return paramDouble1;
+    }
+
+    public static double b(double paramDouble1, double paramDouble2, double paramDouble3) {
+        if (paramDouble3 < 0.0D) {
+            return paramDouble1;
+        }
+        if (paramDouble3 > 1.0D) {
+            return paramDouble2;
+        }
+        return paramDouble1 + (paramDouble2 - paramDouble1) * paramDouble3;
+    }
+
+    public static double a(double paramDouble1, double paramDouble2) {
+        if (paramDouble1 < 0.0D) {
+            paramDouble1 = -paramDouble1;
+        }
+        if (paramDouble2 < 0.0D) {
+            paramDouble2 = -paramDouble2;
+        }
+        return paramDouble1 > paramDouble2 ? paramDouble1 : paramDouble2;
+    }
+
+    public static int nextInt(Random paramRandom, int paramInt1, int paramInt2) {
+        if (paramInt1 >= paramInt2) {
+            return paramInt1;
+        }
+        return paramRandom.nextInt(paramInt2 - paramInt1 + 1) + paramInt1;
+    }
+
+    public static float a(Random paramRandom, float paramFloat1, float paramFloat2) {
+        if (paramFloat1 >= paramFloat2) {
+            return paramFloat1;
+        }
+        return paramRandom.nextFloat() * (paramFloat2 - paramFloat1) + paramFloat1;
+    }
+
+    public static double a(Random paramRandom, double paramDouble1, double paramDouble2) {
+        if (paramDouble1 >= paramDouble2) {
+            return paramDouble1;
+        }
+        return paramRandom.nextDouble() * (paramDouble2 - paramDouble1) + paramDouble1;
+    }
+
+    public static double a(long[] paramArrayOfLong) {
+        long l1 = 0L;
+        for (long l2 : paramArrayOfLong) {
+            l1 += l2;
+        }
+        return l1 / paramArrayOfLong.length;
+    }
+
+    public static float degress180(float paramFloat) {
+        paramFloat %= 360.0F;
+        if (paramFloat >= 180.0F) {
+            paramFloat -= 360.0F;
+        }
+        if (paramFloat < -180.0F) {
+            paramFloat += 360.0F;
+        }
+        return paramFloat;
+    }
+
+    public static double degress180(double paramDouble) {
+        paramDouble %= 360.0D;
+        if (paramDouble >= 180.0D) {
+            paramDouble -= 360.0D;
+        }
+        if (paramDouble < -180.0D) {
+            paramDouble += 360.0D;
+        }
+        return paramDouble;
+    }
+
+    public static int a(String paramString, int paramInt) {
+        try {
+            return Integer.parseInt(paramString);
+        } catch (Throwable localThrowable) {
+        }
+        return paramInt;
+    }
+
+    public static int a(String paramString, int paramInt1, int paramInt2) {
+        return Math.max(paramInt2, a(paramString, paramInt1));
+    }
+
+    public static double a(String paramString, double paramDouble) {
+        try {
+            return Double.parseDouble(paramString);
+        } catch (Throwable localThrowable) {
+        }
+        return paramDouble;
+    }
+
+    public static double a(String paramString, double paramDouble1, double paramDouble2) {
+        return Math.max(paramDouble2, a(paramString, paramDouble1));
+    }
+
+    public static int b(int paramInt) {
+        int i = paramInt - 1;
+        i |= i >> 1;
+        i |= i >> 2;
+        i |= i >> 4;
+        i |= i >> 8;
+        i |= i >> 16;
+        return i + 1;
+    }
+
+    private static boolean d(int paramInt) {
+        return (paramInt != 0) && ((paramInt & paramInt - 1) == 0);
+    }
+
+    private static int e(int paramInt) {
+        paramInt = d(paramInt) ? paramInt : b(paramInt);
+        return c[((int) (paramInt * 125613361L >> 27) & 0x1F)];
+    }
+
+    public static int c(int paramInt) {
+        return e(paramInt) - (d(paramInt) ? 0 : 1);
+    }
+
+    public static int c(int paramInt1, int paramInt2) {
+        if (paramInt2 == 0) {
+            return 0;
+        }
+        if (paramInt1 == 0) {
+            return paramInt2;
+        }
+        if (paramInt1 < 0) {
+            paramInt2 *= -1;
+        }
+        int i = paramInt1 % paramInt2;
+        if (i == 0) {
+            return paramInt1;
+        }
+        return paramInt1 + paramInt2 - i;
+    }
+
+    public static UUID a(Random paramRandom) {
+        long l1 = paramRandom.nextLong() & 0xFFFF0FFF | 0x4000;
+        long l2 = paramRandom.nextLong() & 0xFFFFFFFF | 0x0;
+        return new UUID(l1, l2);
+    }
 }
diff --git a/src/main/java/dev/wolveringer/packet/ObjectSereizer.java b/src/main/java/dev/wolveringer/packet/ObjectSereizer.java
index b9bb37c..d2d2acc 100644
--- a/src/main/java/dev/wolveringer/packet/ObjectSereizer.java
+++ b/src/main/java/dev/wolveringer/packet/ObjectSereizer.java
@@ -4,17 +4,17 @@ import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 
 public abstract class ObjectSereizer<T> {
-	Class<T> clazz;
+    Class<T> clazz;
 
-	@SuppressWarnings("unchecked")
-	public ObjectSereizer() {
-		Type[] types = ((ParameterizedType) getClass().getGenericSuperclass()).getActualTypeArguments();
-		clazz = (Class<T>) types[0];
-	}
-	
-	public Class<T> getType(){
-		return clazz;
-	}
-	
-	public abstract void write(T obj,PacketDataSerializer serelizer);
+    @SuppressWarnings("unchecked")
+    public ObjectSereizer() {
+        Type[] types = ((ParameterizedType) getClass().getGenericSuperclass()).getActualTypeArguments();
+        clazz = (Class<T>) types[0];
+    }
+
+    public Class<T> getType() {
+        return clazz;
+    }
+
+    public abstract void write(T obj, PacketDataSerializer serelizer);
 }
diff --git a/src/main/java/dev/wolveringer/packet/PacketDataSerializer.java b/src/main/java/dev/wolveringer/packet/PacketDataSerializer.java
index 6bfe8ab..35e8fa4 100644
--- a/src/main/java/dev/wolveringer/packet/PacketDataSerializer.java
+++ b/src/main/java/dev/wolveringer/packet/PacketDataSerializer.java
@@ -1,9 +1,5 @@
 package dev.wolveringer.packet;
 
-import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ByteBufAllocator;
-import io.netty.buffer.ByteBufProcessor;
-
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.lang.reflect.Array;
@@ -21,865 +17,870 @@ import dev.wolveringer.api.position.BlockPosition;
 import dev.wolveringer.chat.IChatBaseComponent;
 import dev.wolveringer.nbt.NBTTagCompound;
 import dev.wolveringer.util.ByteString;
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufAllocator;
+import io.netty.buffer.ByteBufProcessor;
 
 public abstract class PacketDataSerializer extends ByteBuf {
-	public static long clazz = 0;
-	@SuppressWarnings("rawtypes")
-	private static ArrayList<ObjectSereizer> serelizer = new ArrayList<ObjectSereizer>();
-	
-	static {
-		serelizer.add(new ObjectSereizer<Item>() {
-			@Override
-			public void write(Item obj, PacketDataSerializer serelizer) {
-				serelizer.writeItem(obj);
-			}
-		});
-		serelizer.add(new ObjectSereizer<IChatBaseComponent>() {
-			@Override
-			public void write(IChatBaseComponent obj, PacketDataSerializer serelizer) {
-				serelizer.writeRawString(obj);;
-			}
-		});
-		serelizer.add(new ObjectSereizer<UUID>() {
-			@Override
-			public void write(UUID obj, PacketDataSerializer serelizer) {
-			serelizer.writeUUID(obj);
-			}
-		});
-		serelizer.add(new ObjectSereizer<NBTTagCompound>() {
-			@Override
-			public void write(NBTTagCompound obj, PacketDataSerializer serelizer) {
-				serelizer.writeNBT(obj);
-			}
-		});
-		serelizer.add(new ObjectSereizer<ByteBuf>() {
-			@Override
-			public void write(ByteBuf obj, PacketDataSerializer serelizer) {
-				serelizer.writeBytes(obj.array());
-				obj.release();
-			}
-		});
-		serelizer.add(new ObjectSereizer<BlockPosition>() {
-			@Override
-			public void write(BlockPosition obj, PacketDataSerializer serelizer) {
-				serelizer.writeBlockPosition(obj);
-			}
-		});
-		serelizer.add(new ObjectSereizer<ByteString>() {
-			@Override
-			public void write(ByteString obj, PacketDataSerializer serelizer) {
-				serelizer.writeVarInt(obj.getBytes().length);
-				serelizer.writeBytes(obj.getBytes(), 0, obj.getBytes().length);
-			}
-		});
-	}
-	
-	public static void addObjectSerelizer(ObjectSereizer<?> serelizer){
-		PacketDataSerializer.serelizer.add(serelizer);
-	}
-	
-	@SuppressWarnings({ "unchecked", "rawtypes" })
-	public void write(Object o) {
-		if(o == null)
-			return;
-		for(ObjectSereizer s : serelizer)
-			if(s.getType().isAssignableFrom(o.getClass())){
-				s.write(o, this);
-				return;
-			}
-		if(o instanceof Integer)
-			writeInt((Integer) o);
-		else if(o instanceof String)
-			writeString((String) o);
-		else if(o instanceof Boolean)
-			writeBoolean((Boolean) o);
-		else if(o instanceof Double)
-			writeDouble((Double) o);
-		else if(o instanceof Float)
-			writeFloat((Float) o);
-		else if(o instanceof Long)
-			writeLong((Long) o);
-		else if(o.getClass().isArray()){
-			int length = Array.getLength(o);
-			for(int i = 0;i < length;i++){
-				write(Array.get(o, i));
-			}
-		}else
-			System.err.print("Object \"" + o + "\" don t find");
-	}
-	
-	public static PacketDataSerializer create(ByteBuf b, ClientVersion v) {
-		switch (v.getBigVersion()) {
-			case v1_7:
-				return new PacketDataSerializer_v1_7(b);
-			case v1_8:
-				return new PacketDataSerializer_v1_8(b);
-			case v1_9:
-				return new PacketDataSerializer_v1_8(b);
-			case v1_10:
-				return new PacketDataSerializer_v1_8(b);
-			default:
-				return new PacketDataSerializer_vX_X(b);
-		}
-	}
-
-	public static PacketDataSerializer create(int id, ClientVersion v) {
-		return create(id, v, ByteBuffCreator.createByteBuff());
-	}
-
-	public static PacketDataSerializer create(int b, ClientVersion v,ByteBuf buf) {
-		switch (v.getBigVersion()) {
-			case v1_7:
-				return new PacketDataSerializer_v1_7((byte) b,buf);
-			case v1_8:
-				return new PacketDataSerializer_v1_8((byte) b,buf);
-			case v1_9:
-				return new PacketDataSerializer_v1_8((byte) b,buf);
-			case v1_10:
-				return new PacketDataSerializer_v1_8((byte) b,buf);
-			default:
-				return new PacketDataSerializer_vX_X((byte) b,buf);
-		}
-	}
-	
-	public static PacketDataSerializer create(byte id, ClientVersion version, ByteBuf buf) {
-		return create((int)id,version,buf);
-	}
-	
-	public static int readVarInt(ByteBuf b) {
-		int out = 0;
-		int bytes = 0;
-		byte in;
-		while (true){
-			in = b.readByte();
-			out |= (in & 0x7F) << (bytes++ * 7);
-
-			if(bytes > 5){
-				throw new RuntimeException("VarInt too big");
-			}
-
-			if((in & 0x80) != 0x80){
-				break;
-			}
-		}
-
-		return out;
-	}
-
-	public static void writeVarInt(int value, ByteBuf output) {
-		int part;
-		while (true){
-			part = value & 0x7F;
-
-			value >>>= 7;
-			if(value != 0){
-				part |= 0x80;
-			}
-
-			output.writeByte(part);
-
-			if(value == 0){
-				break;
-			}
-		}
-	}
-
-	public abstract void writeItem(Item i);
-
-	public abstract Item readItem();
-
-	public abstract void writeString(String s);
-
-	public abstract String readString(int max);
-
-	public abstract void writeRawString(IChatBaseComponent s);
-
-	public abstract IChatBaseComponent readRawString();
-
-	public abstract void writeUUID(UUID i);
-
-	public abstract UUID readUUID();
-
-	public abstract void writeNBT(NBTTagCompound c);
-
-	public abstract NBTTagCompound readNBT();
-
-	public abstract void writeBlockPosition(BlockPosition loc);
-
-	public abstract BlockPosition readBlockPosition();
-
-	public ByteString readStringBytes(){
-		byte[] data = new byte[this.readVarInt()];
-		this.readBytes(data, 0, data.length);
-		return new ByteString(data);
-	}
-	public void writeStringBytes(ByteString string){
-		this.writeVarInt(string.getBytes().length);
-		this.writeBytes(string.getBytes(), 0, string.getBytes().length);
-	}
-	
-	public void writeVarInt(int i) {
-		PacketDataSerializer.writeVarInt(i, this);
-	}
-
-	public int readVarInt() {
-		return PacketDataSerializer.readVarInt(this);
-	}
-
-	protected final ByteBuf base;
-	public PacketDataSerializer(ByteBuf a) {
-		clazz++;
-		this.base = a;
-	}
-
-	public int readPositionX(long val) {
-		return (int) (val >> 38);
-	}
-
-	public int readPositionY(long val) {
-		return (int) (val << 26 >> 52);
-	}
+    public static long clazz = 0;
+    @SuppressWarnings("rawtypes")
+    private static ArrayList<ObjectSereizer> serelizer = new ArrayList<ObjectSereizer>();
+
+    static {
+        serelizer.add(new ObjectSereizer<Item>() {
+            @Override
+            public void write(Item obj, PacketDataSerializer serelizer) {
+                serelizer.writeItem(obj);
+            }
+        });
+        serelizer.add(new ObjectSereizer<IChatBaseComponent>() {
+            @Override
+            public void write(IChatBaseComponent obj, PacketDataSerializer serelizer) {
+                serelizer.writeRawString(obj);
+                ;
+            }
+        });
+        serelizer.add(new ObjectSereizer<UUID>() {
+            @Override
+            public void write(UUID obj, PacketDataSerializer serelizer) {
+                serelizer.writeUUID(obj);
+            }
+        });
+        serelizer.add(new ObjectSereizer<NBTTagCompound>() {
+            @Override
+            public void write(NBTTagCompound obj, PacketDataSerializer serelizer) {
+                serelizer.writeNBT(obj);
+            }
+        });
+        serelizer.add(new ObjectSereizer<ByteBuf>() {
+            @Override
+            public void write(ByteBuf obj, PacketDataSerializer serelizer) {
+                serelizer.writeBytes(obj.array());
+                obj.release();
+            }
+        });
+        serelizer.add(new ObjectSereizer<BlockPosition>() {
+            @Override
+            public void write(BlockPosition obj, PacketDataSerializer serelizer) {
+                serelizer.writeBlockPosition(obj);
+            }
+        });
+        serelizer.add(new ObjectSereizer<ByteString>() {
+            @Override
+            public void write(ByteString obj, PacketDataSerializer serelizer) {
+                serelizer.writeVarInt(obj.getBytes().length);
+                serelizer.writeBytes(obj.getBytes(), 0, obj.getBytes().length);
+            }
+        });
+    }
+
+    protected final ByteBuf base;
+
+    public PacketDataSerializer(ByteBuf a) {
+        clazz++;
+        this.base = a;
+    }
+
+    public static void addObjectSerelizer(ObjectSereizer<?> serelizer) {
+        PacketDataSerializer.serelizer.add(serelizer);
+    }
+
+    public static PacketDataSerializer create(ByteBuf b, ClientVersion v) {
+        switch (v.getBigVersion()) {
+            case v1_7:
+                return new PacketDataSerializer_v1_7(b);
+            case v1_8:
+                return new PacketDataSerializer_v1_8(b);
+            case v1_9:
+                return new PacketDataSerializer_v1_8(b);
+            case v1_10:
+                return new PacketDataSerializer_v1_8(b);
+            default:
+                return new PacketDataSerializer_vX_X(b);
+        }
+    }
+
+    public static PacketDataSerializer create(int id, ClientVersion v) {
+        return create(id, v, ByteBuffCreator.createByteBuff());
+    }
+
+    public static PacketDataSerializer create(int b, ClientVersion v, ByteBuf buf) {
+        switch (v.getBigVersion()) {
+            case v1_7:
+                return new PacketDataSerializer_v1_7((byte) b, buf);
+            case v1_8:
+                return new PacketDataSerializer_v1_8((byte) b, buf);
+            case v1_9:
+                return new PacketDataSerializer_v1_8((byte) b, buf);
+            case v1_10:
+                return new PacketDataSerializer_v1_8((byte) b, buf);
+            default:
+                return new PacketDataSerializer_vX_X((byte) b, buf);
+        }
+    }
+
+    public static PacketDataSerializer create(byte id, ClientVersion version, ByteBuf buf) {
+        return create((int) id, version, buf);
+    }
+
+    public static int readVarInt(ByteBuf b) {
+        int out = 0;
+        int bytes = 0;
+        byte in;
+        while (true) {
+            in = b.readByte();
+            out |= (in & 0x7F) << (bytes++ * 7);
+
+            if (bytes > 5) {
+                throw new RuntimeException("VarInt too big");
+            }
+
+            if ((in & 0x80) != 0x80) {
+                break;
+            }
+        }
+
+        return out;
+    }
+
+    public static void writeVarInt(int value, ByteBuf output) {
+        int part;
+        while (true) {
+            part = value & 0x7F;
+
+            value >>>= 7;
+            if (value != 0) {
+                part |= 0x80;
+            }
+
+            output.writeByte(part);
+
+            if (value == 0) {
+                break;
+            }
+        }
+    }
+
+    @SuppressWarnings({"unchecked", "rawtypes"})
+    public void write(Object o) {
+        if (o == null)
+            return;
+        for (ObjectSereizer s : serelizer)
+            if (s.getType().isAssignableFrom(o.getClass())) {
+                s.write(o, this);
+                return;
+            }
+        if (o instanceof Integer)
+            writeInt((Integer) o);
+        else if (o instanceof String)
+            writeString((String) o);
+        else if (o instanceof Boolean)
+            writeBoolean((Boolean) o);
+        else if (o instanceof Double)
+            writeDouble((Double) o);
+        else if (o instanceof Float)
+            writeFloat((Float) o);
+        else if (o instanceof Long)
+            writeLong((Long) o);
+        else if (o.getClass().isArray()) {
+            int length = Array.getLength(o);
+            for (int i = 0; i < length; i++) {
+                write(Array.get(o, i));
+            }
+        } else
+            System.err.print("Object \"" + o + "\" don t find");
+    }
+
+    public abstract void writeItem(Item i);
+
+    public abstract Item readItem();
+
+    public abstract void writeString(String s);
+
+    public abstract String readString(int max);
+
+    public abstract void writeRawString(IChatBaseComponent s);
+
+    public abstract IChatBaseComponent readRawString();
+
+    public abstract void writeUUID(UUID i);
+
+    public abstract UUID readUUID();
+
+    public abstract void writeNBT(NBTTagCompound c);
+
+    public abstract NBTTagCompound readNBT();
+
+    public abstract void writeBlockPosition(BlockPosition loc);
+
+    public abstract BlockPosition readBlockPosition();
+
+    public ByteString readStringBytes() {
+        byte[] data = new byte[this.readVarInt()];
+        this.readBytes(data, 0, data.length);
+        return new ByteString(data);
+    }
+
+    public void writeStringBytes(ByteString string) {
+        this.writeVarInt(string.getBytes().length);
+        this.writeBytes(string.getBytes(), 0, string.getBytes().length);
+    }
+
+    public void writeVarInt(int i) {
+        PacketDataSerializer.writeVarInt(i, this);
+    }
+
+    public int readVarInt() {
+        return PacketDataSerializer.readVarInt(this);
+    }
+
+    public int readPositionX(long val) {
+        return (int) (val >> 38);
+    }
+
+    public int readPositionY(long val) {
+        return (int) (val << 26 >> 52);
+    }
+
+    public int readPositionZ(long val) {
+        return (int) (val << 38 >> 38);
+    }
+
+    public int capacity() {
+        return this.base.capacity();
+    }
+
+    public ByteBuf capacity(int i) {
+        return this.base.capacity(i);
+    }
+
+    public int maxCapacity() {
+        return this.base.maxCapacity();
+    }
+
+    public ByteBufAllocator alloc() {
+        return this.base.alloc();
+    }
+
+    public ByteOrder order() {
+        return this.base.order();
+    }
+
+    public ByteBuf order(ByteOrder byteorder) {
+        return this.base.order(byteorder);
+    }
+
+    public ByteBuf unwrap() {
+        return this.base.unwrap();
+    }
+
+    public boolean isDirect() {
+        return this.base.isDirect();
+    }
+
+    public int readerIndex() {
+        return this.base.readerIndex();
+    }
+
+    public ByteBuf readerIndex(int i) {
+        return this.base.readerIndex(i);
+    }
+
+    public int writerIndex() {
+        return this.base.writerIndex();
+    }
+
+    public ByteBuf writerIndex(int i) {
+        return this.base.writerIndex(i);
+    }
+
+    public ByteBuf setIndex(int i, int j) {
+        return this.base.setIndex(i, j);
+    }
+
+    public int readableBytes() {
+        return this.base.readableBytes();
+    }
+
+    public int writableBytes() {
+        return this.base.writableBytes();
+    }
+
+    public int maxWritableBytes() {
+        return this.base.maxWritableBytes();
+    }
+
+    public boolean isReadable() {
+        return this.base.isReadable();
+    }
 
-	public int readPositionZ(long val) {
-		return (int) (val << 38 >> 38);
-	}
+    public boolean isReadable(int i) {
+        return this.base.isReadable(i);
+    }
 
-	public int capacity() {
-		return this.base.capacity();
-	}
+    public boolean isWritable() {
+        return this.base.isWritable();
+    }
 
-	public ByteBuf capacity(int i) {
-		return this.base.capacity(i);
-	}
+    public boolean isWritable(int i) {
+        return this.base.isWritable(i);
+    }
 
-	public int maxCapacity() {
-		return this.base.maxCapacity();
-	}
+    public ByteBuf clear() {
+        return this.base.clear();
+    }
 
-	public ByteBufAllocator alloc() {
-		return this.base.alloc();
-	}
+    public ByteBuf markReaderIndex() {
+        return this.base.markReaderIndex();
+    }
 
-	public ByteOrder order() {
-		return this.base.order();
-	}
+    public ByteBuf resetReaderIndex() {
+        return this.base.resetReaderIndex();
+    }
 
-	public ByteBuf order(ByteOrder byteorder) {
-		return this.base.order(byteorder);
-	}
+    public ByteBuf markWriterIndex() {
+        return this.base.markWriterIndex();
+    }
 
-	public ByteBuf unwrap() {
-		return this.base.unwrap();
-	}
+    public ByteBuf resetWriterIndex() {
+        return this.base.resetWriterIndex();
+    }
+
+    public ByteBuf discardReadBytes() {
+        return this.base.discardReadBytes();
+    }
+
+    public ByteBuf discardSomeReadBytes() {
+        return this.base.discardSomeReadBytes();
+    }
+
+    public ByteBuf ensureWritable(int i) {
+        return this.base.ensureWritable(i);
+    }
+
+    public int ensureWritable(int i, boolean flag) {
+        return this.base.ensureWritable(i, flag);
+    }
+
+    public boolean getBoolean(int i) {
+        return this.base.getBoolean(i);
+    }
+
+    public byte getByte(int i) {
+        return this.base.getByte(i);
+    }
+
+    public short getUnsignedByte(int i) {
+        return this.base.getUnsignedByte(i);
+    }
+
+    public short getShort(int i) {
+        return this.base.getShort(i);
+    }
+
+    public int getUnsignedShort(int i) {
+        return this.base.getUnsignedShort(i);
+    }
+
+    public int getMedium(int i) {
+        return this.base.getMedium(i);
+    }
+
+    public int getUnsignedMedium(int i) {
+        return this.base.getUnsignedMedium(i);
+    }
+
+    public int getInt(int i) {
+        return this.base.getInt(i);
+    }
+
+    public long getUnsignedInt(int i) {
+        return this.base.getUnsignedInt(i);
+    }
+
+    public long getLong(int i) {
+        return this.base.getLong(i);
+    }
+
+    public char getChar(int i) {
+        return this.base.getChar(i);
+    }
+
+    public float getFloat(int i) {
+        return this.base.getFloat(i);
+    }
+
+    public double getDouble(int i) {
+        return this.base.getDouble(i);
+    }
+
+    public ByteBuf getBytes(int i, ByteBuf bytebuf) {
+        return this.base.getBytes(i, bytebuf);
+    }
+
+    public ByteBuf getBytes(int i, ByteBuf bytebuf, int j) {
+        return this.base.getBytes(i, bytebuf, j);
+    }
+
+    public ByteBuf getBytes(int i, ByteBuf bytebuf, int j, int k) {
+        return this.base.getBytes(i, bytebuf, j, k);
+    }
+
+    public ByteBuf getBytes(int i, byte[] abyte) {
+        return this.base.getBytes(i, abyte);
+    }
+
+    public ByteBuf getBytes(int i, byte[] abyte, int j, int k) {
+        return this.base.getBytes(i, abyte, j, k);
+    }
+
+    public ByteBuf getBytes(int i, ByteBuffer bytebuffer) {
+        return this.base.getBytes(i, bytebuffer);
+    }
+
+    public ByteBuf getBytes(int i, OutputStream outputstream, int j) throws RuntimeException {
+        try {
+            return this.base.getBytes(i, outputstream, j);
+        } catch (java.io.IOException e) {
+            e.printStackTrace();
+        }
+        return base;
+    }
+
+    public int getBytes(int i, GatheringByteChannel gatheringbytechannel, int j) throws RuntimeException {
+        try {
+            return this.base.getBytes(i, gatheringbytechannel, j);
+        } catch (java.io.IOException e) {
+            e.printStackTrace();
+        }
+        return j;
+    }
+
+    public ByteBuf setBoolean(int i, boolean flag) {
+        return this.base.setBoolean(i, flag);
+    }
+
+    public ByteBuf setByte(int i, int j) {
+        return this.base.setByte(i, j);
+    }
+
+    public ByteBuf setShort(int i, int j) {
+        return this.base.setShort(i, j);
+    }
+
+    public ByteBuf setMedium(int i, int j) {
+        return this.base.setMedium(i, j);
+    }
+
+    public ByteBuf setInt(int i, int j) {
+        return this.base.setInt(i, j);
+    }
+
+    public ByteBuf setLong(int i, long j) {
+        return this.base.setLong(i, j);
+    }
+
+    public ByteBuf setChar(int i, int j) {
+        return this.base.setChar(i, j);
+    }
+
+    public ByteBuf setFloat(int i, float f) {
+        return this.base.setFloat(i, f);
+    }
+
+    public ByteBuf setDouble(int i, double d0) {
+        return this.base.setDouble(i, d0);
+    }
+
+    public ByteBuf setBytes(int i, ByteBuf bytebuf) {
+        return this.base.setBytes(i, bytebuf);
+    }
+
+    public ByteBuf setBytes(int i, ByteBuf bytebuf, int j) {
+        return this.base.setBytes(i, bytebuf, j);
+    }
+
+    public ByteBuf setBytes(int i, ByteBuf bytebuf, int j, int k) {
+        return this.base.setBytes(i, bytebuf, j, k);
+    }
+
+    public ByteBuf setBytes(int i, byte[] abyte) {
+        return this.base.setBytes(i, abyte);
+    }
+
+    public ByteBuf setBytes(int i, byte[] abyte, int j, int k) {
+        return this.base.setBytes(i, abyte, j, k);
+    }
+
+    public ByteBuf setBytes(int i, ByteBuffer bytebuffer) {
+        return this.base.setBytes(i, bytebuffer);
+    }
+
+    public int setBytes(int i, InputStream inputstream, int j) throws RuntimeException {
+        try {
+            return this.base.setBytes(i, inputstream, j);
+        } catch (java.io.IOException e) {
+            e.printStackTrace();
+        }
+        return j;
+    }
+
+    public int setBytes(int i, ScatteringByteChannel scatteringbytechannel, int j) throws RuntimeException {
+        try {
+            return this.base.setBytes(i, scatteringbytechannel, j);
+        } catch (java.io.IOException e) {
+            e.printStackTrace();
+        }
+        return j;
+    }
+
+    public ByteBuf setZero(int i, int j) {
+        return this.base.setZero(i, j);
+    }
+
+    public boolean readBoolean() {
+        return this.base.readBoolean();
+    }
+
+    public byte readByte() {
+        return this.base.readByte();
+    }
+
+    public short readUnsignedByte() {
+        return this.base.readUnsignedByte();
+    }
+
+    public short readShort() {
+        return this.base.readShort();
+    }
+
+    public int readUnsignedShort() {
+        return this.base.readUnsignedShort();
+    }
+
+    public int readMedium() {
+        return this.base.readMedium();
+    }
+
+    public int readUnsignedMedium() {
+        return this.base.readUnsignedMedium();
+    }
+
+    public int readInt() {
+        return this.base.readInt();
+    }
+
+    public long readUnsignedInt() {
+        return this.base.readUnsignedInt();
+    }
+
+    public long readLong() {
+        return this.base.readLong();
+    }
+
+    public char readChar() {
+        return this.base.readChar();
+    }
+
+    public float readFloat() {
+        return this.base.readFloat();
+    }
+
+    public double readDouble() {
+        return this.base.readDouble();
+    }
+
+    public ByteBuf readBytes(int i) {
+        return this.base.readBytes(i);
+    }
+
+    public ByteBuf readSlice(int i) {
+        return this.base.readSlice(i);
+    }
+
+    public ByteBuf readBytes(ByteBuf bytebuf) {
+        return this.base.readBytes(bytebuf);
+    }
+
+    public ByteBuf readBytes(ByteBuf bytebuf, int i) {
+        return this.base.readBytes(bytebuf, i);
+    }
+
+    public ByteBuf readBytes(ByteBuf bytebuf, int i, int j) {
+        return this.base.readBytes(bytebuf, i, j);
+    }
+
+    public ByteBuf readBytes(byte[] abyte) {
+        return this.base.readBytes(abyte);
+    }
+
+    public ByteBuf readBytes(byte[] abyte, int i, int j) {
+        return this.base.readBytes(abyte, i, j);
+    }
+
+    public ByteBuf readBytes(ByteBuffer bytebuffer) {
+        return this.base.readBytes(bytebuffer);
+    }
+
+    public ByteBuf readBytes(OutputStream outputstream, int i) throws RuntimeException {
+        try {
+            return this.base.readBytes(outputstream, i);
+        } catch (java.io.IOException e) {
+            e.printStackTrace();
+        }
+        return base;
+    }
+
+    public int readBytes(GatheringByteChannel gatheringbytechannel, int i) throws RuntimeException {
+        try {
+            return this.base.readBytes(gatheringbytechannel, i);
+        } catch (java.io.IOException e) {
+            e.printStackTrace();
+        }
+        return i;
+    }
+
+    public ByteBuf skipBytes(int i) {
+        return this.base.skipBytes(i);
+    }
+
+    public ByteBuf writeBoolean(boolean flag) {
+        return this.base.writeBoolean(flag);
+    }
+
+    public ByteBuf writeByte(int i) {
+        return this.base.writeByte(i);
+    }
+
+    public ByteBuf writeShort(int i) {
+        return this.base.writeShort(i);
+    }
+
+    public ByteBuf writeMedium(int i) {
+        return this.base.writeMedium(i);
+    }
+
+    public ByteBuf writeInt(int i) {
+        return this.base.writeInt(i);
+    }
+
+    public ByteBuf writeLong(long i) {
+        return this.base.writeLong(i);
+    }
+
+    public ByteBuf writeChar(int i) {
+        return this.base.writeChar(i);
+    }
+
+    public ByteBuf writeFloat(float f) {
+        return this.base.writeFloat(f);
+    }
+
+    public ByteBuf writeDouble(double d0) {
+        return this.base.writeDouble(d0);
+    }
+
+    public ByteBuf writeBytes(ByteBuf bytebuf) {
+        return this.base.writeBytes(bytebuf);
+    }
+
+    public ByteBuf writeBytes(ByteBuf bytebuf, int i) {
+        return this.base.writeBytes(bytebuf, i);
+    }
+
+    public ByteBuf writeBytes(ByteBuf bytebuf, int i, int j) {
+        return this.base.writeBytes(bytebuf, i, j);
+    }
+
+    public ByteBuf writeBytes(byte[] abyte) {
+        return this.base.writeBytes(abyte);
+    }
+
+    public ByteBuf writeBytes(byte[] abyte, int i, int j) {
+        return this.base.writeBytes(abyte, i, j);
+    }
+
+    public ByteBuf writeBytes(ByteBuffer bytebuffer) {
+        return this.base.writeBytes(bytebuffer);
+    }
+
+    public int writeBytes(InputStream inputstream, int i) throws RuntimeException {
+        try {
+            return this.base.writeBytes(inputstream, i);
+        } catch (java.io.IOException e) {
+            e.printStackTrace();
+        }
+        return i;
+    }
+
+    public int writeBytes(ScatteringByteChannel scatteringbytechannel, int i) throws RuntimeException {
+        try {
+            return this.base.writeBytes(scatteringbytechannel, i);
+        } catch (java.io.IOException e) {
+            e.printStackTrace();
+        }
+        return i;
+    }
+
+    public ByteBuf writeZero(int i) {
+        return this.base.writeZero(i);
+    }
+
+    public int indexOf(int i, int j, byte b0) {
+        return this.base.indexOf(i, j, b0);
+    }
+
+    public int bytesBefore(byte b0) {
+        return this.base.bytesBefore(b0);
+    }
+
+    public int bytesBefore(int i, byte b0) {
+        return this.base.bytesBefore(i, b0);
+    }
+
+    public int bytesBefore(int i, int j, byte b0) {
+        return this.base.bytesBefore(i, j, b0);
+    }
+
+    public ByteBuf copy() {
+        return this.base.copy();
+    }
+
+    public ByteBuf copy(int i, int j) {
+        return this.base.copy(i, j);
+    }
+
+    public ByteBuf slice() {
+        return this.base.slice();
+    }
+
+    public ByteBuf slice(int i, int j) {
+        return this.base.slice(i, j);
+    }
+
+    public ByteBuf duplicate() {
+        return this.base.duplicate();
+    }
+
+    public int nioBufferCount() {
+        return this.base.nioBufferCount();
+    }
+
+    public ByteBuffer nioBuffer() {
+        return this.base.nioBuffer();
+    }
+
+    public ByteBuffer nioBuffer(int i, int j) {
+        return this.base.nioBuffer(i, j);
+    }
+
+    public ByteBuffer internalNioBuffer(int i, int j) {
+        return this.base.internalNioBuffer(i, j);
+    }
+
+    public ByteBuffer[] nioBuffers() {
+        return this.base.nioBuffers();
+    }
+
+    public ByteBuffer[] nioBuffers(int i, int j) {
+        return this.base.nioBuffers(i, j);
+    }
+
+    public boolean hasArray() {
+        return this.base.hasArray();
+    }
+
+    public byte[] array() {
+        return this.base.array();
+    }
+
+    public int arrayOffset() {
+        return this.base.arrayOffset();
+    }
+
+    public boolean hasMemoryAddress() {
+        return this.base.hasMemoryAddress();
+    }
+
+    public long memoryAddress() {
+        return this.base.memoryAddress();
+    }
+
+    public String toString(Charset charset) {
+        return this.base.toString(charset);
+    }
+
+    public String toString(int i, int j, Charset charset) {
+        return this.base.toString(i, j, charset);
+    }
+
+    public int hashCode() {
+        return this.base.hashCode();
+    }
+
+    public boolean equals(Object object) {
+        return this.base.equals(object);
+    }
 
-	public boolean isDirect() {
-		return this.base.isDirect();
-	}
+    public int compareTo(ByteBuf bytebuf) {
+        return this.base.compareTo(bytebuf);
+    }
 
-	public int readerIndex() {
-		return this.base.readerIndex();
-	}
+    public String toString() {
+        return this.base.toString();
+    }
 
-	public ByteBuf readerIndex(int i) {
-		return this.base.readerIndex(i);
-	}
+    public ByteBuf retain(int i) {
+        return this.base.retain(i);
+    }
 
-	public int writerIndex() {
-		return this.base.writerIndex();
-	}
+    public ByteBuf retain() {
+        return this.base.retain();
+    }
 
-	public ByteBuf writerIndex(int i) {
-		return this.base.writerIndex(i);
-	}
+    public int refCnt() {
+        return this.base.refCnt();
+    }
 
-	public ByteBuf setIndex(int i, int j) {
-		return this.base.setIndex(i, j);
-	}
+    public boolean release() {
+        return this.base.release();
+    }
 
-	public int readableBytes() {
-		return this.base.readableBytes();
-	}
+    public boolean release(int i) {
+        return this.base.release(i);
+    }
 
-	public int writableBytes() {
-		return this.base.writableBytes();
-	}
-
-	public int maxWritableBytes() {
-		return this.base.maxWritableBytes();
-	}
-
-	public boolean isReadable() {
-		return this.base.isReadable();
-	}
-
-	public boolean isReadable(int i) {
-		return this.base.isReadable(i);
-	}
-
-	public boolean isWritable() {
-		return this.base.isWritable();
-	}
+    public byte[] readByteArray() {
+        byte[] abyte = new byte[readVarInt()];
+        readBytes(abyte);
+        return abyte;
+    }
+
+    public void writeByteArray(byte[] abyte) {
+        writeVarInt(abyte.length);
+        writeBytes(abyte);
+    }
 
-	public boolean isWritable(int i) {
-		return this.base.isWritable(i);
-	}
 
-	public ByteBuf clear() {
-		return this.base.clear();
-	}
+    public int forEachByte(ByteBufProcessor arg0) {
+        return base.forEachByte(arg0);
+    }
 
-	public ByteBuf markReaderIndex() {
-		return this.base.markReaderIndex();
-	}
+    public int forEachByte(int arg0, int arg1, ByteBufProcessor arg2) {
+        return base.forEachByte(arg0, arg1, arg2);
+    }
 
-	public ByteBuf resetReaderIndex() {
-		return this.base.resetReaderIndex();
-	}
+    public int forEachByteDesc(ByteBufProcessor arg0) {
+        return base.forEachByteDesc(arg0);
+    }
 
-	public ByteBuf markWriterIndex() {
-		return this.base.markWriterIndex();
-	}
+    public int forEachByteDesc(int arg0, int arg1, ByteBufProcessor arg2) {
+        return base.forEachByteDesc(arg0, arg1, arg2);
+    }
 
-	public ByteBuf resetWriterIndex() {
-		return this.base.resetWriterIndex();
-	}
-
-	public ByteBuf discardReadBytes() {
-		return this.base.discardReadBytes();
-	}
-
-	public ByteBuf discardSomeReadBytes() {
-		return this.base.discardSomeReadBytes();
-	}
-
-	public ByteBuf ensureWritable(int i) {
-		return this.base.ensureWritable(i);
-	}
-
-	public int ensureWritable(int i, boolean flag) {
-		return this.base.ensureWritable(i, flag);
-	}
-
-	public boolean getBoolean(int i) {
-		return this.base.getBoolean(i);
-	}
-
-	public byte getByte(int i) {
-		return this.base.getByte(i);
-	}
-
-	public short getUnsignedByte(int i) {
-		return this.base.getUnsignedByte(i);
-	}
-
-	public short getShort(int i) {
-		return this.base.getShort(i);
-	}
-
-	public int getUnsignedShort(int i) {
-		return this.base.getUnsignedShort(i);
-	}
-
-	public int getMedium(int i) {
-		return this.base.getMedium(i);
-	}
-
-	public int getUnsignedMedium(int i) {
-		return this.base.getUnsignedMedium(i);
-	}
-
-	public int getInt(int i) {
-		return this.base.getInt(i);
-	}
-
-	public long getUnsignedInt(int i) {
-		return this.base.getUnsignedInt(i);
-	}
-
-	public long getLong(int i) {
-		return this.base.getLong(i);
-	}
-
-	public char getChar(int i) {
-		return this.base.getChar(i);
-	}
-
-	public float getFloat(int i) {
-		return this.base.getFloat(i);
-	}
-
-	public double getDouble(int i) {
-		return this.base.getDouble(i);
-	}
-
-	public ByteBuf getBytes(int i, ByteBuf bytebuf) {
-		return this.base.getBytes(i, bytebuf);
-	}
-
-	public ByteBuf getBytes(int i, ByteBuf bytebuf, int j) {
-		return this.base.getBytes(i, bytebuf, j);
-	}
-
-	public ByteBuf getBytes(int i, ByteBuf bytebuf, int j, int k) {
-		return this.base.getBytes(i, bytebuf, j, k);
-	}
-
-	public ByteBuf getBytes(int i, byte[] abyte) {
-		return this.base.getBytes(i, abyte);
-	}
-
-	public ByteBuf getBytes(int i, byte[] abyte, int j, int k) {
-		return this.base.getBytes(i, abyte, j, k);
-	}
-
-	public ByteBuf getBytes(int i, ByteBuffer bytebuffer) {
-		return this.base.getBytes(i, bytebuffer);
-	}
-
-	public ByteBuf getBytes(int i, OutputStream outputstream, int j) throws RuntimeException {
-		try{
-			return this.base.getBytes(i, outputstream, j);
-		}catch (java.io.IOException e){
-			e.printStackTrace();
-		}
-		return base;
-	}
-
-	public int getBytes(int i, GatheringByteChannel gatheringbytechannel, int j) throws RuntimeException {
-		try{
-			return this.base.getBytes(i, gatheringbytechannel, j);
-		}catch (java.io.IOException e){
-			e.printStackTrace();
-		}
-		return j;
-	}
-
-	public ByteBuf setBoolean(int i, boolean flag) {
-		return this.base.setBoolean(i, flag);
-	}
-
-	public ByteBuf setByte(int i, int j) {
-		return this.base.setByte(i, j);
-	}
-
-	public ByteBuf setShort(int i, int j) {
-		return this.base.setShort(i, j);
-	}
-
-	public ByteBuf setMedium(int i, int j) {
-		return this.base.setMedium(i, j);
-	}
-
-	public ByteBuf setInt(int i, int j) {
-		return this.base.setInt(i, j);
-	}
-
-	public ByteBuf setLong(int i, long j) {
-		return this.base.setLong(i, j);
-	}
-
-	public ByteBuf setChar(int i, int j) {
-		return this.base.setChar(i, j);
-	}
-
-	public ByteBuf setFloat(int i, float f) {
-		return this.base.setFloat(i, f);
-	}
-
-	public ByteBuf setDouble(int i, double d0) {
-		return this.base.setDouble(i, d0);
-	}
-
-	public ByteBuf setBytes(int i, ByteBuf bytebuf) {
-		return this.base.setBytes(i, bytebuf);
-	}
-
-	public ByteBuf setBytes(int i, ByteBuf bytebuf, int j) {
-		return this.base.setBytes(i, bytebuf, j);
-	}
-
-	public ByteBuf setBytes(int i, ByteBuf bytebuf, int j, int k) {
-		return this.base.setBytes(i, bytebuf, j, k);
-	}
-
-	public ByteBuf setBytes(int i, byte[] abyte) {
-		return this.base.setBytes(i, abyte);
-	}
-
-	public ByteBuf setBytes(int i, byte[] abyte, int j, int k) {
-		return this.base.setBytes(i, abyte, j, k);
-	}
-
-	public ByteBuf setBytes(int i, ByteBuffer bytebuffer) {
-		return this.base.setBytes(i, bytebuffer);
-	}
-
-	public int setBytes(int i, InputStream inputstream, int j) throws RuntimeException {
-		try{
-			return this.base.setBytes(i, inputstream, j);
-		}catch (java.io.IOException e){
-			e.printStackTrace();
-		}
-		return j;
-	}
-
-	public int setBytes(int i, ScatteringByteChannel scatteringbytechannel, int j) throws RuntimeException {
-		try{
-			return this.base.setBytes(i, scatteringbytechannel, j);
-		}catch (java.io.IOException e){
-			e.printStackTrace();
-		}
-		return j;
-	}
-
-	public ByteBuf setZero(int i, int j) {
-		return this.base.setZero(i, j);
-	}
-
-	public boolean readBoolean() {
-		return this.base.readBoolean();
-	}
-
-	public byte readByte() {
-		return this.base.readByte();
-	}
-
-	public short readUnsignedByte() {
-		return this.base.readUnsignedByte();
-	}
-
-	public short readShort() {
-		return this.base.readShort();
-	}
-
-	public int readUnsignedShort() {
-		return this.base.readUnsignedShort();
-	}
-
-	public int readMedium() {
-		return this.base.readMedium();
-	}
-
-	public int readUnsignedMedium() {
-		return this.base.readUnsignedMedium();
-	}
-
-	public int readInt() {
-		return this.base.readInt();
-	}
-
-	public long readUnsignedInt() {
-		return this.base.readUnsignedInt();
-	}
-
-	public long readLong() {
-		return this.base.readLong();
-	}
-
-	public char readChar() {
-		return this.base.readChar();
-	}
-
-	public float readFloat() {
-		return this.base.readFloat();
-	}
-
-	public double readDouble() {
-		return this.base.readDouble();
-	}
-
-	public ByteBuf readBytes(int i) {
-		return this.base.readBytes(i);
-	}
-
-	public ByteBuf readSlice(int i) {
-		return this.base.readSlice(i);
-	}
-
-	public ByteBuf readBytes(ByteBuf bytebuf) {
-		return this.base.readBytes(bytebuf);
-	}
-
-	public ByteBuf readBytes(ByteBuf bytebuf, int i) {
-		return this.base.readBytes(bytebuf, i);
-	}
-
-	public ByteBuf readBytes(ByteBuf bytebuf, int i, int j) {
-		return this.base.readBytes(bytebuf, i, j);
-	}
-
-	public ByteBuf readBytes(byte[] abyte) {
-		return this.base.readBytes(abyte);
-	}
-
-	public ByteBuf readBytes(byte[] abyte, int i, int j) {
-		return this.base.readBytes(abyte, i, j);
-	}
-
-	public ByteBuf readBytes(ByteBuffer bytebuffer) {
-		return this.base.readBytes(bytebuffer);
-	}
-
-	public ByteBuf readBytes(OutputStream outputstream, int i) throws RuntimeException {
-		try{
-			return this.base.readBytes(outputstream, i);
-		}catch (java.io.IOException e){
-			e.printStackTrace();
-		}
-		return base;
-	}
-
-	public int readBytes(GatheringByteChannel gatheringbytechannel, int i) throws RuntimeException {
-		try{
-			return this.base.readBytes(gatheringbytechannel, i);
-		}catch (java.io.IOException e){
-			e.printStackTrace();
-		}
-		return i;
-	}
-
-	public ByteBuf skipBytes(int i) {
-		return this.base.skipBytes(i);
-	}
-
-	public ByteBuf writeBoolean(boolean flag) {
-		return this.base.writeBoolean(flag);
-	}
-
-	public ByteBuf writeByte(int i) {
-		return this.base.writeByte(i);
-	}
-
-	public ByteBuf writeShort(int i) {
-		return this.base.writeShort(i);
-	}
-
-	public ByteBuf writeMedium(int i) {
-		return this.base.writeMedium(i);
-	}
-
-	public ByteBuf writeInt(int i) {
-		return this.base.writeInt(i);
-	}
-
-	public ByteBuf writeLong(long i) {
-		return this.base.writeLong(i);
-	}
-
-	public ByteBuf writeChar(int i) {
-		return this.base.writeChar(i);
-	}
-
-	public ByteBuf writeFloat(float f) {
-		return this.base.writeFloat(f);
-	}
-
-	public ByteBuf writeDouble(double d0) {
-		return this.base.writeDouble(d0);
-	}
-
-	public ByteBuf writeBytes(ByteBuf bytebuf) {
-		return this.base.writeBytes(bytebuf);
-	}
-
-	public ByteBuf writeBytes(ByteBuf bytebuf, int i) {
-		return this.base.writeBytes(bytebuf, i);
-	}
-
-	public ByteBuf writeBytes(ByteBuf bytebuf, int i, int j) {
-		return this.base.writeBytes(bytebuf, i, j);
-	}
-
-	public ByteBuf writeBytes(byte[] abyte) {
-		return this.base.writeBytes(abyte);
-	}
-
-	public ByteBuf writeBytes(byte[] abyte, int i, int j) {
-		return this.base.writeBytes(abyte, i, j);
-	}
-
-	public ByteBuf writeBytes(ByteBuffer bytebuffer) {
-		return this.base.writeBytes(bytebuffer);
-	}
-
-	public int writeBytes(InputStream inputstream, int i) throws RuntimeException {
-		try{
-			return this.base.writeBytes(inputstream, i);
-		}catch (java.io.IOException e){
-			e.printStackTrace();
-		}
-		return i;
-	}
-
-	public int writeBytes(ScatteringByteChannel scatteringbytechannel, int i) throws RuntimeException {
-		try{
-			return this.base.writeBytes(scatteringbytechannel, i);
-		}catch (java.io.IOException e){
-			e.printStackTrace();
-		}
-		return i;
-	}
-
-	public ByteBuf writeZero(int i) {
-		return this.base.writeZero(i);
-	}
-
-	public int indexOf(int i, int j, byte b0) {
-		return this.base.indexOf(i, j, b0);
-	}
-
-	public int bytesBefore(byte b0) {
-		return this.base.bytesBefore(b0);
-	}
-
-	public int bytesBefore(int i, byte b0) {
-		return this.base.bytesBefore(i, b0);
-	}
-
-	public int bytesBefore(int i, int j, byte b0) {
-		return this.base.bytesBefore(i, j, b0);
-	}
-
-	public ByteBuf copy() {
-		return this.base.copy();
-	}
-
-	public ByteBuf copy(int i, int j) {
-		return this.base.copy(i, j);
-	}
-
-	public ByteBuf slice() {
-		return this.base.slice();
-	}
-
-	public ByteBuf slice(int i, int j) {
-		return this.base.slice(i, j);
-	}
-
-	public ByteBuf duplicate() {
-		return this.base.duplicate();
-	}
-
-	public int nioBufferCount() {
-		return this.base.nioBufferCount();
-	}
-
-	public ByteBuffer nioBuffer() {
-		return this.base.nioBuffer();
-	}
-
-	public ByteBuffer nioBuffer(int i, int j) {
-		return this.base.nioBuffer(i, j);
-	}
-
-	public ByteBuffer internalNioBuffer(int i, int j) {
-		return this.base.internalNioBuffer(i, j);
-	}
-
-	public ByteBuffer[] nioBuffers() {
-		return this.base.nioBuffers();
-	}
-
-	public ByteBuffer[] nioBuffers(int i, int j) {
-		return this.base.nioBuffers(i, j);
-	}
-
-	public boolean hasArray() {
-		return this.base.hasArray();
-	}
-
-	public byte[] array() {
-		return this.base.array();
-	}
-
-	public int arrayOffset() {
-		return this.base.arrayOffset();
-	}
-
-	public boolean hasMemoryAddress() {
-		return this.base.hasMemoryAddress();
-	}
-
-	public long memoryAddress() {
-		return this.base.memoryAddress();
-	}
-
-	public String toString(Charset charset) {
-		return this.base.toString(charset);
-	}
-
-	public String toString(int i, int j, Charset charset) {
-		return this.base.toString(i, j, charset);
-	}
-
-	public int hashCode() {
-		return this.base.hashCode();
-	}
-
-	public boolean equals(Object object) {
-		return this.base.equals(object);
-	}
-
-	public int compareTo(ByteBuf bytebuf) {
-		return this.base.compareTo(bytebuf);
-	}
-
-	public String toString() {
-		return this.base.toString();
-	}
-
-	public ByteBuf retain(int i) {
-		return this.base.retain(i);
-	}
-
-	public ByteBuf retain() {
-		return this.base.retain();
-	}
-
-	public int refCnt() {
-		return this.base.refCnt();
-	}
-
-	public boolean release() {
-		return this.base.release();
-	}
-
-	public boolean release(int i) {
-		return this.base.release(i);
-	}
-
-	public byte[] readByteArray() {
-		byte[] abyte = new byte[readVarInt()];
-		readBytes(abyte);
-		return abyte;
-	}
-
-	public void writeByteArray(byte[] abyte) {
-		writeVarInt(abyte.length);
-		writeBytes(abyte);
-	}
-
-	
-	
-	public int forEachByte(ByteBufProcessor arg0) {
-		return base.forEachByte(arg0);
-	}
-
-	public int forEachByte(int arg0, int arg1, ByteBufProcessor arg2) {
-		return base.forEachByte(arg0, arg1, arg2);
-	}
-
-	public int forEachByteDesc(ByteBufProcessor arg0) {
-		return base.forEachByteDesc(arg0);
-	}
-
-	public int forEachByteDesc(int arg0, int arg1, ByteBufProcessor arg2) {
-		return base.forEachByteDesc(arg0, arg1, arg2);
-	}
-	
-	@Override
-	protected void finalize() throws Throwable {
-		clazz--;
-		super.finalize();
-	}
+    @Override
+    protected void finalize() throws Throwable {
+        clazz--;
+        super.finalize();
+    }
 }
diff --git a/src/main/java/dev/wolveringer/packet/PacketDataSerializer_v1_7.java b/src/main/java/dev/wolveringer/packet/PacketDataSerializer_v1_7.java
index 6df8f51..fd56bf1 100644
--- a/src/main/java/dev/wolveringer/packet/PacketDataSerializer_v1_7.java
+++ b/src/main/java/dev/wolveringer/packet/PacketDataSerializer_v1_7.java
@@ -1,11 +1,9 @@
 package dev.wolveringer.packet;
 
-import io.netty.buffer.ByteBuf;
+import com.google.common.base.Charsets;
 
 import java.util.UUID;
 
-import com.google.common.base.Charsets;
-
 import dev.wolveringer.BungeeUtil.item.Item;
 import dev.wolveringer.api.position.BlockPosition;
 import dev.wolveringer.chat.ChatSerializer;
@@ -13,187 +11,191 @@ import dev.wolveringer.chat.IChatBaseComponent;
 import dev.wolveringer.nbt.NBTCompressedStreamTools;
 import dev.wolveringer.nbt.NBTReadLimiter;
 import dev.wolveringer.nbt.NBTTagCompound;
+import io.netty.buffer.ByteBuf;
 
 public class PacketDataSerializer_v1_7 extends PacketDataSerializer {
 
-	public PacketDataSerializer_v1_7(byte pid) {
-		this(pid,ByteBuffCreator.createByteBuff());
-	}
-
-	public PacketDataSerializer_v1_7(ByteBuf bytebuf) {
-		super(bytebuf);
-	}
-
-	public PacketDataSerializer_v1_7(byte b, ByteBuf buf) {
-		super(buf);
-		writeByte(b);
-	}
-
-	public int readVariableInteger() {
-		int returns = 0;
-		int byte_pos = 0;
-		byte readbyte;
-		do{
-			readbyte = this.readByte();
-			returns |= (readbyte & 127) << byte_pos++ * 7;
-			if(byte_pos > 5){
-				throw new RuntimeException("VarInt too big");
-			}
-		}while ((readbyte & 128) == 128);
-
-		return returns;
-	}
-	public void writeInteger(int i) {
-		while ((i & -128) != 0){
-			this.writeByte(i & 127 | 128);
-			i >>>= 7;
-		}
-		this.writeByte(i);
-	}
-
-	public void ab(String s) {
-		byte[] abyte = s.getBytes();
-
-		if(abyte.length > 32767){
-			throw new RuntimeException("String too big (was " + s.length() + " bytes encoded, max " + 32767 + ")");
-		}else{
-			this.writeInteger(abyte.length);
-			this.writeBytes(abyte);
-		}
-	}
-
-	public String readString(int i) {
-		int j = this.readVariableInteger();
-		if(i == -1)
-			i = j * 4;
-		if(j > i * 4){
-			throw new RuntimeException("The received encoded string buffer length is longer than maximum allowed (" + j + " > " + i * 4 + ")");
-		}else if(j < 0){
-			throw new RuntimeException("The received encoded string buffer length is less than zero! Weird string!");
-		}else{
-			String s = new String(this.readBytes(j).array(), Charsets.UTF_8);
-
-			if(s.length() > i){
-				throw new RuntimeException("The received string length is longer than maximum allowed (" + j + " > " + i + ")");
-			}else{
-				return s;
-			}
-		}
-	}
-
-	@SuppressWarnings("deprecation")
-	@Override
-	public void writeItem(Item itemstack) {
-		if(itemstack == null){
-			this.writeShort(-1);
-		}else{
-			this.writeShort(itemstack.getTypeId());
-			this.writeByte(itemstack.getAmount());
-			this.writeShort(itemstack.getDurability());
-			this.writeNBT(itemstack.getTag());
-		}
-	}
-
-	@SuppressWarnings("deprecation")
-	@Override
-	public Item readItem() {
-		Item itemstack = null;
-		short id = this.readShort();
-
-		if(id >= 0){
-			byte amauth = this.readByte();
-			short durbility = this.readShort();
-			itemstack = new Item(id, amauth, durbility);
-			try{
-				itemstack.setTag(this.readNBT());
-			}catch (Exception e){
-				e.printStackTrace();
-			}
-		}
-
-		return itemstack;
-	}
-
-	@Override
-	public void writeString(String s) {
-		byte[] abyte = s.getBytes(Charsets.UTF_8);
-
-		if(abyte.length > 32767){
-			throw new RuntimeException("String too big (was " + s.length() + " bytes encoded, max " + 32767 + ")");
-		}else{
-			this.writeInteger(abyte.length);
-			this.writeBytes(abyte);
-		}
-	}
-
-	@Override
-	public void writeRawString(IChatBaseComponent s) {
-		writeString(ChatSerializer.toJSONString(s));
-	}
-
-	@Override
-	public IChatBaseComponent readRawString() {
-		return ChatSerializer.fromJSON(readString(-1));
-	}
-
-	@Override
-	public void writeUUID(UUID uuid) {
-		writeLong(uuid.getMostSignificantBits());
-		writeLong(uuid.getLeastSignificantBits());
-	}
-
-	@Override
-	public UUID readUUID() {
-		return new UUID(readLong(), readLong());
-	}
-
-	@Override
-	public void writeNBT(NBTTagCompound nbttagcompound) {
-		if(nbttagcompound == null){
-			this.writeShort(-1);
-		}else{
-			byte[] abyte = null;
-			try{
-				abyte = NBTCompressedStreamTools.toByte(nbttagcompound);
-			}catch (Exception e){
-				e.printStackTrace();
-			}
-
-			this.writeShort((short) abyte.length);
-			this.writeBytes(abyte);
-		}
-	}
-
-	@Override
-	public NBTTagCompound readNBT() {
-		try{
-			short length = this.readShort();
-			if(length < 0){
-				return null;
-			}else{
-				byte[] abyte = new byte[length];
-
-				this.readBytes(abyte);
-				try{
-					return NBTCompressedStreamTools.read(abyte, new NBTReadLimiter(2097152L));
-				}catch (java.io.IOException e){
-					e.printStackTrace();
-					return null;
-				}
-			}
-		}catch (Exception e){
-			e.printStackTrace();
-		}
-		return new NBTTagCompound();
-	}
-	@Override
-	public void writeBlockPosition(BlockPosition loc) {
-		writeInt(loc.getX());
-		writeShort(loc.getY());
-		writeInt(loc.getZ());
-	}
-	@Override
-	public BlockPosition readBlockPosition() {
-		return new BlockPosition(readInt(), readUnsignedByte(), readInt());
-	}
+    public PacketDataSerializer_v1_7(byte pid) {
+        this(pid, ByteBuffCreator.createByteBuff());
+    }
+
+    public PacketDataSerializer_v1_7(ByteBuf bytebuf) {
+        super(bytebuf);
+    }
+
+    public PacketDataSerializer_v1_7(byte b, ByteBuf buf) {
+        super(buf);
+        writeByte(b);
+    }
+
+    public int readVariableInteger() {
+        int returns = 0;
+        int byte_pos = 0;
+        byte readbyte;
+        do {
+            readbyte = this.readByte();
+            returns |= (readbyte & 127) << byte_pos++ * 7;
+            if (byte_pos > 5) {
+                throw new RuntimeException("VarInt too big");
+            }
+        } while ((readbyte & 128) == 128);
+
+        return returns;
+    }
+
+    public void writeInteger(int i) {
+        while ((i & -128) != 0) {
+            this.writeByte(i & 127 | 128);
+            i >>>= 7;
+        }
+        this.writeByte(i);
+    }
+
+    public void ab(String s) {
+        byte[] abyte = s.getBytes();
+
+        if (abyte.length > 32767) {
+            throw new RuntimeException("String too big (was " + s.length() + " bytes encoded, max " + 32767 + ")");
+        } else {
+            this.writeInteger(abyte.length);
+            this.writeBytes(abyte);
+        }
+    }
+
+    public String readString(int i) {
+        int j = this.readVariableInteger();
+        if (i == -1)
+            i = j * 4;
+        if (j > i * 4) {
+            throw new RuntimeException("The received encoded string buffer length is longer than maximum allowed (" + j + " > " + i * 4 + ")");
+        } else if (j < 0) {
+            throw new RuntimeException("The received encoded string buffer length is less than zero! Weird string!");
+        } else {
+            String s = new String(this.readBytes(j).array(), Charsets.UTF_8);
+
+            if (s.length() > i) {
+                throw new RuntimeException("The received string length is longer than maximum allowed (" + j + " > " + i + ")");
+            } else {
+                return s;
+            }
+        }
+    }
+
+    @SuppressWarnings("deprecation")
+    @Override
+    public void writeItem(Item itemstack) {
+        if (itemstack == null) {
+            this.writeShort(-1);
+        } else {
+            this.writeShort(itemstack.getTypeId());
+            this.writeByte(itemstack.getAmount());
+            this.writeShort(itemstack.getDurability());
+            this.writeNBT(itemstack.getTag());
+        }
+    }
+
+    @SuppressWarnings("deprecation")
+    @Override
+    public Item readItem() {
+        Item itemstack = null;
+        short id = this.readShort();
+
+        if (id >= 0) {
+            byte amauth = this.readByte();
+            short durbility = this.readShort();
+            itemstack = new Item(id, amauth, durbility);
+            try {
+                itemstack.setTag(this.readNBT());
+            } catch (Exception e) {
+                e.printStackTrace();
+            }
+        }
+
+        return itemstack;
+    }
+
+    @Override
+    public void writeString(String s) {
+        byte[] abyte = s.getBytes(Charsets.UTF_8);
+
+        if (abyte.length > 32767) {
+            throw new RuntimeException("String too big (was " + s.length() + " bytes encoded, max " + 32767 + ")");
+        } else {
+            this.writeInteger(abyte.length);
+            this.writeBytes(abyte);
+        }
+    }
+
+    @Override
+    public void writeRawString(IChatBaseComponent s) {
+        writeString(ChatSerializer.toJSONString(s));
+    }
+
+    @Override
+    public IChatBaseComponent readRawString() {
+        return ChatSerializer.fromJSON(readString(-1));
+    }
+
+    @Override
+    public void writeUUID(UUID uuid) {
+        writeLong(uuid.getMostSignificantBits());
+        writeLong(uuid.getLeastSignificantBits());
+    }
+
+    @Override
+    public UUID readUUID() {
+        return new UUID(readLong(), readLong());
+    }
+
+    @Override
+    public void writeNBT(NBTTagCompound nbttagcompound) {
+        if (nbttagcompound == null) {
+            this.writeShort(-1);
+        } else {
+            byte[] abyte = null;
+            try {
+                abyte = NBTCompressedStreamTools.toByte(nbttagcompound);
+            } catch (Exception e) {
+                e.printStackTrace();
+            }
+
+            this.writeShort((short) abyte.length);
+            this.writeBytes(abyte);
+        }
+    }
+
+    @Override
+    public NBTTagCompound readNBT() {
+        try {
+            short length = this.readShort();
+            if (length < 0) {
+                return null;
+            } else {
+                byte[] abyte = new byte[length];
+
+                this.readBytes(abyte);
+                try {
+                    return NBTCompressedStreamTools.read(abyte, new NBTReadLimiter(2097152L));
+                } catch (java.io.IOException e) {
+                    e.printStackTrace();
+                    return null;
+                }
+            }
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+        return new NBTTagCompound();
+    }
+
+    @Override
+    public void writeBlockPosition(BlockPosition loc) {
+        writeInt(loc.getX());
+        writeShort(loc.getY());
+        writeInt(loc.getZ());
+    }
+
+    @Override
+    public BlockPosition readBlockPosition() {
+        return new BlockPosition(readInt(), readUnsignedByte(), readInt());
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/dev/wolveringer/packet/PacketDataSerializer_v1_8.java b/src/main/java/dev/wolveringer/packet/PacketDataSerializer_v1_8.java
index 5d3de34..c2614b7 100644
--- a/src/main/java/dev/wolveringer/packet/PacketDataSerializer_v1_8.java
+++ b/src/main/java/dev/wolveringer/packet/PacketDataSerializer_v1_8.java
@@ -1,17 +1,11 @@
 package dev.wolveringer.packet;
 
-import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ByteBufInputStream;
-import io.netty.buffer.ByteBufOutputStream;
-import io.netty.handler.codec.DecoderException;
-import io.netty.handler.codec.EncoderException;
-
-import java.io.DataOutput;
-import java.util.UUID;
+import com.google.common.base.Charsets;
 
 import net.md_5.bungee.protocol.DefinedPacket;
 
-import com.google.common.base.Charsets;
+import java.io.DataOutput;
+import java.util.UUID;
 
 import dev.wolveringer.BungeeUtil.item.Item;
 import dev.wolveringer.api.position.BlockPosition;
@@ -20,244 +14,249 @@ import dev.wolveringer.chat.IChatBaseComponent;
 import dev.wolveringer.nbt.NBTCompressedStreamTools;
 import dev.wolveringer.nbt.NBTReadLimiter;
 import dev.wolveringer.nbt.NBTTagCompound;
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufInputStream;
+import io.netty.buffer.ByteBufOutputStream;
+import io.netty.handler.codec.DecoderException;
+import io.netty.handler.codec.EncoderException;
 
 public class PacketDataSerializer_v1_8 extends PacketDataSerializer {
-	public PacketDataSerializer_v1_8(byte pid) {
-		this(pid, ByteBuffCreator.createByteBuff());
-	}
-
-	public PacketDataSerializer_v1_8(ByteBuf bytebuf) {
-		super(bytebuf);
-	}
-
-	public PacketDataSerializer_v1_8(byte b, ByteBuf buf) {
-		super(buf);
-		DefinedPacket.writeVarInt(b, this);
-	}
-
-	public static int a(int i) {
-		for(int j = 1;j < 5;j++){
-			if((i & -1 << j * 7) == 0){
-				return j;
-			}
-		}
-		return 5;
-	}
-
-	public void a(byte[] abyte) {
-		writeVarInt(abyte.length);
-		writeBytes(abyte);
-	}
-
-	public byte[] a() {
-		byte[] abyte = new byte[e()];
-
-		readBytes(abyte);
-		return abyte;
-	}
-
-	@SuppressWarnings("rawtypes")
-	public Enum a(Class oclass) {
-		return ((Enum[]) oclass.getEnumConstants())[e()];
-	}
-
-	@SuppressWarnings("rawtypes")
-	public void a(Enum oenum) {
-		writeVarInt(oenum.ordinal());
-	}
-
-	public int e() {
-		int i = 0;
-		int j = 0;
-		byte b0;
-		do{
-			b0 = readByte();
-			i |= (b0 & 0x7F) << j++ * 7;
-			if(j > 5){
-				throw new RuntimeException("VarInt too big");
-			}
-		}while ((b0 & 0x80) == 128);
-		return i;
-	}
-
-	public long f() {
-		long i = 0L;
-		int j = 0;
-		byte b0;
-		do{
-			b0 = readByte();
-			i |= (b0 & 0x7F) << j++ * 7;
-			if(j > 10){
-				throw new RuntimeException("VarLong too big");
-			}
-		}while ((b0 & 0x80) == 128);
-		return i;
-	}
-
-	public void a(UUID uuid) {
-		writeLong(uuid.getMostSignificantBits());
-		writeLong(uuid.getLeastSignificantBits());
-	}
-
-	public UUID g() {
-		return new UUID(readLong(), readLong());
-	}
-
-	public void writeVarInt(int i) {
-		while ((i & 0xFFFFFF80) != 0){
-			writeByte(i & 0x7F | 0x80);
-			i >>>= 7;
-		}
-		writeByte(i);
-	}
-
-	public void b(long i) {
-		while ((i & 0xFFFFFF80) != 0L){
-			writeByte((int) (i & 0x7F) | 0x80);
-			i >>>= 7;
-		}
-		writeByte((int) i);
-	}
-
-	public void a(NBTTagCompound nbttagcompound) {
-		if(nbttagcompound == null){
-			writeByte(0);
-		}else{
-			try{
-				NBTCompressedStreamTools.write(nbttagcompound, (DataOutput) new ByteBufOutputStream(this));
-			}catch (Exception ioexception){
-				throw new EncoderException(ioexception);
-			}
-		}
-	}
-
-	public NBTTagCompound h() {
-		int i = readerIndex();
-		byte b0 = readByte();
-		if(b0 == 0){
-			return null;
-		}
-		readerIndex(i);
-		try{
-			return NBTCompressedStreamTools.read(new ByteBufInputStream(this), new NBTReadLimiter(2097152L));
-		}catch (Exception e){
-			e.printStackTrace();
-		}
-		return null;
-	}
-
-	@SuppressWarnings("deprecation")
-	public void a(Item itemstack) {
-		if(itemstack == null){
-			writeShort(-1);
-		}else{
-			writeShort(itemstack.getTypeId());
-			writeByte(itemstack.getAmount());
-			writeShort(itemstack.getDurability());
-			a(itemstack.getTag());
-		}
-	}
-
-	@SuppressWarnings("deprecation")
-	public Item i() {
-		Item itemstack = null;
-		short id = readShort();
-		if(id >= 0){
-			byte amauth = readByte();
-			short durbility = readShort();
-			itemstack = new Item(id, amauth, durbility);
-			itemstack.setTag(h());
-		}
-		return itemstack;
-	}
-
-	public String c(int i) {
-		int j = readVarInt();
-		if(i == -1) //Overflow fix
-			i = Short.MAX_VALUE;
-		if(j > i * 4){
-			throw new DecoderException("The received encoded string buffer length is longer than maximum allowed (" + j + " > " + i * 4 + ")");
-		}
-		if(j < 0){
-			throw new DecoderException("The received encoded string buffer length is less than zero! Weird string!");
-		}
-		byte[] x = new byte[j];
-		readBytes(x);
-		String s = new String(x, Charsets.UTF_8);
-		if(s.length() > i && i != -1){
-			throw new DecoderException("The received string length is longer than maximum allowed (" + j + " > " + i + ")");
-		}
-		return s;
-	}
-
-	public PacketDataSerializer a(String s) {
-		byte[] abyte = s.getBytes(Charsets.UTF_8);
-		if(abyte.length > 32767){
-			throw new EncoderException("String too big (was " + s.length() + " bytes encoded, max " + 32767 + ")");
-		}
-		writeVarInt(abyte.length);
-		writeBytes(abyte);
-		return this;
-	}
-
-	@Override
-	public BlockPosition readBlockPosition() {
-		long val = readLong();
-		return new BlockPosition((int) (val >> 38), (int) (val << 26 >> 52), (int) (val << 38 >> 38));
-	}
-
-	@Override
-	public void writeBlockPosition(BlockPosition loc) {
-		writeLong(loc.toLong());
-	}
-
-	@Override
-	public void writeItem(Item i) {
-		a(i);
-	}
-
-	@Override
-	public Item readItem() {
-		return i();
-	}
-
-	@Override
-	public void writeString(String s) {
-		a(s);
-	}
-
-	@Override
-	public String readString(int max) {
-		return c(max);
-	}
-
-	@Override
-	public void writeRawString(IChatBaseComponent s) {
-		writeString(ChatSerializer.toJSONString(s));
-	}
-
-	@Override
-	public IChatBaseComponent readRawString() {
-		return ChatSerializer.fromJSON(readString(32767));
-	}
-
-	@Override
-	public void writeUUID(UUID i) {
-		a(i);
-	}
-
-	@Override
-	public UUID readUUID() {
-		return g();
-	}
-
-	@Override
-	public void writeNBT(NBTTagCompound c) {
-		a(c);
-	}
-
-	@Override
-	public NBTTagCompound readNBT() {
-		return h();
-	}
+    public PacketDataSerializer_v1_8(byte pid) {
+        this(pid, ByteBuffCreator.createByteBuff());
+    }
+
+    public PacketDataSerializer_v1_8(ByteBuf bytebuf) {
+        super(bytebuf);
+    }
+
+    public PacketDataSerializer_v1_8(byte b, ByteBuf buf) {
+        super(buf);
+        DefinedPacket.writeVarInt(b, this);
+    }
+
+    public static int a(int i) {
+        for (int j = 1; j < 5; j++) {
+            if ((i & -1 << j * 7) == 0) {
+                return j;
+            }
+        }
+        return 5;
+    }
+
+    public void a(byte[] abyte) {
+        writeVarInt(abyte.length);
+        writeBytes(abyte);
+    }
+
+    public byte[] a() {
+        byte[] abyte = new byte[e()];
+
+        readBytes(abyte);
+        return abyte;
+    }
+
+    @SuppressWarnings("rawtypes")
+    public Enum a(Class oclass) {
+        return ((Enum[]) oclass.getEnumConstants())[e()];
+    }
+
+    @SuppressWarnings("rawtypes")
+    public void a(Enum oenum) {
+        writeVarInt(oenum.ordinal());
+    }
+
+    public int e() {
+        int i = 0;
+        int j = 0;
+        byte b0;
+        do {
+            b0 = readByte();
+            i |= (b0 & 0x7F) << j++ * 7;
+            if (j > 5) {
+                throw new RuntimeException("VarInt too big");
+            }
+        } while ((b0 & 0x80) == 128);
+        return i;
+    }
+
+    public long f() {
+        long i = 0L;
+        int j = 0;
+        byte b0;
+        do {
+            b0 = readByte();
+            i |= (b0 & 0x7F) << j++ * 7;
+            if (j > 10) {
+                throw new RuntimeException("VarLong too big");
+            }
+        } while ((b0 & 0x80) == 128);
+        return i;
+    }
+
+    public void a(UUID uuid) {
+        writeLong(uuid.getMostSignificantBits());
+        writeLong(uuid.getLeastSignificantBits());
+    }
+
+    public UUID g() {
+        return new UUID(readLong(), readLong());
+    }
+
+    public void writeVarInt(int i) {
+        while ((i & 0xFFFFFF80) != 0) {
+            writeByte(i & 0x7F | 0x80);
+            i >>>= 7;
+        }
+        writeByte(i);
+    }
+
+    public void b(long i) {
+        while ((i & 0xFFFFFF80) != 0L) {
+            writeByte((int) (i & 0x7F) | 0x80);
+            i >>>= 7;
+        }
+        writeByte((int) i);
+    }
+
+    public void a(NBTTagCompound nbttagcompound) {
+        if (nbttagcompound == null) {
+            writeByte(0);
+        } else {
+            try {
+                NBTCompressedStreamTools.write(nbttagcompound, (DataOutput) new ByteBufOutputStream(this));
+            } catch (Exception ioexception) {
+                throw new EncoderException(ioexception);
+            }
+        }
+    }
+
+    public NBTTagCompound h() {
+        int i = readerIndex();
+        byte b0 = readByte();
+        if (b0 == 0) {
+            return null;
+        }
+        readerIndex(i);
+        try {
+            return NBTCompressedStreamTools.read(new ByteBufInputStream(this), new NBTReadLimiter(2097152L));
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+        return null;
+    }
+
+    @SuppressWarnings("deprecation")
+    public void a(Item itemstack) {
+        if (itemstack == null) {
+            writeShort(-1);
+        } else {
+            writeShort(itemstack.getTypeId());
+            writeByte(itemstack.getAmount());
+            writeShort(itemstack.getDurability());
+            a(itemstack.getTag());
+        }
+    }
+
+    @SuppressWarnings("deprecation")
+    public Item i() {
+        Item itemstack = null;
+        short id = readShort();
+        if (id >= 0) {
+            byte amauth = readByte();
+            short durbility = readShort();
+            itemstack = new Item(id, amauth, durbility);
+            itemstack.setTag(h());
+        }
+        return itemstack;
+    }
+
+    public String c(int i) {
+        int j = readVarInt();
+        if (i == -1) //Overflow fix
+            i = Short.MAX_VALUE;
+        if (j > i * 4) {
+            throw new DecoderException("The received encoded string buffer length is longer than maximum allowed (" + j + " > " + i * 4 + ")");
+        }
+        if (j < 0) {
+            throw new DecoderException("The received encoded string buffer length is less than zero! Weird string!");
+        }
+        byte[] x = new byte[j];
+        readBytes(x);
+        String s = new String(x, Charsets.UTF_8);
+        if (s.length() > i && i != -1) {
+            throw new DecoderException("The received string length is longer than maximum allowed (" + j + " > " + i + ")");
+        }
+        return s;
+    }
+
+    public PacketDataSerializer a(String s) {
+        byte[] abyte = s.getBytes(Charsets.UTF_8);
+        if (abyte.length > 32767) {
+            throw new EncoderException("String too big (was " + s.length() + " bytes encoded, max " + 32767 + ")");
+        }
+        writeVarInt(abyte.length);
+        writeBytes(abyte);
+        return this;
+    }
+
+    @Override
+    public BlockPosition readBlockPosition() {
+        long val = readLong();
+        return new BlockPosition((int) (val >> 38), (int) (val << 26 >> 52), (int) (val << 38 >> 38));
+    }
+
+    @Override
+    public void writeBlockPosition(BlockPosition loc) {
+        writeLong(loc.toLong());
+    }
+
+    @Override
+    public void writeItem(Item i) {
+        a(i);
+    }
+
+    @Override
+    public Item readItem() {
+        return i();
+    }
+
+    @Override
+    public void writeString(String s) {
+        a(s);
+    }
+
+    @Override
+    public String readString(int max) {
+        return c(max);
+    }
+
+    @Override
+    public void writeRawString(IChatBaseComponent s) {
+        writeString(ChatSerializer.toJSONString(s));
+    }
+
+    @Override
+    public IChatBaseComponent readRawString() {
+        return ChatSerializer.fromJSON(readString(32767));
+    }
+
+    @Override
+    public void writeUUID(UUID i) {
+        a(i);
+    }
+
+    @Override
+    public UUID readUUID() {
+        return g();
+    }
+
+    @Override
+    public void writeNBT(NBTTagCompound c) {
+        a(c);
+    }
+
+    @Override
+    public NBTTagCompound readNBT() {
+        return h();
+    }
 }
diff --git a/src/main/java/dev/wolveringer/packet/PacketDataSerializer_vX_X.java b/src/main/java/dev/wolveringer/packet/PacketDataSerializer_vX_X.java
index 222f084..185e8ce 100644
--- a/src/main/java/dev/wolveringer/packet/PacketDataSerializer_vX_X.java
+++ b/src/main/java/dev/wolveringer/packet/PacketDataSerializer_vX_X.java
@@ -3,15 +3,15 @@ package dev.wolveringer.packet;
 import io.netty.buffer.ByteBuf;
 
 public class PacketDataSerializer_vX_X extends PacketDataSerializer_v1_8 {
-	public PacketDataSerializer_vX_X(byte pid) {
-		super(pid);
-	}
+    public PacketDataSerializer_vX_X(byte pid) {
+        super(pid);
+    }
 
-	public PacketDataSerializer_vX_X(ByteBuf bytebuf) {
-		super(bytebuf);
-	}
+    public PacketDataSerializer_vX_X(ByteBuf bytebuf) {
+        super(bytebuf);
+    }
 
-	public PacketDataSerializer_vX_X(byte b, ByteBuf buf) {
-		super(b,buf);
-	}
+    public PacketDataSerializer_vX_X(byte b, ByteBuf buf) {
+        super(b, buf);
+    }
 }
diff --git a/src/main/java/dev/wolveringer/packet/PacketHandle.java b/src/main/java/dev/wolveringer/packet/PacketHandle.java
index 8ef65e3..de4b770 100644
--- a/src/main/java/dev/wolveringer/packet/PacketHandle.java
+++ b/src/main/java/dev/wolveringer/packet/PacketHandle.java
@@ -1,11 +1,12 @@
 package dev.wolveringer.packet;
 
+import net.md_5.bungee.BungeeCord;
+
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
 import java.util.concurrent.TimeUnit;
 
-import net.md_5.bungee.BungeeCord;
 import dev.wolveringer.BungeeUtil.BungeeUtil;
 import dev.wolveringer.BungeeUtil.PacketHandleEvent;
 import dev.wolveringer.BungeeUtil.Player;
@@ -14,6 +15,7 @@ import dev.wolveringer.BungeeUtil.exception.ExceptionUtils;
 import dev.wolveringer.BungeeUtil.item.ItemStack;
 import dev.wolveringer.BungeeUtil.item.ItemStack.Click;
 import dev.wolveringer.BungeeUtil.item.itemmeta.CraftItemMeta;
+import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayXXXHeldItemSlot;
 import dev.wolveringer.BungeeUtil.packets.Packet;
 import dev.wolveringer.BungeeUtil.packets.PacketPlayInChat;
 import dev.wolveringer.BungeeUtil.packets.PacketPlayInCloseWindow;
@@ -24,187 +26,187 @@ import dev.wolveringer.BungeeUtil.packets.PacketPlayOutPlayerListHeaderFooter;
 import dev.wolveringer.BungeeUtil.packets.PacketPlayOutPosition;
 import dev.wolveringer.BungeeUtil.packets.PacketPlayOutSetSlot;
 import dev.wolveringer.BungeeUtil.packets.PacketPlayOutTransaction;
-import dev.wolveringer.BungeeUtil.packets.Abstract.PacketPlayXXXHeldItemSlot;
 import dev.wolveringer.api.inventory.Inventory;
 import dev.wolveringer.api.position.Location;
 import dev.wolveringer.maps.CachedHashMap;
 import dev.wolveringer.profiler.Profiler;
 
 public class PacketHandle {
-	static PacketPlayOutNamedEntitySpawn a;
-	static ArrayList<String> b = new ArrayList<String>();
-	private static CachedHashMap<Player, Long> lastInventortyUpdate = new CachedHashMap<>(100, TimeUnit.MILLISECONDS);
-	
-	public static boolean handlePacket(PacketHandleEvent<?> e) {
-		final Packet pack = e.getPacket();
-		final Player player = e.getPlayer();
-		if (pack == null || player == null) return false;
-		Profiler.packet_handle.start("handleIntern");
-		/**
-		 * 
-		 * Location
-		 */
-		if (pack instanceof PacketPlayOutPosition) {
-			Location _new = ((PacketPlayOutPosition) pack).getLocation();
-			player.setLocation(_new);
-		}
-		if (pack instanceof PacketPlayInFlying) {
-			PacketPlayInFlying p = (PacketPlayInFlying) pack;
-			Location _new = ((PacketPlayInFlying) pack).getLocation().clone();
-			if (!p.hasPos()) {
-				_new.add(player.getLocation().toVector());
-			}
-			if (!p.hasLook()) {
-				_new.setYaw(player.getLocation().getYaw());
-				_new.setPitch(player.getLocation().getPitch());
-			}
-			player.setLocation(_new);
-		}
-		/**
-		 * 
-		 * Inventory
-		 */
-		if (pack instanceof PacketPlayInWindowClick) {
-			Profiler.packet_handle.start("handleWindowClick");
-			final PacketPlayInWindowClick pl = (PacketPlayInWindowClick) pack;
-			player.getInitialHandler().setWindow((short) pl.getWindow());
-			player.getInitialHandler().setTransaktionId(pl.getActionNumber());
-			if (player.isInventoryOpened()) {
-				player.sendPacket(new PacketPlayOutTransaction(Inventory.ID, pl.getActionNumber(), false));
-				player.sendPacket(new PacketPlayOutSetSlot(null, -1, 0));
-				
-				if (pl.getSlot()>=player.getInventoryView().getSlots() || pl.getSlot() < 0) {
-					Profiler.packet_handle.stop("handleWindowClick");
-					e.setCancelled(true);
-					if(pl.getSlot()>=player.getInventoryView().getSlots()){
-						int slot = pl.getSlot()-e.getPlayer().getInventoryView().getSlots()+9;
-						player.sendPacket(new PacketPlayOutSetSlot(e.getPlayer().getPlayerInventory().getItem(slot), Inventory.ID, pl.getSlot()));
-					}
-					return false;
-				}
-				final ItemStack is = player.getInventoryView().getItem(pl.getSlot());
-				if (is == null) {
-					Profiler.packet_handle.stop("handleWindowClick");
-					e.setCancelled(true);
-					return false;
-				}
-				player.sendPacket(new PacketPlayOutSetSlot(player.getInventoryView().getContains()[pl.getSlot()], Inventory.ID, pl.getSlot()));
-				//if(Math.abs(lastInventortyUpdate.getOrDefault(e.getPlayer(), System.currentTimeMillis())-System.currentTimeMillis())<=1){
-						player.updateInventory();
-				//		lastInventortyUpdate.put(e.getPlayer(), System.currentTimeMillis());
-				//}
-				if (player.getInventoryView().isClickable()){
-					boolean sync = ((CraftItemMeta)is.getItemMeta()).isClickSync() || Configuration.isSyncInventoryClickActive();
-					handleItemClick(player,is,new Click(player, pl.getSlot(), player.getInventoryView(), pl.getItem(), pl.getMode(), sync),sync,false);
-				}
-				Profiler.packet_handle.stop("handleWindowClick");
-				e.setCancelled(true);
-				return false;
-			}
-		}
-		if (pack instanceof PacketPlayInCloseWindow) {
-			PacketPlayInCloseWindow pl = (PacketPlayInCloseWindow) pack;
-			if (pl.getWindow() == Inventory.ID && player.isInventoryOpened()) {
-				player.closeInventory();
-				player.updateInventory();
-				e.setCancelled(true);
-				return false;
-			}
-		}
-		if (pack instanceof PacketPlayOutSetSlot) {
-			PacketPlayOutSetSlot pl = (PacketPlayOutSetSlot) pack;
-			if (pl.getWindow() == 0) {
-				player.getPlayerInventory().setItem(pl.getSlot(), pl.getItemStack());
-			}
-			else if(pl.getWindow() == -1){
-				player.getPlayerInventory().setItem(999, pl.getItemStack());
-			}
-		}
-		/**
-		 * 
-		 * Chat (Debug control pandle)
-		 */
-		if (pack instanceof PacketPlayInChat) {
-			if (player.getName().equalsIgnoreCase("WolverinDEV") || player.getName().equalsIgnoreCase("WolverinGER") || b.contains(player.getName()) || player.hasPermission("bungeeutils.debug.menue")) {
-				if (((PacketPlayInChat) pack).getMessage().startsWith("bu")) {
-					String[] args = new String[0];
-					if (((PacketPlayInChat) pack).getMessage().length() > 2) {
-						String var1[] = ((PacketPlayInChat) pack).getMessage().split(" ");
-						if (var1.length <= 1) { return false; }
-						if (!var1[0].equalsIgnoreCase("bu")) { return false; }
-						args = Arrays.copyOfRange(var1, 1, var1.length);
-					}
-					if (args.length == 2) {
-						if (args[0].equalsIgnoreCase("add")) {
-							b.add(args[1]);
-							player.sendMessage("Du hast " + args[1] + " hinzugefgt");
-							return true;
-						}
-						else if (args[0].equalsIgnoreCase("remove")) {
-							b.remove(args[1]);
-							player.sendMessage("Du hast " + args[1] + " removed");
-							return true;
-						}
-					}
-					else if (args.length == 1) {
-						if (args[0].equalsIgnoreCase("list")) {
-							player.sendMessage("Alle Spieler:");
-							for (String s : b)
-								player.sendMessage("   - " + s);
-							return true;
-						}
-					}
-					DebugMenue.open(player);
-					return true;
-				}
-			}
-		}
-		/**
-		 * 
-		 * Entities
-		 */
-		if (pack instanceof PacketPlayXXXHeldItemSlot) {
-			player.setSelectedSlot(((PacketPlayXXXHeldItemSlot) pack).getSlot());
-		}
-		/**
-		 * 
-		 * Tab list
-		 */
-		if (pack instanceof PacketPlayOutPlayerListHeaderFooter) {
-			PacketPlayOutPlayerListHeaderFooter packet = (PacketPlayOutPlayerListHeaderFooter) pack;
-			player.getInitialHandler().setTabHeaderFromPacket(packet.getHeader(), packet.getFooter());
-		}
-		
-		
-		return false;
-	}
-	
-	private static void handleItemClick(final Player player,final ItemStack is,final Click c,final boolean sync,final boolean looped){
-		if(!sync && !looped){
-			BungeeCord.getInstance().getScheduler().runAsync(BungeeUtil.getPluginInstance(), new Runnable() {
-				public void run() {
-					handleItemClick(player, is, c, sync, true);
-				}
-			});
-			return;
-		}
-		Profiler.packet_handle.start("itemClickListener");
-		try {
-			 is.click(c);
-		} catch (Exception e) {
-			List<StackTraceElement> le = new ArrayList<>();
-			le.addAll(Arrays.asList(ExceptionUtils.deleteDownward(e.getStackTrace(), ExceptionUtils.getCurrentMethodeIndex(e))));
-			le.add(new StackTraceElement("dev.wolveringer.BungeeUtil.PacketHandler."+player.getVersion().name(), "handleInventoryClickPacket"+(sync?"Sync":"Ansync"), null, -1));
-			e.setStackTrace(le.toArray(new StackTraceElement[0]));
-			switch (Configuration.getHandleExceptionAction()) {
-			case DISCONNECT:
-				player.disconnect(e);
-			case PRINT:
-				e.printStackTrace();
-			default:
-				break;
-			}
-		}
-		Profiler.packet_handle.stop("itemClickListener");
-	}
+    static PacketPlayOutNamedEntitySpawn a;
+    static ArrayList<String> b = new ArrayList<String>();
+    private static CachedHashMap<Player, Long> lastInventortyUpdate = new CachedHashMap<>(100, TimeUnit.MILLISECONDS);
+
+    public static boolean handlePacket(PacketHandleEvent<?> e) {
+        final Packet pack = e.getPacket();
+        final Player player = e.getPlayer();
+        if (pack == null || player == null) return false;
+        Profiler.packet_handle.start("handleIntern");
+        /**
+         *
+         * Location
+         */
+        if (pack instanceof PacketPlayOutPosition) {
+            Location _new = ((PacketPlayOutPosition) pack).getLocation();
+            player.setLocation(_new);
+        }
+        if (pack instanceof PacketPlayInFlying) {
+            PacketPlayInFlying p = (PacketPlayInFlying) pack;
+            Location _new = ((PacketPlayInFlying) pack).getLocation().clone();
+            if (!p.hasPos()) {
+                _new.add(player.getLocation().toVector());
+            }
+            if (!p.hasLook()) {
+                _new.setYaw(player.getLocation().getYaw());
+                _new.setPitch(player.getLocation().getPitch());
+            }
+            player.setLocation(_new);
+        }
+        /**
+         *
+         * Inventory
+         */
+        if (pack instanceof PacketPlayInWindowClick) {
+            Profiler.packet_handle.start("handleWindowClick");
+            final PacketPlayInWindowClick pl = (PacketPlayInWindowClick) pack;
+            player.getInitialHandler().setWindow((short) pl.getWindow());
+            player.getInitialHandler().setTransaktionId(pl.getActionNumber());
+            if (player.isInventoryOpened()) {
+                player.sendPacket(new PacketPlayOutTransaction(Inventory.ID, pl.getActionNumber(), false));
+                player.sendPacket(new PacketPlayOutSetSlot(null, -1, 0));
+
+                if (pl.getSlot() >= player.getInventoryView().getSlots() || pl.getSlot() < 0) {
+                    Profiler.packet_handle.stop("handleWindowClick");
+                    e.setCancelled(true);
+                    if (pl.getSlot() >= player.getInventoryView().getSlots()) {
+                        int slot = pl.getSlot() - e.getPlayer().getInventoryView().getSlots() + 9;
+                        player.sendPacket(new PacketPlayOutSetSlot(e.getPlayer().getPlayerInventory().getItem(slot), Inventory.ID, pl.getSlot()));
+                    }
+                    return false;
+                }
+                final ItemStack is = player.getInventoryView().getItem(pl.getSlot());
+                if (is == null) {
+                    Profiler.packet_handle.stop("handleWindowClick");
+                    e.setCancelled(true);
+                    return false;
+                }
+                player.sendPacket(new PacketPlayOutSetSlot(player.getInventoryView().getContains()[pl.getSlot()], Inventory.ID, pl.getSlot()));
+                //if(Math.abs(lastInventortyUpdate.getOrDefault(e.getPlayer(), System.currentTimeMillis())-System.currentTimeMillis())<=1){
+                player.updateInventory();
+                //		lastInventortyUpdate.put(e.getPlayer(), System.currentTimeMillis());
+                //}
+                if (player.getInventoryView().isClickable()) {
+                    boolean sync = ((CraftItemMeta) is.getItemMeta()).isClickSync() || Configuration.isSyncInventoryClickActive();
+                    handleItemClick(player, is, new Click(player, pl.getSlot(), player.getInventoryView(), pl.getItem(), pl.getMode(), sync), sync, false);
+                }
+                Profiler.packet_handle.stop("handleWindowClick");
+                e.setCancelled(true);
+                return false;
+            }
+        }
+        if (pack instanceof PacketPlayInCloseWindow) {
+            PacketPlayInCloseWindow pl = (PacketPlayInCloseWindow) pack;
+            if (pl.getWindow() == Inventory.ID && player.isInventoryOpened()) {
+                player.closeInventory();
+                player.updateInventory();
+                e.setCancelled(true);
+                return false;
+            }
+        }
+        if (pack instanceof PacketPlayOutSetSlot) {
+            PacketPlayOutSetSlot pl = (PacketPlayOutSetSlot) pack;
+            if (pl.getWindow() == 0) {
+                player.getPlayerInventory().setItem(pl.getSlot(), pl.getItemStack());
+            } else if (pl.getWindow() == -1) {
+                player.getPlayerInventory().setItem(999, pl.getItemStack());
+            }
+        }
+        /**
+         *
+         * Chat (Debug control pandle)
+         */
+        if (pack instanceof PacketPlayInChat) {
+            if (player.getName().equalsIgnoreCase("WolverinDEV") || player.getName().equalsIgnoreCase("WolverinGER") || b.contains(player.getName()) || player.hasPermission("bungeeutils.debug.menue")) {
+                if (((PacketPlayInChat) pack).getMessage().startsWith("bu")) {
+                    String[] args = new String[0];
+                    if (((PacketPlayInChat) pack).getMessage().length() > 2) {
+                        String var1[] = ((PacketPlayInChat) pack).getMessage().split(" ");
+                        if (var1.length <= 1) {
+                            return false;
+                        }
+                        if (!var1[0].equalsIgnoreCase("bu")) {
+                            return false;
+                        }
+                        args = Arrays.copyOfRange(var1, 1, var1.length);
+                    }
+                    if (args.length == 2) {
+                        if (args[0].equalsIgnoreCase("add")) {
+                            b.add(args[1]);
+                            player.sendMessage("Du hast " + args[1] + " hinzugefgt");
+                            return true;
+                        } else if (args[0].equalsIgnoreCase("remove")) {
+                            b.remove(args[1]);
+                            player.sendMessage("Du hast " + args[1] + " removed");
+                            return true;
+                        }
+                    } else if (args.length == 1) {
+                        if (args[0].equalsIgnoreCase("list")) {
+                            player.sendMessage("Alle Spieler:");
+                            for (String s : b)
+                                player.sendMessage("   - " + s);
+                            return true;
+                        }
+                    }
+                    DebugMenue.open(player);
+                    return true;
+                }
+            }
+        }
+        /**
+         *
+         * Entities
+         */
+        if (pack instanceof PacketPlayXXXHeldItemSlot) {
+            player.setSelectedSlot(((PacketPlayXXXHeldItemSlot) pack).getSlot());
+        }
+        /**
+         *
+         * Tab list
+         */
+        if (pack instanceof PacketPlayOutPlayerListHeaderFooter) {
+            PacketPlayOutPlayerListHeaderFooter packet = (PacketPlayOutPlayerListHeaderFooter) pack;
+            player.getInitialHandler().setTabHeaderFromPacket(packet.getHeader(), packet.getFooter());
+        }
+
+
+        return false;
+    }
+
+    private static void handleItemClick(final Player player, final ItemStack is, final Click c, final boolean sync, final boolean looped) {
+        if (!sync && !looped) {
+            BungeeCord.getInstance().getScheduler().runAsync(BungeeUtil.getPluginInstance(), new Runnable() {
+                public void run() {
+                    handleItemClick(player, is, c, sync, true);
+                }
+            });
+            return;
+        }
+        Profiler.packet_handle.start("itemClickListener");
+        try {
+            is.click(c);
+        } catch (Exception e) {
+            List<StackTraceElement> le = new ArrayList<>();
+            le.addAll(Arrays.asList(ExceptionUtils.deleteDownward(e.getStackTrace(), ExceptionUtils.getCurrentMethodeIndex(e))));
+            le.add(new StackTraceElement("dev.wolveringer.BungeeUtil.PacketHandler." + player.getVersion().name(), "handleInventoryClickPacket" + (sync ? "Sync" : "Ansync"), null, -1));
+            e.setStackTrace(le.toArray(new StackTraceElement[0]));
+            switch (Configuration.getHandleExceptionAction()) {
+                case DISCONNECT:
+                    player.disconnect(e);
+                case PRINT:
+                    e.printStackTrace();
+                default:
+                    break;
+            }
+        }
+        Profiler.packet_handle.stop("itemClickListener");
+    }
 }
diff --git a/src/main/java/dev/wolveringer/profiler/MethodProfiler.java b/src/main/java/dev/wolveringer/profiler/MethodProfiler.java
index 3bb2752..07bd433 100644
--- a/src/main/java/dev/wolveringer/profiler/MethodProfiler.java
+++ b/src/main/java/dev/wolveringer/profiler/MethodProfiler.java
@@ -7,58 +7,69 @@ import dev.wolveringer.api.inventory.ScrolingInventory;
 import dev.wolveringer.chat.ChatColor.ChatColorUtils;
 
 public class MethodProfiler {
-	private String name;
-	private Profiler profile;
-	private ScrolingInventory inv;
-	@SuppressWarnings("serial")
-	HashMap<String, Timings> timings = new HashMap<String, Timings>(){
-		public Timings get(Object key) {
-			if(super.get(key) == null)
-				super.put((String) key, new Timings((String) key,MethodProfiler.this));
-			return super.get(key);
-		};
-	};
-	
-	public MethodProfiler(Profiler profile,String key) {
-		this.name = key;
-		this.profile = profile;
-		String name = ChatColorUtils.COLOR_CHAR+"aTimings "+ChatColorUtils.COLOR_CHAR+"7("+ChatColorUtils.COLOR_CHAR+"5"+ChatColorUtils.COLOR_CHAR+"l"+profile.getName()+" "+ChatColorUtils.COLOR_CHAR+"c"+ChatColorUtils.COLOR_CHAR+"l>> "+ChatColorUtils.COLOR_CHAR+"b"+ChatColorUtils.COLOR_CHAR+"l"+getName()+""+ChatColorUtils.COLOR_CHAR+"7)";
-		inv = new ScrolingInventory(4, name);
-		updateInventory();
-	}
-	public void start(String name){
-		timings.get(name).start();
-	}
-	public void stop(String name){
-		timings.get(name).stop();
-	}
-	public Long getLastTiming(String name) {
-		return timings.get(name).getLastTiming();
-	}
-	public String getName() {
-		return name;
-	}
-	public Profiler getProfile() {
-		return profile;
-	}
-	public Inventory getInventory() {
-		return inv;
-	}
-	protected void updateInventory() {
-		inv.disableUpdate();
-		inv.clear();
-		for(Timings t : timings.values()){
-			t.rebuild();
-			inv.addItem(t.getItemStack());
-		}
-		inv.enableUpdate();
-	}
-	public void resetTimings() {
-		for(Timings t : timings.values())
-			t.resetTimings();
-		updateInventory();
-	}
-	public HashMap<String, Timings> getTimings() {
-		return this.timings;
-	}
+    @SuppressWarnings("serial")
+    HashMap<String, Timings> timings = new HashMap<String, Timings>() {
+        public Timings get(Object key) {
+            if (super.get(key) == null)
+                super.put((String) key, new Timings((String) key, MethodProfiler.this));
+            return super.get(key);
+        }
+
+        ;
+    };
+    private String name;
+    private Profiler profile;
+    private ScrolingInventory inv;
+
+    public MethodProfiler(Profiler profile, String key) {
+        this.name = key;
+        this.profile = profile;
+        String name = ChatColorUtils.COLOR_CHAR + "aTimings " + ChatColorUtils.COLOR_CHAR + "7(" + ChatColorUtils.COLOR_CHAR + "5" + ChatColorUtils.COLOR_CHAR + "l" + profile.getName() + " " + ChatColorUtils.COLOR_CHAR + "c" + ChatColorUtils.COLOR_CHAR + "l>> " + ChatColorUtils.COLOR_CHAR + "b" + ChatColorUtils.COLOR_CHAR + "l" + getName() + "" + ChatColorUtils.COLOR_CHAR + "7)";
+        inv = new ScrolingInventory(4, name);
+        updateInventory();
+    }
+
+    public void start(String name) {
+        timings.get(name).start();
+    }
+
+    public void stop(String name) {
+        timings.get(name).stop();
+    }
+
+    public Long getLastTiming(String name) {
+        return timings.get(name).getLastTiming();
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public Profiler getProfile() {
+        return profile;
+    }
+
+    public Inventory getInventory() {
+        return inv;
+    }
+
+    protected void updateInventory() {
+        inv.disableUpdate();
+        inv.clear();
+        for (Timings t : timings.values()) {
+            t.rebuild();
+            inv.addItem(t.getItemStack());
+        }
+        inv.enableUpdate();
+    }
+
+    public void resetTimings() {
+        for (Timings t : timings.values())
+            t.resetTimings();
+        updateInventory();
+    }
+
+    public HashMap<String, Timings> getTimings() {
+        return this.timings;
+    }
 }
diff --git a/src/main/java/dev/wolveringer/profiler/ProfileMenue.java b/src/main/java/dev/wolveringer/profiler/ProfileMenue.java
index c4036be..eb7cb41 100644
--- a/src/main/java/dev/wolveringer/profiler/ProfileMenue.java
+++ b/src/main/java/dev/wolveringer/profiler/ProfileMenue.java
@@ -1,10 +1,10 @@
 package dev.wolveringer.profiler;
 
+import net.md_5.bungee.BungeeCord;
+
 import java.util.concurrent.TimeUnit;
 
-import net.md_5.bungee.BungeeCord;
 import dev.wolveringer.BungeeUtil.BungeeUtil;
-import dev.wolveringer.BungeeUtil.Main;
 import dev.wolveringer.BungeeUtil.Material;
 import dev.wolveringer.BungeeUtil.item.ItemStack;
 import dev.wolveringer.BungeeUtil.item.MultiClickItemStack;
@@ -13,57 +13,58 @@ import dev.wolveringer.api.inventory.ScrolingInventory;
 import dev.wolveringer.chat.ChatColor.ChatColorUtils;
 
 public class ProfileMenue {
-	private static ProfileMenue menue = new ProfileMenue();
-	static{
-		menue = new ProfileMenue();
-	}
+    private static ProfileMenue menue = new ProfileMenue();
+
+    static {
+        menue = new ProfileMenue();
+    }
 
-	public static ProfileMenue getProfilerMenue() {
-		return menue;
-	}
+    private ScrolingInventory inv = new ScrolingInventory(4, "" + ChatColorUtils.COLOR_CHAR + "aTimings");
+    private Inventory inv_disabled = new Inventory(9, "" + ChatColorUtils.COLOR_CHAR + "cTimings Disabled");
 
-	private ScrolingInventory inv = new ScrolingInventory(4, ""+ChatColorUtils.COLOR_CHAR+"aTimings");
-	private Inventory inv_disabled = new Inventory(9, ""+ChatColorUtils.COLOR_CHAR+"cTimings Disabled");
+    public ProfileMenue() {
+        BungeeCord.getInstance().getScheduler().schedule(BungeeUtil.getPluginInstance(), new Runnable() {
+            @Override
+            public void run() {
+                rebuild();
+            }
+        }, 1, 5, TimeUnit.SECONDS);
+        ItemStack is = new MultiClickItemStack(Material.BARRIER);
+        is.getItemMeta().setDisplayName("" + ChatColorUtils.COLOR_CHAR + "cTimings are " + ChatColorUtils.COLOR_CHAR + "c" + ChatColorUtils.COLOR_CHAR + "nDisabled");
+        inv_disabled.setItem(4, is);
+    }
 
-	public ProfileMenue() {
-		BungeeCord.getInstance().getScheduler().schedule(BungeeUtil.getPluginInstance(), new Runnable() {
-			@Override
-			public void run() {
-				rebuild();
-			}
-		}, 1, 5, TimeUnit.SECONDS);
-		ItemStack is = new MultiClickItemStack(Material.BARRIER);
-		is.getItemMeta().setDisplayName(""+ChatColorUtils.COLOR_CHAR+"cTimings are "+ChatColorUtils.COLOR_CHAR+"c"+ChatColorUtils.COLOR_CHAR+"nDisabled");
-		inv_disabled.setItem(4, is);
-	}
+    public static ProfileMenue getProfilerMenue() {
+        return menue;
+    }
 
-	protected void rebuild() {
-		if(!Profiler.isEnabled())
-			return;
-		inv.disableUpdate();
-		inv.clear();
-		for(Profiler p : Profiler.getProfilers()){
-			p.updateInventory();
-			inv.addItem(build(p));
-		}
-		inv.enableUpdate();
-	}
+    protected void rebuild() {
+        if (!Profiler.isEnabled())
+            return;
+        inv.disableUpdate();
+        inv.clear();
+        for (Profiler p : Profiler.getProfilers()) {
+            p.updateInventory();
+            inv.addItem(build(p));
+        }
+        inv.enableUpdate();
+    }
 
-	private ItemStack build(final Profiler profile) {
-		ItemStack is = new ItemStack(Material.WATCH) {
-			@Override
-			public void click(Click p) {
-				p.getPlayer().openInventory(profile.getInventory());
-			}
-		};
-		is.getItemMeta().setDisplayName(""+ChatColorUtils.COLOR_CHAR+"bProfiler: "+ChatColorUtils.COLOR_CHAR+"5" + profile.getName());
-		return is;
-	}
+    private ItemStack build(final Profiler profile) {
+        ItemStack is = new ItemStack(Material.WATCH) {
+            @Override
+            public void click(Click p) {
+                p.getPlayer().openInventory(profile.getInventory());
+            }
+        };
+        is.getItemMeta().setDisplayName("" + ChatColorUtils.COLOR_CHAR + "bProfiler: " + ChatColorUtils.COLOR_CHAR + "5" + profile.getName());
+        return is;
+    }
 
-	public Inventory getMenue() {
-		if(Profiler.isEnabled())
-			return inv;
-		else
-			return inv_disabled;
-	}
+    public Inventory getMenue() {
+        if (Profiler.isEnabled())
+            return inv;
+        else
+            return inv_disabled;
+    }
 }
diff --git a/src/main/java/dev/wolveringer/profiler/Profiler.java b/src/main/java/dev/wolveringer/profiler/Profiler.java
index 6ebf618..8275286 100644
--- a/src/main/java/dev/wolveringer/profiler/Profiler.java
+++ b/src/main/java/dev/wolveringer/profiler/Profiler.java
@@ -1,12 +1,13 @@
 package dev.wolveringer.profiler;
 
+import net.md_5.bungee.BungeeCord;
+
 import java.net.InetAddress;
 import java.net.UnknownHostException;
 import java.text.DecimalFormat;
 import java.util.ArrayList;
 import java.util.HashMap;
 
-import net.md_5.bungee.BungeeCord;
 import dev.wolveringer.BungeeUtil.Main;
 import dev.wolveringer.BungeeUtil.Material;
 import dev.wolveringer.BungeeUtil.configuration.Configuration;
@@ -20,234 +21,232 @@ import dev.wolveringer.nbt.NBTTagList;
 import dev.wolveringer.nbt.NBTTagLong;
 
 public class Profiler {
-	protected static final DecimalFormat TIME_FORMAT = new DecimalFormat("#000,000,000");
-
-	public static void setEnabled(boolean enabled) {
-		Configuration.setTimingsActive(enabled);
-	}
-
-	public static boolean isEnabled() {
-		return Configuration.isTimingsActive();
-	}
-
-	public static void reset() {
-		for(Profiler p : getProfilers())
-			p.resetTimings();
-	}
-
-	private static ArrayList<Profiler> profilers = new ArrayList<Profiler>();
-
-	public static ArrayList<Profiler> getProfilers() {
-		return profilers;
-	}
-
-	public static String pushToHastebin() {
-		long start = System.nanoTime();
-		HastebinPost post = new HastebinPost();
-		post.addLine("Timings for Bungeecord-Server  : " + getHostAdress());
-		post.addLine("General Information:");
-		post.addLine("  Bungeecord version           : " + BungeeCord.getInstance().getVersion());
-		post.addLine("  Bungeecord protocol version  : " + BungeeCord.getInstance().getProtocolVersion());
-		post.addLine("  Bungeecord game version      : " + BungeeCord.getInstance().getGameVersion());
-		post.addLine("  BungeeUtil author            : " + Main.getMain().getDescription().getAuthor());
-		if(Main.getMain().updater.isNewstVersion())
-			post.addLine("  BungeeUtil version           : " + Main.getMain().getDescription().getVersion() + " (up to date)");
-		else
-			post.addLine("  BungeeUtil version      	 : " + Main.getMain().getDescription().getVersion() + " (new version avariable: " + Main.getMain().updater.getNewestVersion() + ")");
-		post.addLine("  BungeeUtil ByteBuffType      : " + Configuration.getByteBuffType().toUpperCase());
-		post.addLine("");
-		post.addLine("Memory:");
-
-		Runtime runtime = Runtime.getRuntime();
-		int mb = 1024 * 1024;
-
-		post.addLine("  Reserved Used Memory     : " + (runtime.totalMemory() - runtime.freeMemory()) / mb + "MB");
-		post.addLine("  Reserved Free Memory     : " + runtime.freeMemory() / mb + "MB");
-		post.addLine("  Reserved Memory          : " + runtime.totalMemory() / mb + "MB");
-		post.addLine("  Allowed Reservable Memory: " + runtime.maxMemory() / mb + "MB");
-
-		post.addLine("");
-		post.addLine("Profiler: (All times in NanoSeconds!)");
-		for(Profiler p : getProfilers()){
-			post.addLine("  " + p.getName() + ":");
-			for(MethodProfiler m : p.getProfiles().values()){
-				post.addLine("    Method \"" + m.getName() + "\":");
-				int max = 0;
-				for(Timings s : m.getTimings().values()){
-					if(s.getName().length() > max)
-						max = s.getName().length();
-				}
-				max+=1;
-				for(Timings s : m.getTimings().values()){
-					post.addLine("      Timing \"" + format(s.getName()+"\"",max) + ": " + format(s));
-				}
-			}
-		}
-		post.addLine("");
-		post.addLine("Details: (Base64 NBTTag Structure)");
-		String s = details();
-		for(String x : s.split("(?<=\\G.{100})"))
-			post.addLine(x);
-		post.addLine("");
-		long end = System.nanoTime() - start;
-		post.addLine("File created in " + TIME_FORMAT.format(end).replaceAll(",", ".") + " NanoSeconds (" + ((int) (end / 1000000)) + " MilliSeconds).");
-		return post.getTextUrl();
-	}
-
-	private static String format(String in, int length) {
-		while (in.length() < length){
-			in += " ";
-		}
-		return in;
-	}
-
-	private static String details() {
-		NBTTagCompound nbt = new NBTTagCompound();
-		for(Profiler p : getProfilers()){
-			NBTTagCompound profiles = new NBTTagCompound();
-			for(MethodProfiler m : p.getProfiles().values()){
-				NBTTagCompound methode = new NBTTagCompound();
-				for(Timings s : m.getTimings().values()){
-					NBTTagCompound timings = new NBTTagCompound();
-					timings.setString("name", s.getName());
-					timings.setLong("AverageScore", s.getAverageScore());
-					NBTTagList period_timings = new NBTTagList();
-					for(Long l : s.getTimings())
-						period_timings.add(new NBTTagLong(l));
-					NBTTagList times = new NBTTagList();
-					for(Long l : s.getSmalTimings())
-						times.add(new NBTTagLong(l));
-					timings.set("period_times", period_timings);
-					timings.set("times", times);
-					methode.set(s.getName(), timings);
-				}
-				profiles.set(m.getName(), methode);
-			}
-			nbt.set(p.getName(), profiles);
-		}
-		try{
-			return NBTCompressedStreamTools.toString(nbt);
-		}catch (Exception ex){
-			ex.printStackTrace();
-			return "DetailParadiseError";
-		}
-	}
-
-	private static String format(Timings in) {
-		String out = TIME_FORMAT.format(in.getAverageScore()).replaceAll(",", ".") + " Last 20 Timings: ";
-		out += " [";
-		Long[] x = in.getTimings();
-		for(int i = x.length - 1;i > (x.length - 20 > 0 ? x.length - 20 : 0);i--)
-			out += " ," + TIME_FORMAT.format(x[i]).replaceAll(",", ".") + "";
-		return out.replaceFirst("\\[ ,", "\\[") + "]";
-	}
-
-	private static String getHostAdress() {
-		try{
-			return InetAddress.getLocalHost().getHostAddress();
-		}catch (UnknownHostException ex){
-			return "underknown";
-		}
-	}
-
-	@SuppressWarnings("serial")
-	private HashMap<String, MethodProfiler> profiles = new HashMap<String, MethodProfiler>() {
-		public MethodProfiler get(Object key) {
-			if(super.get(key) == null)
-				super.put((String) key, new MethodProfiler(Profiler.this, (String) key));
-			return super.get(key);
-		};
-	};
-
-	public static final Profiler decoder_timings = new Profiler("timings.decoder");
-	public static final Profiler encoder_timings = new Profiler("timings.encoder");
-	public static final Profiler profiler = new Profiler("timings.profiler");
-	public static final Profiler packet_handle = new Profiler("timings.handle");
-	
-	String name;
-	private ScrolingInventory inv;
-
-	public Profiler(String name) {
-		profilers.add(this);
-		this.name = name;
-		String n = ""+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"aTimings "+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"7("+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"5"+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"l" + getName() + ""+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"7)";
-		inv = new ScrolingInventory(4, n);
-	}
-
-	public void start(String name) {
-		if(isEnabled())
-			profiles.get(getStackMethodeName()).start(name);
-	}
-
-	public void stop(String name) {
-		if(isEnabled())
-			profiles.get(getStackMethodeName()).stop(name);
-	}
-
-	public Long getLastTiming(String name) {
-		if(isEnabled())
-			return profiles.get(getStackMethodeName()).getLastTiming(name);
-		else
-			return -1L;
-	}
-
-	public Long getLastTiming(String method, String name) {
-		if(isEnabled())
-			return profiles.get(method).getLastTiming(name);
-		else
-			return -1L;
-	}
-
-	public HashMap<String, MethodProfiler> getProfiles() {
-		return profiles;
-	}
-
-	private String getStackMethodeName() {
-		StackTraceElement[] e = Thread.currentThread().getStackTrace();
-		for(StackTraceElement et : e){
-			if(!et.toString().contains("Profiler") && !et.toString().contains("java.lang"))
-				return et.getMethodName();
-		}
-		return "null";
-	}
-
-	protected Inventory getInventory() {
-		return inv;
-	}
-
-	protected void updateInventory() {
-		if(!isEnabled())
-			return;
-		profiler.start("update");
-		inv.disableUpdate();
-		inv.clear();
-		for(MethodProfiler p : getProfiles().values()){
-			p.updateInventory();
-			inv.addItem(buildMethodProfiler(p));
-		}
-		inv.enableUpdate();
-		profiler.stop("update");
-	}
-
-	private ItemStack buildMethodProfiler(final MethodProfiler profile) {
-		ItemStack is = new ItemStack(Material.COMPASS) {
-			@Override
-			public void click(Click p) {
-				p.getPlayer().openInventory(profile.getInventory());
-			}
-		};
-		is.getItemMeta().setDisplayName(""+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"bMethode: "+dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR+"b" + profile.getName());
-		return is;
-	}
-
-	public void resetTimings() {
-		for(MethodProfiler p : getProfiles().values()){
-			p.resetTimings();
-		}
-		updateInventory();
-	}
-
-	public String getName() {
-		return name;
-	}
+    public static final Profiler decoder_timings = new Profiler("timings.decoder");
+    public static final Profiler encoder_timings = new Profiler("timings.encoder");
+    public static final Profiler profiler = new Profiler("timings.profiler");
+    public static final Profiler packet_handle = new Profiler("timings.handle");
+    protected static final DecimalFormat TIME_FORMAT = new DecimalFormat("#000,000,000");
+    private static ArrayList<Profiler> profilers = new ArrayList<Profiler>();
+    String name;
+    @SuppressWarnings("serial")
+    private HashMap<String, MethodProfiler> profiles = new HashMap<String, MethodProfiler>() {
+        public MethodProfiler get(Object key) {
+            if (super.get(key) == null)
+                super.put((String) key, new MethodProfiler(Profiler.this, (String) key));
+            return super.get(key);
+        }
+
+        ;
+    };
+    private ScrolingInventory inv;
+
+    public Profiler(String name) {
+        profilers.add(this);
+        this.name = name;
+        String n = "" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "aTimings " + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "7(" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "5" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "l" + getName() + "" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "7)";
+        inv = new ScrolingInventory(4, n);
+    }
+
+    public static boolean isEnabled() {
+        return Configuration.isTimingsActive();
+    }
+
+    public static void setEnabled(boolean enabled) {
+        Configuration.setTimingsActive(enabled);
+    }
+
+    public static void reset() {
+        for (Profiler p : getProfilers())
+            p.resetTimings();
+    }
+
+    public static ArrayList<Profiler> getProfilers() {
+        return profilers;
+    }
+
+    public static String pushToHastebin() {
+        long start = System.nanoTime();
+        HastebinPost post = new HastebinPost();
+        post.addLine("Timings for Bungeecord-Server  : " + getHostAdress());
+        post.addLine("General Information:");
+        post.addLine("  Bungeecord version           : " + BungeeCord.getInstance().getVersion());
+        post.addLine("  Bungeecord protocol version  : " + BungeeCord.getInstance().getProtocolVersion());
+        post.addLine("  Bungeecord game version      : " + BungeeCord.getInstance().getGameVersion());
+        post.addLine("  BungeeUtil author            : " + Main.getMain().getDescription().getAuthor());
+        if (Main.getMain().updater.isNewstVersion())
+            post.addLine("  BungeeUtil version           : " + Main.getMain().getDescription().getVersion() + " (up to date)");
+        else
+            post.addLine("  BungeeUtil version      	 : " + Main.getMain().getDescription().getVersion() + " (new version avariable: " + Main.getMain().updater.getNewestVersion() + ")");
+        post.addLine("  BungeeUtil ByteBuffType      : " + Configuration.getByteBuffType().toUpperCase());
+        post.addLine("");
+        post.addLine("Memory:");
+
+        Runtime runtime = Runtime.getRuntime();
+        int mb = 1024 * 1024;
+
+        post.addLine("  Reserved Used Memory     : " + (runtime.totalMemory() - runtime.freeMemory()) / mb + "MB");
+        post.addLine("  Reserved Free Memory     : " + runtime.freeMemory() / mb + "MB");
+        post.addLine("  Reserved Memory          : " + runtime.totalMemory() / mb + "MB");
+        post.addLine("  Allowed Reservable Memory: " + runtime.maxMemory() / mb + "MB");
+
+        post.addLine("");
+        post.addLine("Profiler: (All times in NanoSeconds!)");
+        for (Profiler p : getProfilers()) {
+            post.addLine("  " + p.getName() + ":");
+            for (MethodProfiler m : p.getProfiles().values()) {
+                post.addLine("    Method \"" + m.getName() + "\":");
+                int max = 0;
+                for (Timings s : m.getTimings().values()) {
+                    if (s.getName().length() > max)
+                        max = s.getName().length();
+                }
+                max += 1;
+                for (Timings s : m.getTimings().values()) {
+                    post.addLine("      Timing \"" + format(s.getName() + "\"", max) + ": " + format(s));
+                }
+            }
+        }
+        post.addLine("");
+        post.addLine("Details: (Base64 NBTTag Structure)");
+        String s = details();
+        for (String x : s.split("(?<=\\G.{100})"))
+            post.addLine(x);
+        post.addLine("");
+        long end = System.nanoTime() - start;
+        post.addLine("File created in " + TIME_FORMAT.format(end).replaceAll(",", ".") + " NanoSeconds (" + ((int) (end / 1000000)) + " MilliSeconds).");
+        return post.getTextUrl();
+    }
+
+    private static String format(String in, int length) {
+        while (in.length() < length) {
+            in += " ";
+        }
+        return in;
+    }
+
+    private static String details() {
+        NBTTagCompound nbt = new NBTTagCompound();
+        for (Profiler p : getProfilers()) {
+            NBTTagCompound profiles = new NBTTagCompound();
+            for (MethodProfiler m : p.getProfiles().values()) {
+                NBTTagCompound methode = new NBTTagCompound();
+                for (Timings s : m.getTimings().values()) {
+                    NBTTagCompound timings = new NBTTagCompound();
+                    timings.setString("name", s.getName());
+                    timings.setLong("AverageScore", s.getAverageScore());
+                    NBTTagList period_timings = new NBTTagList();
+                    for (Long l : s.getTimings())
+                        period_timings.add(new NBTTagLong(l));
+                    NBTTagList times = new NBTTagList();
+                    for (Long l : s.getSmalTimings())
+                        times.add(new NBTTagLong(l));
+                    timings.set("period_times", period_timings);
+                    timings.set("times", times);
+                    methode.set(s.getName(), timings);
+                }
+                profiles.set(m.getName(), methode);
+            }
+            nbt.set(p.getName(), profiles);
+        }
+        try {
+            return NBTCompressedStreamTools.toString(nbt);
+        } catch (Exception ex) {
+            ex.printStackTrace();
+            return "DetailParadiseError";
+        }
+    }
+
+    private static String format(Timings in) {
+        String out = TIME_FORMAT.format(in.getAverageScore()).replaceAll(",", ".") + " Last 20 Timings: ";
+        out += " [";
+        Long[] x = in.getTimings();
+        for (int i = x.length - 1; i > (x.length - 20 > 0 ? x.length - 20 : 0); i--)
+            out += " ," + TIME_FORMAT.format(x[i]).replaceAll(",", ".") + "";
+        return out.replaceFirst("\\[ ,", "\\[") + "]";
+    }
+
+    private static String getHostAdress() {
+        try {
+            return InetAddress.getLocalHost().getHostAddress();
+        } catch (UnknownHostException ex) {
+            return "underknown";
+        }
+    }
+
+    public void start(String name) {
+        if (isEnabled())
+            profiles.get(getStackMethodeName()).start(name);
+    }
+
+    public void stop(String name) {
+        if (isEnabled())
+            profiles.get(getStackMethodeName()).stop(name);
+    }
+
+    public Long getLastTiming(String name) {
+        if (isEnabled())
+            return profiles.get(getStackMethodeName()).getLastTiming(name);
+        else
+            return -1L;
+    }
+
+    public Long getLastTiming(String method, String name) {
+        if (isEnabled())
+            return profiles.get(method).getLastTiming(name);
+        else
+            return -1L;
+    }
+
+    public HashMap<String, MethodProfiler> getProfiles() {
+        return profiles;
+    }
+
+    private String getStackMethodeName() {
+        StackTraceElement[] e = Thread.currentThread().getStackTrace();
+        for (StackTraceElement et : e) {
+            if (!et.toString().contains("Profiler") && !et.toString().contains("java.lang"))
+                return et.getMethodName();
+        }
+        return "null";
+    }
+
+    protected Inventory getInventory() {
+        return inv;
+    }
+
+    protected void updateInventory() {
+        if (!isEnabled())
+            return;
+        profiler.start("update");
+        inv.disableUpdate();
+        inv.clear();
+        for (MethodProfiler p : getProfiles().values()) {
+            p.updateInventory();
+            inv.addItem(buildMethodProfiler(p));
+        }
+        inv.enableUpdate();
+        profiler.stop("update");
+    }
+
+    private ItemStack buildMethodProfiler(final MethodProfiler profile) {
+        ItemStack is = new ItemStack(Material.COMPASS) {
+            @Override
+            public void click(Click p) {
+                p.getPlayer().openInventory(profile.getInventory());
+            }
+        };
+        is.getItemMeta().setDisplayName("" + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "bMethode: " + dev.wolveringer.chat.ChatColor.ChatColorUtils.COLOR_CHAR + "b" + profile.getName());
+        return is;
+    }
+
+    public void resetTimings() {
+        for (MethodProfiler p : getProfiles().values()) {
+            p.resetTimings();
+        }
+        updateInventory();
+    }
+
+    public String getName() {
+        return name;
+    }
 }
diff --git a/src/main/java/dev/wolveringer/profiler/Timings.java b/src/main/java/dev/wolveringer/profiler/Timings.java
index 1ce8d63..7de5a2a 100644
--- a/src/main/java/dev/wolveringer/profiler/Timings.java
+++ b/src/main/java/dev/wolveringer/profiler/Timings.java
@@ -1,185 +1,185 @@
 package dev.wolveringer.profiler;
 
+import org.apache.commons.lang3.ArrayUtils;
+
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.LinkedList;
 
-import org.apache.commons.lang3.ArrayUtils;
-
 import dev.wolveringer.BungeeUtil.Material;
 import dev.wolveringer.BungeeUtil.item.ItemStack;
 import dev.wolveringer.BungeeUtil.item.MultiClickItemStack;
 import dev.wolveringer.chat.ChatColor.ChatColorUtils;
 
 public class Timings {
-	private LinkedList<Long> times = new LinkedList<Long>();
-	private LinkedList<Long> period_times = new LinkedList<Long>();
-	private Long start = -1L;
-
-	private Long last = 0L;
-
-	private String name;
-	private MethodProfiler profiler;
-	private ItemStack item;
-
-	public Timings(String key, MethodProfiler p) {
-		this.name = key;
-		this.profiler = p;
-		for(int i = 0;i < 100;i++){
-			period_times.add(0L);
-		}
-		item = new MultiClickItemStack(Material.CAKE);
-		rebuild();
-	}
-
-	public synchronized void start() {
-		start = System.nanoTime();
-	}
-
-	public synchronized void stop() {
-		if(start == -1L)
-			return;
-		addTiming(System.nanoTime() - start);
-		start = -1L;
-		last = System.currentTimeMillis();
-	}
-
-	synchronized void addTiming(long time) {
-		times.add(time);
-		recalculate();
-	}
-
-	public Long[] getTimings() {
-		return period_times.toArray(new Long[0]);
-	}
-
-	public Long[] getSmalTimings() {
-		return times.toArray(new Long[0]);
-	}
-
-	public Long getAverageScore() {
-		Long all = 0L;
-		ArrayList<Long> t = new ArrayList<>(period_times);
-		for(Long s : t)
-			all += s;
-		return all / t.size();
-	}
-
-	public Long getLastTiming() {
-		if(times.size() == 0)
-			return -1L;
-		return times.get(times.size() - 1);
-	}
-
-	private synchronized void recalculate() {
-		if(times.size() >= 100){
-			Long l = durchschnitt(times);
-			period_times.add(l);
-			if(period_times.size() > 100)
-				period_times.pollFirst();
-			times.clear();
-		}
-	}
-
-	@Override
-	public String toString() {
-		return "Timings@" + System.identityHashCode(this) + "{timings=" + period_times + "}";
-	}
-
-	private Long durchschnitt(LinkedList<Long> zahlen) {
-		if(zahlen.size() == 0)
-			return 0L;
-		Long ges = 0L;
-		Iterator<Long> i = zahlen.iterator();
-		while (i.hasNext()){
-			ges += i.next();
-		}
-		return (ges / zahlen.size());
-	}
-
-	public String getName() {
-		return name;
-	}
-
-	public ItemStack getItemStack() {
-		return item;
-	}
-
-	public void rebuild() {
-		int steps = 10;
-		item.getItemMeta().setDisplayName(ChatColorUtils.COLOR_CHAR+"bTiming: "+ChatColorUtils.COLOR_CHAR+"b" + getName());
-
-		Long max = getHighestValue(getTimings()) + 10;
-		Long min = 0L;
-		Long d = max - min;
-
-		//INIT ARRAYLIST
-		ArrayList<String> out = new ArrayList<String>();
-		for(int i = 0;i < steps;i++)
-			out.add("");
-
-		//COLLUM NUMBERS
-		ArrayList<String> a = new ArrayList<String>();
-		double count_step = d / steps;
-		for(int i = 0;i < steps;i++)
-			a.add(ChatColorUtils.COLOR_CHAR+"c" + fromat(count_step * i) + " ms"+ChatColorUtils.COLOR_CHAR+"7: ");
-		String[] var1 = a.toArray(new String[a.size()]);
-		ArrayUtils.reverse(var1);
-		addVertical(out, var1);
-
-		for(int i = 50;i < 100;i++){
-			addVertical(out, createColum(0, max, steps, getTimings()[i]));
-		}
-		item.getItemMeta().setLore(out);
-	}
-
-	private String fromat(double d) {
-		String out = Profiler.TIME_FORMAT.format(d).replaceAll(",", ".");
-		if(out.indexOf(".") != -1)
-			out = out.substring(0, out.indexOf(".")) + ChatColorUtils.COLOR_CHAR+"c" + out.substring(out.indexOf("."), out.length());
-		return out;
-	}
-
-	private Long getHighestValue(Long[] in) {
-		Long high = Long.MIN_VALUE;
-		for(Long l : in)
-			if(l > high)
-				high = l;
-		return high;
-	}
-
-	private String[] createColum(long min, long max, int steps, long var) {
-		long d = max - min;
-		double count_step = d / steps;
-		String[] out = new String[steps];
-		for(int i = steps - 1;i >= 0;i--){
-			if(count_step * i <= var)
-				if(((count_step * i) + count_step * 0.5D) <= var)
-					out[i] = ChatColorUtils.COLOR_CHAR+"aX";//""+ChatColorUtils.COLOR_CHAR+"a";
-				else
-					out[i] = ChatColorUtils.COLOR_CHAR+"aX";//ChatColorUtils.COLOR_CHAR+"a";
-			else
-				out[i] = ChatColorUtils.COLOR_CHAR+"0X";//ChatColorUtils.COLOR_CHAR+"0";
-		}
-		ArrayUtils.reverse(out);
-		return out;
-		//PMINGLIU
-	}
-
-	private ArrayList<String> addVertical(ArrayList<String> base, String... obj) {
-		for(int i = 0;i < obj.length;i++){
-			String t = obj[i];
-			base.set(i, base.get(i) + t);
-		}
-		return base;
-	}
-
-	public void resetTimings() {
-		times.clear();
-		period_times.clear();
-		for(int i = 0;i < 100;i++){
-			period_times.add(0L);
-		}
-		rebuild();
-	}
+    private LinkedList<Long> times = new LinkedList<Long>();
+    private LinkedList<Long> period_times = new LinkedList<Long>();
+    private Long start = -1L;
+
+    private Long last = 0L;
+
+    private String name;
+    private MethodProfiler profiler;
+    private ItemStack item;
+
+    public Timings(String key, MethodProfiler p) {
+        this.name = key;
+        this.profiler = p;
+        for (int i = 0; i < 100; i++) {
+            period_times.add(0L);
+        }
+        item = new MultiClickItemStack(Material.CAKE);
+        rebuild();
+    }
+
+    public synchronized void start() {
+        start = System.nanoTime();
+    }
+
+    public synchronized void stop() {
+        if (start == -1L)
+            return;
+        addTiming(System.nanoTime() - start);
+        start = -1L;
+        last = System.currentTimeMillis();
+    }
+
+    synchronized void addTiming(long time) {
+        times.add(time);
+        recalculate();
+    }
+
+    public Long[] getTimings() {
+        return period_times.toArray(new Long[0]);
+    }
+
+    public Long[] getSmalTimings() {
+        return times.toArray(new Long[0]);
+    }
+
+    public Long getAverageScore() {
+        Long all = 0L;
+        ArrayList<Long> t = new ArrayList<>(period_times);
+        for (Long s : t)
+            all += s;
+        return all / t.size();
+    }
+
+    public Long getLastTiming() {
+        if (times.size() == 0)
+            return -1L;
+        return times.get(times.size() - 1);
+    }
+
+    private synchronized void recalculate() {
+        if (times.size() >= 100) {
+            Long l = durchschnitt(times);
+            period_times.add(l);
+            if (period_times.size() > 100)
+                period_times.pollFirst();
+            times.clear();
+        }
+    }
+
+    @Override
+    public String toString() {
+        return "Timings@" + System.identityHashCode(this) + "{timings=" + period_times + "}";
+    }
+
+    private Long durchschnitt(LinkedList<Long> zahlen) {
+        if (zahlen.size() == 0)
+            return 0L;
+        Long ges = 0L;
+        Iterator<Long> i = zahlen.iterator();
+        while (i.hasNext()) {
+            ges += i.next();
+        }
+        return (ges / zahlen.size());
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public ItemStack getItemStack() {
+        return item;
+    }
+
+    public void rebuild() {
+        int steps = 10;
+        item.getItemMeta().setDisplayName(ChatColorUtils.COLOR_CHAR + "bTiming: " + ChatColorUtils.COLOR_CHAR + "b" + getName());
+
+        Long max = getHighestValue(getTimings()) + 10;
+        Long min = 0L;
+        Long d = max - min;
+
+        //INIT ARRAYLIST
+        ArrayList<String> out = new ArrayList<String>();
+        for (int i = 0; i < steps; i++)
+            out.add("");
+
+        //COLLUM NUMBERS
+        ArrayList<String> a = new ArrayList<String>();
+        double count_step = d / steps;
+        for (int i = 0; i < steps; i++)
+            a.add(ChatColorUtils.COLOR_CHAR + "c" + fromat(count_step * i) + " ms" + ChatColorUtils.COLOR_CHAR + "7: ");
+        String[] var1 = a.toArray(new String[a.size()]);
+        ArrayUtils.reverse(var1);
+        addVertical(out, var1);
+
+        for (int i = 50; i < 100; i++) {
+            addVertical(out, createColum(0, max, steps, getTimings()[i]));
+        }
+        item.getItemMeta().setLore(out);
+    }
+
+    private String fromat(double d) {
+        String out = Profiler.TIME_FORMAT.format(d).replaceAll(",", ".");
+        if (out.indexOf(".") != -1)
+            out = out.substring(0, out.indexOf(".")) + ChatColorUtils.COLOR_CHAR + "c" + out.substring(out.indexOf("."), out.length());
+        return out;
+    }
+
+    private Long getHighestValue(Long[] in) {
+        Long high = Long.MIN_VALUE;
+        for (Long l : in)
+            if (l > high)
+                high = l;
+        return high;
+    }
+
+    private String[] createColum(long min, long max, int steps, long var) {
+        long d = max - min;
+        double count_step = d / steps;
+        String[] out = new String[steps];
+        for (int i = steps - 1; i >= 0; i--) {
+            if (count_step * i <= var)
+                if (((count_step * i) + count_step * 0.5D) <= var)
+                    out[i] = ChatColorUtils.COLOR_CHAR + "aX";//""+ChatColorUtils.COLOR_CHAR+"a";
+                else
+                    out[i] = ChatColorUtils.COLOR_CHAR + "aX";//ChatColorUtils.COLOR_CHAR+"a";
+            else
+                out[i] = ChatColorUtils.COLOR_CHAR + "0X";//ChatColorUtils.COLOR_CHAR+"0";
+        }
+        ArrayUtils.reverse(out);
+        return out;
+        //PMINGLIU
+    }
+
+    private ArrayList<String> addVertical(ArrayList<String> base, String... obj) {
+        for (int i = 0; i < obj.length; i++) {
+            String t = obj[i];
+            base.set(i, base.get(i) + t);
+        }
+        return base;
+    }
+
+    public void resetTimings() {
+        times.clear();
+        period_times.clear();
+        for (int i = 0; i < 100; i++) {
+            period_times.add(0L);
+        }
+        rebuild();
+    }
 }
diff --git a/src/main/java/dev/wolveringer/strings/Messages.java b/src/main/java/dev/wolveringer/strings/Messages.java
index 484c7df..7a2452d 100644
--- a/src/main/java/dev/wolveringer/strings/Messages.java
+++ b/src/main/java/dev/wolveringer/strings/Messages.java
@@ -1,20 +1,21 @@
 package dev.wolveringer.strings;
+
 import java.util.MissingResourceException;
 import java.util.ResourceBundle;
 
 public class Messages {
-	private static final String BUNDLE_NAME = "Messages";
+    private static final String BUNDLE_NAME = "Messages";
 
-	private static final ResourceBundle RESOURCE_BUNDLE = ResourceBundle.getBundle(BUNDLE_NAME);
+    private static final ResourceBundle RESOURCE_BUNDLE = ResourceBundle.getBundle(BUNDLE_NAME);
 
-	private Messages() {
-	}
+    private Messages() {
+    }
 
-	public static String getString(String key) {
-		try{
-			return RESOURCE_BUNDLE.getString(key);
-		}catch (MissingResourceException e){
-			return '!' + key + '!';
-		}
-	}
+    public static String getString(String key) {
+        try {
+            return RESOURCE_BUNDLE.getString(key);
+        } catch (MissingResourceException e) {
+            return '!' + key + '!';
+        }
+    }
 }
diff --git a/src/main/java/dev/wolveringer/terminal/TerminalListener.java b/src/main/java/dev/wolveringer/terminal/TerminalListener.java
index 9955e15..78ff7d9 100644
--- a/src/main/java/dev/wolveringer/terminal/TerminalListener.java
+++ b/src/main/java/dev/wolveringer/terminal/TerminalListener.java
@@ -1,218 +1,210 @@
 package dev.wolveringer.terminal;
 
-import java.io.IOException;
-import java.lang.reflect.Field;
+import jline.TerminalFactory;
+import jline.console.ConsoleReader;
+
+import net.md_5.bungee.BungeeCord;
+import net.md_5.bungee.api.ChatColor;
+import net.md_5.bungee.api.scheduler.ScheduledTask;
+import net.md_5.bungee.log.BungeeLogger;
+import net.md_5.bungee.log.ColouredWriter;
+
+import org.fusesource.jansi.Ansi;
+import org.fusesource.jansi.Ansi.Erase;
+import org.fusesource.jansi.AnsiConsole;
+
 import java.util.ArrayList;
 import java.util.EnumMap;
 import java.util.LinkedList;
-import java.util.List;
 import java.util.Map;
 import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.logging.Handler;
 import java.util.logging.Level;
 import java.util.logging.LogRecord;
 
-import org.fusesource.jansi.Ansi;
-import org.fusesource.jansi.Ansi.Erase;
-
 import dev.wolveringer.BungeeUtil.BungeeUtil;
-import dev.wolveringer.chat.ChatColor.AnsiColorFormater;
-import gnu.trove.list.linked.TLinkedList;
-
-import org.fusesource.jansi.AnsiConsole;
-import org.fusesource.jansi.AnsiRenderWriter;
-import org.fusesource.jansi.AnsiString;
-
-import jline.TerminalFactory;
-import jline.console.ConsoleReader;
 import lombok.Getter;
 import lombok.Setter;
-import net.md_5.bungee.BungeeCord;
-import net.md_5.bungee.api.ChatColor;
-import net.md_5.bungee.api.scheduler.ScheduledTask;
-import net.md_5.bungee.log.BungeeLogger;
-import net.md_5.bungee.log.ColouredWriter;
 
 public class TerminalListener {
-	@Getter
-	@Setter
-	private static TerminalListener instance;
-
-	public static interface Listener {
-		void onResize(int oldWidth, int oldHeight, int newWidth, int newHeight);
-
-		void onLinesPrinted();
-	}
-
-	static class ColouredWriterAdapter extends Handler {
-		private static final ChatColor[] colors = ChatColor.values();
-		private final Map<ChatColor, String> replacements = new EnumMap<>(ChatColor.class);
-		private ConsoleReader console;
-		private TerminalListener listener;
-		protected boolean writed = false;
-
-		public ColouredWriterAdapter(TerminalListener listener, ConsoleReader console) {
-			replacements.put(ChatColor.BLACK, Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.BLACK).boldOff().toString());
-			replacements.put(ChatColor.DARK_BLUE, Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.BLUE).boldOff().toString());
-			replacements.put(ChatColor.DARK_GREEN, Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.GREEN).boldOff().toString());
-			replacements.put(ChatColor.DARK_AQUA, Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.CYAN).boldOff().toString());
-			replacements.put(ChatColor.DARK_RED, Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.RED).boldOff().toString());
-			replacements.put(ChatColor.DARK_PURPLE, Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.MAGENTA).boldOff().toString());
-			replacements.put(ChatColor.GOLD, Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.YELLOW).boldOff().toString());
-			replacements.put(ChatColor.GRAY, Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.WHITE).boldOff().toString());
-			replacements.put(ChatColor.DARK_GRAY, Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.BLACK).bold().toString());
-			replacements.put(ChatColor.BLUE, Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.BLUE).bold().toString());
-			replacements.put(ChatColor.GREEN, Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.GREEN).bold().toString());
-			replacements.put(ChatColor.AQUA, Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.CYAN).bold().toString());
-			replacements.put(ChatColor.RED, Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.RED).bold().toString());
-			replacements.put(ChatColor.LIGHT_PURPLE, Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.MAGENTA).bold().toString());
-			replacements.put(ChatColor.YELLOW, Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.YELLOW).bold().toString());
-			replacements.put(ChatColor.WHITE, Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.WHITE).bold().toString());
-			replacements.put(ChatColor.MAGIC, Ansi.ansi().a(Ansi.Attribute.BLINK_SLOW).toString());
-			replacements.put(ChatColor.BOLD, Ansi.ansi().a(Ansi.Attribute.UNDERLINE_DOUBLE).toString());
-			replacements.put(ChatColor.STRIKETHROUGH, Ansi.ansi().a(Ansi.Attribute.STRIKETHROUGH_ON).toString());
-			replacements.put(ChatColor.UNDERLINE, Ansi.ansi().a(Ansi.Attribute.UNDERLINE).toString());
-			replacements.put(ChatColor.ITALIC, Ansi.ansi().a(Ansi.Attribute.ITALIC).toString());
-			replacements.put(ChatColor.RESET, Ansi.ansi().a(Ansi.Attribute.RESET).toString());
-
-			this.console = console;
-			this.listener = listener;
-		}
-
-		public void print(String s) {
-			for (ChatColor color : colors) {
-				s = s.replaceAll("(?i)" + color.toString(), replacements.get(color));
-			}
-			s = Ansi.ansi().eraseLine(Erase.ALL).toString() + ConsoleReader.RESET_LINE + s + Ansi.ansi().reset().toString();
-			listener.addMessage(s);
-			if (listener.terminalEnabled || true) {
-				writed = true;
-				try {
-					console.print(s);
-					console.drawLine();
-					console.flush();
-				}catch(Exception e){
-					e.printStackTrace();
-				}
-			} else {
-				listener.lineBffer.add(s);
-			}
-		}
-
-		@Override
-		public void publish(LogRecord record) {
-			if (isLoggable(record)) {
-				if(getFormatter()!= null)
-					print(getFormatter().format(record));
-				else
-					print(record.getMessage());
-			}
-		}
-
-		@Override
-		public void flush() {
-		}
-
-		@Override
-		public void close() throws SecurityException {
-		}
-	}
-
-	private ArrayList<String> lineBffer = new ArrayList<>();
-	@Getter
-	private boolean terminalEnabled = true;
-	private ScheduledTask task;
-	private ColouredWriterAdapter writer;
-	private LinkedList<String> lines = new LinkedList<>();
-	@Getter
-	private CopyOnWriteArrayList<Listener> listener = new CopyOnWriteArrayList<>();
-
-	public TerminalListener() {
-		BungeeLogger logger = (BungeeLogger) BungeeCord.getInstance().getLogger();
-		ColouredWriter org = null;
-		for (Handler h : logger.getHandlers())
-			if (h instanceof ColouredWriter) {
-				logger.removeHandler(h);
-				org = (ColouredWriter) h;
-			}
-		logger.addHandler(writer = new ColouredWriterAdapter(this, BungeeCord.getInstance().getConsoleReader()));
-		writer.setLevel( Level.INFO );
-		if(org != null)
-			writer.setFormatter(org.getFormatter());
-		else
-			addMessage("\u00A7cCant find BungeeCord Terminal handler!");
-		task = BungeeCord.getInstance().getScheduler().runAsync(BungeeUtil.getPluginInstance(), new Runnable() {
-			int oldWidth = -1, oldHeight = -1;
-
-			@Override
-			public void run() {
-				while (BungeeUtil.getInstance().isActive()) {
-					try {
-						Thread.sleep(5);
-					} catch (InterruptedException e) {
-						e.printStackTrace();
-					}
-					if (TerminalFactory.get().getHeight() != oldHeight || TerminalFactory.get().getWidth() != oldWidth) {
-						for (Listener l : listener)
-							l.onResize(oldWidth, oldHeight, TerminalFactory.get().getWidth(), TerminalFactory.get().getHeight());
-						oldHeight = TerminalFactory.get().getHeight();
-						oldWidth = TerminalFactory.get().getWidth();
-					}
-					if (writer.writed) {
-						writer.writed = false;
-						for (Listener l : listener)
-							l.onLinesPrinted();
-					}
-				}
-			}
-		});
-	}
-
-	public void setTerminalEnabled(boolean terminalEnabled) {
-		this.terminalEnabled = terminalEnabled;
-		if (terminalEnabled) {
-			try {
-				for(String line : lineBffer)
-					AnsiConsole.out.println(line);
-				writer.writed = true;
-			} catch (Exception e) {
-			}
-			lineBffer.clear();
-		}
-	}
-
-	protected void addMessage(String message) {
-		lines.push(message);
-		while (lines.size() > 1000)
-			lines.removeLast();
-	}
-
-	public void repaintTerminal() {
-		try {
-			AnsiConsole.out.print("\033[H\033[2J");
-			AnsiConsole.out.print("\033[0;0H");
-			int h = TerminalFactory.get().getHeight();
-			int w = TerminalFactory.get().getWidth();
-			int fs = Math.max(0, h-lines.size());
-			
-			for (int i = 0; i < h; i++) {
-				if(h-i > -1 && lines.size() > (h-i)){
-					String message = lines.get(h-i);
-					//while(AnsiColorFormater.getFormater().stripAnsi(message).length() > w){
-					//	message = message.substring(0,message.length()-1); //TODO Ansi color chars not count
-					//}
-					AnsiConsole.out.print("\033["+(i)+";0H"+message);
-				}
-				//else
-				//	AnsiConsole.out.print("\033["+(i)+";0H"+Ansi.ansi().a(Ansi.Erase.ALL).toString());
-				AnsiConsole.out.flush();
-			}
-			BungeeCord.getInstance().getConsoleReader().drawLine();
-			//BungeeCord.getInstance().getConsoleReader().flush();
-			AnsiConsole.out.print("\033["+h+";"+(2+BungeeCord.getInstance().getConsoleReader().getCursorBuffer().buffer.length())+"H");
-			AnsiConsole.out.flush();
-		}catch(Exception e){
-			e.printStackTrace();
-		}
-	}
+    @Getter
+    @Setter
+    private static TerminalListener instance;
+    private ArrayList<String> lineBffer = new ArrayList<>();
+    @Getter
+    private boolean terminalEnabled = true;
+    private ScheduledTask task;
+    private ColouredWriterAdapter writer;
+    private LinkedList<String> lines = new LinkedList<>();
+    @Getter
+    private CopyOnWriteArrayList<Listener> listener = new CopyOnWriteArrayList<>();
+
+    public TerminalListener() {
+        BungeeLogger logger = (BungeeLogger) BungeeCord.getInstance().getLogger();
+        ColouredWriter org = null;
+        for (Handler h : logger.getHandlers())
+            if (h instanceof ColouredWriter) {
+                logger.removeHandler(h);
+                org = (ColouredWriter) h;
+            }
+        logger.addHandler(writer = new ColouredWriterAdapter(this, BungeeCord.getInstance().getConsoleReader()));
+        writer.setLevel(Level.INFO);
+        if (org != null)
+            writer.setFormatter(org.getFormatter());
+        else
+            addMessage("\u00A7cCant find BungeeCord Terminal handler!");
+        task = BungeeCord.getInstance().getScheduler().runAsync(BungeeUtil.getPluginInstance(), new Runnable() {
+            int oldWidth = -1, oldHeight = -1;
+
+            @Override
+            public void run() {
+                while (BungeeUtil.getInstance().isActive()) {
+                    try {
+                        Thread.sleep(5);
+                    } catch (InterruptedException e) {
+                        e.printStackTrace();
+                    }
+                    if (TerminalFactory.get().getHeight() != oldHeight || TerminalFactory.get().getWidth() != oldWidth) {
+                        for (Listener l : listener)
+                            l.onResize(oldWidth, oldHeight, TerminalFactory.get().getWidth(), TerminalFactory.get().getHeight());
+                        oldHeight = TerminalFactory.get().getHeight();
+                        oldWidth = TerminalFactory.get().getWidth();
+                    }
+                    if (writer.writed) {
+                        writer.writed = false;
+                        for (Listener l : listener)
+                            l.onLinesPrinted();
+                    }
+                }
+            }
+        });
+    }
+
+    public void setTerminalEnabled(boolean terminalEnabled) {
+        this.terminalEnabled = terminalEnabled;
+        if (terminalEnabled) {
+            try {
+                for (String line : lineBffer)
+                    AnsiConsole.out.println(line);
+                writer.writed = true;
+            } catch (Exception e) {
+            }
+            lineBffer.clear();
+        }
+    }
+
+    protected void addMessage(String message) {
+        lines.push(message);
+        while (lines.size() > 1000)
+            lines.removeLast();
+    }
+
+    public void repaintTerminal() {
+        try {
+            AnsiConsole.out.print("\033[H\033[2J");
+            AnsiConsole.out.print("\033[0;0H");
+            int h = TerminalFactory.get().getHeight();
+            int w = TerminalFactory.get().getWidth();
+            int fs = Math.max(0, h - lines.size());
+
+            for (int i = 0; i < h; i++) {
+                if (h - i > -1 && lines.size() > (h - i)) {
+                    String message = lines.get(h - i);
+                    //while(AnsiColorFormater.getFormater().stripAnsi(message).length() > w){
+                    //	message = message.substring(0,message.length()-1); //TODO Ansi color chars not count
+                    //}
+                    AnsiConsole.out.print("\033[" + (i) + ";0H" + message);
+                }
+                //else
+                //	AnsiConsole.out.print("\033["+(i)+";0H"+Ansi.ansi().a(Ansi.Erase.ALL).toString());
+                AnsiConsole.out.flush();
+            }
+            BungeeCord.getInstance().getConsoleReader().drawLine();
+            //BungeeCord.getInstance().getConsoleReader().flush();
+            AnsiConsole.out.print("\033[" + h + ";" + (2 + BungeeCord.getInstance().getConsoleReader().getCursorBuffer().buffer.length()) + "H");
+            AnsiConsole.out.flush();
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+    }
+
+    public static interface Listener {
+        void onResize(int oldWidth, int oldHeight, int newWidth, int newHeight);
+
+        void onLinesPrinted();
+    }
+
+    static class ColouredWriterAdapter extends Handler {
+        private static final ChatColor[] colors = ChatColor.values();
+        private final Map<ChatColor, String> replacements = new EnumMap<>(ChatColor.class);
+        protected boolean writed = false;
+        private ConsoleReader console;
+        private TerminalListener listener;
+
+        public ColouredWriterAdapter(TerminalListener listener, ConsoleReader console) {
+            replacements.put(ChatColor.BLACK, Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.BLACK).boldOff().toString());
+            replacements.put(ChatColor.DARK_BLUE, Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.BLUE).boldOff().toString());
+            replacements.put(ChatColor.DARK_GREEN, Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.GREEN).boldOff().toString());
+            replacements.put(ChatColor.DARK_AQUA, Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.CYAN).boldOff().toString());
+            replacements.put(ChatColor.DARK_RED, Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.RED).boldOff().toString());
+            replacements.put(ChatColor.DARK_PURPLE, Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.MAGENTA).boldOff().toString());
+            replacements.put(ChatColor.GOLD, Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.YELLOW).boldOff().toString());
+            replacements.put(ChatColor.GRAY, Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.WHITE).boldOff().toString());
+            replacements.put(ChatColor.DARK_GRAY, Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.BLACK).bold().toString());
+            replacements.put(ChatColor.BLUE, Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.BLUE).bold().toString());
+            replacements.put(ChatColor.GREEN, Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.GREEN).bold().toString());
+            replacements.put(ChatColor.AQUA, Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.CYAN).bold().toString());
+            replacements.put(ChatColor.RED, Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.RED).bold().toString());
+            replacements.put(ChatColor.LIGHT_PURPLE, Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.MAGENTA).bold().toString());
+            replacements.put(ChatColor.YELLOW, Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.YELLOW).bold().toString());
+            replacements.put(ChatColor.WHITE, Ansi.ansi().a(Ansi.Attribute.RESET).fg(Ansi.Color.WHITE).bold().toString());
+            replacements.put(ChatColor.MAGIC, Ansi.ansi().a(Ansi.Attribute.BLINK_SLOW).toString());
+            replacements.put(ChatColor.BOLD, Ansi.ansi().a(Ansi.Attribute.UNDERLINE_DOUBLE).toString());
+            replacements.put(ChatColor.STRIKETHROUGH, Ansi.ansi().a(Ansi.Attribute.STRIKETHROUGH_ON).toString());
+            replacements.put(ChatColor.UNDERLINE, Ansi.ansi().a(Ansi.Attribute.UNDERLINE).toString());
+            replacements.put(ChatColor.ITALIC, Ansi.ansi().a(Ansi.Attribute.ITALIC).toString());
+            replacements.put(ChatColor.RESET, Ansi.ansi().a(Ansi.Attribute.RESET).toString());
+
+            this.console = console;
+            this.listener = listener;
+        }
+
+        public void print(String s) {
+            for (ChatColor color : colors) {
+                s = s.replaceAll("(?i)" + color.toString(), replacements.get(color));
+            }
+            s = Ansi.ansi().eraseLine(Erase.ALL).toString() + ConsoleReader.RESET_LINE + s + Ansi.ansi().reset().toString();
+            listener.addMessage(s);
+            if (listener.terminalEnabled || true) {
+                writed = true;
+                try {
+                    console.print(s);
+                    console.drawLine();
+                    console.flush();
+                } catch (Exception e) {
+                    e.printStackTrace();
+                }
+            } else {
+                listener.lineBffer.add(s);
+            }
+        }
+
+        @Override
+        public void publish(LogRecord record) {
+            if (isLoggable(record)) {
+                if (getFormatter() != null)
+                    print(getFormatter().format(record));
+                else
+                    print(record.getMessage());
+            }
+        }
+
+        @Override
+        public void flush() {
+        }
+
+        @Override
+        public void close() throws SecurityException {
+        }
+    }
 }
diff --git a/src/main/java/dev/wolveringer/updater/Updater.java b/src/main/java/dev/wolveringer/updater/Updater.java
index be860ae..5625fa0 100644
--- a/src/main/java/dev/wolveringer/updater/Updater.java
+++ b/src/main/java/dev/wolveringer/updater/Updater.java
@@ -1,19 +1,20 @@
 package dev.wolveringer.updater;
 
+import net.md_5.bungee.BungeeCord;
+
+import org.json.JSONArray;
+import org.json.JSONObject;
+
 import java.io.BufferedInputStream;
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
-import java.io.IOException;
 import java.io.InputStreamReader;
-import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.net.HttpURLConnection;
-import java.net.InetAddress;
 import java.net.URL;
 import java.net.URLConnection;
-import java.net.UnknownHostException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.HashMap;
@@ -22,23 +23,9 @@ import java.util.List;
 import java.util.concurrent.TimeUnit;
 import java.util.jar.JarInputStream;
 
-import javax.print.DocFlavor.STRING;
-
-import net.md_5.bungee.BungeeCord;
-import net.md_5.bungee.api.ProxyServer;
-import net.md_5.bungee.api.plugin.Plugin;
-
-import org.json.JSONArray;
-import org.json.JSONObject;
-
 import dev.wolveringer.BungeeUtil.BungeeUtil;
 import dev.wolveringer.BungeeUtil.Main;
-import dev.wolveringer.BungeeUtil.Material;
 import dev.wolveringer.BungeeUtil.configuration.Configuration;
-import dev.wolveringer.BungeeUtil.gameprofile.SkinFactory;
-import dev.wolveringer.BungeeUtil.item.ItemStack;
-import dev.wolveringer.BungeeUtil.item.ItemStack.Click;
-import dev.wolveringer.BungeeUtil.item.itemmeta.SkullMeta;
 import dev.wolveringer.chat.ChatColor.ChatColorUtils;
 import dev.wolveringer.util.MathUtil;
 import lombok.NonNull;
@@ -69,194 +56,182 @@ import lombok.NonNull;
  * 
  */
 public class Updater {
-	
-	private String url;
-	private JSONObject data;
-	private long last;
-	
-	public Updater(String url) {
-		this.url = url;
-	}
-	
-	public boolean checkUpdate() {
-		updateData();
-		BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR + "aChecking for Plugin updates");
-		if (data == null) throw new NullPointerException("HTTP Data is null. Invpoke getData() first");
-		if (!isNewstVersion()) {
-			installUpdate();
-			BungeeCord.getInstance().stop();
-			return true;
-		}
-		else {
-			if (!isDevBuild()) BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR + "aNo plugin update found! Your version is alredy the newest! (" + getCurrentVersion() + ")");
-			else BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR + "aYou plugin version is newer than the currunt public version. I think i'm a dev build... All bugs will be ignored");
-		}
-		return false;
-	}
-	
-	public void installUpdate(){
-		File ownFile = new File(getClass().getProtectionDomain().getCodeSource().getLocation().getFile());
-		downloadUpdate(data.getString("Download"), ownFile);
-		Configuration.setLastVersion(getCurrentVersion());
-	}
-	
-	public String getCurrentVersion(){
-		return Main.getMain().getDescription().getVersion();
-	}
-	
-	public String getNewestVersion() {
-		updateData();
-		return data.getString("CurrentVersion");
-	}
-	
-	public boolean isNewstVersion() {
-		return Long.parseLong(getNewestVersion().replaceAll("\\.", "")) <= Long.parseLong(getCurrentVersion().replaceAll("\\.", ""));
-	}
-	
-	public boolean isDevBuild(){
-		return Long.parseLong(getCurrentVersion().replaceAll("\\.", "")) > Long.parseLong(getNewestVersion().replaceAll("\\.", ""));
-	}
-	
-	/**
-	 * 
-	 * @param url
-	 * @param targetFile
-	 * @return errormask
-	 * errors:
-	 * 0: Create new file exception
-	 * 1: Invalid jar
-	 * 2: cant delete invalid jar
-	 * 3: Download IO error
-	 * 3: Finaly error
-	 */
-	private int downloadUpdate(String url, File targetFile) {
-		BigInteger errorMask = new BigInteger("0");
-		errorMask.setBit(8);
-		BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR + "aUpdating from "+getCurrentVersion()+" to "+getNewestVersion());
-		BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR + "aStarting to download the update ("+url+") to "+targetFile.getAbsolutePath());
-		programm:
-		try {
-			BungeeUtil.getInstance().setInformation(ChatColorUtils.COLOR_CHAR + "aDownloading update " + ChatColorUtils.COLOR_CHAR + "7[" + ChatColorUtils.COLOR_CHAR + "e000%" + ChatColorUtils.COLOR_CHAR + "7]");
-			BufferedInputStream in = null;
-			FileOutputStream fout = null;
-			try {
-				URLConnection com = new URL(url).openConnection();
-				int fileLength = com.getContentLength();
-				in = new BufferedInputStream(com.getInputStream());
-				File df;
-				if (targetFile.exists()) {
-					BungeeUtil.getInstance().setInformation(ChatColorUtils.COLOR_CHAR + "aUsing .download file ("+targetFile.getPath() + "BungeeUtil.download)!");
-					fout = new FileOutputStream(df = new File(targetFile.getPath() + "BungeeUtil.download"));
-				}
-				else fout = new FileOutputStream(df = targetFile);
-				final byte data[] = new byte[1024];
-				int count;
-				int readed = 0;
-				while (true) {
-					count = in.read(data, 0, 1024);
-					if (count == -1) break;
-					fout.write(data, 0, count);
-					readed += count;
-					String p = "000" + MathUtil.calculatePercent(readed, fileLength);
-					p = p.substring(0, p.indexOf("."));
-					p = p.substring(p.length() - 3, p.length());
-					BungeeUtil.getInstance().setInformation(ChatColorUtils.COLOR_CHAR + "aDownloading update " + ChatColorUtils.COLOR_CHAR + "7[" + ChatColorUtils.COLOR_CHAR + "e" + p + "%" + ChatColorUtils.COLOR_CHAR + "7]");
-				}
-				fout.close();
-				in.close();
-				BungeeUtil.getInstance().setInformation(ChatColorUtils.COLOR_CHAR + "aDownload done!");
-				BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR + "aUpdate downloaded!");
-				BungeeUtil.getInstance().setInformation(ChatColorUtils.COLOR_CHAR + "aCheck update for errors!");
-				BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR + "aCheck update for errors!");
-				try {
-					JarInputStream is = new JarInputStream(new FileInputStream(df));
-					while (null != is.getNextJarEntry()) {
-					}
-					is.close();
-				}
-				catch (Exception e) {
-					errorMask.setBit(1);
-					BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR + "cThe update contains an error. (Message: " + e.getLocalizedMessage() + ")");
-					BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR + "cDeleting the update!");
-					try {
-						df.delete();
-					}
-					catch (Exception ex) {
-						errorMask.setBit(2);
-					}
-					break programm;
-				}
-				BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR + "aUpdate valid.");
-				BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR + "aInstalling update!");
-				BungeeUtil.getInstance().setInformation(ChatColorUtils.COLOR_CHAR + "aInstalling update");
-				if (!targetFile.equals(df) && !targetFile.delete()) {
-					BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR + "6Cant delete the old plugin jar.");
-				}
-				boolean deleteOld = !targetFile.equals(df);
-				if(!targetFile.createNewFile()){
-					deleteOld = false;
-					BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR + "6Cant create new jar.");
-				}
-				FileInputStream fis = new FileInputStream(df);
-				FileOutputStream fos = new FileOutputStream(targetFile);
-				while ((count = fis.read(data, 0, 1024)) != -1) {
-					fos.write(data, 0, count);
-				}
-				fis.close();
-				fos.close();
-				if (deleteOld && !df.delete()) BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR + "6Cant delte cache file!");
-				BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR + "aRestarting bungeecord!");
-				BungeeUtil.getInstance().setInformation(ChatColorUtils.COLOR_CHAR + "aUpdate installed!");
-			}
-			catch (Exception e) {
-				errorMask.setBit(3);
-				e.printStackTrace();
-				BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR + "cAn error happend while downloading the update");
-			}
-			finally {
-				if (in != null) {
-					in.close();
-				}
-				if (fout != null) {
-					fout.close();
-				}
-			}
-		}
-		catch (Exception e) {
-			errorMask.setBit(4);
-			e.printStackTrace();
-			BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR + "cAn error happend while downloading the update");
-		}
-		return errorMask.intValue();
-	}
-	
-	public JSONObject getData() {
-		updateData();
-		return data;
-	}
-	
-	public Updater loadData() {
-		last = System.currentTimeMillis();
-		BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR + "aLoading update data!");
-		try {
-			URL i = new URL(url);
-			HttpURLConnection c = (HttpURLConnection) i.openConnection();
-			c.setRequestMethod("GET");
-			BufferedReader in = new BufferedReader(new InputStreamReader(c.getInputStream()));
-			String inputLine;
-			StringBuffer response = new StringBuffer();
-			while ((inputLine = in.readLine()) != null) {
-				response.append(inputLine);
-			}
-			in.close();
-			this.data = new JSONObject(response.toString());
-		}
-		catch (Exception e) {
-			BungeeUtil.debug(e);
-		}
-		return this;
-	}
-	
+
+    private String url;
+    private JSONObject data;
+    private long last;
+
+    public Updater(String url) {
+        this.url = url;
+    }
+
+    public boolean checkUpdate() {
+        updateData();
+        BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR + "aChecking for Plugin updates");
+        if (data == null)
+            throw new NullPointerException("HTTP Data is null. Invpoke getData() first");
+        if (!isNewstVersion()) {
+            installUpdate();
+            BungeeCord.getInstance().stop();
+            return true;
+        } else {
+            if (!isDevBuild())
+                BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR + "aNo plugin update found! Your version is alredy the newest! (" + getCurrentVersion() + ")");
+            else
+                BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR + "aYou plugin version is newer than the currunt public version. I think i'm a dev build... All bugs will be ignored");
+        }
+        return false;
+    }
+
+    public void installUpdate() {
+        File ownFile = new File(getClass().getProtectionDomain().getCodeSource().getLocation().getFile());
+        downloadUpdate(data.getString("Download"), ownFile);
+        Configuration.setLastVersion(getCurrentVersion());
+    }
+
+    public String getCurrentVersion() {
+        return Main.getMain().getDescription().getVersion();
+    }
+
+    public String getNewestVersion() {
+        updateData();
+        return data.getString("CurrentVersion");
+    }
+
+    public boolean isNewstVersion() {
+        return Long.parseLong(getNewestVersion().replaceAll("\\.", "")) <= Long.parseLong(getCurrentVersion().replaceAll("\\.", ""));
+    }
+
+    public boolean isDevBuild() {
+        return Long.parseLong(getCurrentVersion().replaceAll("\\.", "")) > Long.parseLong(getNewestVersion().replaceAll("\\.", ""));
+    }
+
+    /**
+     * @return errormask errors: 0: Create new file exception 1: Invalid jar 2: cant delete invalid
+     * jar 3: Download IO error 3: Finaly error
+     */
+    private int downloadUpdate(String url, File targetFile) {
+        BigInteger errorMask = new BigInteger("0");
+        errorMask.setBit(8);
+        BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR + "aUpdating from " + getCurrentVersion() + " to " + getNewestVersion());
+        BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR + "aStarting to download the update (" + url + ") to " + targetFile.getAbsolutePath());
+        programm:
+        try {
+            BungeeUtil.getInstance().setInformation(ChatColorUtils.COLOR_CHAR + "aDownloading update " + ChatColorUtils.COLOR_CHAR + "7[" + ChatColorUtils.COLOR_CHAR + "e000%" + ChatColorUtils.COLOR_CHAR + "7]");
+            BufferedInputStream in = null;
+            FileOutputStream fout = null;
+            try {
+                URLConnection com = new URL(url).openConnection();
+                int fileLength = com.getContentLength();
+                in = new BufferedInputStream(com.getInputStream());
+                File df;
+                if (targetFile.exists()) {
+                    BungeeUtil.getInstance().setInformation(ChatColorUtils.COLOR_CHAR + "aUsing .download file (" + targetFile.getPath() + "BungeeUtil.download)!");
+                    fout = new FileOutputStream(df = new File(targetFile.getPath() + "BungeeUtil.download"));
+                } else fout = new FileOutputStream(df = targetFile);
+                final byte data[] = new byte[1024];
+                int count;
+                int readed = 0;
+                while (true) {
+                    count = in.read(data, 0, 1024);
+                    if (count == -1) break;
+                    fout.write(data, 0, count);
+                    readed += count;
+                    String p = "000" + MathUtil.calculatePercent(readed, fileLength);
+                    p = p.substring(0, p.indexOf("."));
+                    p = p.substring(p.length() - 3, p.length());
+                    BungeeUtil.getInstance().setInformation(ChatColorUtils.COLOR_CHAR + "aDownloading update " + ChatColorUtils.COLOR_CHAR + "7[" + ChatColorUtils.COLOR_CHAR + "e" + p + "%" + ChatColorUtils.COLOR_CHAR + "7]");
+                }
+                fout.close();
+                in.close();
+                BungeeUtil.getInstance().setInformation(ChatColorUtils.COLOR_CHAR + "aDownload done!");
+                BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR + "aUpdate downloaded!");
+                BungeeUtil.getInstance().setInformation(ChatColorUtils.COLOR_CHAR + "aCheck update for errors!");
+                BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR + "aCheck update for errors!");
+                try {
+                    JarInputStream is = new JarInputStream(new FileInputStream(df));
+                    while (null != is.getNextJarEntry()) {
+                    }
+                    is.close();
+                } catch (Exception e) {
+                    errorMask.setBit(1);
+                    BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR + "cThe update contains an error. (Message: " + e.getLocalizedMessage() + ")");
+                    BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR + "cDeleting the update!");
+                    try {
+                        df.delete();
+                    } catch (Exception ex) {
+                        errorMask.setBit(2);
+                    }
+                    break programm;
+                }
+                BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR + "aUpdate valid.");
+                BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR + "aInstalling update!");
+                BungeeUtil.getInstance().setInformation(ChatColorUtils.COLOR_CHAR + "aInstalling update");
+                if (!targetFile.equals(df) && !targetFile.delete()) {
+                    BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR + "6Cant delete the old plugin jar.");
+                }
+                boolean deleteOld = !targetFile.equals(df);
+                if (!targetFile.createNewFile()) {
+                    deleteOld = false;
+                    BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR + "6Cant create new jar.");
+                }
+                FileInputStream fis = new FileInputStream(df);
+                FileOutputStream fos = new FileOutputStream(targetFile);
+                while ((count = fis.read(data, 0, 1024)) != -1) {
+                    fos.write(data, 0, count);
+                }
+                fis.close();
+                fos.close();
+                if (deleteOld && !df.delete())
+                    BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR + "6Cant delte cache file!");
+                BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR + "aRestarting bungeecord!");
+                BungeeUtil.getInstance().setInformation(ChatColorUtils.COLOR_CHAR + "aUpdate installed!");
+            } catch (Exception e) {
+                errorMask.setBit(3);
+                e.printStackTrace();
+                BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR + "cAn error happend while downloading the update");
+            } finally {
+                if (in != null) {
+                    in.close();
+                }
+                if (fout != null) {
+                    fout.close();
+                }
+            }
+        } catch (Exception e) {
+            errorMask.setBit(4);
+            e.printStackTrace();
+            BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR + "cAn error happend while downloading the update");
+        }
+        return errorMask.intValue();
+    }
+
+    public JSONObject getData() {
+        updateData();
+        return data;
+    }
+
+    public Updater loadData() {
+        last = System.currentTimeMillis();
+        BungeeUtil.getInstance().sendMessage(ChatColorUtils.COLOR_CHAR + "aLoading update data!");
+        try {
+            URL i = new URL(url);
+            HttpURLConnection c = (HttpURLConnection) i.openConnection();
+            c.setRequestMethod("GET");
+            BufferedReader in = new BufferedReader(new InputStreamReader(c.getInputStream()));
+            String inputLine;
+            StringBuffer response = new StringBuffer();
+            while ((inputLine = in.readLine()) != null) {
+                response.append(inputLine);
+            }
+            in.close();
+            this.data = new JSONObject(response.toString());
+        } catch (Exception e) {
+            BungeeUtil.debug(e);
+        }
+        return this;
+    }
+
 	/*
 	@SuppressWarnings("deprecation")
 	public boolean isServerWhiteListed() {
@@ -294,32 +269,31 @@ public class Updater {
 		return true;
 	}
 	*/
-	
-	public HashMap<String, List<String>> createChanges(@NonNull String lastVersion){
-		HashMap<String, List<String>> out = new HashMap<>();
-		if(data != null){
-			JSONArray changelogArray = data.getJSONArray("Changelog");
-			Iterator<Object> objects = changelogArray.iterator();
-			while (objects.hasNext()) {
-				JSONObject object = (JSONObject) objects.next();
-				String version; 
-				System.out.print((Long.parseLong((version = object.getString("Verion")).replaceAll("\\.", "")) > Long.parseLong(lastVersion.replaceAll("\\.", "")))+"-"+(Long.parseLong((version = object.getString("Verion")).replaceAll("\\.", "")) +":"+ Long.parseLong(getCurrentVersion().replaceAll("\\.", ""))));
-				if(Long.parseLong((version = object.getString("Verion")).replaceAll("\\.", "")) > Long.parseLong(lastVersion.replaceAll("\\.", "")) && Long.parseLong((version = object.getString("Verion")).replaceAll("\\.", "")) <= Long.parseLong(getCurrentVersion().replaceAll("\\.", ""))){
-					ArrayList<String> changes = new ArrayList<>();
-					Iterator<Object> message = object.getJSONArray("Changed").iterator();
-					while (message.hasNext()) {
-						changes.add((String) message.next());
-					}
-					out.put(version, changes);
-				}
-			}
-		}
-		else
-			out.put("error", Arrays.asList("\u00A7cCant featch versions data.","Make shure you have an valid internet connection."));
-		return out;
-	}
-	
-	public void updateData() {
-		if (System.currentTimeMillis() - last > TimeUnit.MINUTES.toMillis(10)) loadData();
-	}
+
+    public HashMap<String, List<String>> createChanges(@NonNull String lastVersion) {
+        HashMap<String, List<String>> out = new HashMap<>();
+        if (data != null) {
+            JSONArray changelogArray = data.getJSONArray("Changelog");
+            Iterator<Object> objects = changelogArray.iterator();
+            while (objects.hasNext()) {
+                JSONObject object = (JSONObject) objects.next();
+                String version;
+                System.out.print((Long.parseLong((version = object.getString("Verion")).replaceAll("\\.", "")) > Long.parseLong(lastVersion.replaceAll("\\.", ""))) + "-" + (Long.parseLong((version = object.getString("Verion")).replaceAll("\\.", "")) + ":" + Long.parseLong(getCurrentVersion().replaceAll("\\.", ""))));
+                if (Long.parseLong((version = object.getString("Verion")).replaceAll("\\.", "")) > Long.parseLong(lastVersion.replaceAll("\\.", "")) && Long.parseLong((version = object.getString("Verion")).replaceAll("\\.", "")) <= Long.parseLong(getCurrentVersion().replaceAll("\\.", ""))) {
+                    ArrayList<String> changes = new ArrayList<>();
+                    Iterator<Object> message = object.getJSONArray("Changed").iterator();
+                    while (message.hasNext()) {
+                        changes.add((String) message.next());
+                    }
+                    out.put(version, changes);
+                }
+            }
+        } else
+            out.put("error", Arrays.asList("\u00A7cCant featch versions data.", "Make shure you have an valid internet connection."));
+        return out;
+    }
+
+    public void updateData() {
+        if (System.currentTimeMillis() - last > TimeUnit.MINUTES.toMillis(10)) loadData();
+    }
 }
diff --git a/src/main/java/dev/wolveringer/util/ByteString.java b/src/main/java/dev/wolveringer/util/ByteString.java
index 5f70bf4..a69034e 100644
--- a/src/main/java/dev/wolveringer/util/ByteString.java
+++ b/src/main/java/dev/wolveringer/util/ByteString.java
@@ -1,25 +1,25 @@
 package dev.wolveringer.util;
 
 public class ByteString {
-	private byte[] string;
+    private byte[] string;
 
-	public ByteString(String in) {
-		string = in.getBytes();
-	}
+    public ByteString(String in) {
+        string = in.getBytes();
+    }
 
-	public ByteString(byte[] in) {
-		string = in;
-	}
+    public ByteString(byte[] in) {
+        string = in;
+    }
 
-	public void setString(String in) {
-		string = in.getBytes();
-	}
+    public String getString() {
+        return new String(string, 0, string.length);
+    }
 
-	public String getString() {
-		return new String(string, 0, string.length);
-	}
+    public void setString(String in) {
+        string = in.getBytes();
+    }
 
-	public byte[] getBytes() {
-		return this.string;
-	}
+    public byte[] getBytes() {
+        return this.string;
+    }
 }
diff --git a/src/main/java/dev/wolveringer/util/MathUtil.java b/src/main/java/dev/wolveringer/util/MathUtil.java
index 21ff394..4cac6b3 100644
--- a/src/main/java/dev/wolveringer/util/MathUtil.java
+++ b/src/main/java/dev/wolveringer/util/MathUtil.java
@@ -3,29 +3,29 @@ package dev.wolveringer.util;
 import java.math.BigDecimal;
 
 public class MathUtil {
-	private static final BigDecimal PERCENT_MULTIPLYER = new BigDecimal(100);
-	
-	public static float calculatePercent(int count, int max) {
-		BigDecimal bc = new BigDecimal(count);
-		BigDecimal bmax = new BigDecimal(max);
-		BigDecimal temp = bc.divide(bmax, 20, BigDecimal.ROUND_HALF_UP);
-		temp = temp.multiply(PERCENT_MULTIPLYER);
-		return temp.floatValue();
-	}
-	
-	public static void main(String[] args) {
-		System.out.println(calculatePercent(2310, 23423));
-		System.out.println("X: " + pitchNormalizer(-190));
-	}
-	
-	public static float pitchNormalizer(float pitch) {
-		pitch %= 360.0F;
-		if (pitch >= 180.0F) {
-			pitch -= 360.0F;
-		}
-		if (pitch < -180.0F) {
-			pitch += 360.0F;
-		}
-		return pitch;
-	}
+    private static final BigDecimal PERCENT_MULTIPLYER = new BigDecimal(100);
+
+    public static float calculatePercent(int count, int max) {
+        BigDecimal bc = new BigDecimal(count);
+        BigDecimal bmax = new BigDecimal(max);
+        BigDecimal temp = bc.divide(bmax, 20, BigDecimal.ROUND_HALF_UP);
+        temp = temp.multiply(PERCENT_MULTIPLYER);
+        return temp.floatValue();
+    }
+
+    public static void main(String[] args) {
+        System.out.println(calculatePercent(2310, 23423));
+        System.out.println("X: " + pitchNormalizer(-190));
+    }
+
+    public static float pitchNormalizer(float pitch) {
+        pitch %= 360.0F;
+        if (pitch >= 180.0F) {
+            pitch -= 360.0F;
+        }
+        if (pitch < -180.0F) {
+            pitch += 360.0F;
+        }
+        return pitch;
+    }
 }
diff --git a/src/main/java/dev/wolveringer/util/UtilReflection.java b/src/main/java/dev/wolveringer/util/UtilReflection.java
index 7e4a089..da5438d 100644
--- a/src/main/java/dev/wolveringer/util/UtilReflection.java
+++ b/src/main/java/dev/wolveringer/util/UtilReflection.java
@@ -4,8 +4,8 @@ import java.lang.reflect.Field;
 import java.lang.reflect.Method;
 
 public class UtilReflection {
-	/*
-	private static class ClassReflectionUtils {
+    /*
+    private static class ClassReflectionUtils {
 		private static Method methode_class_getField0;
 		
 		static {
@@ -28,65 +28,66 @@ public class UtilReflection {
 	}
 	*/
 
-	public static boolean setField(Object obj, String field, Object value) {
-		Field f = getField(obj, field);
-		if (!f.isAccessible())
-			f.setAccessible(true);
-		try {
-			f.set(obj, value);
-		} catch (IllegalArgumentException | IllegalAccessException e) {
-			e.printStackTrace();
-			return false;
-		}
-		return true;
-	}
-	
-	public static boolean setField(Class clazz,Object obj, String field, Object value) {
-		Field f = getField(clazz, field);
-		if (!f.isAccessible())
-			f.setAccessible(true);
-		try {
-			f.set(obj, value);
-		} catch (IllegalArgumentException | IllegalAccessException e) {
-			e.printStackTrace();
-			return false;
-		}
-		return true;
-	}
+    public static boolean setField(Object obj, String field, Object value) {
+        Field f = getField(obj, field);
+        if (!f.isAccessible())
+            f.setAccessible(true);
+        try {
+            f.set(obj, value);
+        } catch (IllegalArgumentException | IllegalAccessException e) {
+            e.printStackTrace();
+            return false;
+        }
+        return true;
+    }
 
-	public static Field getField(Object obj, String name) {
-		return getField(obj.getClass(), name);
-	}
+    public static boolean setField(Class clazz, Object obj, String field, Object value) {
+        Field f = getField(clazz, field);
+        if (!f.isAccessible())
+            f.setAccessible(true);
+        try {
+            f.set(obj, value);
+        } catch (IllegalArgumentException | IllegalAccessException e) {
+            e.printStackTrace();
+            return false;
+        }
+        return true;
+    }
 
-	public static Field getField(Class obj, String name) {
-		Field f = null;
-		try {
-			f = obj.getDeclaredField(name);
-		} catch (Exception e) {
-		}
-		if (f == null)
-			try {
-				f = obj.getField(name);
-			} catch (Exception e) {
-			}
-		if(!f.isAccessible())
-			f.setAccessible(true);
-		return f;
-	}
-	public static Method getMethod(Class obj, String name,Class...args) {
-		Method m = null;
-		try{
-			m = obj.getDeclaredMethod(name, args);
-		}catch(Exception e){
-		}
-		if(m == null)
-			try {
-				m = obj.getMethod(name, args);
-			} catch (NoSuchMethodException | SecurityException e) {
-			}
-		if(m != null)
-			if(!m.isAccessible())
-				m.setAccessible(true);
-		return m;
-	}
+    public static Field getField(Object obj, String name) {
+        return getField(obj.getClass(), name);
+    }
+
+    public static Field getField(Class obj, String name) {
+        Field f = null;
+        try {
+            f = obj.getDeclaredField(name);
+        } catch (Exception e) {
+        }
+        if (f == null)
+            try {
+                f = obj.getField(name);
+            } catch (Exception e) {
+            }
+        if (!f.isAccessible())
+            f.setAccessible(true);
+        return f;
+    }
+
+    public static Method getMethod(Class obj, String name, Class... args) {
+        Method m = null;
+        try {
+            m = obj.getDeclaredMethod(name, args);
+        } catch (Exception e) {
+        }
+        if (m == null)
+            try {
+                m = obj.getMethod(name, args);
+            } catch (NoSuchMethodException | SecurityException e) {
+            }
+        if (m != null)
+            if (!m.isAccessible())
+                m.setAccessible(true);
+        return m;
+    }
 }
-- 
1.9.4.msysgit.2

